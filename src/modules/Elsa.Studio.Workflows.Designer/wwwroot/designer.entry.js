/******/ var __webpack_modules__ = ({

/***/ "./node_modules/@antv/g-webgpu-core/es/ComponentManager.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@antv/g-webgpu-core/es/ComponentManager.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Component: () => (/* binding */ Component),
/* harmony export */   ComponentManager: () => (/* binding */ ComponentManager)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Entity */ "./node_modules/@antv/g-webgpu-core/es/Entity.js");





var Component = /*#__PURE__*/(0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(function Component(data) {
  (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__["default"])(this, Component);
} //
);

/**
 * 管理某一类 Component，尽可能做到 AoS 而非 SoA
 * @see https://wickedengine.net/2019/09/29/entity-component-system/
 * @see https://github.com/turanszkij/WickedEngine/blob/master/WickedEngine/wiECS.h
 */
// tslint:disable-next-line:max-classes-per-file
var ComponentManager = /*#__PURE__*/function () {
  /**
   * 不在 Entity 中维护拥有的 Component 列表，反之亦然
   */

  function ComponentManager(clazz) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__["default"])(this, ComponentManager);
    this.clazz = void 0;
    this.components = [];
    this.entities = [];
    this.lookup = {};
    this.clazz = clazz;
  }
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(ComponentManager, [{
    key: "clear",
    value: function clear() {
      this.components = [];
      this.entities = [];
      this.lookup = {};
    }
  }, {
    key: "contains",
    value: function contains(entity) {
      return this.lookup[entity] > -1;
    }
  }, {
    key: "create",
    value: function create(entity, data) {
      this.lookup[entity] = this.components.length;
      var component = new this.clazz(data || {});
      this.components.push(component);
      this.entities.push(entity);
      return component;
    }
  }, {
    key: "remove",
    value: function remove(entity) {
      var componentIndex = this.lookup[entity];
      if (componentIndex > -1) {
        if (componentIndex < this.components.length - 1) {
          // 将待删除元素和最后一个元素交换
          // C++ 中有 std::move 这样的操作，避免数据的拷贝
          // @see https://github.com/turanszkij/WickedEngine/blob/master/WickedEngine/wiECS.h#L169
          this.components[componentIndex] = this.components[this.components.length - 1];
          this.entities[componentIndex] = this.entities[this.entities.length - 1];
          this.lookup[this.entities[componentIndex]] = componentIndex;
        }
      }

      // 待删除元素已经移动到了最后一个
      this.components.pop();
      this.entities.pop();
      delete this.lookup[entity];
    }
  }, {
    key: "removeKeepSorted",
    value: function removeKeepSorted(entity) {
      var componentIndex = this.lookup[entity];
      if (componentIndex > -1) {
        var entity2 = this.entities[componentIndex];
        if (componentIndex < this.components.length - 1) {
          // Move every component left by one that is after this element:
          for (var _i = componentIndex + 1; _i < this.components.length; ++_i) {
            this.components[_i - 1] = this.components[_i];
          }
          // Move every entity left by one that is after this element and update lut:
          for (var _i2 = componentIndex + 1; _i2 < this.entities.length; ++_i2) {
            this.entities[_i2 - 1] = this.entities[_i2];
            this.lookup[this.entities[_i2 - 1]] = _i2 - 1;
          }
        }
        this.components.pop();
        this.entities.pop();
        delete this.lookup[entity2];
      }
    }
  }, {
    key: "moveItem",
    value: function moveItem(srcIndex, destIndex) {
      if (srcIndex === destIndex) {
        return;
      }

      // Save the moved component and entity:
      var srcComponent = this.components[srcIndex];
      var srcEntity = this.entities[srcIndex];

      // Every other entity-component that's in the way gets moved by one and lut is kept updated:
      var direction = srcIndex < destIndex ? 1 : -1;
      for (var _i3 = srcIndex; _i3 !== destIndex; _i3 += direction) {
        var next = _i3 + direction;
        this.components[_i3] = this.components[next];
        this.entities[_i3] = this.entities[next];
        this.lookup[this.entities[_i3]] = _i3;
      }

      // Saved entity-component moved to the required position:
      this.components[destIndex] = srcComponent;
      this.entities[destIndex] = srcEntity;
      this.lookup[srcEntity] = destIndex;
    }
  }, {
    key: "getEntity",
    value: function getEntity(index) {
      return this.entities[index];
    }

    /**
     * 由于缺少类似 C++ 的重载操作符，没法通过 [下标] 直接访问。因此只能增加该方法用于遍历。
     */
  }, {
    key: "getComponent",
    value: function getComponent(index) {
      return this.components[index];
    }
  }, {
    key: "getComponentByEntity",
    value: function getComponentByEntity(entity) {
      var componentIndex = this.lookup[entity];
      if (componentIndex > -1) {
        return this.components[componentIndex];
      }
      return null;
    }
  }, {
    key: "getCount",
    value: function getCount() {
      return this.components.length;
    }
  }, {
    key: "getEntityByComponentIndex",
    value: function getEntityByComponentIndex(componentIdx) {
      for (var _i4 = 0, _Object$keys = Object.keys(this.lookup); _i4 < _Object$keys.length; _i4++) {
        var _entity = _Object$keys[_i4];
        var entityInNum = Number(_entity);
        if (this.lookup[entityInNum] === componentIdx) {
          return entityInNum;
        }
      }
      return _Entity__WEBPACK_IMPORTED_MODULE_4__.EMPTY;
    }
  }, {
    key: "find",
    value: function find(callback) {
      for (var _i5 = 0; _i5 < this.getCount(); _i5++) {
        var _component = this.getComponent(_i5);
        if (callback(_component, _i5)) {
          return _component;
        }
      }
      return null;
    }
  }, {
    key: "findIndex",
    value: function findIndex(callback) {
      for (var _i6 = 0; _i6 < this.getCount(); _i6++) {
        var _component2 = this.getComponent(_i6);
        if (callback(_component2, _i6)) {
          return _i6;
        }
      }
      return -1;
    }
  }, {
    key: "forEach",
    value: function forEach(callback) {
      for (var _i7 = 0, _Object$keys2 = Object.keys(this.lookup); _i7 < _Object$keys2.length; _i7++) {
        var _entity2 = _Object$keys2[_i7];
        var entityInNum = Number(_entity2);
        var componentIndex = this.lookup[entityInNum];
        callback(entityInNum, this.getComponent(componentIndex));
      }
    }
  }, {
    key: "forEachAsync",
    value: function () {
      var _forEachAsync = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee(callback) {
        var _i8, _Object$keys3, _entity3, entityInNum, componentIndex;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _i8 = 0, _Object$keys3 = Object.keys(this.lookup);
              case 1:
                if (!(_i8 < _Object$keys3.length)) {
                  _context.next = 10;
                  break;
                }
                _entity3 = _Object$keys3[_i8];
                entityInNum = Number(_entity3);
                componentIndex = this.lookup[entityInNum];
                _context.next = 7;
                return callback(entityInNum, this.getComponent(componentIndex));
              case 7:
                _i8++;
                _context.next = 1;
                break;
              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));
      function forEachAsync(_x) {
        return _forEachAsync.apply(this, arguments);
      }
      return forEachAsync;
    }()
  }, {
    key: "map",
    value: function map(callback) {
      var result = [];
      for (var _i9 = 0, _Object$keys4 = Object.keys(this.lookup); _i9 < _Object$keys4.length; _i9++) {
        var _entity4 = _Object$keys4[_i9];
        var entityInNum = Number(_entity4);
        var componentIndex = this.lookup[entityInNum];
        result.push(callback(entityInNum, this.getComponent(componentIndex)));
      }
      return result;
    }
  }]);
  return ComponentManager;
}();
//# sourceMappingURL=ComponentManager.js.map

/***/ }),

/***/ "./node_modules/@antv/g-webgpu-core/es/Entity.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/g-webgpu-core/es/Entity.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EMPTY: () => (/* binding */ EMPTY),
/* harmony export */   createEntity: () => (/* binding */ createEntity)
/* harmony export */ });
var EMPTY = -1;
var entitySequence = 1;

/**
 * 类似关系型数据库的主键
 * TODO: 自动生成，考虑序列化
 */
function createEntity() {
  return entitySequence++;
}
//# sourceMappingURL=Entity.js.map

/***/ }),

/***/ "./node_modules/@antv/g-webgpu-core/es/components/renderer/gl.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@antv/g-webgpu-core/es/components/renderer/gl.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   gl: () => (/* binding */ gl)
/* harmony export */ });
/**
 * WebGL 枚举值
 * @see http://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14
 * 使用 babel 插件对常量进行内联，以减少最终打包产物大小
 * @see https://github.com/uber/deck.gl/blob/7.1-release/dev-docs/roadmaps/dist-size-roadmap.md#inline-gl-constants
 * 为了支持 WebGPU，新增 TextureUsage
 * @see https://gpuweb.github.io/gpuweb/#gputextureusage
 */
var gl;
(function (gl) {
  gl[gl["DEPTH_BUFFER_BIT"] = 256] = "DEPTH_BUFFER_BIT";
  gl[gl["STENCIL_BUFFER_BIT"] = 1024] = "STENCIL_BUFFER_BIT";
  gl[gl["COLOR_BUFFER_BIT"] = 16384] = "COLOR_BUFFER_BIT";
  gl[gl["POINTS"] = 0] = "POINTS";
  gl[gl["LINES"] = 1] = "LINES";
  gl[gl["LINE_LOOP"] = 2] = "LINE_LOOP";
  gl[gl["LINE_STRIP"] = 3] = "LINE_STRIP";
  gl[gl["TRIANGLES"] = 4] = "TRIANGLES";
  gl[gl["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  gl[gl["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
  gl[gl["ZERO"] = 0] = "ZERO";
  gl[gl["ONE"] = 1] = "ONE";
  gl[gl["SRC_COLOR"] = 768] = "SRC_COLOR";
  gl[gl["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
  gl[gl["SRC_ALPHA"] = 770] = "SRC_ALPHA";
  gl[gl["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
  gl[gl["DST_ALPHA"] = 772] = "DST_ALPHA";
  gl[gl["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
  gl[gl["DST_COLOR"] = 774] = "DST_COLOR";
  gl[gl["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
  gl[gl["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
  gl[gl["FUNC_ADD"] = 32774] = "FUNC_ADD";
  gl[gl["BLEND_EQUATION"] = 32777] = "BLEND_EQUATION";
  gl[gl["BLEND_EQUATION_RGB"] = 32777] = "BLEND_EQUATION_RGB";
  gl[gl["BLEND_EQUATION_ALPHA"] = 34877] = "BLEND_EQUATION_ALPHA";
  gl[gl["FUNC_SUBTRACT"] = 32778] = "FUNC_SUBTRACT";
  gl[gl["FUNC_REVERSE_SUBTRACT"] = 32779] = "FUNC_REVERSE_SUBTRACT";
  gl[gl["MAX_EXT"] = 32776] = "MAX_EXT";
  gl[gl["MIN_EXT"] = 32775] = "MIN_EXT";
  gl[gl["BLEND_DST_RGB"] = 32968] = "BLEND_DST_RGB";
  gl[gl["BLEND_SRC_RGB"] = 32969] = "BLEND_SRC_RGB";
  gl[gl["BLEND_DST_ALPHA"] = 32970] = "BLEND_DST_ALPHA";
  gl[gl["BLEND_SRC_ALPHA"] = 32971] = "BLEND_SRC_ALPHA";
  gl[gl["CONSTANT_COLOR"] = 32769] = "CONSTANT_COLOR";
  gl[gl["ONE_MINUS_CONSTANT_COLOR"] = 32770] = "ONE_MINUS_CONSTANT_COLOR";
  gl[gl["CONSTANT_ALPHA"] = 32771] = "CONSTANT_ALPHA";
  gl[gl["ONE_MINUS_CONSTANT_ALPHA"] = 32772] = "ONE_MINUS_CONSTANT_ALPHA";
  gl[gl["BLEND_COLOR"] = 32773] = "BLEND_COLOR";
  gl[gl["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  gl[gl["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  gl[gl["ARRAY_BUFFER_BINDING"] = 34964] = "ARRAY_BUFFER_BINDING";
  gl[gl["ELEMENT_ARRAY_BUFFER_BINDING"] = 34965] = "ELEMENT_ARRAY_BUFFER_BINDING";
  gl[gl["STREAM_DRAW"] = 35040] = "STREAM_DRAW";
  gl[gl["STATIC_DRAW"] = 35044] = "STATIC_DRAW";
  gl[gl["DYNAMIC_DRAW"] = 35048] = "DYNAMIC_DRAW";
  gl[gl["BUFFER_SIZE"] = 34660] = "BUFFER_SIZE";
  gl[gl["BUFFER_USAGE"] = 34661] = "BUFFER_USAGE";
  gl[gl["CURRENT_VERTEX_ATTRIB"] = 34342] = "CURRENT_VERTEX_ATTRIB";
  gl[gl["FRONT"] = 1028] = "FRONT";
  gl[gl["BACK"] = 1029] = "BACK";
  gl[gl["FRONT_AND_BACK"] = 1032] = "FRONT_AND_BACK";
  gl[gl["CULL_FACE"] = 2884] = "CULL_FACE";
  gl[gl["BLEND"] = 3042] = "BLEND";
  gl[gl["DITHER"] = 3024] = "DITHER";
  gl[gl["STENCIL_TEST"] = 2960] = "STENCIL_TEST";
  gl[gl["DEPTH_TEST"] = 2929] = "DEPTH_TEST";
  gl[gl["SCISSOR_TEST"] = 3089] = "SCISSOR_TEST";
  gl[gl["POLYGON_OFFSET_FILL"] = 32823] = "POLYGON_OFFSET_FILL";
  gl[gl["SAMPLE_ALPHA_TO_COVERAGE"] = 32926] = "SAMPLE_ALPHA_TO_COVERAGE";
  gl[gl["SAMPLE_COVERAGE"] = 32928] = "SAMPLE_COVERAGE";
  gl[gl["NO_ERROR"] = 0] = "NO_ERROR";
  gl[gl["INVALID_ENUM"] = 1280] = "INVALID_ENUM";
  gl[gl["INVALID_VALUE"] = 1281] = "INVALID_VALUE";
  gl[gl["INVALID_OPERATION"] = 1282] = "INVALID_OPERATION";
  gl[gl["OUT_OF_MEMORY"] = 1285] = "OUT_OF_MEMORY";
  gl[gl["CW"] = 2304] = "CW";
  gl[gl["CCW"] = 2305] = "CCW";
  gl[gl["LINE_WIDTH"] = 2849] = "LINE_WIDTH";
  gl[gl["ALIASED_POINT_SIZE_RANGE"] = 33901] = "ALIASED_POINT_SIZE_RANGE";
  gl[gl["ALIASED_LINE_WIDTH_RANGE"] = 33902] = "ALIASED_LINE_WIDTH_RANGE";
  gl[gl["CULL_FACE_MODE"] = 2885] = "CULL_FACE_MODE";
  gl[gl["FRONT_FACE"] = 2886] = "FRONT_FACE";
  gl[gl["DEPTH_RANGE"] = 2928] = "DEPTH_RANGE";
  gl[gl["DEPTH_WRITEMASK"] = 2930] = "DEPTH_WRITEMASK";
  gl[gl["DEPTH_CLEAR_VALUE"] = 2931] = "DEPTH_CLEAR_VALUE";
  gl[gl["DEPTH_FUNC"] = 2932] = "DEPTH_FUNC";
  gl[gl["STENCIL_CLEAR_VALUE"] = 2961] = "STENCIL_CLEAR_VALUE";
  gl[gl["STENCIL_FUNC"] = 2962] = "STENCIL_FUNC";
  gl[gl["STENCIL_FAIL"] = 2964] = "STENCIL_FAIL";
  gl[gl["STENCIL_PASS_DEPTH_FAIL"] = 2965] = "STENCIL_PASS_DEPTH_FAIL";
  gl[gl["STENCIL_PASS_DEPTH_PASS"] = 2966] = "STENCIL_PASS_DEPTH_PASS";
  gl[gl["STENCIL_REF"] = 2967] = "STENCIL_REF";
  gl[gl["STENCIL_VALUE_MASK"] = 2963] = "STENCIL_VALUE_MASK";
  gl[gl["STENCIL_WRITEMASK"] = 2968] = "STENCIL_WRITEMASK";
  gl[gl["STENCIL_BACK_FUNC"] = 34816] = "STENCIL_BACK_FUNC";
  gl[gl["STENCIL_BACK_FAIL"] = 34817] = "STENCIL_BACK_FAIL";
  gl[gl["STENCIL_BACK_PASS_DEPTH_FAIL"] = 34818] = "STENCIL_BACK_PASS_DEPTH_FAIL";
  gl[gl["STENCIL_BACK_PASS_DEPTH_PASS"] = 34819] = "STENCIL_BACK_PASS_DEPTH_PASS";
  gl[gl["STENCIL_BACK_REF"] = 36003] = "STENCIL_BACK_REF";
  gl[gl["STENCIL_BACK_VALUE_MASK"] = 36004] = "STENCIL_BACK_VALUE_MASK";
  gl[gl["STENCIL_BACK_WRITEMASK"] = 36005] = "STENCIL_BACK_WRITEMASK";
  gl[gl["VIEWPORT"] = 2978] = "VIEWPORT";
  gl[gl["SCISSOR_BOX"] = 3088] = "SCISSOR_BOX";
  gl[gl["COLOR_CLEAR_VALUE"] = 3106] = "COLOR_CLEAR_VALUE";
  gl[gl["COLOR_WRITEMASK"] = 3107] = "COLOR_WRITEMASK";
  gl[gl["UNPACK_ALIGNMENT"] = 3317] = "UNPACK_ALIGNMENT";
  gl[gl["PACK_ALIGNMENT"] = 3333] = "PACK_ALIGNMENT";
  gl[gl["MAX_TEXTURE_SIZE"] = 3379] = "MAX_TEXTURE_SIZE";
  gl[gl["MAX_VIEWPORT_DIMS"] = 3386] = "MAX_VIEWPORT_DIMS";
  gl[gl["SUBPIXEL_BITS"] = 3408] = "SUBPIXEL_BITS";
  gl[gl["RED_BITS"] = 3410] = "RED_BITS";
  gl[gl["GREEN_BITS"] = 3411] = "GREEN_BITS";
  gl[gl["BLUE_BITS"] = 3412] = "BLUE_BITS";
  gl[gl["ALPHA_BITS"] = 3413] = "ALPHA_BITS";
  gl[gl["DEPTH_BITS"] = 3414] = "DEPTH_BITS";
  gl[gl["STENCIL_BITS"] = 3415] = "STENCIL_BITS";
  gl[gl["POLYGON_OFFSET_UNITS"] = 10752] = "POLYGON_OFFSET_UNITS";
  gl[gl["POLYGON_OFFSET_FACTOR"] = 32824] = "POLYGON_OFFSET_FACTOR";
  gl[gl["TEXTURE_BINDING_2D"] = 32873] = "TEXTURE_BINDING_2D";
  gl[gl["SAMPLE_BUFFERS"] = 32936] = "SAMPLE_BUFFERS";
  gl[gl["SAMPLES"] = 32937] = "SAMPLES";
  gl[gl["SAMPLE_COVERAGE_VALUE"] = 32938] = "SAMPLE_COVERAGE_VALUE";
  gl[gl["SAMPLE_COVERAGE_INVERT"] = 32939] = "SAMPLE_COVERAGE_INVERT";
  gl[gl["COMPRESSED_TEXTURE_FORMATS"] = 34467] = "COMPRESSED_TEXTURE_FORMATS";
  gl[gl["DONT_CARE"] = 4352] = "DONT_CARE";
  gl[gl["FASTEST"] = 4353] = "FASTEST";
  gl[gl["NICEST"] = 4354] = "NICEST";
  gl[gl["GENERATE_MIPMAP_HINT"] = 33170] = "GENERATE_MIPMAP_HINT";
  gl[gl["BYTE"] = 5120] = "BYTE";
  gl[gl["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  gl[gl["SHORT"] = 5122] = "SHORT";
  gl[gl["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  gl[gl["INT"] = 5124] = "INT";
  gl[gl["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  gl[gl["FLOAT"] = 5126] = "FLOAT";
  gl[gl["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  gl[gl["ALPHA"] = 6406] = "ALPHA";
  gl[gl["RGB"] = 6407] = "RGB";
  gl[gl["RGBA"] = 6408] = "RGBA";
  gl[gl["LUMINANCE"] = 6409] = "LUMINANCE";
  gl[gl["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  gl[gl["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  gl[gl["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  gl[gl["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  gl[gl["FRAGMENT_SHADER"] = 35632] = "FRAGMENT_SHADER";
  gl[gl["VERTEX_SHADER"] = 35633] = "VERTEX_SHADER";
  gl[gl["MAX_VERTEX_ATTRIBS"] = 34921] = "MAX_VERTEX_ATTRIBS";
  gl[gl["MAX_VERTEX_UNIFORM_VECTORS"] = 36347] = "MAX_VERTEX_UNIFORM_VECTORS";
  gl[gl["MAX_VARYING_VECTORS"] = 36348] = "MAX_VARYING_VECTORS";
  gl[gl["MAX_COMBINED_TEXTURE_IMAGE_UNITS"] = 35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS";
  gl[gl["MAX_VERTEX_TEXTURE_IMAGE_UNITS"] = 35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS";
  gl[gl["MAX_TEXTURE_IMAGE_UNITS"] = 34930] = "MAX_TEXTURE_IMAGE_UNITS";
  gl[gl["MAX_FRAGMENT_UNIFORM_VECTORS"] = 36349] = "MAX_FRAGMENT_UNIFORM_VECTORS";
  gl[gl["SHADER_TYPE"] = 35663] = "SHADER_TYPE";
  gl[gl["DELETE_STATUS"] = 35712] = "DELETE_STATUS";
  gl[gl["LINK_STATUS"] = 35714] = "LINK_STATUS";
  gl[gl["VALIDATE_STATUS"] = 35715] = "VALIDATE_STATUS";
  gl[gl["ATTACHED_SHADERS"] = 35717] = "ATTACHED_SHADERS";
  gl[gl["ACTIVE_UNIFORMS"] = 35718] = "ACTIVE_UNIFORMS";
  gl[gl["ACTIVE_ATTRIBUTES"] = 35721] = "ACTIVE_ATTRIBUTES";
  gl[gl["SHADING_LANGUAGE_VERSION"] = 35724] = "SHADING_LANGUAGE_VERSION";
  gl[gl["CURRENT_PROGRAM"] = 35725] = "CURRENT_PROGRAM";
  gl[gl["NEVER"] = 512] = "NEVER";
  gl[gl["LESS"] = 513] = "LESS";
  gl[gl["EQUAL"] = 514] = "EQUAL";
  gl[gl["LEQUAL"] = 515] = "LEQUAL";
  gl[gl["GREATER"] = 516] = "GREATER";
  gl[gl["NOTEQUAL"] = 517] = "NOTEQUAL";
  gl[gl["GEQUAL"] = 518] = "GEQUAL";
  gl[gl["ALWAYS"] = 519] = "ALWAYS";
  gl[gl["KEEP"] = 7680] = "KEEP";
  gl[gl["REPLACE"] = 7681] = "REPLACE";
  gl[gl["INCR"] = 7682] = "INCR";
  gl[gl["DECR"] = 7683] = "DECR";
  gl[gl["INVERT"] = 5386] = "INVERT";
  gl[gl["INCR_WRAP"] = 34055] = "INCR_WRAP";
  gl[gl["DECR_WRAP"] = 34056] = "DECR_WRAP";
  gl[gl["VENDOR"] = 7936] = "VENDOR";
  gl[gl["RENDERER"] = 7937] = "RENDERER";
  gl[gl["VERSION"] = 7938] = "VERSION";
  gl[gl["NEAREST"] = 9728] = "NEAREST";
  gl[gl["LINEAR"] = 9729] = "LINEAR";
  gl[gl["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
  gl[gl["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
  gl[gl["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
  gl[gl["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
  gl[gl["TEXTURE_MAG_FILTER"] = 10240] = "TEXTURE_MAG_FILTER";
  gl[gl["TEXTURE_MIN_FILTER"] = 10241] = "TEXTURE_MIN_FILTER";
  gl[gl["TEXTURE_WRAP_S"] = 10242] = "TEXTURE_WRAP_S";
  gl[gl["TEXTURE_WRAP_T"] = 10243] = "TEXTURE_WRAP_T";
  gl[gl["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  gl[gl["TEXTURE"] = 5890] = "TEXTURE";
  gl[gl["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  gl[gl["TEXTURE_BINDING_CUBE_MAP"] = 34068] = "TEXTURE_BINDING_CUBE_MAP";
  gl[gl["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  gl[gl["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  gl[gl["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  gl[gl["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  gl[gl["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  gl[gl["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  gl[gl["MAX_CUBE_MAP_TEXTURE_SIZE"] = 34076] = "MAX_CUBE_MAP_TEXTURE_SIZE";
  gl[gl["TEXTURE0"] = 33984] = "TEXTURE0";
  gl[gl["TEXTURE1"] = 33985] = "TEXTURE1";
  gl[gl["TEXTURE2"] = 33986] = "TEXTURE2";
  gl[gl["TEXTURE3"] = 33987] = "TEXTURE3";
  gl[gl["TEXTURE4"] = 33988] = "TEXTURE4";
  gl[gl["TEXTURE5"] = 33989] = "TEXTURE5";
  gl[gl["TEXTURE6"] = 33990] = "TEXTURE6";
  gl[gl["TEXTURE7"] = 33991] = "TEXTURE7";
  gl[gl["TEXTURE8"] = 33992] = "TEXTURE8";
  gl[gl["TEXTURE9"] = 33993] = "TEXTURE9";
  gl[gl["TEXTURE10"] = 33994] = "TEXTURE10";
  gl[gl["TEXTURE11"] = 33995] = "TEXTURE11";
  gl[gl["TEXTURE12"] = 33996] = "TEXTURE12";
  gl[gl["TEXTURE13"] = 33997] = "TEXTURE13";
  gl[gl["TEXTURE14"] = 33998] = "TEXTURE14";
  gl[gl["TEXTURE15"] = 33999] = "TEXTURE15";
  gl[gl["TEXTURE16"] = 34000] = "TEXTURE16";
  gl[gl["TEXTURE17"] = 34001] = "TEXTURE17";
  gl[gl["TEXTURE18"] = 34002] = "TEXTURE18";
  gl[gl["TEXTURE19"] = 34003] = "TEXTURE19";
  gl[gl["TEXTURE20"] = 34004] = "TEXTURE20";
  gl[gl["TEXTURE21"] = 34005] = "TEXTURE21";
  gl[gl["TEXTURE22"] = 34006] = "TEXTURE22";
  gl[gl["TEXTURE23"] = 34007] = "TEXTURE23";
  gl[gl["TEXTURE24"] = 34008] = "TEXTURE24";
  gl[gl["TEXTURE25"] = 34009] = "TEXTURE25";
  gl[gl["TEXTURE26"] = 34010] = "TEXTURE26";
  gl[gl["TEXTURE27"] = 34011] = "TEXTURE27";
  gl[gl["TEXTURE28"] = 34012] = "TEXTURE28";
  gl[gl["TEXTURE29"] = 34013] = "TEXTURE29";
  gl[gl["TEXTURE30"] = 34014] = "TEXTURE30";
  gl[gl["TEXTURE31"] = 34015] = "TEXTURE31";
  gl[gl["ACTIVE_TEXTURE"] = 34016] = "ACTIVE_TEXTURE";
  gl[gl["REPEAT"] = 10497] = "REPEAT";
  gl[gl["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
  gl[gl["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
  gl[gl["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
  gl[gl["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
  gl[gl["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
  gl[gl["INT_VEC2"] = 35667] = "INT_VEC2";
  gl[gl["INT_VEC3"] = 35668] = "INT_VEC3";
  gl[gl["INT_VEC4"] = 35669] = "INT_VEC4";
  gl[gl["BOOL"] = 35670] = "BOOL";
  gl[gl["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
  gl[gl["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
  gl[gl["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
  gl[gl["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
  gl[gl["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
  gl[gl["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
  gl[gl["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
  gl[gl["SAMPLER_CUBE"] = 35680] = "SAMPLER_CUBE";
  gl[gl["VERTEX_ATTRIB_ARRAY_ENABLED"] = 34338] = "VERTEX_ATTRIB_ARRAY_ENABLED";
  gl[gl["VERTEX_ATTRIB_ARRAY_SIZE"] = 34339] = "VERTEX_ATTRIB_ARRAY_SIZE";
  gl[gl["VERTEX_ATTRIB_ARRAY_STRIDE"] = 34340] = "VERTEX_ATTRIB_ARRAY_STRIDE";
  gl[gl["VERTEX_ATTRIB_ARRAY_TYPE"] = 34341] = "VERTEX_ATTRIB_ARRAY_TYPE";
  gl[gl["VERTEX_ATTRIB_ARRAY_NORMALIZED"] = 34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED";
  gl[gl["VERTEX_ATTRIB_ARRAY_POINTER"] = 34373] = "VERTEX_ATTRIB_ARRAY_POINTER";
  gl[gl["VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"] = 34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING";
  gl[gl["COMPILE_STATUS"] = 35713] = "COMPILE_STATUS";
  gl[gl["LOW_FLOAT"] = 36336] = "LOW_FLOAT";
  gl[gl["MEDIUM_FLOAT"] = 36337] = "MEDIUM_FLOAT";
  gl[gl["HIGH_FLOAT"] = 36338] = "HIGH_FLOAT";
  gl[gl["LOW_INT"] = 36339] = "LOW_INT";
  gl[gl["MEDIUM_INT"] = 36340] = "MEDIUM_INT";
  gl[gl["HIGH_INT"] = 36341] = "HIGH_INT";
  gl[gl["FRAMEBUFFER"] = 36160] = "FRAMEBUFFER";
  gl[gl["RENDERBUFFER"] = 36161] = "RENDERBUFFER";
  gl[gl["RGBA4"] = 32854] = "RGBA4";
  gl[gl["RGB5_A1"] = 32855] = "RGB5_A1";
  gl[gl["RGB565"] = 36194] = "RGB565";
  gl[gl["DEPTH_COMPONENT16"] = 33189] = "DEPTH_COMPONENT16";
  gl[gl["STENCIL_INDEX"] = 6401] = "STENCIL_INDEX";
  gl[gl["STENCIL_INDEX8"] = 36168] = "STENCIL_INDEX8";
  gl[gl["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
  gl[gl["RENDERBUFFER_WIDTH"] = 36162] = "RENDERBUFFER_WIDTH";
  gl[gl["RENDERBUFFER_HEIGHT"] = 36163] = "RENDERBUFFER_HEIGHT";
  gl[gl["RENDERBUFFER_INTERNAL_FORMAT"] = 36164] = "RENDERBUFFER_INTERNAL_FORMAT";
  gl[gl["RENDERBUFFER_RED_SIZE"] = 36176] = "RENDERBUFFER_RED_SIZE";
  gl[gl["RENDERBUFFER_GREEN_SIZE"] = 36177] = "RENDERBUFFER_GREEN_SIZE";
  gl[gl["RENDERBUFFER_BLUE_SIZE"] = 36178] = "RENDERBUFFER_BLUE_SIZE";
  gl[gl["RENDERBUFFER_ALPHA_SIZE"] = 36179] = "RENDERBUFFER_ALPHA_SIZE";
  gl[gl["RENDERBUFFER_DEPTH_SIZE"] = 36180] = "RENDERBUFFER_DEPTH_SIZE";
  gl[gl["RENDERBUFFER_STENCIL_SIZE"] = 36181] = "RENDERBUFFER_STENCIL_SIZE";
  gl[gl["FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE"] = 36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE";
  gl[gl["FRAMEBUFFER_ATTACHMENT_OBJECT_NAME"] = 36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME";
  gl[gl["FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL"] = 36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL";
  gl[gl["FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE"] = 36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE";
  gl[gl["COLOR_ATTACHMENT0"] = 36064] = "COLOR_ATTACHMENT0";
  gl[gl["DEPTH_ATTACHMENT"] = 36096] = "DEPTH_ATTACHMENT";
  gl[gl["STENCIL_ATTACHMENT"] = 36128] = "STENCIL_ATTACHMENT";
  gl[gl["DEPTH_STENCIL_ATTACHMENT"] = 33306] = "DEPTH_STENCIL_ATTACHMENT";
  gl[gl["NONE"] = 0] = "NONE";
  gl[gl["FRAMEBUFFER_COMPLETE"] = 36053] = "FRAMEBUFFER_COMPLETE";
  gl[gl["FRAMEBUFFER_INCOMPLETE_ATTACHMENT"] = 36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
  gl[gl["FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"] = 36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
  gl[gl["FRAMEBUFFER_INCOMPLETE_DIMENSIONS"] = 36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
  gl[gl["FRAMEBUFFER_UNSUPPORTED"] = 36061] = "FRAMEBUFFER_UNSUPPORTED";
  gl[gl["FRAMEBUFFER_BINDING"] = 36006] = "FRAMEBUFFER_BINDING";
  gl[gl["RENDERBUFFER_BINDING"] = 36007] = "RENDERBUFFER_BINDING";
  gl[gl["MAX_RENDERBUFFER_SIZE"] = 34024] = "MAX_RENDERBUFFER_SIZE";
  gl[gl["INVALID_FRAMEBUFFER_OPERATION"] = 1286] = "INVALID_FRAMEBUFFER_OPERATION";
  gl[gl["UNPACK_FLIP_Y_WEBGL"] = 37440] = "UNPACK_FLIP_Y_WEBGL";
  gl[gl["UNPACK_PREMULTIPLY_ALPHA_WEBGL"] = 37441] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL";
  gl[gl["CONTEXT_LOST_WEBGL"] = 37442] = "CONTEXT_LOST_WEBGL";
  gl[gl["UNPACK_COLORSPACE_CONVERSION_WEBGL"] = 37443] = "UNPACK_COLORSPACE_CONVERSION_WEBGL";
  gl[gl["BROWSER_DEFAULT_WEBGL"] = 37444] = "BROWSER_DEFAULT_WEBGL";
  gl[gl["COPY_SRC"] = 1] = "COPY_SRC";
  gl[gl["COPY_DST"] = 2] = "COPY_DST";
  gl[gl["SAMPLED"] = 4] = "SAMPLED";
  gl[gl["STORAGE"] = 8] = "STORAGE";
  gl[gl["RENDER_ATTACHMENT"] = 16] = "RENDER_ATTACHMENT";
})(gl || (gl = {}));
//# sourceMappingURL=gl.js.map

/***/ }),

/***/ "./node_modules/@antv/g-webgpu-core/es/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@antv/g-webgpu-core/es/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AST_NODE_TYPES: () => (/* binding */ AST_NODE_TYPES),
/* harmony export */   AST_TOKEN_TYPES: () => (/* binding */ AST_TOKEN_TYPES),
/* harmony export */   Component: () => (/* reexport safe */ _ComponentManager__WEBPACK_IMPORTED_MODULE_0__.Component),
/* harmony export */   ComponentManager: () => (/* reexport safe */ _ComponentManager__WEBPACK_IMPORTED_MODULE_0__.ComponentManager),
/* harmony export */   ConfigService: () => (/* reexport safe */ _services_config_ConfigService__WEBPACK_IMPORTED_MODULE_3__.ConfigService),
/* harmony export */   DefineValuePlaceholder: () => (/* binding */ DefineValuePlaceholder),
/* harmony export */   STORAGE_CLASS: () => (/* binding */ STORAGE_CLASS),
/* harmony export */   Target: () => (/* binding */ Target),
/* harmony export */   createEntity: () => (/* reexport safe */ _Entity__WEBPACK_IMPORTED_MODULE_2__.createEntity),
/* harmony export */   gl: () => (/* reexport safe */ _components_renderer_gl__WEBPACK_IMPORTED_MODULE_1__.gl),
/* harmony export */   isSafari: () => (/* reexport safe */ _utils_isSafari__WEBPACK_IMPORTED_MODULE_4__.isSafari)
/* harmony export */ });
/* harmony import */ var _ComponentManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ComponentManager */ "./node_modules/@antv/g-webgpu-core/es/ComponentManager.js");
/* harmony import */ var _components_renderer_gl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/renderer/gl */ "./node_modules/@antv/g-webgpu-core/es/components/renderer/gl.js");
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Entity */ "./node_modules/@antv/g-webgpu-core/es/Entity.js");
/* harmony import */ var _services_config_ConfigService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./services/config/ConfigService */ "./node_modules/@antv/g-webgpu-core/es/services/config/ConfigService.js");
/* harmony import */ var _utils_isSafari__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/isSafari */ "./node_modules/@antv/g-webgpu-core/es/utils/isSafari.js");





var AST_TOKEN_TYPES;
(function (AST_TOKEN_TYPES) {
  AST_TOKEN_TYPES["Void"] = "Void";
  AST_TOKEN_TYPES["Boolean"] = "Boolean";
  AST_TOKEN_TYPES["Float"] = "Float";
  AST_TOKEN_TYPES["Uint32"] = "Uint32";
  AST_TOKEN_TYPES["Int32"] = "Int32";
  AST_TOKEN_TYPES["Vector"] = "Vector";
  AST_TOKEN_TYPES["Vector2Float"] = "vec2<f32>";
  AST_TOKEN_TYPES["Vector3Float"] = "vec3<f32>";
  AST_TOKEN_TYPES["Vector4Float"] = "vec4<f32>";
  AST_TOKEN_TYPES["Vector2Boolean"] = "vec2<bool>";
  AST_TOKEN_TYPES["Vector3Boolean"] = "vec3<bool>";
  AST_TOKEN_TYPES["Vector4Boolean"] = "vec4<bool>";
  AST_TOKEN_TYPES["Vector2Uint"] = "vec2<u32>";
  AST_TOKEN_TYPES["Vector3Uint"] = "vec3<u32>";
  AST_TOKEN_TYPES["Vector4Uint"] = "vec4<u32>";
  AST_TOKEN_TYPES["Vector2Int"] = "vec2<i32>";
  AST_TOKEN_TYPES["Vector3Int"] = "vec3<i32>";
  AST_TOKEN_TYPES["Vector4Int"] = "vec4<i32>";
  AST_TOKEN_TYPES["Matrix"] = "Matrix";
  AST_TOKEN_TYPES["Matrix3x3Float"] = "mat3x3<f32>";
  AST_TOKEN_TYPES["Matrix4x4Float"] = "mat4x4<i32>";
  AST_TOKEN_TYPES["Struct"] = "Struct";
  AST_TOKEN_TYPES["FloatArray"] = "Float[]";
  AST_TOKEN_TYPES["Vector4FloatArray"] = "vec4<f32>[]";
})(AST_TOKEN_TYPES || (AST_TOKEN_TYPES = {}));
var AST_NODE_TYPES;
(function (AST_NODE_TYPES) {
  AST_NODE_TYPES["Program"] = "Program";
  AST_NODE_TYPES["Identifier"] = "Identifier";
  AST_NODE_TYPES["VariableDeclaration"] = "VariableDeclaration";
  AST_NODE_TYPES["BlockStatement"] = "BlockStatement";
  AST_NODE_TYPES["ReturnStatement"] = "ReturnStatement";
  AST_NODE_TYPES["FunctionDeclaration"] = "FunctionDeclaration";
  AST_NODE_TYPES["VariableDeclarator"] = "VariableDeclarator";
  AST_NODE_TYPES["AssignmentExpression"] = "AssignmentExpression";
  AST_NODE_TYPES["LogicalExpression"] = "LogicalExpression";
  AST_NODE_TYPES["BinaryExpression"] = "BinaryExpression";
  AST_NODE_TYPES["ArrayExpression"] = "ArrayExpression";
  AST_NODE_TYPES["UnaryExpression"] = "UnaryExpression";
  AST_NODE_TYPES["UpdateExpression"] = "UpdateExpression";
  AST_NODE_TYPES["FunctionExpression"] = "FunctionExpression";
  AST_NODE_TYPES["MemberExpression"] = "MemberExpression";
  AST_NODE_TYPES["ConditionalExpression"] = "ConditionalExpression";
  AST_NODE_TYPES["ExpressionStatement"] = "ExpressionStatement";
  AST_NODE_TYPES["CallExpression"] = "CallExpression";
  AST_NODE_TYPES["NumThreadStatement"] = "NumThreadStatement";
  AST_NODE_TYPES["StorageStatement"] = "StorageStatement";
  AST_NODE_TYPES["DoWhileStatement"] = "DoWhileStatement";
  AST_NODE_TYPES["WhileStatement"] = "WhileStatement";
  AST_NODE_TYPES["ForStatement"] = "ForStatement";
  AST_NODE_TYPES["BreakStatement"] = "BreakStatement";
  AST_NODE_TYPES["ContinueStatement"] = "ContinueStatement";
  AST_NODE_TYPES["IfStatement"] = "IfStatement";
  AST_NODE_TYPES["ImportedFunctionStatement"] = "ImportedFunctionStatement";
})(AST_NODE_TYPES || (AST_NODE_TYPES = {}));
var STORAGE_CLASS;
(function (STORAGE_CLASS) {
  STORAGE_CLASS["Input"] = "Input";
  STORAGE_CLASS["Output"] = "Output";
  STORAGE_CLASS["Uniform"] = "Uniform";
  STORAGE_CLASS["Workgroup"] = "Workgroup";
  STORAGE_CLASS["UniformConstant"] = "UniformConstant";
  STORAGE_CLASS["Image"] = "Image";
  STORAGE_CLASS["StorageBuffer"] = "StorageBuffer";
  STORAGE_CLASS["Private"] = "Private";
  STORAGE_CLASS["Function"] = "Function";
})(STORAGE_CLASS || (STORAGE_CLASS = {}));
/**
 * 根据目标平台生成 Shader 代码
 * * WebGL GLSL 1.0
 * * WebGPU Chrome/Edge GLSL 4.5 & WGSL @see https://gpuweb.github.io/gpuweb/wgsl.html
 * * Safari WHLSL (maybe deprecated)
 */
var Target;
(function (Target) {
  Target["GLSL100"] = "GLSL100";
  Target["GLSL450"] = "GLSL450";
  Target["WGSL"] = "WGSL";
})(Target || (Target = {}));
var DefineValuePlaceholder = '__DefineValuePlaceholder__';

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/g-webgpu-core/es/services/config/ConfigService.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@antv/g-webgpu-core/es/services/config/ConfigService.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConfigService: () => (/* binding */ ConfigService)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");


var ConfigService = /*#__PURE__*/function () {
  function ConfigService() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, ConfigService);
    this.config = void 0;
  }
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(ConfigService, [{
    key: "get",
    value: function get() {
      return this.config;
    }
  }, {
    key: "set",
    value: function set(config) {
      this.config = config;
    }
  }]);
  return ConfigService;
}();
//# sourceMappingURL=ConfigService.js.map

/***/ }),

/***/ "./node_modules/@antv/g-webgpu-core/es/utils/isSafari.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/g-webgpu-core/es/utils/isSafari.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isSafari: () => (/* binding */ isSafari)
/* harmony export */ });
var isSafari = typeof navigator !== 'undefined' && /Version\/[\d\.]+.*Safari/.test(navigator.userAgent);
//# sourceMappingURL=isSafari.js.map

/***/ }),

/***/ "./node_modules/@antv/g-webgpu-engine/es/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/g-webgpu-engine/es/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebGLEngine: () => (/* reexport safe */ _webgl__WEBPACK_IMPORTED_MODULE_0__.WebGLEngine)
/* harmony export */ });
/* harmony import */ var _webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgl */ "./node_modules/@antv/g-webgpu-engine/es/webgl/index.js");


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/g-webgpu-engine/es/utils/uniform.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/g-webgpu-engine/es/utils/uniform.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   extractUniforms: () => (/* binding */ extractUniforms)
/* harmony export */ });
/* harmony import */ var lodash_isTypedArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isTypedArray */ "./node_modules/lodash/isTypedArray.js");
/* harmony import */ var lodash_isTypedArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isTypedArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isPlainObject */ "./node_modules/lodash/isPlainObject.js");
/* harmony import */ var lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_1__);


/**
 * 考虑结构体命名, eg:
 * a: { b: 1 }  ->  'a.b'
 * a: [ { b: 1 } ] -> 'a[0].b'
 */
function extractUniforms(uniforms) {
  var extractedUniforms = {};
  Object.keys(uniforms).forEach(function (uniformName) {
    extractUniformsRecursively(uniformName, uniforms[uniformName], extractedUniforms, '');
  });
  return extractedUniforms;
}
function extractUniformsRecursively(uniformName, uniformValue, uniforms, prefix) {
  if (uniformValue === null || typeof uniformValue === 'number' ||
  // u_A: 1
  typeof uniformValue === 'boolean' ||
  // u_A: false
  Array.isArray(uniformValue) && typeof uniformValue[0] === 'number' ||
  // u_A: [1, 2, 3]
  lodash_isTypedArray__WEBPACK_IMPORTED_MODULE_0___default()(uniformValue) ||
  // u_A: Float32Array
  // @ts-ignore
  uniformValue === '' ||
  // @ts-ignore
  uniformValue.resize !== undefined) {
    uniforms["".concat(prefix && prefix + '.').concat(uniformName)] = uniformValue;
    return;
  }

  // u_Struct.a.b.c
  if (lodash_isPlainObject__WEBPACK_IMPORTED_MODULE_1___default()(uniformValue)) {
    Object.keys(uniformValue).forEach(function (childName) {
      extractUniformsRecursively(childName,
      // @ts-ignore
      uniformValue[childName], uniforms, "".concat(prefix && prefix + '.').concat(uniformName));
    });
  }

  // u_Struct[0].a
  if (Array.isArray(uniformValue)) {
    // @ts-ignore
    uniformValue.forEach(function (child, idx) {
      Object.keys(child).forEach(function (childName) {
        extractUniformsRecursively(childName,
        // @ts-ignore
        child[childName], uniforms, "".concat(prefix && prefix + '.').concat(uniformName, "[").concat(idx, "]"));
      });
    });
  }
}
//# sourceMappingURL=uniform.js.map

/***/ }),

/***/ "./node_modules/@antv/g-webgpu-engine/es/webgl/ReglAttribute.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@antv/g-webgpu-engine/es/webgl/ReglAttribute.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ReglAttribute)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");


/**
 * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#attributes
 */
var ReglAttribute = /*#__PURE__*/function () {
  function ReglAttribute(gl, options) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, ReglAttribute);
    this.attribute = void 0;
    this.buffer = void 0;
    var buffer = options.buffer,
      offset = options.offset,
      stride = options.stride,
      normalized = options.normalized,
      size = options.size,
      divisor = options.divisor;
    this.buffer = buffer;
    this.attribute = {
      buffer: buffer.get(),
      offset: offset || 0,
      stride: stride || 0,
      normalized: normalized || false,
      divisor: divisor || 0
    };
    if (size) {
      this.attribute.size = size;
    }
  }
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(ReglAttribute, [{
    key: "get",
    value: function get() {
      return this.attribute;
    }
  }, {
    key: "updateBuffer",
    value: function updateBuffer(options) {
      this.buffer.subData(options);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.buffer.destroy();
    }
  }]);
  return ReglAttribute;
}();

//# sourceMappingURL=ReglAttribute.js.map

/***/ }),

/***/ "./node_modules/@antv/g-webgpu-engine/es/webgl/ReglBuffer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@antv/g-webgpu-engine/es/webgl/ReglBuffer.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ReglBuffer)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @antv/g-webgpu-core */ "./node_modules/@antv/g-webgpu-core/es/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants */ "./node_modules/@antv/g-webgpu-engine/es/webgl/constants.js");





/**
 * adaptor for regl.Buffer
 * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#buffers
 */
var ReglBuffer = /*#__PURE__*/function () {
  function ReglBuffer(reGl, options) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, ReglBuffer);
    this.buffer = void 0;
    var data = options.data,
      usage = options.usage,
      type = options.type;
    // @ts-ignore
    this.buffer = reGl.buffer({
      data: data,
      usage: _constants__WEBPACK_IMPORTED_MODULE_3__.usageMap[usage || _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_2__.gl.STATIC_DRAW],
      type: _constants__WEBPACK_IMPORTED_MODULE_3__.dataTypeMap[type || _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_2__.gl.UNSIGNED_BYTE]
      // length: 0,
    });
  }
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(ReglBuffer, [{
    key: "get",
    value: function get() {
      return this.buffer;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      // this.buffer.destroy();
    }
  }, {
    key: "subData",
    value: function subData(_ref) {
      var data = _ref.data,
        offset = _ref.offset;
      // @ts-ignore
      this.buffer.subdata(data, offset);
    }
  }]);
  return ReglBuffer;
}();

//# sourceMappingURL=ReglBuffer.js.map

/***/ }),

/***/ "./node_modules/@antv/g-webgpu-engine/es/webgl/ReglComputeModel.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@antv/g-webgpu-engine/es/webgl/ReglComputeModel.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ReglComputeModel)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var lodash_isTypedArray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/isTypedArray */ "./node_modules/lodash/isTypedArray.js");
/* harmony import */ var lodash_isTypedArray__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(lodash_isTypedArray__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @antv/g-webgpu-core */ "./node_modules/@antv/g-webgpu-core/es/index.js");






function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }


/* babel-plugin-inline-import './shaders/quad.vert.glsl' */
var quadVert = "attribute vec3 a_Position;\nattribute vec2 a_TexCoord;\n\nvarying vec2 v_TexCoord;\n\nvoid main() {\n  gl_Position = vec4(a_Position, 1.0);\n  v_TexCoord = a_TexCoord;\n}";
var textureId = 0;
var debug = false;

/**
 * adaptor for regl.DrawCommand
 */
var ReglComputeModel = /*#__PURE__*/function () {
  function ReglComputeModel(reGl, context) {
    var _this = this;
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3__["default"])(this, ReglComputeModel);
    this.reGl = reGl;
    this.context = context;
    this.entity = (0,_antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_7__.createEntity)();
    this.texFBO = void 0;
    this.computeCommand = void 0;
    this.textureCache = {};
    this.outputTextureName = void 0;
    this.swapOutputTextureName = void 0;
    this.compiledPingpong = void 0;
    this.dynamicPingpong = void 0;
    var uniforms = {};
    this.context.uniforms.forEach(function (uniform) {
      var name = uniform.name,
        type = uniform.type,
        data = uniform.data,
        isReferer = uniform.isReferer,
        storageClass = uniform.storageClass;
      // store data with a 2D texture
      if (storageClass === _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_7__.STORAGE_CLASS.StorageBuffer) {
        if (!isReferer) {
          _this.textureCache[name] = _this.calcDataTexture(name, type, data);
          var _this$textureCache$na = _this.textureCache[name],
            width = _this$textureCache$na.textureWidth,
            isOutput = _this$textureCache$na.isOutput;
          uniforms["".concat(name, "Size")] = [width, width];
          if (isOutput) {
            _this.outputTextureName = name;
            if (_this.context.needPingpong) {
              _this.outputTextureName = "".concat(name, "Output");
              _this.textureCache[_this.outputTextureName] = _this.calcDataTexture(name, type, data);
            }
          }
        } else {
          // @ts-ignore
          _this.textureCache[name] = {
            data: undefined
          };
          // refer to another kernel's output,
          // the referred kernel may not have been initialized, so we use dynamic way here
          uniforms["".concat(name, "Size")] = function () {
            return (
              // @ts-ignore
              data.compiledBundle.context.output.textureSize
            );
          };
        }
        uniforms[name] = function () {
          if (debug) {
            console.log("[".concat(_this.entity, "]: ").concat(name, " ").concat(_this.textureCache[name].id));
          }
          return _this.textureCache[name].texture;
        };
      } else if (storageClass === _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_7__.STORAGE_CLASS.Uniform) {
        if (data && (Array.isArray(data) || lodash_isTypedArray__WEBPACK_IMPORTED_MODULE_5___default()(data)) && data.length > 16) {
          // up to mat4 which includes 16 elements
          throw new Error("invalid data type ".concat(type));
        }
        // get uniform dynamically
        uniforms[name] = function () {
          return uniform.data;
        };
      }
    });
    var _this$getOuputDataTex = this.getOuputDataTexture(),
      textureWidth = _this$getOuputDataTex.textureWidth,
      texelCount = _this$getOuputDataTex.texelCount;

    // 传入 output 纹理尺寸和数据长度，便于多余的 texel 提前退出
    uniforms.u_OutputTextureSize = [textureWidth, textureWidth];
    uniforms.u_OutputTexelCount = texelCount;

    // 保存在 Kernel 的上下文中，供其他 Kernel 引用
    this.context.output.textureSize = [textureWidth, textureWidth];
    var drawParams = {
      attributes: {
        a_Position: [[-1, 1, 0], [-1, -1, 0], [1, 1, 0], [1, -1, 0]],
        a_TexCoord: [[0, 1], [0, 0], [1, 1], [1, 0]]
      },
      frag: "#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n".concat(this.context.shader),
      uniforms: uniforms,
      vert: quadVert,
      // TODO: use a fullscreen triangle instead.
      primitive: 'triangle strip',
      count: 4
    };
    this.computeCommand = this.reGl(drawParams);
  }
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4__["default"])(ReglComputeModel, [{
    key: "run",
    value: function run() {
      var _this2 = this;
      if (this.context.maxIteration > 1 && this.context.needPingpong) {
        this.compiledPingpong = true;
      }
      // need pingpong when (@in@out and execute(10)) or use `setBinding('out', self)`
      // this.needPingpong =
      //   !!(this.context.maxIteration > 1 && this.context.needPingpong);

      // if (this.relativeOutputTextureNames.length) {
      //   const { id, texture } = this.getOuputDataTexture();
      //   this.relativeOutputTextureNames.forEach((name) => {
      //     this.textureCache[name].id = id;
      //     this.textureCache[name].texture = texture;
      //   });
      //   this.swap();
      // }

      if (this.compiledPingpong || this.dynamicPingpong) {
        this.swap();
      }
      this.texFBO = this.reGl.framebuffer({
        color: this.getOuputDataTexture().texture
      });
      this.texFBO.use(function () {
        _this2.computeCommand();
      });
      if (debug) {
        console.log("[".concat(this.entity, "]: output ").concat(this.getOuputDataTexture().id));
      }
    }
  }, {
    key: "readData",
    value: function () {
      var _readData = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_6___default().mark(function _callee() {
        var _this3 = this;
        var pixels, _this$getOuputDataTex2, originalDataLength, elementsPerTexel, _this$getOuputDataTex3, typedArrayConstructor, formattedPixels, i;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_6___default().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.reGl({
                  framebuffer: this.texFBO
                })(function () {
                  pixels = _this3.reGl.read();
                });

                // @ts-ignore
                if (!pixels) {
                  _context.next = 6;
                  break;
                }
                _this$getOuputDataTex2 = this.getOuputDataTexture(), originalDataLength = _this$getOuputDataTex2.originalDataLength, elementsPerTexel = _this$getOuputDataTex2.elementsPerTexel, _this$getOuputDataTex3 = _this$getOuputDataTex2.typedArrayConstructor, typedArrayConstructor = _this$getOuputDataTex3 === void 0 ? Float32Array : _this$getOuputDataTex3;
                formattedPixels = [];
                if (elementsPerTexel !== 4) {
                  for (i = 0; i < pixels.length; i += 4) {
                    if (elementsPerTexel === 1) {
                      formattedPixels.push(pixels[i]);
                    } else if (elementsPerTexel === 2) {
                      formattedPixels.push(pixels[i], pixels[i + 1]);
                    } else {
                      formattedPixels.push(pixels[i], pixels[i + 1], pixels[i + 2]);
                    }
                  }
                } else {
                  // @ts-ignore
                  formattedPixels = pixels;
                }

                // 截取多余的部分
                // @ts-ignore
                return _context.abrupt("return", new typedArrayConstructor(formattedPixels.slice(0, originalDataLength)));
              case 6:
                return _context.abrupt("return", new Float32Array());
              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));
      function readData() {
        return _readData.apply(this, arguments);
      }
      return readData;
    }()
  }, {
    key: "confirmInput",
    value: function confirmInput(model, inputName) {
      var inputModel;
      // refer to self, same as pingpong
      if (this.entity === model.entity) {
        this.dynamicPingpong = true;
        inputModel = this;
      } else {
        inputModel = model;
      }
      this.textureCache[inputName].id = inputModel.getOuputDataTexture().id;
      this.textureCache[inputName].texture = inputModel.getOuputDataTexture().texture;
      if (debug) {
        console.log("[".concat(this.entity, "]: confirm input ").concat(inputName, " from model ").concat(inputModel.entity, ", ").concat(inputModel.getOuputDataTexture().id));
      }
    }
  }, {
    key: "updateUniform",
    value: function updateUniform() {
      // already get uniform's data dynamically when created, do nothing here
    }
  }, {
    key: "updateBuffer",
    value: function updateBuffer(bufferName, data) {
      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      // regenerate data texture
      var buffer = this.context.uniforms.find(function (_ref) {
        var name = _ref.name;
        return name === bufferName;
      });
      if (buffer) {
        var _this$calcDataTexture = this.calcDataTexture(bufferName, buffer.type, data),
          texture = _this$calcDataTexture.texture,
          paddingData = _this$calcDataTexture.data;

        // TODO: destroy outdated texture
        this.textureCache[bufferName].data = paddingData;
        this.textureCache[bufferName].texture = texture;
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      // regl will destroy all resources
    }
  }, {
    key: "swap",
    value: function swap() {
      if (!this.swapOutputTextureName) {
        this.createSwapOutputDataTexture();
      }
      if (this.compiledPingpong) {
        var outputTextureUniformName = this.context.output.name;
        this.textureCache[outputTextureUniformName].id = this.getOuputDataTexture().id;
        this.textureCache[outputTextureUniformName].texture = this.getOuputDataTexture().texture;
      }
      var tmp = this.outputTextureName;
      this.outputTextureName = this.swapOutputTextureName;
      this.swapOutputTextureName = tmp;
      if (debug) {
        console.log("[".concat(this.entity, "]: after swap, output ").concat(this.getOuputDataTexture().id));
      }
    }
  }, {
    key: "getOuputDataTexture",
    value: function getOuputDataTexture() {
      return this.textureCache[this.outputTextureName];
    }
  }, {
    key: "createSwapOutputDataTexture",
    value: function createSwapOutputDataTexture() {
      var texture = this.cloneDataTexture(this.getOuputDataTexture());
      this.swapOutputTextureName = "".concat(this.entity, "-swap");
      this.textureCache[this.swapOutputTextureName] = texture;
    }
  }, {
    key: "cloneDataTexture",
    value: function cloneDataTexture(texture) {
      var data = texture.data,
        textureWidth = texture.textureWidth;
      return _objectSpread(_objectSpread({}, texture), {}, {
        id: textureId++,
        // @ts-ignore
        texture: this.reGl.texture({
          width: textureWidth,
          height: textureWidth,
          data: data,
          type: 'float'
        })
      });
    }
  }, {
    key: "calcDataTexture",
    value: function calcDataTexture(name, type, data) {
      var elementsPerTexel = 1;
      if (type === _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_7__.AST_TOKEN_TYPES.Vector4FloatArray) {
        elementsPerTexel = 4;
      }

      // 用 0 补全不足 vec4 的部分
      var paddingData = [];
      for (var i = 0; i < data.length; i += elementsPerTexel) {
        if (elementsPerTexel === 1) {
          paddingData.push(data[i], 0, 0, 0);
        } else if (elementsPerTexel === 2) {
          paddingData.push(data[i], data[i + 1], 0, 0);
        } else if (elementsPerTexel === 3) {
          paddingData.push(data[i], data[i + 1], data[i + 2], 0);
        } else if (elementsPerTexel === 4) {
          paddingData.push(data[i], data[i + 1], data[i + 2], data[i + 3]);
        }
      }

      // 使用纹理存储，例如 Array(8) 使用 3 * 3 纹理，末尾空白使用 0 填充
      var originalDataLength = data.length;
      var texelCount = Math.ceil(originalDataLength / elementsPerTexel);
      var width = Math.ceil(Math.sqrt(texelCount));
      var paddingTexelCount = width * width;
      if (texelCount < paddingTexelCount) {
        paddingData.push.apply(paddingData, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__["default"])(new Array((paddingTexelCount - texelCount) * 4).fill(0)));
      }
      var texture = this.reGl.texture({
        width: width,
        height: width,
        data: paddingData,
        type: 'float'
      });
      return {
        id: textureId++,
        data: paddingData,
        originalDataLength: originalDataLength,
        typedArrayConstructor: lodash_isTypedArray__WEBPACK_IMPORTED_MODULE_5___default()(data) ? data.constructor : undefined,
        textureWidth: width,
        texture: texture,
        texelCount: texelCount,
        elementsPerTexel: elementsPerTexel,
        isOutput: name === this.context.output.name
      };
    }
  }]);
  return ReglComputeModel;
}();

//# sourceMappingURL=ReglComputeModel.js.map

/***/ }),

/***/ "./node_modules/@antv/g-webgpu-engine/es/webgl/ReglElements.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@antv/g-webgpu-engine/es/webgl/ReglElements.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ReglElements)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @antv/g-webgpu-core */ "./node_modules/@antv/g-webgpu-core/es/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants */ "./node_modules/@antv/g-webgpu-engine/es/webgl/constants.js");





/**
 * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#elements
 */
var ReglElements = /*#__PURE__*/function () {
  function ReglElements(reGl, options) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, ReglElements);
    this.elements = void 0;
    var data = options.data,
      usage = options.usage,
      type = options.type,
      count = options.count;
    this.elements = reGl.elements({
      data: data,
      usage: _constants__WEBPACK_IMPORTED_MODULE_3__.usageMap[usage || _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_2__.gl.STATIC_DRAW],
      type: _constants__WEBPACK_IMPORTED_MODULE_3__.dataTypeMap[type || _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_2__.gl.UNSIGNED_BYTE],
      count: count
    });
  }
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(ReglElements, [{
    key: "get",
    value: function get() {
      return this.elements;
    }
  }, {
    key: "subData",
    value: function subData(_ref) {
      var data = _ref.data;
      this.elements.subdata(data);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.elements.destroy();
    }
  }]);
  return ReglElements;
}();

//# sourceMappingURL=ReglElements.js.map

/***/ }),

/***/ "./node_modules/@antv/g-webgpu-engine/es/webgl/ReglFramebuffer.js":
/*!************************************************************************!*\
  !*** ./node_modules/@antv/g-webgpu-engine/es/webgl/ReglFramebuffer.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ReglFramebuffer)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");


/**
 * adaptor for regl.Framebuffer
 * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#framebuffers
 */
var ReglFramebuffer = /*#__PURE__*/function () {
  function ReglFramebuffer(reGl, options) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, ReglFramebuffer);
    this.framebuffer = void 0;
    var width = options.width,
      height = options.height,
      color = options.color,
      colors = options.colors,
      depth = options.depth,
      stencil = options.stencil;
    var framebufferOptions = {
      width: width,
      height: height
    };
    if (Array.isArray(colors)) {
      framebufferOptions.colors = colors.map(function (c) {
        return c.get();
      });
    }
    if (color && typeof color !== 'boolean') {
      framebufferOptions.color = color.get();
    }

    // TODO: depth & stencil

    this.framebuffer = reGl.framebuffer(framebufferOptions);
  }
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(ReglFramebuffer, [{
    key: "get",
    value: function get() {
      return this.framebuffer;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.framebuffer.destroy();
    }
  }, {
    key: "resize",
    value: function resize(_ref) {
      var width = _ref.width,
        height = _ref.height;
      this.framebuffer.resize(width, height);
    }
  }]);
  return ReglFramebuffer;
}();

//# sourceMappingURL=ReglFramebuffer.js.map

/***/ }),

/***/ "./node_modules/@antv/g-webgpu-engine/es/webgl/ReglModel.js":
/*!******************************************************************!*\
  !*** ./node_modules/@antv/g-webgpu-engine/es/webgl/ReglModel.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ReglModel)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/esm/typeof.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @antv/g-webgpu-core */ "./node_modules/@antv/g-webgpu-core/es/index.js");
/* harmony import */ var _utils_uniform__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/uniform */ "./node_modules/@antv/g-webgpu-engine/es/utils/uniform.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./constants */ "./node_modules/@antv/g-webgpu-engine/es/webgl/constants.js");




function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }



/**
 * adaptor for regl.DrawCommand
 */
var ReglModel = /*#__PURE__*/function () {
  function ReglModel(reGl, options) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__["default"])(this, ReglModel);
    this.reGl = void 0;
    this.drawCommand = void 0;
    this.uniforms = {};
    this.reGl = reGl;
    var vs = options.vs,
      fs = options.fs,
      defines = options.defines,
      attributes = options.attributes,
      uniforms = options.uniforms,
      primitive = options.primitive,
      count = options.count,
      elements = options.elements,
      depth = options.depth,
      blend = options.blend,
      stencil = options.stencil,
      cull = options.cull,
      instances = options.instances,
      scissor = options.scissor,
      viewport = options.viewport;
    var reglUniforms = {};
    if (uniforms) {
      this.uniforms = (0,_utils_uniform__WEBPACK_IMPORTED_MODULE_5__.extractUniforms)(uniforms);
      Object.keys(uniforms).forEach(function (uniformName) {
        // use regl prop API
        // @ts-ignore
        reglUniforms[uniformName] = reGl.prop(uniformName);
      });
    }
    var reglAttributes = {};
    Object.keys(attributes).forEach(function (name) {
      reglAttributes[name] = attributes[name].get();
    });
    var defineStmts = defines && this.generateDefines(defines) || '';
    var drawParams = {
      attributes: reglAttributes,
      frag: "#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n".concat(defineStmts, "\n").concat(fs),
      uniforms: reglUniforms,
      vert: "\n".concat(defineStmts, "\n").concat(vs),
      primitive: _constants__WEBPACK_IMPORTED_MODULE_6__.primitiveMap[primitive === undefined ? _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_4__.gl.TRIANGLES : primitive]
    };
    if (instances) {
      drawParams.instances = instances;
    }

    // elements 中可能包含 count，此时不应传入
    if (count) {
      drawParams.count = count;
    }
    if (elements) {
      drawParams.elements = elements.get();
    }
    if (scissor) {
      drawParams.scissor = scissor;
    }
    if (viewport) {
      drawParams.viewport = viewport;
    }
    this.initDepthDrawParams({
      depth: depth
    }, drawParams);
    this.initBlendDrawParams({
      blend: blend
    }, drawParams);
    this.initStencilDrawParams({
      stencil: stencil
    }, drawParams);
    this.initCullDrawParams({
      cull: cull
    }, drawParams);
    this.drawCommand = reGl(drawParams);
  }
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__["default"])(ReglModel, [{
    key: "addUniforms",
    value: function addUniforms(uniforms) {
      this.uniforms = _objectSpread(_objectSpread({}, this.uniforms), (0,_utils_uniform__WEBPACK_IMPORTED_MODULE_5__.extractUniforms)(uniforms));
    }
  }, {
    key: "draw",
    value: function draw(options) {
      var uniforms = _objectSpread(_objectSpread({}, this.uniforms), (0,_utils_uniform__WEBPACK_IMPORTED_MODULE_5__.extractUniforms)(options.uniforms || {}));
      var reglDrawProps = {};
      Object.keys(uniforms).forEach(function (uniformName) {
        var type = (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(uniforms[uniformName]);
        if (type === 'boolean' || type === 'number' || Array.isArray(uniforms[uniformName]) ||
        // @ts-ignore
        uniforms[uniformName].BYTES_PER_ELEMENT) {
          reglDrawProps[uniformName] = uniforms[uniformName];
        } else if (type === 'string') {
          // TODO: image url
        } else {
          reglDrawProps[uniformName] = uniforms[uniformName].get();
        }
      });
      this.drawCommand(reglDrawProps);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      // don't need do anything since we will call `rendererService.cleanup()`
    }

    /**
     * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#depth-buffer
     */
  }, {
    key: "initDepthDrawParams",
    value: function initDepthDrawParams(_ref, drawParams) {
      var depth = _ref.depth;
      if (depth) {
        drawParams.depth = {
          enable: depth.enable === undefined ? true : !!depth.enable,
          mask: depth.mask === undefined ? true : !!depth.mask,
          func: _constants__WEBPACK_IMPORTED_MODULE_6__.depthFuncMap[depth.func || _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_4__.gl.LESS],
          range: depth.range || [0, 1]
        };
      }
    }

    /**
     * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#blending
     */
  }, {
    key: "initBlendDrawParams",
    value: function initBlendDrawParams(_ref2, drawParams) {
      var blend = _ref2.blend;
      if (blend) {
        var enable = blend.enable,
          func = blend.func,
          equation = blend.equation,
          _blend$color = blend.color,
          color = _blend$color === void 0 ? [0, 0, 0, 0] : _blend$color;
        // @ts-ignore
        drawParams.blend = {
          enable: !!enable,
          func: {
            srcRGB: _constants__WEBPACK_IMPORTED_MODULE_6__.blendFuncMap[func && func.srcRGB || _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_4__.gl.SRC_ALPHA],
            srcAlpha: _constants__WEBPACK_IMPORTED_MODULE_6__.blendFuncMap[func && func.srcAlpha || _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_4__.gl.SRC_ALPHA],
            dstRGB: _constants__WEBPACK_IMPORTED_MODULE_6__.blendFuncMap[func && func.dstRGB || _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_4__.gl.ONE_MINUS_SRC_ALPHA],
            dstAlpha: _constants__WEBPACK_IMPORTED_MODULE_6__.blendFuncMap[func && func.dstAlpha || _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_4__.gl.ONE_MINUS_SRC_ALPHA]
          },
          equation: {
            rgb: _constants__WEBPACK_IMPORTED_MODULE_6__.blendEquationMap[equation && equation.rgb || _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_4__.gl.FUNC_ADD],
            alpha: _constants__WEBPACK_IMPORTED_MODULE_6__.blendEquationMap[equation && equation.alpha || _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_4__.gl.FUNC_ADD]
          },
          color: color
        };
      }
    }

    /**
     * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#stencil
     */
  }, {
    key: "initStencilDrawParams",
    value: function initStencilDrawParams(_ref3, drawParams) {
      var stencil = _ref3.stencil;
      if (stencil) {
        var enable = stencil.enable,
          _stencil$mask = stencil.mask,
          mask = _stencil$mask === void 0 ? -1 : _stencil$mask,
          _stencil$func = stencil.func,
          func = _stencil$func === void 0 ? {
            cmp: _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_4__.gl.ALWAYS,
            ref: 0,
            mask: -1
          } : _stencil$func,
          _stencil$opFront = stencil.opFront,
          opFront = _stencil$opFront === void 0 ? {
            fail: _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_4__.gl.KEEP,
            zfail: _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_4__.gl.KEEP,
            zpass: _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_4__.gl.KEEP
          } : _stencil$opFront,
          _stencil$opBack = stencil.opBack,
          opBack = _stencil$opBack === void 0 ? {
            fail: _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_4__.gl.KEEP,
            zfail: _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_4__.gl.KEEP,
            zpass: _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_4__.gl.KEEP
          } : _stencil$opBack;
        drawParams.stencil = {
          enable: !!enable,
          mask: mask,
          func: _objectSpread(_objectSpread({}, func), {}, {
            cmp: _constants__WEBPACK_IMPORTED_MODULE_6__.stencilFuncMap[func.cmp]
          }),
          opFront: {
            fail: _constants__WEBPACK_IMPORTED_MODULE_6__.stencilOpMap[opFront.fail],
            zfail: _constants__WEBPACK_IMPORTED_MODULE_6__.stencilOpMap[opFront.zfail],
            zpass: _constants__WEBPACK_IMPORTED_MODULE_6__.stencilOpMap[opFront.zpass]
          },
          opBack: {
            fail: _constants__WEBPACK_IMPORTED_MODULE_6__.stencilOpMap[opBack.fail],
            zfail: _constants__WEBPACK_IMPORTED_MODULE_6__.stencilOpMap[opBack.zfail],
            zpass: _constants__WEBPACK_IMPORTED_MODULE_6__.stencilOpMap[opBack.zpass]
          }
        };
      }
    }

    /**
     * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#culling
     */
  }, {
    key: "initCullDrawParams",
    value: function initCullDrawParams(_ref4, drawParams) {
      var cull = _ref4.cull;
      if (cull) {
        var enable = cull.enable,
          _cull$face = cull.face,
          face = _cull$face === void 0 ? _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_4__.gl.BACK : _cull$face;
        drawParams.cull = {
          enable: !!enable,
          face: _constants__WEBPACK_IMPORTED_MODULE_6__.cullFaceMap[face]
        };
      }
    }
  }, {
    key: "generateDefines",
    value: function generateDefines(defines) {
      return Object.keys(defines).map(function (name) {
        return "#define ".concat(name, " ").concat(Number(defines[name]));
      }).join('\n');
    }
  }]);
  return ReglModel;
}();

//# sourceMappingURL=ReglModel.js.map

/***/ }),

/***/ "./node_modules/@antv/g-webgpu-engine/es/webgl/ReglTexture2D.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@antv/g-webgpu-engine/es/webgl/ReglTexture2D.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ReglTexture2D)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @antv/g-webgpu-core */ "./node_modules/@antv/g-webgpu-core/es/index.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants */ "./node_modules/@antv/g-webgpu-engine/es/webgl/constants.js");





/**
 * adaptor for regl.Buffer
 * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#buffers
 */
var ReglTexture2D = /*#__PURE__*/function () {
  function ReglTexture2D(reGl, options) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, ReglTexture2D);
    this.texture = void 0;
    this.width = void 0;
    this.height = void 0;
    var data = options.data,
      _options$type = options.type,
      type = _options$type === void 0 ? _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_2__.gl.UNSIGNED_BYTE : _options$type,
      width = options.width,
      height = options.height,
      _options$flipY = options.flipY,
      flipY = _options$flipY === void 0 ? false : _options$flipY,
      _options$format = options.format,
      format = _options$format === void 0 ? _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_2__.gl.RGBA : _options$format,
      _options$mipmap = options.mipmap,
      mipmap = _options$mipmap === void 0 ? false : _options$mipmap,
      _options$wrapS = options.wrapS,
      wrapS = _options$wrapS === void 0 ? _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_2__.gl.CLAMP_TO_EDGE : _options$wrapS,
      _options$wrapT = options.wrapT,
      wrapT = _options$wrapT === void 0 ? _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_2__.gl.CLAMP_TO_EDGE : _options$wrapT,
      _options$aniso = options.aniso,
      aniso = _options$aniso === void 0 ? 0 : _options$aniso,
      _options$alignment = options.alignment,
      alignment = _options$alignment === void 0 ? 1 : _options$alignment,
      _options$premultiplyA = options.premultiplyAlpha,
      premultiplyAlpha = _options$premultiplyA === void 0 ? false : _options$premultiplyA,
      _options$mag = options.mag,
      mag = _options$mag === void 0 ? _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_2__.gl.NEAREST : _options$mag,
      _options$min = options.min,
      min = _options$min === void 0 ? _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_2__.gl.NEAREST : _options$min,
      _options$colorSpace = options.colorSpace,
      colorSpace = _options$colorSpace === void 0 ? _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_2__.gl.BROWSER_DEFAULT_WEBGL : _options$colorSpace;
    this.width = width;
    this.height = height;
    var textureOptions = {
      width: width,
      height: height,
      // @ts-ignore
      type: _constants__WEBPACK_IMPORTED_MODULE_3__.dataTypeMap[type],
      format: _constants__WEBPACK_IMPORTED_MODULE_3__.formatMap[format],
      wrapS: _constants__WEBPACK_IMPORTED_MODULE_3__.wrapModeMap[wrapS],
      wrapT: _constants__WEBPACK_IMPORTED_MODULE_3__.wrapModeMap[wrapT],
      // @ts-ignore
      mag: _constants__WEBPACK_IMPORTED_MODULE_3__.filterMap[mag],
      min: _constants__WEBPACK_IMPORTED_MODULE_3__.filterMap[min],
      alignment: alignment,
      flipY: flipY,
      colorSpace: _constants__WEBPACK_IMPORTED_MODULE_3__.colorSpaceMap[colorSpace],
      premultiplyAlpha: premultiplyAlpha,
      aniso: aniso
    };
    if (data) {
      textureOptions.data = data;
    }
    if (typeof mipmap === 'number') {
      textureOptions.mipmap = _constants__WEBPACK_IMPORTED_MODULE_3__.mipmapMap[mipmap];
    } else if (typeof mipmap === 'boolean') {
      textureOptions.mipmap = mipmap;
    }
    this.texture = reGl.texture(textureOptions);
  }
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(ReglTexture2D, [{
    key: "get",
    value: function get() {
      return this.texture;
    }
  }, {
    key: "update",
    value: function update() {
      // @ts-ignore
      this.texture._texture.bind();
    }
  }, {
    key: "resize",
    value: function resize(_ref) {
      var width = _ref.width,
        height = _ref.height;
      this.texture.resize(width, height);
      this.width = width;
      this.height = height;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.texture.destroy();
    }
  }]);
  return ReglTexture2D;
}();

//# sourceMappingURL=ReglTexture2D.js.map

/***/ }),

/***/ "./node_modules/@antv/g-webgpu-engine/es/webgl/constants.js":
/*!******************************************************************!*\
  !*** ./node_modules/@antv/g-webgpu-engine/es/webgl/constants.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   blendEquationMap: () => (/* binding */ blendEquationMap),
/* harmony export */   blendFuncMap: () => (/* binding */ blendFuncMap),
/* harmony export */   colorSpaceMap: () => (/* binding */ colorSpaceMap),
/* harmony export */   cullFaceMap: () => (/* binding */ cullFaceMap),
/* harmony export */   dataTypeMap: () => (/* binding */ dataTypeMap),
/* harmony export */   depthFuncMap: () => (/* binding */ depthFuncMap),
/* harmony export */   filterMap: () => (/* binding */ filterMap),
/* harmony export */   formatMap: () => (/* binding */ formatMap),
/* harmony export */   mipmapMap: () => (/* binding */ mipmapMap),
/* harmony export */   primitiveMap: () => (/* binding */ primitiveMap),
/* harmony export */   stencilFuncMap: () => (/* binding */ stencilFuncMap),
/* harmony export */   stencilOpMap: () => (/* binding */ stencilOpMap),
/* harmony export */   usageMap: () => (/* binding */ usageMap),
/* harmony export */   wrapModeMap: () => (/* binding */ wrapModeMap)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/g-webgpu-core */ "./node_modules/@antv/g-webgpu-core/es/index.js");

var _primitiveMap, _usageMap, _dataTypeMap, _formatMap, _mipmapMap, _filterMap, _wrapModeMap, _colorSpaceMap, _depthFuncMap, _blendEquationMap, _blendFuncMap, _stencilFuncMap, _stencilOpMap, _cullFaceMap;
/**
 * @desc 由于 regl 使用大量字符串而非 WebGL 常量，因此需要映射
 */

// @see https://github.com/regl-project/regl/blob/gh-pages/lib/constants/primitives.json
var primitiveMap = (_primitiveMap = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_primitiveMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.POINTS, 'points'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_primitiveMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.LINES, 'lines'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_primitiveMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.LINE_LOOP, 'line loop'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_primitiveMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.LINE_STRIP, 'line strip'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_primitiveMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.TRIANGLES, 'triangles'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_primitiveMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.TRIANGLE_FAN, 'triangle fan'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_primitiveMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.TRIANGLE_STRIP, 'triangle strip'), _primitiveMap);
var usageMap = (_usageMap = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_usageMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.STATIC_DRAW, 'static'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_usageMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.DYNAMIC_DRAW, 'dynamic'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_usageMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.STREAM_DRAW, 'stream'), _usageMap);
var dataTypeMap = (_dataTypeMap = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_dataTypeMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.BYTE, 'int8'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_dataTypeMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.UNSIGNED_INT, 'int16'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_dataTypeMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.INT, 'int32'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_dataTypeMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.UNSIGNED_BYTE, 'uint8'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_dataTypeMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.UNSIGNED_SHORT, 'uint16'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_dataTypeMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.UNSIGNED_INT, 'uint32'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_dataTypeMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.FLOAT, 'float'), _dataTypeMap);
var formatMap = (_formatMap = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_formatMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.ALPHA, 'alpha'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_formatMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.LUMINANCE, 'luminance'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_formatMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.LUMINANCE_ALPHA, 'luminance alpha'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_formatMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.RGB, 'rgb'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_formatMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.RGBA, 'rgba'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_formatMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.RGBA4, 'rgba4'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_formatMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.RGB5_A1, 'rgb5 a1'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_formatMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.RGB565, 'rgb565'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_formatMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.DEPTH_COMPONENT, 'depth'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_formatMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.DEPTH_STENCIL, 'depth stencil'), _formatMap);
var mipmapMap = (_mipmapMap = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_mipmapMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.DONT_CARE, 'dont care'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_mipmapMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.NICEST, 'nice'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_mipmapMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.FASTEST, 'fast'), _mipmapMap);
var filterMap = (_filterMap = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_filterMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.NEAREST, 'nearest'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_filterMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.LINEAR, 'linear'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_filterMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.LINEAR_MIPMAP_LINEAR, 'mipmap'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_filterMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.NEAREST_MIPMAP_LINEAR, 'nearest mipmap linear'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_filterMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.LINEAR_MIPMAP_NEAREST, 'linear mipmap nearest'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_filterMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.NEAREST_MIPMAP_NEAREST, 'nearest mipmap nearest'), _filterMap);
var wrapModeMap = (_wrapModeMap = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_wrapModeMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.REPEAT, 'repeat'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_wrapModeMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.CLAMP_TO_EDGE, 'clamp'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_wrapModeMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.MIRRORED_REPEAT, 'mirror'), _wrapModeMap);
var colorSpaceMap = (_colorSpaceMap = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_colorSpaceMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.NONE, 'none'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_colorSpaceMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.BROWSER_DEFAULT_WEBGL, 'browser'), _colorSpaceMap);
var depthFuncMap = (_depthFuncMap = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_depthFuncMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.NEVER, 'never'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_depthFuncMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.ALWAYS, 'always'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_depthFuncMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.LESS, 'less'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_depthFuncMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.LEQUAL, 'lequal'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_depthFuncMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.GREATER, 'greater'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_depthFuncMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.GEQUAL, 'gequal'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_depthFuncMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.EQUAL, 'equal'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_depthFuncMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.NOTEQUAL, 'notequal'), _depthFuncMap);
var blendEquationMap = (_blendEquationMap = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_blendEquationMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.FUNC_ADD, 'add'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_blendEquationMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.MIN_EXT, 'min'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_blendEquationMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.MAX_EXT, 'max'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_blendEquationMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.FUNC_SUBTRACT, 'subtract'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_blendEquationMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.FUNC_REVERSE_SUBTRACT, 'reverse subtract'), _blendEquationMap);
var blendFuncMap = (_blendFuncMap = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_blendFuncMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.ZERO, 'zero'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_blendFuncMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.ONE, 'one'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_blendFuncMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.SRC_COLOR, 'src color'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_blendFuncMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.ONE_MINUS_SRC_COLOR, 'one minus src color'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_blendFuncMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.SRC_ALPHA, 'src alpha'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_blendFuncMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.ONE_MINUS_SRC_ALPHA, 'one minus src alpha'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_blendFuncMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.DST_COLOR, 'dst color'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_blendFuncMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.ONE_MINUS_DST_COLOR, 'one minus dst color'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_blendFuncMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.DST_ALPHA, 'dst alpha'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_blendFuncMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.ONE_MINUS_DST_ALPHA, 'one minus dst alpha'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_blendFuncMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.CONSTANT_COLOR, 'constant color'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_blendFuncMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.ONE_MINUS_CONSTANT_COLOR, 'one minus constant color'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_blendFuncMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.CONSTANT_ALPHA, 'constant alpha'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_blendFuncMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.ONE_MINUS_CONSTANT_ALPHA, 'one minus constant alpha'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_blendFuncMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.SRC_ALPHA_SATURATE, 'src alpha saturate'), _blendFuncMap);
var stencilFuncMap = (_stencilFuncMap = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_stencilFuncMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.NEVER, 'never'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_stencilFuncMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.ALWAYS, 'always'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_stencilFuncMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.LESS, 'less'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_stencilFuncMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.LEQUAL, 'lequal'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_stencilFuncMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.GREATER, 'greater'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_stencilFuncMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.GEQUAL, 'gequal'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_stencilFuncMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.EQUAL, 'equal'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_stencilFuncMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.NOTEQUAL, 'notequal'), _stencilFuncMap);
var stencilOpMap = (_stencilOpMap = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_stencilOpMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.ZERO, 'zero'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_stencilOpMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.KEEP, 'keep'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_stencilOpMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.REPLACE, 'replace'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_stencilOpMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.INVERT, 'invert'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_stencilOpMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.INCR, 'increment'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_stencilOpMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.DECR, 'decrement'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_stencilOpMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.INCR_WRAP, 'increment wrap'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_stencilOpMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.DECR_WRAP, 'decrement wrap'), _stencilOpMap);
var cullFaceMap = (_cullFaceMap = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_cullFaceMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.FRONT, 'front'), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_cullFaceMap, _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_1__.gl.BACK, 'back'), _cullFaceMap);
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "./node_modules/@antv/g-webgpu-engine/es/webgl/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/g-webgpu-engine/es/webgl/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebGLEngine: () => (/* binding */ WebGLEngine)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @antv/g-webgpu-core */ "./node_modules/@antv/g-webgpu-core/es/index.js");
/* harmony import */ var regl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! regl */ "./node_modules/regl/dist/regl.js");
/* harmony import */ var regl__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(regl__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _ReglAttribute__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ReglAttribute */ "./node_modules/@antv/g-webgpu-engine/es/webgl/ReglAttribute.js");
/* harmony import */ var _ReglBuffer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ReglBuffer */ "./node_modules/@antv/g-webgpu-engine/es/webgl/ReglBuffer.js");
/* harmony import */ var _ReglComputeModel__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ReglComputeModel */ "./node_modules/@antv/g-webgpu-engine/es/webgl/ReglComputeModel.js");
/* harmony import */ var _ReglElements__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ReglElements */ "./node_modules/@antv/g-webgpu-engine/es/webgl/ReglElements.js");
/* harmony import */ var _ReglFramebuffer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ReglFramebuffer */ "./node_modules/@antv/g-webgpu-engine/es/webgl/ReglFramebuffer.js");
/* harmony import */ var _ReglModel__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./ReglModel */ "./node_modules/@antv/g-webgpu-engine/es/webgl/ReglModel.js");
/* harmony import */ var _ReglTexture2D__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./ReglTexture2D */ "./node_modules/@antv/g-webgpu-engine/es/webgl/ReglTexture2D.js");




/**
 * render w/ regl
 * @see https://github.com/regl-project/regl/blob/gh-pages/API.md
 */










/**
 * regl renderer
 */
var WebGLEngine = /*#__PURE__*/function () {
  function WebGLEngine() {
    var _this = this;
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__["default"])(this, WebGLEngine);
    this.supportWebGPU = false;
    this.useWGSL = false;
    this.$canvas = void 0;
    this.gl = void 0;
    this.inited = void 0;
    this.createModel = /*#__PURE__*/function () {
      var _ref = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee2(options) {
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!options.uniforms) {
                  _context2.next = 3;
                  break;
                }
                _context2.next = 3;
                return Promise.all(Object.keys(options.uniforms).map( /*#__PURE__*/function () {
                  var _ref2 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee(name) {
                    var texture;
                    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            if (!(options.uniforms[name] &&
                            // @ts-ignore
                            options.uniforms[name].load !== undefined)) {
                              _context.next = 5;
                              break;
                            }
                            _context.next = 3;
                            return options.uniforms[name].load();
                          case 3:
                            texture = _context.sent;
                            // @ts-ignore
                            options.uniforms[name] = texture;
                          case 5:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  }));
                  return function (_x2) {
                    return _ref2.apply(this, arguments);
                  };
                }()));
              case 3:
                return _context2.abrupt("return", new _ReglModel__WEBPACK_IMPORTED_MODULE_11__["default"](_this.gl, options));
              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));
      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }();
    this.createAttribute = function (options) {
      return new _ReglAttribute__WEBPACK_IMPORTED_MODULE_6__["default"](_this.gl, options);
    };
    this.createBuffer = function (options) {
      return new _ReglBuffer__WEBPACK_IMPORTED_MODULE_7__["default"](_this.gl, options);
    };
    this.createElements = function (options) {
      return new _ReglElements__WEBPACK_IMPORTED_MODULE_9__["default"](_this.gl, options);
    };
    this.createTexture2D = function (options) {
      return new _ReglTexture2D__WEBPACK_IMPORTED_MODULE_12__["default"](_this.gl, options);
    };
    this.createFramebuffer = function (options) {
      return new _ReglFramebuffer__WEBPACK_IMPORTED_MODULE_10__["default"](_this.gl, options);
    };
    this.useFramebuffer = function (framebuffer, drawCommands) {
      _this.gl({
        framebuffer: framebuffer ? framebuffer.get() : null
      })(drawCommands);
    };
    this.createComputeModel = /*#__PURE__*/function () {
      var _ref3 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee3(context) {
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", new _ReglComputeModel__WEBPACK_IMPORTED_MODULE_8__["default"](_this.gl, context));
              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));
      return function (_x3) {
        return _ref3.apply(this, arguments);
      };
    }();
    this.clear = function (options) {
      // @see https://github.com/regl-project/regl/blob/gh-pages/API.md#clear-the-draw-buffer
      var color = options.color,
        depth = options.depth,
        stencil = options.stencil,
        _options$framebuffer = options.framebuffer,
        framebuffer = _options$framebuffer === void 0 ? null : _options$framebuffer;
      var reglClearOptions = {
        color: color,
        depth: depth,
        stencil: stencil
      };
      reglClearOptions.framebuffer = framebuffer === null ? framebuffer : framebuffer.get();
      _this.gl.clear(reglClearOptions);
    };
    this.setScissor = function (scissor) {
      if (_this.gl && _this.gl._gl) {
        // https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/scissor
        if (scissor.enable && scissor.box) {
          // console.log(scissor.box);
          _this.gl._gl.enable(_antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_4__.gl.SCISSOR_TEST);
          _this.gl._gl.scissor(scissor.box.x, scissor.box.y, scissor.box.width, scissor.box.height);
        } else {
          _this.gl._gl.disable(_antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_4__.gl.SCISSOR_TEST);
        }
        _this.gl._refresh();
      }
    };
    this.viewport = function (_ref4) {
      var x = _ref4.x,
        y = _ref4.y,
        width = _ref4.width,
        height = _ref4.height;
      if (_this.gl && _this.gl._gl) {
        // use WebGL context directly
        // @see https://github.com/regl-project/regl/blob/gh-pages/API.md#unsafe-escape-hatch
        _this.gl._gl.viewport(x, y, width, height);
        _this.gl._refresh();
      }
    };
    this.readPixels = function (options) {
      var framebuffer = options.framebuffer,
        x = options.x,
        y = options.y,
        width = options.width,
        height = options.height;
      var readPixelsOptions = {
        x: x,
        y: y,
        width: width,
        height: height
      };
      if (framebuffer) {
        readPixelsOptions.framebuffer = framebuffer.get();
      }
      return _this.gl.read(readPixelsOptions);
    };
    this.getCanvas = function () {
      return _this.$canvas;
    };
    this.getGLContext = function () {
      return _this.gl._gl;
    };
    this.destroy = function () {
      if (_this.gl) {
        // @see https://github.com/regl-project/regl/blob/gh-pages/API.md#clean-up
        _this.gl.destroy();
        _this.inited = false;
      }
    };
  }
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__["default"])(WebGLEngine, [{
    key: "init",
    value: function () {
      var _init = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee4(cfg) {
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!this.inited) {
                  _context4.next = 2;
                  break;
                }
                return _context4.abrupt("return");
              case 2:
                this.$canvas = cfg.canvas;
                // tslint:disable-next-line:typedef
                _context4.next = 5;
                return new Promise(function (resolve, reject) {
                  regl__WEBPACK_IMPORTED_MODULE_5___default()({
                    canvas: cfg.canvas,
                    attributes: {
                      alpha: true,
                      // use TAA instead of MSAA
                      // @see https://www.khronos.org/registry/webgl/specs/1.0/#5.2.1
                      antialias: cfg.antialias,
                      premultipliedAlpha: true
                      // preserveDrawingBuffer: false,
                    },

                    pixelRatio: 1,
                    // TODO: use extensions
                    extensions: ['OES_element_index_uint', 'OES_texture_float', 'OES_standard_derivatives',
                    // wireframe
                    'angle_instanced_arrays' // VSM shadow map
                    ],

                    optionalExtensions: ['EXT_texture_filter_anisotropic', 'EXT_blend_minmax', 'WEBGL_depth_texture'],
                    profile: true,
                    onDone: function onDone(err, r) {
                      if (err || !r) {
                        reject(err);
                      }
                      // @ts-ignore
                      resolve(r);
                    }
                  });
                });
              case 5:
                this.gl = _context4.sent;
                this.inited = true;
              case 7:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));
      function init(_x4) {
        return _init.apply(this, arguments);
      }
      return init;
    }()
  }, {
    key: "isFloatSupported",
    value: function isFloatSupported() {
      // @see https://github.com/antvis/GWebGPUEngine/issues/26
      // @ts-ignore
      return this.gl.limits.readFloat;
    }
  }, {
    key: "beginFrame",
    value: function beginFrame() {
      //
    }
  }, {
    key: "endFrame",
    value: function endFrame() {
      //
    }
  }]);
  return WebGLEngine;
}();
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/g-webgpu/es/Kernel.js":
/*!**************************************************!*\
  !*** ./node_modules/@antv/g-webgpu/es/Kernel.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Kernel: () => (/* binding */ Kernel)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var lodash_isTypedArray__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash/isTypedArray */ "./node_modules/lodash/isTypedArray.js");
/* harmony import */ var lodash_isTypedArray__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash_isTypedArray__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/isNumber */ "./node_modules/lodash/isNumber.js");
/* harmony import */ var lodash_isNumber__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(lodash_isNumber__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var lodash_isArray__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash/isArray */ "./node_modules/lodash/isArray.js");
/* harmony import */ var lodash_isArray__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(lodash_isArray__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @antv/g-webgpu-core */ "./node_modules/@antv/g-webgpu-core/es/index.js");
/* harmony import */ var _utils_canvas__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/canvas */ "./node_modules/@antv/g-webgpu/es/utils/canvas.js");








function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }


var Kernel = /*#__PURE__*/function () {
  function Kernel(engine, configService) {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__["default"])(this, Kernel);
    this.engine = engine;
    this.configService = configService;
    this.model = void 0;
    this.dirty = true;
    this.compiledBundle = void 0;
    this.initPromise = void 0;
  }
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__["default"])(Kernel, [{
    key: "init",
    value: function init() {
      var _this$configService$g = this.configService.get(),
        canvas = _this$configService$g.canvas,
        engineOptions = _this$configService$g.engineOptions;
      this.initPromise = this.engine.init(_objectSpread({
        canvas: canvas || (0,_utils_canvas__WEBPACK_IMPORTED_MODULE_9__.createCanvas)(),
        // swapChainFormat: WebGPUConstants.TextureFormat.BGRA8Unorm,
        antialiasing: false
      }, engineOptions));
    }
  }, {
    key: "setBundle",
    value: function setBundle(bundle) {
      // deep clone
      this.compiledBundle = JSON.parse(JSON.stringify(bundle));
    }
  }, {
    key: "setDispatch",
    value: function setDispatch(dispatch) {
      if (this.compiledBundle.context) {
        this.compiledBundle.context.dispatch = dispatch;
      }
      return this;
    }
  }, {
    key: "setMaxIteration",
    value: function setMaxIteration(maxIteration) {
      if (this.compiledBundle.context) {
        this.compiledBundle.context.maxIteration = maxIteration;
      }
      return this;
    }
  }, {
    key: "setBinding",
    value: function setBinding(name, data) {
      var _this = this;
      if (typeof name === 'string') {
        var isNumberLikeData = lodash_isNumber__WEBPACK_IMPORTED_MODULE_5___default()(data) || lodash_isTypedArray__WEBPACK_IMPORTED_MODULE_4___default()(data) || lodash_isArray__WEBPACK_IMPORTED_MODULE_6___default()(data);
        if (this.compiledBundle && this.compiledBundle.context) {
          // set define, eg. setBinding('MAX_LENGTH', 10)
          var existedDefine = this.compiledBundle.context.defines.find(function (b) {
            return b.name === name;
          });
          if (existedDefine) {
            existedDefine.value = data;
            return this;
          }

          // set uniform
          var existedBinding = this.compiledBundle.context.uniforms.find(function (b) {
            return b.name === name;
          });
          if (existedBinding) {
            // update uniform or buffer
            if (isNumberLikeData) {
              // @ts-ignore
              existedBinding.data = data;
              existedBinding.isReferer = false;
              if (existedBinding.storageClass === _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_8__.STORAGE_CLASS.Uniform) {
                if (this.model) {
                  // @ts-ignore
                  this.model.updateUniform(name, data);
                }
              } else {
                if (this.model) {
                  // @ts-ignore
                  this.model.updateBuffer(name, data);
                }
              }
            } else {
              // update with another kernel
              existedBinding.isReferer = true;
              // @ts-ignore
              existedBinding.data = data;
            }
          }
        }
      } else {
        Object.keys(name).forEach(function (key) {
          _this.setBinding(key, name[key]);
        });
      }
      return this;
    }
  }, {
    key: "execute",
    value: function () {
      var _execute = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_7___default().mark(function _callee() {
        var _this2 = this;
        var iteration,
          i,
          _args = arguments;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_7___default().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                iteration = _args.length > 0 && _args[0] !== undefined ? _args[0] : 1;
                if (!this.dirty) {
                  _context.next = 6;
                  break;
                }
                if (this.compiledBundle.context) {
                  if (iteration > 1) {
                    this.compiledBundle.context.maxIteration = iteration;
                  } else {
                    this.compiledBundle.context.maxIteration++;
                  }
                }
                _context.next = 5;
                return this.compile();
              case 5:
                this.dirty = false;
              case 6:
                this.engine.beginFrame();

                // 首先开启当前 frame 的 compute pass
                this.engine.clear({});
                if (this.compiledBundle.context) {
                  this.compiledBundle.context.uniforms.filter(function (_ref) {
                    var isReferer = _ref.isReferer;
                    return isReferer;
                  }).forEach(function (_ref2) {
                    var data = _ref2.data,
                      name = _ref2.name;
                    // @ts-ignore
                    _this2.model.confirmInput(data.model, name);
                  });
                }
                for (i = 0; i < iteration; i++) {
                  this.model.run();
                }
                this.engine.endFrame();
                return _context.abrupt("return", this);
              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));
      function execute() {
        return _execute.apply(this, arguments);
      }
      return execute;
    }()
    /**
     * read output from GPUBuffer
     */
  }, {
    key: "getOutput",
    value: function () {
      var _getOutput = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_7___default().mark(function _callee2() {
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_7___default().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", this.model.readData());
              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));
      function getOutput() {
        return _getOutput.apply(this, arguments);
      }
      return getOutput;
    }()
  }, {
    key: "compile",
    value: function () {
      var _compile = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_7___default().mark(function _callee3() {
        var context, target, shader;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_7___default().wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.initPromise;
              case 2:
                context = _objectSpread({}, this.compiledBundle.context);
                target = this.engine.supportWebGPU ? this.engine.useWGSL ? _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_8__.Target.WGSL : _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_8__.Target.GLSL450 : _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_8__.Target.GLSL100;
                shader = this.compiledBundle.shaders[target]; // this.bindings?.forEach(({ name, data }) => {
                //   if (name === name.toUpperCase()) {
                //     const define = context.defines.find((d) => d.name === name);
                //     if (define) {
                //       // @ts-ignore
                //       define.value = data;
                //     }
                //   }
                // });
                // 生成运行时 define
                context.defines.filter(function (define) {
                  return define.runtime;
                }).forEach(function (define) {
                  var valuePlaceHolder = "".concat(_antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_8__.DefineValuePlaceholder).concat(define.name);
                  shader = shader.replace(valuePlaceHolder, "".concat(define.value));
                });
                context.shader = shader;

                // 添加 uniform 绑定的数据
                context.uniforms.forEach(function (uniform) {
                  // const binding = this.bindings.find((b) => b.name === uniform.name);
                  // if (binding) {
                  //   // @ts-ignore
                  //   uniform.data = binding.referer || binding.data;
                  //   // @ts-ignore
                  //   uniform.isReferer = !!binding.referer;
                  // }

                  // 未指定数据，尝试根据 uniform 类型初始化
                  if (!uniform.data) {
                    if (uniform.storageClass === _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_8__.STORAGE_CLASS.StorageBuffer) {
                      var sizePerElement = 1;
                      if (uniform.type === _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_8__.AST_TOKEN_TYPES.FloatArray) {
                        sizePerElement = 1;
                      } else if (uniform.type === _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_8__.AST_TOKEN_TYPES.Vector4FloatArray) {
                        sizePerElement = 4;
                      }
                      uniform.data = new Float32Array(context.output.length * sizePerElement).fill(0);
                    }
                  }
                });
                // } else if (uniform.type === 'image2D') {
                //   // @ts-ignore
                //   buffer.data = new Uint8ClampedArray(context.output.length!).fill(0);
                // }

                this.compiledBundle.context = context;
                _context3.next = 11;
                return this.engine.createComputeModel(this.compiledBundle.context);
              case 11:
                this.model = _context3.sent;
              case 12:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));
      function compile() {
        return _compile.apply(this, arguments);
      }
      return compile;
    }()
  }]);
  return Kernel;
}();
//# sourceMappingURL=Kernel.js.map

/***/ }),

/***/ "./node_modules/@antv/g-webgpu/es/World.js":
/*!*************************************************!*\
  !*** ./node_modules/@antv/g-webgpu/es/World.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   World: () => (/* binding */ World)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @antv/g-webgpu-core */ "./node_modules/@antv/g-webgpu-core/es/index.js");
/* harmony import */ var _antv_g_webgpu_engine__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @antv/g-webgpu-engine */ "./node_modules/@antv/g-webgpu-engine/es/index.js");
/* harmony import */ var _Kernel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Kernel */ "./node_modules/@antv/g-webgpu/es/Kernel.js");





var World = /*#__PURE__*/function () {
  function World() {
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, World);
    this.engine = void 0;
    this.configService = new _antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_2__.ConfigService();
  }
  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(World, [{
    key: "setConfig",
    value: function setConfig(config) {
      this.configService.set(config);
    }
  }, {
    key: "setEngine",
    value: function setEngine(engine) {
      this.engine = engine;
    }
  }, {
    key: "createEntity",
    value: function createEntity() {
      return (0,_antv_g_webgpu_core__WEBPACK_IMPORTED_MODULE_2__.createEntity)();
    }
  }, {
    key: "createKernel",
    value: function createKernel(precompiledBundle) {
      var kernel = new _Kernel__WEBPACK_IMPORTED_MODULE_4__.Kernel(this.engine, this.configService);
      if (typeof precompiledBundle === 'string') {
        kernel.setBundle(JSON.parse(precompiledBundle));
      } else {
        kernel.setBundle(precompiledBundle);
      }
      kernel.init();
      return kernel;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.engine.destroy();
    }
  }], [{
    key: "create",
    value: function create() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var world = new World();
      world.setConfig(config);
      world.setEngine(new _antv_g_webgpu_engine__WEBPACK_IMPORTED_MODULE_3__.WebGLEngine());
      return world;
    }
  }]);
  return World;
}();
//# sourceMappingURL=World.js.map

/***/ }),

/***/ "./node_modules/@antv/g-webgpu/es/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@antv/g-webgpu/es/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Kernel: () => (/* reexport safe */ _Kernel__WEBPACK_IMPORTED_MODULE_0__.Kernel),
/* harmony export */   World: () => (/* reexport safe */ _World__WEBPACK_IMPORTED_MODULE_1__.World)
/* harmony export */ });
/* harmony import */ var _Kernel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Kernel */ "./node_modules/@antv/g-webgpu/es/Kernel.js");
/* harmony import */ var _World__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./World */ "./node_modules/@antv/g-webgpu/es/World.js");



//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/g-webgpu/es/utils/canvas.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/g-webgpu/es/utils/canvas.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createCanvas: () => (/* binding */ createCanvas)
/* harmony export */ });
function createCanvas() {
  if (typeof document !== 'undefined') {
    return document.createElement('canvas');
  } else {
    throw new Error('Cannot create a canvas in this context');
  }
}
//# sourceMappingURL=canvas.js.map

/***/ }),

/***/ "./node_modules/@antv/graphlib/es/Graph/enum.js":
/*!******************************************************!*\
  !*** ./node_modules/@antv/graphlib/es/Graph/enum.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GraphEnum: () => (/* binding */ GraphEnum)
/* harmony export */ });
var GraphEnum;

(function (GraphEnum) {
  GraphEnum["DEFAULT_EDGE_NAME"] = "\0";
  GraphEnum["GRAPH_NODE"] = "\0";
  GraphEnum["EDGE_KEY_DELIM"] = "\x01";
})(GraphEnum || (GraphEnum = {}));

/***/ }),

/***/ "./node_modules/@antv/graphlib/es/Graph/event.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/graphlib/es/Graph/event.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GraphWithEvent: () => (/* binding */ GraphWithEvent)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! . */ "./node_modules/@antv/graphlib/es/Graph/index.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var GraphWithEvent = /*#__PURE__*/function (_Graph) {
  _inherits(GraphWithEvent, _Graph);

  var _super = _createSuper(GraphWithEvent);

  function GraphWithEvent() {
    var _this;

    _classCallCheck(this, GraphWithEvent);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.eventPool = {};
    return _this;
  }

  _createClass(GraphWithEvent, [{
    key: "appendEvent",
    value:
    /**
     * @description Add an event listener.
     * @description.zh-CN 添加事件监听器。
     */
    function appendEvent(type, callback) {
      if (!this.eventPool[type]) {
        this.eventPool[type] = [];
      }

      this.eventPool[type].push(callback);
    }
    /**
     * @description remove an event listener.
     * @description.zh-CN 移除事件监听器。
     */

  }, {
    key: "removeEvent",
    value: function removeEvent(type, callback) {
      if (!this.eventPool[type]) {
        return;
      }

      var index = this.eventPool[type].indexOf(callback);

      if (index > -1) {
        this.eventPool[type].splice(index, 1);
      }
    }
    /**
     * @description trigger an event.
     * @description.zh-CN 触发事件。
     */

  }, {
    key: "emitEvent",
    value: function emitEvent(type) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      if (!this.eventPool[type]) {
        return;
      }

      this.eventPool[type].forEach(function (callback) {
        callback.apply(void 0, args);
      });
    }
  }, {
    key: "setNode",
    value: function setNode(node, value) {
      _get(_getPrototypeOf(GraphWithEvent.prototype), "setNode", this).call(this, node, value);

      this.emitEvent('nodeAdd', node, value);
      return this;
    }
  }, {
    key: "removeNode",
    value: function removeNode(node) {
      _get(_getPrototypeOf(GraphWithEvent.prototype), "removeNode", this).call(this, node);

      this.emitEvent('nodeRemove', node);
      return this;
    }
  }, {
    key: "setEdge",
    value: function setEdge(v_, w_, value, name) {
      _get(_getPrototypeOf(GraphWithEvent.prototype), "setEdge", this).call(this, v_, w_, value, name);

      this.emitEvent('edgeAdd', v_, w_, value, name);
      return this;
    }
  }, {
    key: "removeEdge",
    value: function removeEdge(v_, w_, name) {
      _get(_getPrototypeOf(GraphWithEvent.prototype), "removeEdge", this).call(this, v_, w_, name);

      this.emitEvent('edgeRemove', v_, w_, name);
      return this;
    }
  }]);

  return GraphWithEvent;
}(___WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./node_modules/@antv/graphlib/es/Graph/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/graphlib/es/Graph/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Graph)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/graphlib/es/util.js");
/* harmony import */ var _enum__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enum */ "./node_modules/@antv/graphlib/es/Graph/enum.js");
/* harmony import */ var _toJSON__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./toJSON */ "./node_modules/@antv/graphlib/es/Graph/toJSON.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }





var defaultOption = {
  compound: false,
  multigraph: false,
  directed: true
};

var Graph = /*#__PURE__*/function () {
  // Graph option or basic props

  /**
   * @description Label for this graph itself
   * @description.zh-CN 图本身的标签（label）
   * @default undefined
   */

  /**
   * @description Number of nodes in the graph
   * @description.zh-CN 节点的数量
   * @default 0
   */

  /**
   * @description Number of edges in the graph
   * @description.zh-CN 节点的数量
   * @default 0
   */

  /**
   * @description return node label with its id
   * @description.zh-CN 返回节点的默认的标签
   */

  /**
   * @description return edge label with its id
   * @description.zh-CN 返回边的默认的标签
   */
  function Graph() {
    var _this = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Graph);

    this.directed = true;
    this.multigraph = false;
    this.compound = false;
    this.GRAPH_NODE = _enum__WEBPACK_IMPORTED_MODULE_1__.GraphEnum.GRAPH_NODE;
    this.label = void 0;
    this.nodeCountNum = 0;
    this.edgeCountNum = 0;

    this.defaultNodeLabelFn = function () {
      return undefined;
    };

    this.defaultEdgeLabelFn = function () {
      return undefined;
    };

    this.parentMap = void 0;
    this.childrenMap = void 0;
    this.nodesLabelMap = new Map();
    this.inEdgesMap = new Map();
    this.outEdgesMap = new Map();
    this.predecessorsMap = new Map();
    this.successorsMap = new Map();
    this.edgesMap = new Map();
    this.edgesLabelsMap = new Map();

    this.isDirected = function () {
      return _this.directed;
    };

    this.isMultigraph = function () {
      return _this.multigraph;
    };

    this.isCompound = function () {
      return _this.compound;
    };

    this.setGraph = function (label) {
      _this.label = label;
      return _this;
    };

    this.graph = function () {
      return _this.label;
    };

    this.setDefaultNodeLabel = function (newDefault) {
      if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(newDefault)) {
        _this.defaultNodeLabelFn = newDefault;
      } else {
        _this.defaultNodeLabelFn = function () {
          return newDefault;
        };
      }

      return _this;
    };

    this.nodeCount = function () {
      return _this.nodeCountNum;
    };

    this.node = function (n) {
      return _this.nodesLabelMap.get(n);
    };

    this.nodes = function () {
      return Array.from(_this.nodesLabelMap.keys());
    };

    this.sources = function () {
      return _this.nodes().filter(function (n) {
        var _this$inEdgesMap$get;

        return !((_this$inEdgesMap$get = _this.inEdgesMap.get(n)) === null || _this$inEdgesMap$get === void 0 ? void 0 : _this$inEdgesMap$get.size);
      });
    };

    this.sinks = function () {
      return _this.nodes().filter(function (n) {
        var _this$outEdgesMap$get;

        return !((_this$outEdgesMap$get = _this.outEdgesMap.get(n)) === null || _this$outEdgesMap$get === void 0 ? void 0 : _this$outEdgesMap$get.size);
      });
    };

    this.setNodes = function (nodes, value) {
      nodes.map(function (node) {
        return _this.setNode(node, value);
      });
      return _this;
    };

    this.hasNode = function (node) {
      return _this.nodesLabelMap.has(node);
    };

    this.checkCompound = function () {
      if (!_this.isCompound()) {
        throw new Error('Cannot construct parent-children relations in a non-compound graph');
      }
    };

    this.parent = function (node) {
      if (_this.isCompound()) {
        var _this$parentMap;

        var parent = (_this$parentMap = _this.parentMap) === null || _this$parentMap === void 0 ? void 0 : _this$parentMap.get(node);

        if (parent !== _this.GRAPH_NODE) {
          return parent;
        }
      }
    };

    this.removeFromParentsChildList = function (node) {
      var targetParent = _this.parentMap.get(node);

      _this.childrenMap.get(targetParent).delete(node);
    };

    this.setParent = function (node, parent) {
      var _this$parentMap2, _this$childrenMap;

      _this.checkCompound();

      var realParent = parent === undefined ? _this.GRAPH_NODE : parent;

      var checkNode = _this.parent(realParent);

      while (checkNode) {
        if (node === checkNode) {
          throw new Error('Setting ' + parent + ' as parent of ' + node + ' would create a cycle');
        }

        checkNode = _this.parent(checkNode);
      }

      if (parent) {
        _this.setNode(parent);
      }

      _this.setNode(node);

      _this.removeFromParentsChildList(node);

      (_this$parentMap2 = _this.parentMap) === null || _this$parentMap2 === void 0 ? void 0 : _this$parentMap2.set(node, realParent);

      var realParentChilren = _this.childrenMap.get(realParent);

      realParentChilren.set(node, true);
      (_this$childrenMap = _this.childrenMap) === null || _this$childrenMap === void 0 ? void 0 : _this$childrenMap.set(realParent, realParentChilren);
      return _this;
    };

    this.children = function (node) {
      var targetNode = node === undefined ? _this.GRAPH_NODE : node;

      if (_this.isCompound()) {
        var _this$childrenMap2;

        var target = (_this$childrenMap2 = _this.childrenMap) === null || _this$childrenMap2 === void 0 ? void 0 : _this$childrenMap2.get(targetNode);

        if (target) {
          return Array.from(target.keys());
        }

        return undefined;
      }

      if (targetNode === _this.GRAPH_NODE) {
        return _this.nodes();
      }

      if (node && _this.hasNode(node)) {
        return [];
      }
    };

    this.predecessors = function (node) {
      var preds = _this.predecessorsMap.get(node);

      return preds ? Array.from(preds.keys()) : undefined;
    };

    this.successors = function (node) {
      var succs = _this.successorsMap.get(node);

      return succs ? Array.from(succs.keys()) : undefined;
    };

    this.neighbors = function (node) {
      var _this$predecessors;

      if (!_this.hasNode(node)) {
        return undefined;
      }

      return Array.from(new Set((_this$predecessors = _this.predecessors(node)) === null || _this$predecessors === void 0 ? void 0 : _this$predecessors.concat(_this.successors(node))));
    };

    this.isLeaf = function (node) {
      var _this$neighbors;

      if (_this.isDirected()) {
        var _this$successors;

        return !((_this$successors = _this.successors(node)) === null || _this$successors === void 0 ? void 0 : _this$successors.length);
      }

      return !((_this$neighbors = _this.neighbors(node)) === null || _this$neighbors === void 0 ? void 0 : _this$neighbors.length);
    };

    this.filterNodes = function (filter) {
      var directed = _this.directed,
          multigraph = _this.multigraph,
          compound = _this.compound;
      var copyGraph = new Graph({
        directed: directed,
        multigraph: multigraph,
        compound: compound
      });
      copyGraph.setGraph(_this.graph());

      _this.nodes().forEach(function (n) {
        if (filter(n)) {
          copyGraph.setNode(n, _this.node(n));
        }
      });

      _this.edges().forEach(function (edgeObj) {
        if (copyGraph.hasNode(edgeObj.v) && copyGraph.hasNode(edgeObj.w)) {
          copyGraph.setEdgeObj(edgeObj, _this.edge(edgeObj));
        }
      });

      if (compound) {
        var findParent = function findParent(node) {
          var parent = _this.parent(node);

          while (parent !== undefined && !copyGraph.hasNode(parent)) {
            parent = _this.parent(parent);
          }

          return parent;
        };

        copyGraph.nodes().forEach(function (node) {
          copyGraph.setParent(node, findParent(node));
        });
      }

      return copyGraph;
    };

    this.setDefaultEdgeLabel = function (newDefault) {
      if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(newDefault)) {
        _this.defaultEdgeLabelFn = newDefault;
      } else {
        _this.defaultEdgeLabelFn = function () {
          return newDefault;
        };
      }

      return _this;
    };

    this.edgeCount = function () {
      return _this.edgeCountNum;
    };

    this.setEdgeObj = function (edgeObj, value) {
      return _this.setEdge(edgeObj.v, edgeObj.w, value, edgeObj.name);
    };

    this.setPath = function (edges, value) {
      edges.reduce(function (v, w) {
        _this.setEdge(v, w, value);

        return w;
      });
      return _this;
    };

    this.edgeFromArgs = function (v, w, name) {
      return _this.edge({
        v: v,
        w: w,
        name: name
      });
    };

    this.edge = function (edgeObj) {
      return _this.edgesLabelsMap.get((0,_util__WEBPACK_IMPORTED_MODULE_0__.edgeObjToId)(_this.isDirected(), edgeObj));
    };

    this.hasEdge = function (v, w, name) {
      return _this.edgesLabelsMap.has((0,_util__WEBPACK_IMPORTED_MODULE_0__.edgeObjToId)(_this.isDirected(), {
        v: v,
        w: w,
        name: name
      }));
    };

    this.removeEdgeObj = function (_ref) {
      var v = _ref.v,
          w = _ref.w,
          name = _ref.name;
      return _this.removeEdge(v, w, name);
    };

    this.edges = function () {
      return Array.from(_this.edgesMap.values());
    };

    this.inEdges = function (v, u) {
      var inV = _this.inEdgesMap.get(v);

      if (inV) {
        return Array.from(inV.values()).filter(function (e) {
          return !u || e.v === u;
        });
      }

      return undefined;
    };

    this.outEdges = function (w, u) {
      var outW = _this.outEdgesMap.get(w);

      if (outW) {
        return Array.from(outW.values()).filter(function (e) {
          return !u || e.w === u;
        });
      }

      return undefined;
    };

    this.nodeEdges = function (v, w) {
      var _this$inEdges;

      if (!_this.hasNode(v)) {
        return undefined;
      }

      return (_this$inEdges = _this.inEdges(v, w)) === null || _this$inEdges === void 0 ? void 0 : _this$inEdges.concat(_this.outEdges(v, w));
    };

    this.toJSON = function () {
      return (0,_toJSON__WEBPACK_IMPORTED_MODULE_2__.write)(_this);
    };

    this.nodeInDegree = function (node) {
      var inEdges = _this.inEdgesMap.get(node);

      if (inEdges) {
        return inEdges.size;
      }

      return 0;
    };

    this.nodeOutDegree = function (node) {
      var outEdges = _this.outEdgesMap.get(node);

      if (outEdges) {
        return outEdges.size;
      }

      return 0;
    };

    this.nodeDegree = function (node) {
      return _this.nodeInDegree(node) + _this.nodeOutDegree(node);
    };

    this.source = function (edge) {
      return edge.v;
    };

    this.target = function (edge) {
      return edge.w;
    };

    var resultOptions = _objectSpread(_objectSpread({}, defaultOption), options);

    this.compound = resultOptions.compound;
    this.directed = resultOptions.directed;
    this.multigraph = resultOptions.multigraph;

    if (this.compound) {
      this.parentMap = new Map();
      this.childrenMap = new Map();
    }
  } // Map for graph

  /**
   * @description Map for parent relationship
   * @description.zh-CN 父子关系的映射
   */


  _createClass(Graph, [{
    key: "setNode",
    value:
    /**
     * @description Set Node label in graph if node not in graph then create it
     * @description.zh-CN 设置节点的label，如果这个节点不在图中，则在图中创建这个节点
     * @param node
     * @param value
     * @returns
     */
    function setNode(node, value) {
      var nodesLabelMap = this.nodesLabelMap,
          defaultNodeLabelFn = this.defaultNodeLabelFn,
          isCompound = this.isCompound,
          parentMap = this.parentMap,
          childrenMap = this.childrenMap,
          inEdgesMap = this.inEdgesMap,
          outEdgesMap = this.outEdgesMap,
          predecessorsMap = this.predecessorsMap,
          successorsMap = this.successorsMap; // 如果节点不在图中，则创建节点

      if (nodesLabelMap.has(node)) {
        if (value !== undefined) {
          nodesLabelMap.set(node, value);
        }

        return this;
      }

      nodesLabelMap.set(node, value || defaultNodeLabelFn(node)); // 如果是复合图，则创建节点的子节点

      if (isCompound()) {
        var _childrenMap$get;

        parentMap === null || parentMap === void 0 ? void 0 : parentMap.set(node, this.GRAPH_NODE);
        childrenMap === null || childrenMap === void 0 ? void 0 : childrenMap.set(node, new Map());

        if (!(childrenMap === null || childrenMap === void 0 ? void 0 : childrenMap.has(this.GRAPH_NODE))) {
          childrenMap === null || childrenMap === void 0 ? void 0 : childrenMap.set(this.GRAPH_NODE, new Map());
        }

        childrenMap === null || childrenMap === void 0 ? void 0 : (_childrenMap$get = childrenMap.get(this.GRAPH_NODE)) === null || _childrenMap$get === void 0 ? void 0 : _childrenMap$get.set(node, true);
      }

      [inEdgesMap, outEdgesMap, predecessorsMap, successorsMap].forEach(function (map) {
        return map.set(node, new Map());
      });
      this.nodeCountNum += 1;
      return this;
    }
    /**
     * @description Set nodes or add nodes in batch
     * @description.zh-CN 批量设置或者创建节点
     * @param nodes
     * @param value
     * @returns
     */

  }, {
    key: "removeNode",
    value:
    /**
     * @description Remove node from graph
     * @description.zh-CN 将节点从图中移除
     * @param node
     * @returns
     */
    function removeNode(node) {
      var _this2 = this;

      if (this.hasNode(node)) {
        var cleanEdge = function cleanEdge(edgeObj) {
          _this2.removeEdge(edgeObj.v, edgeObj.w, edgeObj.name);
        };

        var inEdgesMap = this.inEdgesMap,
            outEdgesMap = this.outEdgesMap,
            predecessorsMap = this.predecessorsMap,
            successorsMap = this.successorsMap,
            nodesLabelMap = this.nodesLabelMap;

        if (this.isCompound()) {
          var _this$parentMap3, _this$children, _this$childrenMap3;

          this.removeFromParentsChildList(node);
          (_this$parentMap3 = this.parentMap) === null || _this$parentMap3 === void 0 ? void 0 : _this$parentMap3.delete(node);
          (_this$children = this.children(node)) === null || _this$children === void 0 ? void 0 : _this$children.forEach(function (n) {
            return _this2.setParent(n);
          });
          (_this$childrenMap3 = this.childrenMap) === null || _this$childrenMap3 === void 0 ? void 0 : _this$childrenMap3.delete(node);
        }

        var inE = inEdgesMap.get(node);
        var outE = outEdgesMap.get(node);
        Array.from(inE.values()).forEach(function (edge) {
          return cleanEdge(edge);
        });
        Array.from(outE.values()).forEach(function (edge) {
          return cleanEdge(edge);
        });
        nodesLabelMap.delete(node);
        inEdgesMap.delete(node);
        outEdgesMap.delete(node);
        predecessorsMap.delete(node);
        successorsMap.delete(node);
        this.nodeCountNum -= 1;
      }

      return this;
    }
    /**
     * @description Set function that generate default label for edge, if param is non-function value then default label will always be this value;
     * @description.zh-CN 设置默认获取边Label的方法，如果传入不是函数的，那么默认label 的值只会是传入值
     * @param newDefault
     * @returns
     */

  }, {
    key: "setEdge",
    value:
    /**
     * @description set edge value, if nodes or edges not exsit then add to graph
     * @description.zh-CN 设置边的属性，如果边或节点不存在，那么将他们加入这个图
     * @param v
     * @param w
     * @param value
     * @param name
     * @returns
     */
    function setEdge(v_, w_, value, name) {
      var _this$inEdgesMap$get2, _this$outEdgesMap$get2;

      var edgeObj = (0,_util__WEBPACK_IMPORTED_MODULE_0__.edgeArgsToObj)(this.isDirected(), v_, w_, name);
      var edgeId = (0,_util__WEBPACK_IMPORTED_MODULE_0__.edgeObjToId)(this.isDirected(), edgeObj);
      var v = edgeObj.v,
          w = edgeObj.w;

      if (this.edgesLabelsMap.has(edgeId)) {
        this.edgesLabelsMap.set(edgeId, value);
        return this;
      }

      if (name !== undefined && !this.isMultigraph()) {
        throw new Error('Cannot set a named edge when isMultigraph = false');
      }

      this.setNode(v);
      this.setNode(w);
      this.edgesLabelsMap.set(edgeId, value || this.defaultEdgeLabelFn(v, w, name));
      Object.freeze(edgeObj);
      this.edgesMap.set(edgeId, edgeObj);
      var preds = this.predecessorsMap.get(w);
      var succs = this.successorsMap.get(v);
      (0,_util__WEBPACK_IMPORTED_MODULE_0__.incrementOrInitEntry)(preds, v);
      (0,_util__WEBPACK_IMPORTED_MODULE_0__.incrementOrInitEntry)(succs, w);
      (_this$inEdgesMap$get2 = this.inEdgesMap.get(w)) === null || _this$inEdgesMap$get2 === void 0 ? void 0 : _this$inEdgesMap$get2.set(edgeId, edgeObj);
      (_this$outEdgesMap$get2 = this.outEdgesMap.get(v)) === null || _this$outEdgesMap$get2 === void 0 ? void 0 : _this$outEdgesMap$get2.set(edgeId, edgeObj);
      this.edgeCountNum += 1;
      return this;
    }
  }, {
    key: "removeEdge",
    value:
    /**
     * @description remove a specific edge
     * @description.zh-CN 删除一条边
     * @param v
     * @param w
     * @param name
     * @returns
     */
    function removeEdge(v_, w_, name) {
      var edgeId = (0,_util__WEBPACK_IMPORTED_MODULE_0__.edgeArgsToId)(this.isDirected(), v_, w_, name);
      var edgeObj = this.edgesMap.get(edgeId);

      if (edgeObj) {
        var _edgeArgsToObj = (0,_util__WEBPACK_IMPORTED_MODULE_0__.edgeArgsToObj)(this.isDirected(), v_, w_, name),
            v = _edgeArgsToObj.v,
            w = _edgeArgsToObj.w;

        this.edgesLabelsMap.delete(edgeId);
        this.edgesMap.delete(edgeId);
        var preds = this.predecessorsMap.get(w);
        var succs = this.successorsMap.get(v);
        (0,_util__WEBPACK_IMPORTED_MODULE_0__.decrementOrRemoveEntry)(preds, v);
        (0,_util__WEBPACK_IMPORTED_MODULE_0__.decrementOrRemoveEntry)(succs, w);
        this.inEdgesMap.get(w).delete(edgeId);
        this.outEdgesMap.get(v).delete(edgeId);
        this.edgeCountNum -= 1;
      }

      return this;
    }
    /**
     * @description remove a specific edge by edge object
     * @description.zh-CN 删除一条边
     */

  }]);

  return Graph;
}();

Graph.fromJSON = _toJSON__WEBPACK_IMPORTED_MODULE_2__.read;


/***/ }),

/***/ "./node_modules/@antv/graphlib/es/Graph/toJSON.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/graphlib/es/Graph/toJSON.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   read: () => (/* binding */ read),
/* harmony export */   write: () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! . */ "./node_modules/@antv/graphlib/es/Graph/index.js");

/**
 * @description Convert a graph's node to JSON.
 * @description.zh-CN 转换图的节点为 JSON。
 * @param graph
 * @returns
 */

var nodeToJSON = function nodeToJSON(graph) {
  return graph.nodes().map(function (n) {
    var value = graph.node(n);
    var parent = graph.parent(n);
    var node = {
      id: n,
      value: value,
      parent: parent
    };

    if (node.value === undefined) {
      delete node.value;
    }

    if (node.parent === undefined) {
      delete node.parent;
    }

    return node;
  });
};
/**
 * @description Convert all graph's edges to JSON.
 * @description.zh-CN 转换图的所有边为 JSON。
 * @param graph
 * @returns
 */


var edgeToJSON = function edgeToJSON(graph) {
  return graph.edges().map(function (edge) {
    var value = graph.edge(edge);
    var e = {
      v: edge.v,
      w: edge.w,
      value: value,
      name: edge.name
    };

    if (e.name === undefined) {
      delete e.name;
    }

    if (e.value === undefined) {
      delete e.value;
    }

    return e;
  });
};
/**
 * @description Convert a graph to JSON.
 * @description.zh-CN 转换图为 JSON。
 * @param graph
 * @returns
 */


var write = function write(graph) {
  var json = {
    options: {
      directed: graph.isDirected(),
      multigraph: graph.isMultigraph(),
      compound: graph.isCompound()
    },
    nodes: nodeToJSON(graph),
    edges: edgeToJSON(graph),
    value: graph.graph()
  };

  if (json.value === undefined) {
    delete json.value;
  }

  return json;
};
/**
 * @description read a graph from JSON.
 * @description.zh-CN 从 JSON 读取图。
 * @param json
 * @returns
 */

var read = function read(json) {
  var graph = new ___WEBPACK_IMPORTED_MODULE_0__["default"](json.options);

  if (json.value !== undefined) {
    graph.setGraph(json.value);
  }

  json.nodes.forEach(function (entry) {
    graph.setNode(entry.id, entry.value);

    if (entry.parent) {
      graph.setParent(entry.id, entry.parent);
    }
  });
  json.edges.forEach(function (entry) {
    graph.setEdge(entry.v, entry.w, entry.value, entry.name);
  });
  return graph;
};

/***/ }),

/***/ "./node_modules/@antv/graphlib/es/algorithm/PriorityQueue/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@antv/graphlib/es/algorithm/PriorityQueue/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PriorityQueue)
/* harmony export */ });
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// A PriorityQueue is a queue that can be sorted by priority.
var PriorityQueue = /*#__PURE__*/_createClass(function PriorityQueue() {
  var _this = this;

  _classCallCheck(this, PriorityQueue);

  this.arr = [];
  this.keyIndice = new Map();

  this.size = function () {
    return _this.arr.length;
  };

  this.keys = function () {
    return _this.arr.map(function (e) {
      return e.key;
    });
  };

  this.has = function (key) {
    return _this.keyIndice.has(key);
  };

  this.priority = function (key) {
    var index = _this.keyIndice.get(key);

    if (index !== undefined) {
      return _this.arr[index].priority;
    }
  };

  this.swap = function (i, j) {
    var arr = _this.arr,
        keyIndice = _this.keyIndice;
    var _ref = [arr[i], arr[j]],
        originI = _ref[0],
        originJ = _ref[1];
    arr[i] = originJ;
    arr[j] = originI;
    keyIndice.set(originI.key, j);
    keyIndice.set(originJ.key, i);
  };

  this.innerDecrease = function (index) {
    var arr = _this.arr;
    var priority = arr[index].priority;
    var parent;
    var i = index;

    while (i !== 0) {
      var _arr$parent;

      parent = i >> 1;

      if (((_arr$parent = arr[parent]) === null || _arr$parent === void 0 ? void 0 : _arr$parent.priority) < priority) {
        break;
      }

      _this.swap(i, parent);

      i = parent;
    }
  };

  this.heapify = function (i) {
    var arr = _this.arr;
    var l = i << 1;
    var r = l + 1;
    var largest = i;

    if (l < arr.length) {
      largest = arr[l].priority < arr[largest].priority ? l : largest;

      if (r < arr.length) {
        largest = arr[r].priority < arr[largest].priority ? r : largest;
      }

      if (largest !== i) {
        _this.swap(i, largest);

        _this.heapify(largest);
      }
    }
  };

  this.min = function () {
    if (_this.size() === 0) {
      throw new Error('Queue underflow');
    }

    return _this.arr[0].key;
  };

  this.add = function (key, priority) {
    var keyIndice = _this.keyIndice,
        arr = _this.arr; // if the key is already in the queue, update the priority

    if (!keyIndice.has(key)) {
      var index = arr.length;
      keyIndice.set(key, index);
      arr.push({
        key: key,
        priority: priority
      });

      _this.innerDecrease(index);

      return true;
    }

    return false;
  };

  this.removeMin = function () {
    _this.swap(0, _this.arr.length - 1);

    var min = _this.arr.pop();

    _this.keyIndice.delete(min.key);

    _this.heapify(0);

    return min.key;
  };

  this.decrease = function (key, priority) {
    if (!_this.has(key)) {
      throw new Error("There's no key named ".concat(key));
    } // there must be an index


    var index = _this.keyIndice.get(key);

    if (priority > _this.arr[index].priority) {
      throw new Error("New priority is greater than current priority.Key: ".concat(key, " Old: + ").concat(_this.arr[index].priority, " New: ").concat(priority));
    }

    _this.arr[index].priority = priority;

    _this.innerDecrease(index);
  };
});



/***/ }),

/***/ "./node_modules/@antv/graphlib/es/algorithm/components.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/graphlib/es/algorithm/components.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var components = function components(graph) {
  var visited = new Set();
  var resultComponents = [];
  var nodes = graph.nodes();
  nodes.forEach(function (n) {
    var componentsArr = [];
    var waitingList = [n];

    while (waitingList.length > 0) {
      var node = waitingList.pop();

      if (!visited.has(node)) {
        var _graph$successors, _graph$predecessors;

        visited.add(node);
        componentsArr.push(node);
        (_graph$successors = graph.successors(node)) === null || _graph$successors === void 0 ? void 0 : _graph$successors.forEach(function (n) {
          return waitingList.push(n);
        });
        (_graph$predecessors = graph.predecessors(node)) === null || _graph$predecessors === void 0 ? void 0 : _graph$predecessors.forEach(function (n) {
          return waitingList.push(n);
        });
      }
    }

    if (componentsArr.length) {
      resultComponents.push(componentsArr);
    }
  });
  return resultComponents;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (components);

/***/ }),

/***/ "./node_modules/@antv/graphlib/es/algorithm/dfs.js":
/*!*********************************************************!*\
  !*** ./node_modules/@antv/graphlib/es/algorithm/dfs.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @description DFS traversal.
 * @description.zh-CN DFS 遍历。
 */
var doDFS = function doDFS(graph, node, postorder, visited, navigator, result) {
  if (!visited.includes(node)) {
    visited.push(node);

    if (!postorder) {
      result.push(node);
    }

    navigator(node).forEach(function (n) {
      return doDFS(graph, n, postorder, visited, navigator, result);
    });

    if (postorder) {
      result.push(node);
    }
  }
};
/**
 * @description DFS traversal.
 * @description.zh-CN DFS 遍历。
 */


var dfs = function dfs(graph, node, order) {
  var nodes = Array.isArray(node) ? node : [node];

  var navigator = function navigator(n) {
    return graph.isDirected() ? graph.successors(n) : graph.neighbors(n);
  };

  var results = [];
  var visited = [];
  nodes.forEach(function (node) {
    if (!graph.hasNode(node)) {
      throw new Error('Graph does not have node: ' + node);
    } else {
      doDFS(graph, node, order === 'post', visited, navigator, results);
    }
  });
  return results;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dfs);

/***/ }),

/***/ "./node_modules/@antv/graphlib/es/algorithm/dijkstra-all.js":
/*!******************************************************************!*\
  !*** ./node_modules/@antv/graphlib/es/algorithm/dijkstra-all.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dijkstra__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dijkstra */ "./node_modules/@antv/graphlib/es/algorithm/dijkstra.js");


var dijkstraAll = function dijkstraAll(graph, weightFn, edgeFn) {
  var map = {};
  graph.nodes().forEach(function (node) {
    map[String(node)] = (0,_dijkstra__WEBPACK_IMPORTED_MODULE_0__["default"])(graph, node, weightFn, edgeFn);
    return map;
  });
  return map;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dijkstraAll);

/***/ }),

/***/ "./node_modules/@antv/graphlib/es/algorithm/dijkstra.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/graphlib/es/algorithm/dijkstra.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _PriorityQueue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PriorityQueue */ "./node_modules/@antv/graphlib/es/algorithm/PriorityQueue/index.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }



var DEFAULT_WEIGHT_FUNC = function DEFAULT_WEIGHT_FUNC() {
  return 1;
};
/**
 * @description Dijkstra's algorithm for single-source shortest paths.
 * @description https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm
 * @description.zh-CN Dijkstra 算法用于单源最短路径。
 */


var dijkstra = function dijkstra(graph, source, weightFn, edgeFn) {
  return runDijkstra(graph, source, weightFn || DEFAULT_WEIGHT_FUNC, edgeFn || function (v) {
    return graph.outEdges(v);
  });
};
/**
 * @description Dijkstra's algorithm for single-source shortest paths.
 * @description https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm
 * @description.zh-CN Dijkstra 算法用于单源最短路径。
 */


var runDijkstra = function runDijkstra(graph, source, weightFn, edgeFn) {
  var results = new Map();
  var pq = new _PriorityQueue__WEBPACK_IMPORTED_MODULE_0__["default"]();
  var v;
  var vEntry;

  var updateNeighbors = function updateNeighbors(edge) {
    var w = edge.v !== v ? edge.v : edge.w;
    var wEntry = results.get(w);
    var weight = weightFn(edge);
    var distance = vEntry.distance + weight;

    if (weight < 0) {
      throw new Error('dijkstra does not allow negative edge weights. ' + 'Bad edge: ' + edge + ' Weight: ' + weight);
    } // If there is already a shorter path to w, ignore this edge.


    if (distance < wEntry.distance) {
      wEntry.distance = distance;
      wEntry.predecessor = v;
      pq.decrease(w, distance);
    }
  };

  graph.nodes().forEach(function (v) {
    var distance = v === source ? 0 : Number.POSITIVE_INFINITY;
    results.set(v, {
      distance: distance
    });
    pq.add(v, distance);
  });

  while (pq.size() > 0) {
    v = pq.removeMin();
    vEntry = results.get(v);

    if (vEntry && vEntry.distance === Number.POSITIVE_INFINITY) {
      break;
    }

    edgeFn(v).forEach(updateNeighbors);
  }

  var obj = {};
  Array.from(results.entries()).forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        node = _ref2[0],
        e = _ref2[1];

    obj[String(node)] = e;
    return obj;
  });
  return obj;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dijkstra);

/***/ }),

/***/ "./node_modules/@antv/graphlib/es/algorithm/find-cycles.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@antv/graphlib/es/algorithm/find-cycles.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _tarjan__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tarjan */ "./node_modules/@antv/graphlib/es/algorithm/tarjan.js");


var findCycles = function findCycles(graph) {
  return (0,_tarjan__WEBPACK_IMPORTED_MODULE_0__["default"])(graph).filter(function (cmpt) {
    return cmpt.length > 1 || cmpt.length === 1 && graph.hasEdge(cmpt[0], cmpt[0]);
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (findCycles);

/***/ }),

/***/ "./node_modules/@antv/graphlib/es/algorithm/floyd-warshall.js":
/*!********************************************************************!*\
  !*** ./node_modules/@antv/graphlib/es/algorithm/floyd-warshall.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   floydWarshall: () => (/* binding */ floydWarshall)
/* harmony export */ });
var DEFAULT_WEIGHT_FUNC = function DEFAULT_WEIGHT_FUNC() {
  return 1;
};

function floydWarshall(graph, weightFn, edgeFn) {
  return runFloydWarshall(graph, weightFn || DEFAULT_WEIGHT_FUNC, edgeFn || function (v) {
    return graph.outEdges(v);
  });
}

function runFloydWarshall(graph, weightFn, edgeFn) {
  var results = {};
  var nodes = graph.nodes();
  nodes.forEach(function (node) {
    var v = String(node);
    results[v] = {};
    results[v][v] = {
      distance: 0
    };
    nodes.forEach(function (w) {
      if (node !== w) {
        results[v][String(w)] = {
          distance: Number.POSITIVE_INFINITY
        };
      }
    });
    edgeFn(node).forEach(function (edge) {
      var w = edge.v === node ? edge.w : edge.v;
      var d = weightFn(edge);
      results[v][String(w)] = {
        distance: d,
        predecessor: node
      };
    });
  });
  nodes.forEach(function (nodek) {
    var k = String(nodek);
    var rowK = results[k];
    nodes.forEach(function (nodei) {
      var i = String(nodei);
      var rowI = results[i];
      nodes.forEach(function (nodej) {
        var j = String(nodej);
        var ik = rowI[k];
        var kj = rowK[j];
        var ij = rowI[j];
        var altDistance = ik.distance + kj.distance;

        if (altDistance < ij.distance) {
          ij.distance = altDistance;
          ij.predecessor = kj.predecessor;
        }
      });
    });
  });
  return results;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (floydWarshall);

/***/ }),

/***/ "./node_modules/@antv/graphlib/es/algorithm/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/graphlib/es/algorithm/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   components: () => (/* reexport safe */ _components__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   dfs: () => (/* reexport safe */ _dfs__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   dijkstra: () => (/* reexport safe */ _dijkstra__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   dijkstraAll: () => (/* reexport safe */ _dijkstra_all__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   findCycles: () => (/* reexport safe */ _find_cycles__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   floydWarshall: () => (/* reexport safe */ _floyd_warshall__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   isAcyclic: () => (/* reexport safe */ _is_acyclic__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   postorder: () => (/* reexport safe */ _postorder__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   preorder: () => (/* reexport safe */ _preorder__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   prim: () => (/* reexport safe */ _prim__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   tarjan: () => (/* reexport safe */ _tarjan__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   topsort: () => (/* reexport safe */ _topsort__WEBPACK_IMPORTED_MODULE_10__["default"])
/* harmony export */ });
/* harmony import */ var _prim__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./prim */ "./node_modules/@antv/graphlib/es/algorithm/prim.js");
/* harmony import */ var _components__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components */ "./node_modules/@antv/graphlib/es/algorithm/components.js");
/* harmony import */ var _dfs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dfs */ "./node_modules/@antv/graphlib/es/algorithm/dfs.js");
/* harmony import */ var _dijkstra__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dijkstra */ "./node_modules/@antv/graphlib/es/algorithm/dijkstra.js");
/* harmony import */ var _dijkstra_all__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dijkstra-all */ "./node_modules/@antv/graphlib/es/algorithm/dijkstra-all.js");
/* harmony import */ var _find_cycles__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./find-cycles */ "./node_modules/@antv/graphlib/es/algorithm/find-cycles.js");
/* harmony import */ var _is_acyclic__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./is-acyclic */ "./node_modules/@antv/graphlib/es/algorithm/is-acyclic.js");
/* harmony import */ var _postorder__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./postorder */ "./node_modules/@antv/graphlib/es/algorithm/postorder.js");
/* harmony import */ var _preorder__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./preorder */ "./node_modules/@antv/graphlib/es/algorithm/preorder.js");
/* harmony import */ var _tarjan__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./tarjan */ "./node_modules/@antv/graphlib/es/algorithm/tarjan.js");
/* harmony import */ var _topsort__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./topsort */ "./node_modules/@antv/graphlib/es/algorithm/topsort.js");
/* harmony import */ var _floyd_warshall__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./floyd-warshall */ "./node_modules/@antv/graphlib/es/algorithm/floyd-warshall.js");














/***/ }),

/***/ "./node_modules/@antv/graphlib/es/algorithm/is-acyclic.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/graphlib/es/algorithm/is-acyclic.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _topsort__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./topsort */ "./node_modules/@antv/graphlib/es/algorithm/topsort.js");


var isAcyclic = function isAcyclic(graph) {
  try {
    (0,_topsort__WEBPACK_IMPORTED_MODULE_0__["default"])(graph);
  } catch (e) {
    if (e instanceof _topsort__WEBPACK_IMPORTED_MODULE_0__.CycleException) {
      return false;
    }

    throw e;
  }

  return true;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isAcyclic);

/***/ }),

/***/ "./node_modules/@antv/graphlib/es/algorithm/postorder.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/graphlib/es/algorithm/postorder.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dfs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dfs */ "./node_modules/@antv/graphlib/es/algorithm/dfs.js");


var postorder = function postorder(graph, nodes) {
  return (0,_dfs__WEBPACK_IMPORTED_MODULE_0__["default"])(graph, nodes, 'post');
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (postorder);

/***/ }),

/***/ "./node_modules/@antv/graphlib/es/algorithm/preorder.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/graphlib/es/algorithm/preorder.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dfs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dfs */ "./node_modules/@antv/graphlib/es/algorithm/dfs.js");


var preorder = function preorder(graph, nodes) {
  return (0,_dfs__WEBPACK_IMPORTED_MODULE_0__["default"])(graph, nodes, 'pre');
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (preorder);

/***/ }),

/***/ "./node_modules/@antv/graphlib/es/algorithm/prim.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/graphlib/es/algorithm/prim.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Graph */ "./node_modules/@antv/graphlib/es/Graph/index.js");
/* harmony import */ var _PriorityQueue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PriorityQueue */ "./node_modules/@antv/graphlib/es/algorithm/PriorityQueue/index.js");



var prim = function prim(graph, weightFn) {
  var result = new _Graph__WEBPACK_IMPORTED_MODULE_0__["default"]();
  var parents = new Map();
  var pq = new _PriorityQueue__WEBPACK_IMPORTED_MODULE_1__["default"]();
  var v;

  function updateNeighbors(edge) {
    var w = edge.v === v ? edge.w : edge.v;
    var pri = pq.priority(w);

    if (pri !== undefined) {
      var edgeWeight = weightFn(edge);

      if (edgeWeight < pri) {
        parents.set(w, v);
        pq.decrease(w, edgeWeight);
      }
    }
  }

  if (graph.nodeCount() === 0) {
    return result;
  }

  graph.nodes().forEach(function (node) {
    pq.add(node, Number.POSITIVE_INFINITY);
    result.setNode(node);
  }); // Start from an arbitrary node

  pq.decrease(graph.nodes()[0], 0);
  var init = false;

  while (pq.size() > 0) {
    var _graph$nodeEdges;

    v = pq.removeMin();

    if (parents.has(v)) {
      result.setEdge(v, parents.get(v));
    } else if (init) {
      throw new Error('Input graph is not connected: ' + graph.graph());
    } else {
      init = true;
    }

    (_graph$nodeEdges = graph.nodeEdges(v)) === null || _graph$nodeEdges === void 0 ? void 0 : _graph$nodeEdges.forEach(updateNeighbors);
  }

  return result;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (prim);

/***/ }),

/***/ "./node_modules/@antv/graphlib/es/algorithm/tarjan.js":
/*!************************************************************!*\
  !*** ./node_modules/@antv/graphlib/es/algorithm/tarjan.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @description Tarjan's algorithm for finding the strongly connected components of a graph.
 * @description https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm
 * @description.zh-CN Tarjan 算法用于找到图的强连通子图。
 * @param graph
 * @returns
 */
var tarjan = function tarjan(graph) {
  var index = 0;
  var stack = [];
  var visited = new Map(); // node id -> { onStack, lowlink, index }

  var results = [];

  function dfs(v) {
    var _graph$successors;

    var entry = {
      onStack: true,
      lowlink: index,
      index: index
    };
    visited.set(v, entry);
    index += 1;
    stack.push(v);
    (_graph$successors = graph.successors(v)) === null || _graph$successors === void 0 ? void 0 : _graph$successors.forEach(function (w) {
      var _visited$get;

      // 如果 w 没有被访问过，则继续访问 w
      if (!visited.has(w)) {
        dfs(w);
        var wEntry = visited.get(w);
        entry.lowlink = Math.min(entry.lowlink, wEntry.lowlink); // 如果 w 在栈顶，则说明 w 和 v 不是强连通的
      } else if ((_visited$get = visited.get(w)) === null || _visited$get === void 0 ? void 0 : _visited$get.onStack) {
        var _wEntry = visited.get(w); // 如果 w 在栈中，则说明 w 在当前访问的路径上


        entry.lowlink = Math.min(entry.lowlink, _wEntry.index);
      }
    }); // 如果 v 的 lowlink 不等于 v 的 index，则说明 v 和 v 的 lowlink 不是强连通的

    if (entry.lowlink === entry.index) {
      var cmpt = [];
      var w;

      do {
        // 将 w 出栈，并将 w 的所有邻接点加入强连通子图
        w = stack.pop();
        var wEntry = visited.get(w);
        wEntry.onStack = false;
        cmpt.push(w);
      } while (v !== w);

      results.push(cmpt);
    }
  }

  graph.nodes().forEach(function (v) {
    if (!visited.has(v)) {
      dfs(v);
    }
  });
  return results;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (tarjan);

/***/ }),

/***/ "./node_modules/@antv/graphlib/es/algorithm/topsort.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/graphlib/es/algorithm/topsort.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CycleException: () => (/* binding */ CycleException),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var CycleException = /*#__PURE__*/function (_Error) {
  _inherits(CycleException, _Error);

  var _super = _createSuper(CycleException);

  function CycleException() {
    _classCallCheck(this, CycleException);

    return _super.apply(this, arguments);
  }

  return _createClass(CycleException);
}( /*#__PURE__*/_wrapNativeSuper(Error));

function topsort(graph) {
  var visited = new Set();
  var stack = new Set();
  var results = [];

  function visit(node) {
    if (stack.has(node)) {
      throw new CycleException();
    }

    if (!visited.has(node)) {
      var _graph$predecessors;

      stack.add(node);
      visited.add(node);
      (_graph$predecessors = graph.predecessors(node)) === null || _graph$predecessors === void 0 ? void 0 : _graph$predecessors.forEach(visit);
      stack.delete(node);
      results.push(node);
    }
  }

  graph.sinks().forEach(visit);

  if (visited.size !== graph.nodeCount()) {
    throw new CycleException();
  }

  return results;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (topsort);

/***/ }),

/***/ "./node_modules/@antv/graphlib/es/comparision/complement.js":
/*!******************************************************************!*\
  !*** ./node_modules/@antv/graphlib/es/comparision/complement.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isGraphComplement: () => (/* binding */ isGraphComplement)
/* harmony export */ });
/* harmony import */ var _essence__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../essence */ "./node_modules/@antv/graphlib/es/essence/index.js");
/* harmony import */ var _contain__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./contain */ "./node_modules/@antv/graphlib/es/comparision/contain.js");


/**
 * @description Check if one graph is the complement of another graph.
 * @description.zh-CN 检查一个图是否是另一个图的补图。
 */

var isGraphComplement = function isGraphComplement(originGraph, targetGraph) {
  if (!(0,_essence__WEBPACK_IMPORTED_MODULE_0__.isSimpleGraph)(originGraph) || !(0,_essence__WEBPACK_IMPORTED_MODULE_0__.isSimpleGraph)(targetGraph)) {
    return false;
  }

  if (!(0,_contain__WEBPACK_IMPORTED_MODULE_1__.containAllSameNodes)(originGraph, targetGraph)) {
    return false;
  }

  if ((0,_contain__WEBPACK_IMPORTED_MODULE_1__.containSameEdges)(originGraph, targetGraph)) {
    return false;
  }

  var nodeCount = originGraph.nodeCount();
  return originGraph.edgeCount() + targetGraph.edgeCount() === nodeCount * (nodeCount - 1) / 2;
};

/***/ }),

/***/ "./node_modules/@antv/graphlib/es/comparision/contain.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/graphlib/es/comparision/contain.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   containAllSameEdges: () => (/* binding */ containAllSameEdges),
/* harmony export */   containAllSameNodes: () => (/* binding */ containAllSameNodes),
/* harmony export */   containSameEdges: () => (/* binding */ containSameEdges),
/* harmony export */   containSameNodes: () => (/* binding */ containSameNodes),
/* harmony export */   getSameEdges: () => (/* binding */ getSameEdges),
/* harmony export */   getSameNodes: () => (/* binding */ getSameNodes),
/* harmony export */   isGraphContainsAnother: () => (/* binding */ isGraphContainsAnother),
/* harmony export */   isGraphOptionSame: () => (/* binding */ isGraphOptionSame),
/* harmony export */   isGraphSame: () => (/* binding */ isGraphSame)
/* harmony export */ });
/**
 * @file Functions that used to find similar element between two graph
 * @file.zh-CN 在两个图中查找相似元素的函数
 */

/**
 * @description Check if two graphs are contains the same nodes.
 * @description.zh-CN 检查两个图是否包含相同的节点。
 */
var containSameNodes = function containSameNodes(aGraph, bGraph) {
  var aNodes = aGraph.nodes();

  for (var i = 0; i < aNodes.length; i++) {
    var aNode = aNodes[i];

    if (bGraph.hasNode(aNode)) {
      return true;
    }
  }

  return false;
};
/**
 * @description Check if two graphs are contains the same edges.
 * @description.zh-CN 检查两个图是否包含相同的边。
 */

var containSameEdges = function containSameEdges(aGraph, bGraph) {
  var aEdges = aGraph.edges();

  for (var i = 0; i < aEdges.length; i++) {
    var aEdge = aEdges[i];

    if (bGraph.hasEdge(aEdge.v, aEdge.w, aEdge.name)) {
      return true;
    }
  }

  return false;
};
/**
 * @description get same nodes in two graphs.
 * @description.zh-CN 获取两个图中相同的节点。
 */

var getSameNodes = function getSameNodes(aGraph, bGraph) {
  var aNodes = aGraph.nodes();
  var sameNodes = aNodes.filter(function (aNode) {
    return bGraph.hasNode(aNode);
  });
  return sameNodes;
};
/**
 * @description get same edges in two graphs.
 * @description.zh-CN 获取两个图中相同的边。
 */

var getSameEdges = function getSameEdges(aGraph, bGraph) {
  var aEdges = aGraph.edges();
  var sameEdges = aEdges.filter(function (aEdge) {
    return bGraph.hasEdge(aEdge.v, aEdge.w, aEdge.name);
  });
  return sameEdges;
};
/**
 * @description Check if two graphs'option are the same.
 * @description.zh-CN 检查两个图的选项是否相同。
 */

var isGraphOptionSame = function isGraphOptionSame(aGraph, bGraph) {
  return aGraph.isCompound() === bGraph.isCompound() && aGraph.isDirected() === bGraph.isDirected() && aGraph.isMultigraph() === bGraph.isMultigraph();
};
/**
 * @description Check if a graph contains all nodes in another graph.
 * @description.zh-CN 检查一个图是否包含另一个图的所有节点。
 */

var containAllSameNodes = function containAllSameNodes(aGraph, bGraph) {
  var sameNodes = getSameNodes(aGraph, bGraph);
  return sameNodes.length === aGraph.nodes().length;
};
/**
 * @description Check if a graph contains all edges in another graph.
 * @description.zh-CN 检查一个图是否包含另一个图的所有边。
 */

var containAllSameEdges = function containAllSameEdges(aGraph, bGraph) {
  var sameEdges = getSameEdges(aGraph, bGraph);
  return sameEdges.length === aGraph.edges().length;
};
/**
 * @description Check if two graphs are the same.
 * @description.zh-CN 检查两个图是否相同。
 */

var isGraphSame = function isGraphSame(aGraph, bGraph) {
  return isGraphOptionSame(aGraph, bGraph) && aGraph.nodeCount() === bGraph.nodeCount() && containAllSameNodes(aGraph, bGraph) && aGraph.edgeCount() === bGraph.edgeCount() && containAllSameEdges(aGraph, bGraph);
};
/**
 * @description Check if one graph is the subgraph of another graph.
 * @description.zh-CN 检查一个图是否是另一个图的子图。
 */

var isGraphContainsAnother = function isGraphContainsAnother(originGraph, targetGraph) {
  return containAllSameNodes(originGraph, targetGraph) && containAllSameEdges(originGraph, targetGraph);
};

/***/ }),

/***/ "./node_modules/@antv/graphlib/es/comparision/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/graphlib/es/comparision/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   containAllSameEdges: () => (/* reexport safe */ _contain__WEBPACK_IMPORTED_MODULE_0__.containAllSameEdges),
/* harmony export */   containAllSameNodes: () => (/* reexport safe */ _contain__WEBPACK_IMPORTED_MODULE_0__.containAllSameNodes),
/* harmony export */   containSameEdges: () => (/* reexport safe */ _contain__WEBPACK_IMPORTED_MODULE_0__.containSameEdges),
/* harmony export */   containSameNodes: () => (/* reexport safe */ _contain__WEBPACK_IMPORTED_MODULE_0__.containSameNodes),
/* harmony export */   getSameEdges: () => (/* reexport safe */ _contain__WEBPACK_IMPORTED_MODULE_0__.getSameEdges),
/* harmony export */   getSameNodes: () => (/* reexport safe */ _contain__WEBPACK_IMPORTED_MODULE_0__.getSameNodes),
/* harmony export */   isGraphComplement: () => (/* reexport safe */ _complement__WEBPACK_IMPORTED_MODULE_1__.isGraphComplement),
/* harmony export */   isGraphContainsAnother: () => (/* reexport safe */ _contain__WEBPACK_IMPORTED_MODULE_0__.isGraphContainsAnother),
/* harmony export */   isGraphOptionSame: () => (/* reexport safe */ _contain__WEBPACK_IMPORTED_MODULE_0__.isGraphOptionSame),
/* harmony export */   isGraphSame: () => (/* reexport safe */ _contain__WEBPACK_IMPORTED_MODULE_0__.isGraphSame)
/* harmony export */ });
/* harmony import */ var _contain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./contain */ "./node_modules/@antv/graphlib/es/comparision/contain.js");
/* harmony import */ var _complement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./complement */ "./node_modules/@antv/graphlib/es/comparision/complement.js");




/***/ }),

/***/ "./node_modules/@antv/graphlib/es/essence/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@antv/graphlib/es/essence/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hasSelfLoop: () => (/* binding */ hasSelfLoop),
/* harmony export */   isGraph: () => (/* binding */ isGraph),
/* harmony export */   isNullGraph: () => (/* binding */ isNullGraph),
/* harmony export */   isSimpleGraph: () => (/* binding */ isSimpleGraph)
/* harmony export */ });
/* harmony import */ var _Graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Graph */ "./node_modules/@antv/graphlib/es/Graph/index.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * @file To get graph essencial information.
 * @file.zh-CN 获取图的基本信息
 * @module essence
 */

/**
 * @description Check if the object is a graph.
 * @description.zh-CN 检查对象是否为图。
 */

function isGraph(obj) {
  return obj instanceof _Graph__WEBPACK_IMPORTED_MODULE_0__["default"];
}
/**
 * @description Check if the graph is a simple graph.
 * @description.zh-CN 检查图是否为简单图。
 */

function isSimpleGraph(graph) {
  if (graph.isMultigraph()) {
    return false;
  }

  var edges = graph.edges();
  var edgeStack = new Map();

  for (var i = 0; i < edges.length; i++) {
    var edge = edges[i];

    if (edge.v === edge.w) {
      return false;
    }

    var _sort = [edge.v, edge.w].sort(),
        _sort2 = _slicedToArray(_sort, 2),
        v = _sort2[0],
        w = _sort2[1];

    var key = "".concat(v, "-").concat(w);

    if (edgeStack.has(key)) {
      return false;
    }

    edgeStack.set(key, true);
  }

  return true;
}
/**
 * @description Check if the graph is a null graph.
 * @description.zh-CN 检查图是否为空图。
 */

function isNullGraph(graph) {
  return graph.nodes().length === 0;
}
/**
 * @description Check if the graph contains Self loops.
 * @description.zh-CN 检查图是否包含自环。
 */

function hasSelfLoop(graph) {
  var edges = graph.edges();

  for (var i = 0; i < edges.length; i++) {
    var edge = edges[i];

    if (edge.v === edge.w) {
      return true;
    }
  }

  return false;
}

/***/ }),

/***/ "./node_modules/@antv/graphlib/es/generate/compelement.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/graphlib/es/generate/compelement.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getGraphComplement: () => (/* binding */ getGraphComplement)
/* harmony export */ });
/* harmony import */ var _essence__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../essence */ "./node_modules/@antv/graphlib/es/essence/index.js");
/* harmony import */ var _Graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Graph */ "./node_modules/@antv/graphlib/es/Graph/index.js");


/**
 * @description Get the graph's complement
 * @description.zh-CN 获取图的补图
 */

var getGraphComplement = function getGraphComplement(originGraph) {
  if (!(0,_essence__WEBPACK_IMPORTED_MODULE_0__.isSimpleGraph)(originGraph)) {
    return null;
  }

  var nodeCount = originGraph.nodeCount();
  var complementGraph = new _Graph__WEBPACK_IMPORTED_MODULE_1__["default"]({
    compound: originGraph.isCompound(),
    directed: originGraph.isDirected(),
    multigraph: originGraph.isMultigraph()
  });
  var nodes = originGraph.nodes();

  for (var i = 0; i < nodeCount; i++) {
    var nodei = nodes[i];
    complementGraph.setNode(nodei, originGraph.node(nodei));

    for (var j = i + 1; j < nodeCount; j++) {
      var nodej = nodes[j];

      if (!originGraph.hasEdge(nodei, nodej)) {
        complementGraph.setEdge(nodei, nodej);
      }
    }
  }

  return complementGraph;
};

/***/ }),

/***/ "./node_modules/@antv/graphlib/es/generate/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/graphlib/es/generate/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getGraphComplement: () => (/* reexport safe */ _compelement__WEBPACK_IMPORTED_MODULE_0__.getGraphComplement)
/* harmony export */ });
/* harmony import */ var _compelement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compelement */ "./node_modules/@antv/graphlib/es/generate/compelement.js");



/***/ }),

/***/ "./node_modules/@antv/graphlib/es/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@antv/graphlib/es/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Graph: () => (/* reexport safe */ _Graph__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   GraphWithEvent: () => (/* reexport safe */ _Graph_event__WEBPACK_IMPORTED_MODULE_1__.GraphWithEvent),
/* harmony export */   algorithm: () => (/* reexport module object */ _algorithm__WEBPACK_IMPORTED_MODULE_2__),
/* harmony export */   comparision: () => (/* reexport module object */ _comparision__WEBPACK_IMPORTED_MODULE_3__),
/* harmony export */   essence: () => (/* reexport module object */ _essence__WEBPACK_IMPORTED_MODULE_4__),
/* harmony export */   generate: () => (/* reexport module object */ _generate__WEBPACK_IMPORTED_MODULE_5__)
/* harmony export */ });
/* harmony import */ var _Graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Graph */ "./node_modules/@antv/graphlib/es/Graph/index.js");
/* harmony import */ var _Graph_event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Graph/event */ "./node_modules/@antv/graphlib/es/Graph/event.js");
/* harmony import */ var _algorithm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./algorithm */ "./node_modules/@antv/graphlib/es/algorithm/index.js");
/* harmony import */ var _comparision__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./comparision */ "./node_modules/@antv/graphlib/es/comparision/index.js");
/* harmony import */ var _essence__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./essence */ "./node_modules/@antv/graphlib/es/essence/index.js");
/* harmony import */ var _generate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./generate */ "./node_modules/@antv/graphlib/es/generate/index.js");








/***/ }),

/***/ "./node_modules/@antv/graphlib/es/util.js":
/*!************************************************!*\
  !*** ./node_modules/@antv/graphlib/es/util.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decrementOrRemoveEntry: () => (/* binding */ decrementOrRemoveEntry),
/* harmony export */   edgeArgsToId: () => (/* binding */ edgeArgsToId),
/* harmony export */   edgeArgsToObj: () => (/* binding */ edgeArgsToObj),
/* harmony export */   edgeObjToId: () => (/* binding */ edgeObjToId),
/* harmony export */   incrementOrInitEntry: () => (/* binding */ incrementOrInitEntry),
/* harmony export */   isFunction: () => (/* binding */ isFunction)
/* harmony export */ });
/* harmony import */ var _Graph_enum__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Graph/enum */ "./node_modules/@antv/graphlib/es/Graph/enum.js");

/**
 * @description add one to key's value in map
 * @description.zh-CN 在 map 中 key 的值加 1
 * @param map
 * @param key
 */

function incrementOrInitEntry(map, key) {
  var val = map.get(key) || 0;
  map.set(key, val + 1);
}
/**
 * @description minus one from key's value in map, is value is 0, delete the key
 * @description.zh-CN 在 map 中 key 的值减 1，如果值为 0，则删除 key
 */

function decrementOrRemoveEntry(map, key) {
  var val = map.get(key);

  if (val !== undefined) {
    val = val - 1;

    if (val > 0) {
      map.set(key, val);
    } else {
      map.delete(key);
    }
  }
}
/**
 * @description convert edge to string id
 * @description.zh-CN 转换边为字符串 id
 */

function edgeArgsToId(isDirected, v_, w_, name) {
  var v = String(v_);
  var w = String(w_);

  if (!isDirected && v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }

  return v + _Graph_enum__WEBPACK_IMPORTED_MODULE_0__.GraphEnum.EDGE_KEY_DELIM + w + _Graph_enum__WEBPACK_IMPORTED_MODULE_0__.GraphEnum.EDGE_KEY_DELIM + (name === undefined ? _Graph_enum__WEBPACK_IMPORTED_MODULE_0__.GraphEnum.DEFAULT_EDGE_NAME : name);
}
/**
 * @description convert edge arguments to edge object
 * @description.zh-CN 转换边参数为边对象
 */

function edgeArgsToObj(isDirected, v, w, name) {
  var strV = String(v);
  var strW = String(w);
  var edgeObj = {
    v: v,
    w: w
  };

  if (!isDirected && strV > strW) {
    var tmp = edgeObj.v;
    edgeObj.v = edgeObj.w;
    edgeObj.w = tmp;
  }

  if (name !== undefined) {
    edgeObj.name = name;
  }

  return edgeObj;
}
/**
 * @description convert edge object to string id
 * @description.zh-CN 转换边对象为字符串 id
 */

function edgeObjToId(isDirected, edgeObj) {
  return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
}
function isFunction(obj) {
  return typeof obj === 'function';
}

/***/ }),

/***/ "./node_modules/@antv/layout/es/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@antv/layout/es/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CircularLayout: () => (/* reexport safe */ _layout__WEBPACK_IMPORTED_MODULE_1__.CircularLayout),
/* harmony export */   ComboCombinedLayout: () => (/* reexport safe */ _layout__WEBPACK_IMPORTED_MODULE_1__.ComboCombinedLayout),
/* harmony export */   ComboForceLayout: () => (/* reexport safe */ _layout__WEBPACK_IMPORTED_MODULE_1__.ComboForceLayout),
/* harmony export */   ConcentricLayout: () => (/* reexport safe */ _layout__WEBPACK_IMPORTED_MODULE_1__.ConcentricLayout),
/* harmony export */   DagreCompoundLayout: () => (/* reexport safe */ _layout__WEBPACK_IMPORTED_MODULE_1__.DagreCompoundLayout),
/* harmony export */   DagreLayout: () => (/* reexport safe */ _layout__WEBPACK_IMPORTED_MODULE_1__.DagreLayout),
/* harmony export */   ERLayout: () => (/* reexport safe */ _layout__WEBPACK_IMPORTED_MODULE_1__.ERLayout),
/* harmony export */   Force2Layout: () => (/* reexport safe */ _layout__WEBPACK_IMPORTED_MODULE_1__.Force2Layout),
/* harmony export */   ForceAtlas2Layout: () => (/* reexport safe */ _layout__WEBPACK_IMPORTED_MODULE_1__.ForceAtlas2Layout),
/* harmony export */   ForceLayout: () => (/* reexport safe */ _layout__WEBPACK_IMPORTED_MODULE_1__.ForceLayout),
/* harmony export */   FruchtermanGPULayout: () => (/* reexport safe */ _layout__WEBPACK_IMPORTED_MODULE_1__.FruchtermanGPULayout),
/* harmony export */   FruchtermanLayout: () => (/* reexport safe */ _layout__WEBPACK_IMPORTED_MODULE_1__.FruchtermanLayout),
/* harmony export */   GForceGPULayout: () => (/* reexport safe */ _layout__WEBPACK_IMPORTED_MODULE_1__.GForceGPULayout),
/* harmony export */   GForceLayout: () => (/* reexport safe */ _layout__WEBPACK_IMPORTED_MODULE_1__.GForceLayout),
/* harmony export */   GridLayout: () => (/* reexport safe */ _layout__WEBPACK_IMPORTED_MODULE_1__.GridLayout),
/* harmony export */   Layout: () => (/* reexport safe */ _layout__WEBPACK_IMPORTED_MODULE_1__.Layout),
/* harmony export */   Layouts: () => (/* reexport safe */ _layout__WEBPACK_IMPORTED_MODULE_1__.Layouts),
/* harmony export */   MDSLayout: () => (/* reexport safe */ _layout__WEBPACK_IMPORTED_MODULE_1__.MDSLayout),
/* harmony export */   RadialLayout: () => (/* reexport safe */ _layout__WEBPACK_IMPORTED_MODULE_1__.RadialLayout),
/* harmony export */   RandomLayout: () => (/* reexport safe */ _layout__WEBPACK_IMPORTED_MODULE_1__.RandomLayout),
/* harmony export */   getLayoutByName: () => (/* reexport safe */ _registy__WEBPACK_IMPORTED_MODULE_0__.getLayoutByName),
/* harmony export */   registerLayout: () => (/* reexport safe */ _registy__WEBPACK_IMPORTED_MODULE_0__.registerLayout),
/* harmony export */   unRegisterLayout: () => (/* reexport safe */ _registy__WEBPACK_IMPORTED_MODULE_0__.unRegisterLayout)
/* harmony export */ });
/* harmony import */ var _registy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./registy */ "./node_modules/@antv/layout/es/registy/index.js");
/* harmony import */ var _layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./layout */ "./node_modules/@antv/layout/es/layout/index.js");

// register layout

// layout, layout types file, worker

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/base.js":
/*!*****************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/base.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Base: () => (/* binding */ Base)
/* harmony export */ });
class Base {
    constructor() {
        this.nodes = [];
        this.edges = [];
        this.combos = [];
        this.comboEdges = [];
        this.hiddenNodes = [];
        this.hiddenEdges = [];
        this.hiddenCombos = [];
        // temp edges e.g. the edge generated for releated collapsed combo
        this.vedges = [];
        this.positions = [];
        this.destroyed = false;
        this.onLayoutEnd = () => { };
    }
    layout(data) {
        this.init(data);
        return this.execute(true);
    }
    init(data) {
        this.nodes = data.nodes || [];
        this.edges = data.edges || [];
        this.combos = data.combos || [];
        this.comboEdges = data.comboEdges || [];
        this.hiddenNodes = data.hiddenNodes || [];
        this.hiddenEdges = data.hiddenEdges || [];
        this.hiddenCombos = data.hiddenCombos || [];
        this.vedges = data.vedges || [];
    }
    execute(reloadData) { }
    executeWithWorker() { }
    getDefaultCfg() {
        return {};
    }
    updateCfg(cfg) {
        if (cfg) {
            Object.assign(this, cfg);
        }
    }
    getType() {
        return 'base';
    }
    destroy() {
        this.nodes = null;
        this.edges = null;
        this.combos = null;
        this.positions = null;
        this.destroyed = true;
    }
}
//# sourceMappingURL=base.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/circular.js":
/*!*********************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/circular.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CircularLayout: () => (/* binding */ CircularLayout)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./node_modules/@antv/layout/es/layout/base.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/layout/es/util/index.js");
/**
 * @fileOverview random layout
 * @author shiwu.wyy@antfin.com
 */


function initHierarchy(nodes, edges, nodeMap, directed) {
    nodes.forEach((_, i) => {
        nodes[i].children = [];
        nodes[i].parent = [];
    });
    if (directed) {
        edges.forEach((e) => {
            const source = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getEdgeTerminal)(e, 'source');
            const target = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getEdgeTerminal)(e, 'target');
            let sourceIdx = 0;
            if (source) {
                sourceIdx = nodeMap[source];
            }
            let targetIdx = 0;
            if (target) {
                targetIdx = nodeMap[target];
            }
            const child = nodes[sourceIdx].children;
            const parent = nodes[targetIdx].parent;
            child.push(nodes[targetIdx].id);
            parent.push(nodes[sourceIdx].id);
        });
    }
    else {
        edges.forEach((e) => {
            const source = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getEdgeTerminal)(e, 'source');
            const target = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getEdgeTerminal)(e, 'target');
            let sourceIdx = 0;
            if (source) {
                sourceIdx = nodeMap[source];
            }
            let targetIdx = 0;
            if (target) {
                targetIdx = nodeMap[target];
            }
            const sourceChildren = nodes[sourceIdx].children;
            const targetChildren = nodes[targetIdx].children;
            sourceChildren.push(nodes[targetIdx].id);
            targetChildren.push(nodes[sourceIdx].id);
        });
    }
}
function connect(a, b, edges) {
    const m = edges.length;
    for (let i = 0; i < m; i++) {
        const source = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getEdgeTerminal)(edges[i], 'source');
        const target = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getEdgeTerminal)(edges[i], 'target');
        if ((a.id === source && b.id === target) ||
            (b.id === source && a.id === target)) {
            return true;
        }
    }
    return false;
}
function compareDegree(a, b) {
    const aDegree = a.degree;
    const bDegree = b.degree;
    if (aDegree < bDegree) {
        return -1;
    }
    if (aDegree > bDegree) {
        return 1;
    }
    return 0;
}
/**
 * 圆形布局
 */
class CircularLayout extends _base__WEBPACK_IMPORTED_MODULE_0__.Base {
    constructor(options) {
        super();
        /** 固定半径，若设置了 radius，则 startRadius 与 endRadius 不起效 */
        this.radius = null;
        /** 节点大小，配合 nodeSpacing，一起用于计算 radius。若不配置，节点大小默认为 30 */
        this.nodeSize = undefined;
        /** 起始半径 */
        this.startRadius = null;
        /** 终止半径 */
        this.endRadius = null;
        /** 起始角度 */
        this.startAngle = 0;
        /** 终止角度 */
        this.endAngle = 2 * Math.PI;
        /** 是否顺时针 */
        this.clockwise = true;
        /** 节点在环上分成段数（几个段将均匀分布），在 endRadius - startRadius != 0 时生效 */
        this.divisions = 1;
        /** 节点在环上排序的依据，可选: 'topology', 'degree', 'null' */
        this.ordering = null;
        /** how many 2*pi from first to last nodes */
        this.angleRatio = 1;
        this.nodes = [];
        this.edges = [];
        this.nodeMap = {};
        this.degrees = [];
        this.width = 300;
        this.height = 300;
        this.updateCfg(options);
    }
    getDefaultCfg() {
        return {
            radius: null,
            startRadius: null,
            endRadius: null,
            startAngle: 0,
            endAngle: 2 * Math.PI,
            clockwise: true,
            divisions: 1,
            ordering: null,
            angleRatio: 1
        };
    }
    /**
     * 执行布局
     */
    execute() {
        var _a;
        const self = this;
        const nodes = self.nodes;
        const edges = self.edges;
        const n = nodes.length;
        if (n === 0) {
            if (self.onLayoutEnd)
                self.onLayoutEnd();
            return;
        }
        if (!self.width && typeof window !== "undefined") {
            self.width = window.innerWidth;
        }
        if (!self.height && typeof window !== "undefined") {
            self.height = window.innerHeight;
        }
        if (!self.center) {
            self.center = [self.width / 2, self.height / 2];
        }
        const center = self.center;
        if (n === 1) {
            nodes[0].x = center[0];
            nodes[0].y = center[1];
            if (self.onLayoutEnd)
                self.onLayoutEnd();
            return;
        }
        let { radius, startRadius, endRadius } = self;
        const { divisions, startAngle, endAngle, angleRatio, ordering, clockwise, nodeSpacing: paramNodeSpacing, nodeSize: paramNodeSize } = self;
        const angleStep = (endAngle - startAngle) / n;
        // layout
        const nodeMap = {};
        nodes.forEach((node, i) => {
            nodeMap[node.id] = i;
        });
        self.nodeMap = nodeMap;
        const degrees = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getDegree)(nodes.length, nodeMap, edges);
        self.degrees = degrees;
        if (paramNodeSpacing) {
            const nodeSpacing = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getFuncByUnknownType)(10, paramNodeSpacing);
            const nodeSize = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getFuncByUnknownType)(10, paramNodeSize);
            let maxNodeSize = -Infinity;
            nodes.forEach((node) => {
                const nSize = nodeSize(node);
                if (maxNodeSize < nSize)
                    maxNodeSize = nSize;
            });
            let length = 0;
            nodes.forEach((node, i) => {
                if (i === 0)
                    length += (maxNodeSize || 10);
                else
                    length += (nodeSpacing(node) || 0) + (maxNodeSize || 10);
            });
            radius = length / (2 * Math.PI);
        }
        else if (!radius && !startRadius && !endRadius) {
            radius = self.height > self.width ? self.width / 2 : self.height / 2;
        }
        else if (!startRadius && endRadius) {
            startRadius = endRadius;
        }
        else if (startRadius && !endRadius) {
            endRadius = startRadius;
        }
        const astep = angleStep * angleRatio;
        let layoutNodes = [];
        if (ordering === "topology") {
            // layout according to the topology
            layoutNodes = self.topologyOrdering();
        }
        else if (ordering === "topology-directed") {
            // layout according to the topology
            layoutNodes = self.topologyOrdering(true);
        }
        else if (ordering === "degree") {
            // layout according to the descent order of degrees
            layoutNodes = self.degreeOrdering();
        }
        else {
            // layout according to the original order in the data.nodes
            layoutNodes = nodes;
        }
        const divN = Math.ceil(n / divisions); // node number in each division
        for (let i = 0; i < n; ++i) {
            let r = radius;
            if (!r && startRadius !== null && endRadius !== null) {
                r = startRadius + (i * (endRadius - startRadius)) / (n - 1);
            }
            if (!r) {
                r = 10 + (i * 100) / (n - 1);
            }
            let angle = startAngle +
                (i % divN) * astep +
                ((2 * Math.PI) / divisions) * Math.floor(i / divN);
            if (!clockwise) {
                angle =
                    endAngle -
                        (i % divN) * astep -
                        ((2 * Math.PI) / divisions) * Math.floor(i / divN);
            }
            layoutNodes[i].x = center[0] + Math.cos(angle) * r;
            layoutNodes[i].y = center[1] + Math.sin(angle) * r;
            layoutNodes[i].weight = degrees[i].all;
        }
        (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);
        return {
            nodes: layoutNodes,
            edges: this.edges
        };
    }
    /**
     * 根据节点的拓扑结构排序
     * @return {array} orderedNodes 排序后的结果
     */
    topologyOrdering(directed = false) {
        const self = this;
        const degrees = self.degrees;
        const edges = self.edges;
        const nodes = self.nodes;
        const cnodes = (0,_util__WEBPACK_IMPORTED_MODULE_1__.clone)(nodes);
        const nodeMap = self.nodeMap;
        const orderedCNodes = [cnodes[0]];
        const resNodes = [nodes[0]];
        const pickFlags = [];
        const n = nodes.length;
        pickFlags[0] = true;
        initHierarchy(cnodes, edges, nodeMap, directed);
        let k = 0;
        cnodes.forEach((cnode, i) => {
            if (i !== 0) {
                if ((i === n - 1 ||
                    degrees[i].all !== degrees[i + 1].all ||
                    connect(orderedCNodes[k], cnode, edges)) &&
                    !pickFlags[i]) {
                    orderedCNodes.push(cnode);
                    resNodes.push(nodes[nodeMap[cnode.id]]);
                    pickFlags[i] = true;
                    k++;
                }
                else {
                    const children = orderedCNodes[k].children;
                    let foundChild = false;
                    for (let j = 0; j < children.length; j++) {
                        const childIdx = nodeMap[children[j]];
                        if (degrees[childIdx].all === degrees[i].all && !pickFlags[childIdx]) {
                            orderedCNodes.push(cnodes[childIdx]);
                            resNodes.push(nodes[nodeMap[cnodes[childIdx].id]]);
                            pickFlags[childIdx] = true;
                            foundChild = true;
                            break;
                        }
                    }
                    let ii = 0;
                    while (!foundChild) {
                        if (!pickFlags[ii]) {
                            orderedCNodes.push(cnodes[ii]);
                            resNodes.push(nodes[nodeMap[cnodes[ii].id]]);
                            pickFlags[ii] = true;
                            foundChild = true;
                        }
                        ii++;
                        if (ii === n) {
                            break;
                        }
                    }
                }
            }
        });
        return resNodes;
    }
    /**
     * 根据节点度数大小排序
     * @return {array} orderedNodes 排序后的结果
     */
    degreeOrdering() {
        const self = this;
        const nodes = self.nodes;
        const orderedNodes = [];
        const degrees = self.degrees;
        nodes.forEach((node, i) => {
            node.degree = degrees[i].all;
            orderedNodes.push(node);
        });
        orderedNodes.sort(compareDegree);
        return orderedNodes;
    }
    getType() {
        return "circular";
    }
}
//# sourceMappingURL=circular.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/comboCombined.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/comboCombined.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ComboCombinedLayout: () => (/* binding */ ComboCombinedLayout)
/* harmony export */ });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "./node_modules/@antv/layout/es/layout/constants.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./node_modules/@antv/layout/es/layout/base.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/layout/es/util/index.js");
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! . */ "./node_modules/@antv/layout/es/layout/index.js");
/**
 * @fileOverview Combo force layout
 * @author shiwu.wyy@antfin.com
 */




/**
 * combined two layouts (inner and outer) for graph with combos
 */
class ComboCombinedLayout extends _base__WEBPACK_IMPORTED_MODULE_1__.Base {
    constructor(options) {
        super();
        /** 布局中心 */
        this.center = [0, 0];
        /** 内部计算参数 */
        this.nodes = [];
        this.edges = [];
        this.combos = [];
        this.comboEdges = [];
        /** Combo 内部的 padding */
        this.comboPadding = 10;
        this.comboTrees = [];
        this.updateCfg(options);
    }
    getDefaultCfg() {
        return {};
    }
    /**
     * 执行布局
     */
    execute() {
        const self = this;
        const nodes = self.nodes;
        const center = self.center;
        if (!nodes || nodes.length === 0) {
            if (self.onLayoutEnd)
                self.onLayoutEnd();
            return;
        }
        if (nodes.length === 1) {
            nodes[0].x = center[0];
            nodes[0].y = center[1];
            if (self.onLayoutEnd)
                self.onLayoutEnd();
            return;
        }
        self.initVals();
        // layout
        self.run();
        if (self.onLayoutEnd)
            self.onLayoutEnd();
    }
    run() {
        var _a;
        const self = this;
        const { nodes, edges, combos, comboEdges, center } = self;
        const nodeMap = {};
        nodes.forEach((node) => {
            nodeMap[node.id] = node;
        });
        const comboMap = {};
        combos.forEach((combo) => {
            comboMap[combo.id] = combo;
        });
        const innerGraphs = self.getInnerGraphs(nodeMap);
        // 每个 innerGraph 作为一个节点，带有大小，参与 force 计算
        const outerNodeIds = [];
        const outerNodes = [];
        const nodeAncestorIdMap = {};
        let allHaveNoPosition = true;
        this.comboTrees.forEach((cTree) => {
            const innerNode = innerGraphs[cTree.id];
            if (!innerNode) {
                return;
            }
            // 代表 combo 的节点
            const oNode = Object.assign(Object.assign({}, cTree), { x: innerNode.x || comboMap[cTree.id].x, y: innerNode.y || comboMap[cTree.id].y, fx: innerNode.fx || comboMap[cTree.id].fx, fy: innerNode.fy || comboMap[cTree.id].fy, mass: innerNode.mass || comboMap[cTree.id].mass, size: innerNode.size });
            outerNodes.push(oNode);
            if (!isNaN(oNode.x) &&
                oNode.x !== 0 &&
                !isNaN(oNode.y) &&
                oNode.y !== 0) {
                allHaveNoPosition = false;
            }
            else {
                oNode.x = Math.random() * 100;
                oNode.y = Math.random() * 100;
            }
            outerNodeIds.push(cTree.id);
            (0,_util__WEBPACK_IMPORTED_MODULE_2__.traverseTreeUp)(cTree, (child) => {
                if (child.id !== cTree.id)
                    nodeAncestorIdMap[child.id] = cTree.id;
                return true;
            });
        });
        nodes.forEach((node) => {
            if (node.comboId && comboMap[node.comboId])
                return;
            // 代表节点的节点
            const oNode = Object.assign({}, node);
            outerNodes.push(oNode);
            if (!isNaN(oNode.x) &&
                oNode.x !== 0 &&
                !isNaN(oNode.y) &&
                oNode.y !== 0) {
                allHaveNoPosition = false;
            }
            else {
                oNode.x = Math.random() * 100;
                oNode.y = Math.random() * 100;
            }
            outerNodeIds.push(node.id);
        });
        const outerEdges = [];
        edges.concat(comboEdges).forEach((edge) => {
            const sourceAncestorId = nodeAncestorIdMap[edge.source] || edge.source;
            const targetAncestorId = nodeAncestorIdMap[edge.target] || edge.target;
            // 若两个点的祖先都在力导图的节点中，且是不同的节点，创建一条链接两个祖先的边到力导图的边中
            if (sourceAncestorId !== targetAncestorId &&
                outerNodeIds.includes(sourceAncestorId) &&
                outerNodeIds.includes(targetAncestorId)) {
                outerEdges.push({
                    source: sourceAncestorId,
                    target: targetAncestorId,
                });
            }
        });
        // 若有需要最外层的 combo 或节点，则对最外层执行力导向
        if (outerNodes === null || outerNodes === void 0 ? void 0 : outerNodes.length) {
            if (outerNodes.length === 1) {
                outerNodes[0].x = center[0];
                outerNodes[0].y = center[1];
            }
            else {
                const outerData = {
                    nodes: outerNodes,
                    edges: outerEdges,
                };
                // 需要使用一个同步的布局
                // @ts-ignore
                const outerLayout = this.outerLayout ||
                    new ___WEBPACK_IMPORTED_MODULE_3__.GForceLayout({
                        gravity: 1,
                        factor: 4,
                        linkDistance: (edge, source, target) => {
                            var _a, _b;
                            const nodeSize = ((((_a = source.size) === null || _a === void 0 ? void 0 : _a[0]) || 30) + (((_b = target.size) === null || _b === void 0 ? void 0 : _b[0]) || 30)) / 2;
                            return Math.min(nodeSize * 1.5, 700);
                        },
                    });
                const outerLayoutType = (_a = outerLayout.getType) === null || _a === void 0 ? void 0 : _a.call(outerLayout);
                outerLayout.updateCfg({
                    center,
                    kg: 5,
                    preventOverlap: true,
                    animate: false,
                });
                // 若所有 outerNodes 都没有位置，且 outerLayout 是力导家族的布局，则先执行 preset mds 或 grid
                if (allHaveNoPosition && _constants__WEBPACK_IMPORTED_MODULE_0__.FORCE_LAYOUT_TYPE_MAP[outerLayoutType]) {
                    const outerLayoutPreset = outerNodes.length < 100 ? new ___WEBPACK_IMPORTED_MODULE_3__.MDSLayout() : new ___WEBPACK_IMPORTED_MODULE_3__.GridLayout();
                    outerLayoutPreset.layout(outerData);
                }
                outerLayout.layout(outerData);
            }
            // 根据外部布局结果，平移 innerGraphs 中的节点（第一层）
            outerNodes.forEach((outerNode) => {
                const innerGraph = innerGraphs[outerNode.id];
                if (!innerGraph) {
                    const node = nodeMap[outerNode.id];
                    if (node) {
                        node.x = outerNode.x;
                        node.y = outerNode.y;
                    }
                    return;
                }
                innerGraph.visited = true;
                innerGraph.x = outerNode.x;
                innerGraph.y = outerNode.y;
                innerGraph.nodes.forEach((node) => {
                    node.x += outerNode.x;
                    node.y += outerNode.y;
                });
            });
        }
        // 至上而下遍历树处理下面各层节点位置
        const innerGraphIds = Object.keys(innerGraphs);
        for (let i = innerGraphIds.length - 1; i >= 0; i--) {
            const id = innerGraphIds[i];
            const innerGraph = innerGraphs[id];
            if (!innerGraph)
                continue;
            innerGraph.nodes.forEach((node) => {
                if (!innerGraph.visited) {
                    node.x += innerGraph.x || 0;
                    node.y += innerGraph.y || 0;
                }
                if (nodeMap[node.id]) {
                    nodeMap[node.id].x = node.x;
                    nodeMap[node.id].y = node.y;
                }
            });
            if (comboMap[id]) {
                comboMap[id].x = innerGraph.x;
                comboMap[id].y = innerGraph.y;
            }
        }
        return { nodes, edges, combos, comboEdges };
    }
    getInnerGraphs(nodeMap) {
        const self = this;
        const { comboTrees, nodeSize, edges, comboPadding, spacing } = self;
        const innerGraphs = {};
        // @ts-ignore
        const innerGraphLayout = this.innerLayout ||
            new ___WEBPACK_IMPORTED_MODULE_3__.ConcentricLayout({ type: 'concentric', sortBy: 'id' });
        innerGraphLayout.center = [0, 0];
        innerGraphLayout.preventOverlap = true;
        innerGraphLayout.nodeSpacing = spacing;
        (comboTrees || []).forEach((ctree) => {
            (0,_util__WEBPACK_IMPORTED_MODULE_2__.traverseTreeUp)(ctree, (treeNode) => {
                var _a;
                // @ts-ignore
                let padding = (comboPadding === null || comboPadding === void 0 ? void 0 : comboPadding(treeNode)) || 10; // 返回的最大值
                if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(padding))
                    padding = Math.max(...padding);
                if (!((_a = treeNode.children) === null || _a === void 0 ? void 0 : _a.length)) {
                    // 空 combo
                    if (treeNode.itemType === 'combo') {
                        const treeNodeSize = padding
                            ? [padding * 2, padding * 2]
                            : [30, 30];
                        innerGraphs[treeNode.id] = {
                            id: treeNode.id,
                            nodes: [],
                            size: treeNodeSize,
                        };
                    }
                }
                else {
                    // 非空 combo
                    const innerGraphNodes = treeNode.children.map((child) => {
                        if (child.itemType === 'combo')
                            return innerGraphs[child.id];
                        const oriNode = nodeMap[child.id] || {};
                        return Object.assign(Object.assign({}, oriNode), child);
                    });
                    const innerGraphNodeIds = innerGraphNodes.map((node) => node.id);
                    const innerGraphData = {
                        nodes: innerGraphNodes,
                        edges: edges.filter((edge) => innerGraphNodeIds.includes(edge.source) &&
                            innerGraphNodeIds.includes(edge.target)),
                    };
                    let minNodeSize = Infinity;
                    innerGraphNodes.forEach((node) => {
                        var _a;
                        // @ts-ignore
                        if (!node.size)
                            node.size = ((_a = innerGraphs[node.id]) === null || _a === void 0 ? void 0 : _a.size) ||
                                (nodeSize === null || nodeSize === void 0 ? void 0 : nodeSize(node)) || [30, 30];
                        if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isNumber)(node.size))
                            node.size = [node.size, node.size];
                        if (minNodeSize > node.size[0])
                            minNodeSize = node.size[0];
                        if (minNodeSize > node.size[1])
                            minNodeSize = node.size[1];
                    });
                    // 根据节点数量、spacing，调整布局参数
                    innerGraphLayout.layout(innerGraphData);
                    const { minX, minY, maxX, maxY } = (0,_util__WEBPACK_IMPORTED_MODULE_2__.getLayoutBBox)(innerGraphNodes);
                    // move the innerGraph to [0, 0],for later controled by parent layout
                    const center = { x: (maxX + minX) / 2, y: (maxY + minY) / 2 };
                    innerGraphData.nodes.forEach((node) => {
                        node.x -= center.x;
                        node.y -= center.y;
                    });
                    const innerGraphWidth = Math.max(maxX - minX, minNodeSize) + padding * 2;
                    const innerGraphHeight = Math.max(maxY - minY, minNodeSize) + padding * 2;
                    innerGraphs[treeNode.id] = {
                        id: treeNode.id,
                        nodes: innerGraphNodes,
                        size: [innerGraphWidth, innerGraphHeight],
                    };
                }
                return true;
            });
        });
        return innerGraphs;
    }
    initVals() {
        const self = this;
        const nodeSize = self.nodeSize;
        const spacing = self.spacing;
        let nodeSizeFunc;
        let spacingFunc;
        // nodeSpacing to function
        if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isNumber)(spacing)) {
            spacingFunc = () => spacing;
        }
        else if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(spacing)) {
            spacingFunc = spacing;
        }
        else {
            spacingFunc = () => 0;
        }
        this.spacing = spacingFunc;
        // nodeSize to function
        if (!nodeSize) {
            nodeSizeFunc = (d) => {
                const spacing = spacingFunc(d);
                if (d.size) {
                    if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(d.size)) {
                        const res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];
                        return (res + spacing) / 2;
                    }
                    if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isObject)(d.size)) {
                        const res = d.size.width > d.size.height ? d.size.width : d.size.height;
                        return (res + spacing) / 2;
                    }
                    return (d.size + spacing) / 2;
                }
                return 10 + spacing / 2;
            };
        }
        else if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(nodeSize)) {
            nodeSizeFunc = (d) => {
                const size = nodeSize(d);
                const spacing = spacingFunc(d);
                if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(d.size)) {
                    const res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];
                    return (res + spacing) / 2;
                }
                return ((size || 10) + spacing) / 2;
            };
        }
        else if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(nodeSize)) {
            const larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];
            const radius = larger / 2;
            nodeSizeFunc = (d) => radius + spacingFunc(d) / 2;
        }
        else {
            // number type
            const radius = nodeSize / 2;
            nodeSizeFunc = (d) => radius + spacingFunc(d) / 2;
        }
        this.nodeSize = nodeSizeFunc;
        // comboPadding to function
        const comboPadding = self.comboPadding;
        let comboPaddingFunc;
        if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isNumber)(comboPadding)) {
            comboPaddingFunc = () => comboPadding;
        }
        else if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(comboPadding)) {
            comboPaddingFunc = () => Math.max.apply(null, comboPadding);
        }
        else if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(comboPadding)) {
            comboPaddingFunc = comboPadding;
        }
        else {
            // null type
            comboPaddingFunc = () => 0;
        }
        this.comboPadding = comboPaddingFunc;
    }
    getType() {
        return 'comboCombined';
    }
}
//# sourceMappingURL=comboCombined.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/comboForce.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/comboForce.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ComboForceLayout: () => (/* binding */ ComboForceLayout)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./node_modules/@antv/layout/es/layout/base.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/layout/es/util/index.js");
/**
 * @fileOverview Combo force layout
 * @author shiwu.wyy@antfin.com
 */


/**
 * force layout for graph with combos
 */
class ComboForceLayout extends _base__WEBPACK_IMPORTED_MODULE_0__.Base {
    constructor(options) {
        super();
        /** 布局中心 */
        this.center = [0, 0];
        /** 停止迭代的最大迭代数 */
        this.maxIteration = 100;
        /** 重力大小，影响图的紧凑程度 */
        this.gravity = 10;
        /** 群组中心力大小 */
        this.comboGravity = 10;
        /** 默认边长度 */
        this.linkDistance = 10;
        /** 每次迭代位移的衰减相关参数 */
        this.alpha = 1;
        this.alphaMin = 0.001;
        this.alphaDecay = 1 - Math.pow(this.alphaMin, (1 / 300));
        this.alphaTarget = 0;
        /** 节点运动速度衰减参数 */
        this.velocityDecay = 0.6;
        /** 边引力大小 */
        this.edgeStrength = 0.6;
        /** 节点引力大小 */
        this.nodeStrength = 30;
        /** 是否开启防止重叠 */
        this.preventOverlap = false;
        /** 是否开启节点之间的防止重叠 */
        this.preventNodeOverlap = false;
        /** 是否开启 Combo 之间的防止重叠 */
        this.preventComboOverlap = false;
        /** 防止重叠的碰撞力大小 */
        this.collideStrength = undefined;
        /** 防止重叠的碰撞力大小 */
        this.nodeCollideStrength = 0.5;
        /** 防止重叠的碰撞力大小 */
        this.comboCollideStrength = 0.5;
        /** Combo 最小间距，防止重叠时的间隙 */
        this.comboSpacing = 20;
        /** Combo 内部的 padding */
        this.comboPadding = 10;
        /** 优化计算斥力的速度，两节点间距超过 optimizeRangeFactor * width 则不再计算斥力和重叠斥力 */
        this.optimizeRangeFactor = 1;
        /** 每次迭代的回调函数 */
        this.onTick = () => { };
        /** 迭代结束的回调函数 */
        this.onLayoutEnd = () => { };
        /** 根据边两端节点层级差距的调整引力系数的因子，取值范围 [0, 1]。层级差距越大，引力越小 */
        this.depthAttractiveForceScale = 1;
        /** 根据边两端节点层级差距的调整斥力系数的因子，取值范围 [1, Infinity]。层级差距越大，斥力越大 */
        this.depthRepulsiveForceScale = 2;
        /** 内部计算参数 */
        this.nodes = [];
        this.edges = [];
        this.combos = [];
        this.comboTrees = [];
        this.width = 300;
        this.height = 300;
        this.bias = [];
        this.nodeMap = {};
        this.oriComboMap = {};
        this.indexMap = {};
        this.comboMap = {};
        this.previousLayouted = false;
        this.updateCfg(options);
    }
    getDefaultCfg() {
        return {
            maxIteration: 100,
            center: [0, 0],
            gravity: 10,
            speed: 1,
            comboGravity: 30,
            preventOverlap: false,
            preventComboOverlap: true,
            preventNodeOverlap: true,
            nodeSpacing: undefined,
            collideStrength: undefined,
            nodeCollideStrength: 0.5,
            comboCollideStrength: 0.5,
            comboSpacing: 20,
            comboPadding: 10,
            edgeStrength: 0.6,
            nodeStrength: 30,
            linkDistance: 10
        };
    }
    /**
     * 执行布局
     */
    execute() {
        const self = this;
        const nodes = self.nodes;
        const center = self.center;
        self.comboTree = {
            id: "comboTreeRoot",
            depth: -1,
            children: self.comboTrees
        };
        if (!nodes || nodes.length === 0) {
            if (self.onLayoutEnd)
                self.onLayoutEnd();
            return;
        }
        if (nodes.length === 1) {
            nodes[0].x = center[0];
            nodes[0].y = center[1];
            if (self.onLayoutEnd)
                self.onLayoutEnd();
            return;
        }
        self.initVals();
        // layout
        self.run();
        if (self.onLayoutEnd)
            self.onLayoutEnd();
    }
    run() {
        const self = this;
        const nodes = self.nodes;
        const maxIteration = self.previousLayouted
            ? self.maxIteration / 5
            : self.maxIteration;
        if (!self.width && typeof window !== "undefined") {
            self.width = window.innerWidth;
        }
        if (!self.height && typeof window !== "undefined") {
            self.height = window.innerHeight;
        }
        const center = self.center;
        const velocityDecay = self.velocityDecay;
        // init the positions to make the nodes with same combo gather around the combo
        const comboMap = self.comboMap;
        if (!self.previousLayouted)
            self.initPos(comboMap);
        // iterate
        for (let i = 0; i < maxIteration; i++) {
            const displacements = [];
            nodes.forEach((_, j) => {
                displacements[j] = { x: 0, y: 0 };
            });
            self.applyCalculate(displacements);
            // gravity for combos
            self.applyComboCenterForce(displacements);
            // move
            nodes.forEach((n, j) => {
                if (!(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(n.x) || !(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(n.y))
                    return;
                n.x += displacements[j].x * velocityDecay;
                n.y += displacements[j].y * velocityDecay;
            });
            self.alpha += (self.alphaTarget - self.alpha) * self.alphaDecay;
            self.onTick();
        }
        // move to center
        const meanCenter = [0, 0];
        nodes.forEach((n) => {
            if (!(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(n.x) || !(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(n.y))
                return;
            meanCenter[0] += n.x;
            meanCenter[1] += n.y;
        });
        meanCenter[0] /= nodes.length;
        meanCenter[1] /= nodes.length;
        const centerOffset = [center[0] - meanCenter[0], center[1] - meanCenter[1]];
        nodes.forEach((n, j) => {
            if (!(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(n.x) || !(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(n.y))
                return;
            n.x += centerOffset[0];
            n.y += centerOffset[1];
        });
        // arrange the empty combo
        self.combos.forEach((combo) => {
            const mapped = comboMap[combo.id];
            if (mapped && mapped.empty) {
                combo.x = mapped.cx || combo.x;
                combo.y = mapped.cy || combo.y;
            }
        });
        self.previousLayouted = true;
    }
    initVals() {
        const self = this;
        const edges = self.edges;
        const nodes = self.nodes;
        const combos = self.combos;
        const count = {};
        const nodeMap = {};
        const indexMap = {};
        nodes.forEach((node, i) => {
            nodeMap[node.id] = node;
            indexMap[node.id] = i;
        });
        self.nodeMap = nodeMap;
        self.indexMap = indexMap;
        const oriComboMap = {};
        combos.forEach((combo) => {
            oriComboMap[combo.id] = combo;
        });
        self.oriComboMap = oriComboMap;
        self.comboMap = self.getComboMap();
        const preventOverlap = self.preventOverlap;
        self.preventComboOverlap = self.preventComboOverlap || preventOverlap;
        self.preventNodeOverlap = self.preventNodeOverlap || preventOverlap;
        const collideStrength = self.collideStrength;
        if (collideStrength) {
            self.comboCollideStrength = collideStrength;
            self.nodeCollideStrength = collideStrength;
        }
        self.comboCollideStrength = self.comboCollideStrength
            ? self.comboCollideStrength
            : 0;
        self.nodeCollideStrength = self.nodeCollideStrength
            ? self.nodeCollideStrength
            : 0;
        // get edge bias
        for (let i = 0; i < edges.length; ++i) {
            const source = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getEdgeTerminal)(edges[i], 'source');
            const target = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getEdgeTerminal)(edges[i], 'target');
            if (count[source])
                count[source]++;
            else
                count[source] = 1;
            if (count[target])
                count[target]++;
            else
                count[target] = 1;
        }
        const bias = [];
        for (let i = 0; i < edges.length; ++i) {
            const source = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getEdgeTerminal)(edges[i], 'source');
            const target = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getEdgeTerminal)(edges[i], 'target');
            bias[i] = count[source] / (count[source] + count[target]);
        }
        this.bias = bias;
        const nodeSize = self.nodeSize;
        const nodeSpacing = self.nodeSpacing;
        let nodeSizeFunc;
        let nodeSpacingFunc;
        // nodeSpacing to function
        if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(nodeSpacing)) {
            nodeSpacingFunc = () => nodeSpacing;
        }
        else if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(nodeSpacing)) {
            nodeSpacingFunc = nodeSpacing;
        }
        else {
            nodeSpacingFunc = () => 0;
        }
        this.nodeSpacing = nodeSpacingFunc;
        // nodeSize to function
        if (!nodeSize) {
            nodeSizeFunc = (d) => {
                if (d.size) {
                    if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(d.size)) {
                        const res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];
                        return res / 2;
                    }
                    if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isObject)(d.size)) {
                        const res = d.size.width > d.size.height ? d.size.width : d.size.height;
                        return res / 2;
                    }
                    return d.size / 2;
                }
                return 10;
            };
        }
        else if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(nodeSize)) {
            nodeSizeFunc = (d) => {
                return nodeSize(d);
            };
        }
        else if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(nodeSize)) {
            const larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];
            const radius = larger / 2;
            nodeSizeFunc = (d) => radius;
        }
        else {
            // number type
            const radius = nodeSize / 2;
            nodeSizeFunc = (d) => radius;
        }
        this.nodeSize = nodeSizeFunc;
        // comboSpacing to function
        const comboSpacing = self.comboSpacing;
        let comboSpacingFunc;
        if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(comboSpacing)) {
            comboSpacingFunc = () => comboSpacing;
        }
        else if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comboSpacing)) {
            comboSpacingFunc = comboSpacing;
        }
        else {
            // null type
            comboSpacingFunc = () => 0;
        }
        this.comboSpacing = comboSpacingFunc;
        // comboPadding to function
        const comboPadding = self.comboPadding;
        let comboPaddingFunc;
        if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(comboPadding)) {
            comboPaddingFunc = () => comboPadding;
        }
        else if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(comboPadding)) {
            comboPaddingFunc = () => Math.max.apply(null, comboPadding);
        }
        else if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(comboPadding)) {
            comboPaddingFunc = comboPadding;
        }
        else {
            // null type
            comboPaddingFunc = () => 0;
        }
        this.comboPadding = comboPaddingFunc;
        // linkDistance to function
        let linkDistance = this.linkDistance;
        let linkDistanceFunc;
        if (!linkDistance) {
            linkDistance = 10;
        }
        if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(linkDistance)) {
            linkDistanceFunc = (d) => {
                return linkDistance;
            };
        }
        else {
            linkDistanceFunc = linkDistance;
        }
        this.linkDistance = linkDistanceFunc;
        // linkStrength to function
        let edgeStrength = this.edgeStrength;
        let edgeStrengthFunc;
        if (!edgeStrength) {
            edgeStrength = 1;
        }
        if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(edgeStrength)) {
            edgeStrengthFunc = (d) => {
                return edgeStrength;
            };
        }
        else {
            edgeStrengthFunc = edgeStrength;
        }
        this.edgeStrength = edgeStrengthFunc;
        // nodeStrength to function
        let nodeStrength = this.nodeStrength;
        let nodeStrengthFunc;
        if (!nodeStrength) {
            nodeStrength = 30;
        }
        if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(nodeStrength)) {
            nodeStrengthFunc = (d) => {
                return nodeStrength;
            };
        }
        else {
            nodeStrengthFunc = nodeStrength;
        }
        this.nodeStrength = nodeStrengthFunc;
    }
    initPos(comboMap) {
        const self = this;
        const nodes = self.nodes;
        nodes.forEach((node, i) => {
            const comboId = node.comboId;
            const combo = comboMap[comboId];
            if (comboId && combo) {
                node.x = combo.cx + 100 / (i + 1);
                node.y = combo.cy + 100 / (i + 1);
            }
            else {
                node.x = 100 / (i + 1);
                node.y = 100 / (i + 1);
            }
        });
    }
    getComboMap() {
        const self = this;
        const nodeMap = self.nodeMap;
        const comboTrees = self.comboTrees;
        const oriComboMap = self.oriComboMap;
        const comboMap = {};
        (comboTrees || []).forEach((ctree) => {
            const treeChildren = [];
            (0,_util__WEBPACK_IMPORTED_MODULE_1__.traverseTreeUp)(ctree, (treeNode) => {
                if (treeNode.itemType === "node")
                    return true; // skip it
                if (!oriComboMap[treeNode.id])
                    return true; // means it is hidden, skip it
                if (comboMap[treeNode.id] === undefined) {
                    const combo = {
                        id: treeNode.id,
                        name: treeNode.id,
                        cx: 0,
                        cy: 0,
                        count: 0,
                        depth: self.oriComboMap[treeNode.id].depth || 0,
                        children: []
                    };
                    comboMap[treeNode.id] = combo;
                }
                const children = treeNode.children;
                if (children) {
                    children.forEach((child) => {
                        if (!comboMap[child.id] && !nodeMap[child.id])
                            return true; // means it is hidden
                        treeChildren.push(child);
                    });
                }
                const c = comboMap[treeNode.id];
                c.cx = 0;
                c.cy = 0;
                if (treeChildren.length === 0) {
                    c.empty = true;
                    const oriCombo = oriComboMap[treeNode.id];
                    c.cx = oriCombo.x;
                    c.cy = oriCombo.y;
                }
                treeChildren.forEach((child) => {
                    c.count++;
                    if (child.itemType !== "node") {
                        const childCombo = comboMap[child.id];
                        if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(childCombo.cx))
                            c.cx += childCombo.cx;
                        if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(childCombo.cy))
                            c.cy += childCombo.cy;
                        return;
                    }
                    const node = nodeMap[child.id];
                    // means the node is hidden, skip it
                    if (!node)
                        return;
                    if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(node.x)) {
                        c.cx += node.x;
                    }
                    if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(node.y)) {
                        c.cy += node.y;
                    }
                });
                c.cx /= (c.count || 1);
                c.cy /= (c.count || 1);
                c.children = treeChildren;
                return true;
            });
        });
        return comboMap;
    }
    applyComboCenterForce(displacements) {
        const self = this;
        const gravity = self.gravity;
        const comboGravity = self.comboGravity || gravity;
        const alpha = this.alpha;
        const comboTrees = self.comboTrees;
        const indexMap = self.indexMap;
        const nodeMap = self.nodeMap;
        const comboMap = self.comboMap;
        (comboTrees || []).forEach((ctree) => {
            (0,_util__WEBPACK_IMPORTED_MODULE_1__.traverseTreeUp)(ctree, (treeNode) => {
                if (treeNode.itemType === "node")
                    return true; // skip it
                const combo = comboMap[treeNode.id];
                // means the combo is hidden, skip it
                if (!combo)
                    return true;
                const c = comboMap[treeNode.id];
                // higher depth the combo, larger the gravity
                const gravityScale = ((c.depth + 1) / 10) * 0.5;
                // apply combo center force for all the descend nodes in this combo
                // and update the center position and count for this combo
                const comboX = c.cx;
                const comboY = c.cy;
                c.cx = 0;
                c.cy = 0;
                c.children.forEach((child) => {
                    if (child.itemType !== "node") {
                        const childCombo = comboMap[child.id];
                        if (childCombo && (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(childCombo.cx))
                            c.cx += childCombo.cx;
                        if (childCombo && (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(childCombo.cy))
                            c.cy += childCombo.cy;
                        return;
                    }
                    const node = nodeMap[child.id];
                    const vecX = (node.x - comboX) || 0.005;
                    const vecY = (node.y - comboY) || 0.005;
                    const l = Math.sqrt(vecX * vecX + vecY * vecY);
                    const childIdx = indexMap[node.id];
                    const params = ((comboGravity * alpha) / l) * gravityScale;
                    displacements[childIdx].x -= vecX * params;
                    displacements[childIdx].y -= vecY * params;
                    if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(node.x))
                        c.cx += node.x;
                    if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(node.y))
                        c.cy += node.y;
                });
                c.cx /= (c.count || 1);
                c.cy /= (c.count || 1);
                return true;
            });
        });
    }
    applyCalculate(displacements) {
        const self = this;
        const comboMap = self.comboMap;
        const nodes = self.nodes;
        // store the vx, vy, and distance to reduce dulplicate calculation
        const vecMap = {};
        nodes.forEach((v, i) => {
            nodes.forEach((u, j) => {
                if (i < j)
                    return;
                const vx = (v.x - u.x) || 0.005;
                const vy = (v.y - u.y) || 0.005;
                let vl2 = vx * vx + vy * vy;
                const vl = Math.sqrt(vl2);
                if (vl2 < 1)
                    vl2 = vl;
                vecMap[`${v.id}-${u.id}`] = { vx, vy, vl2, vl };
                vecMap[`${u.id}-${v.id}`] = { vl2, vl, vx: -vx, vy: -vy };
            });
        });
        // get the sizes of the combos
        self.updateComboSizes(comboMap);
        self.calRepulsive(displacements, vecMap);
        self.calAttractive(displacements, vecMap);
        const preventComboOverlap = self.preventComboOverlap;
        if (preventComboOverlap)
            self.comboNonOverlapping(displacements, comboMap);
    }
    /**
     * Update the sizes of the combos according to their children
     * Used for combos nonoverlap, but not re-render the combo shapes
     */
    updateComboSizes(comboMap) {
        const self = this;
        const comboTrees = self.comboTrees;
        const nodeMap = self.nodeMap;
        const nodeSize = self.nodeSize;
        const comboSpacing = self.comboSpacing;
        const comboPadding = self.comboPadding;
        (comboTrees || []).forEach((ctree) => {
            const treeChildren = [];
            (0,_util__WEBPACK_IMPORTED_MODULE_1__.traverseTreeUp)(ctree, (treeNode) => {
                if (treeNode.itemType === "node")
                    return true; // skip it
                const c = comboMap[treeNode.id];
                // means the combo is hidden, skip it
                if (!c)
                    return false;
                const children = treeNode.children;
                if (children) {
                    children.forEach((child) => {
                        // means the combo is hidden.
                        if (!comboMap[child.id] && !nodeMap[child.id])
                            return;
                        treeChildren.push(child);
                    });
                }
                c.minX = Infinity;
                c.minY = Infinity;
                c.maxX = -Infinity;
                c.maxY = -Infinity;
                treeChildren.forEach((child) => {
                    if (child.itemType !== "node")
                        return true; // skip it
                    const node = nodeMap[child.id];
                    if (!node)
                        return true; // means it is hidden
                    const r = nodeSize(node);
                    const nodeMinX = node.x - r;
                    const nodeMinY = node.y - r;
                    const nodeMaxX = node.x + r;
                    const nodeMaxY = node.y + r;
                    if (c.minX > nodeMinX)
                        c.minX = nodeMinX;
                    if (c.minY > nodeMinY)
                        c.minY = nodeMinY;
                    if (c.maxX < nodeMaxX)
                        c.maxX = nodeMaxX;
                    if (c.maxY < nodeMaxY)
                        c.maxY = nodeMaxY;
                });
                let minSize = self.oriComboMap[treeNode.id].size || 10;
                if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(minSize))
                    minSize = minSize[0];
                const maxLength = Math.max(c.maxX - c.minX, c.maxY - c.minY, minSize);
                c.r = maxLength / 2 + comboSpacing(c) / 2 + comboPadding(c);
                return true;
            });
        });
    }
    /**
     * prevent the overlappings among combos
     */
    comboNonOverlapping(displacements, comboMap) {
        const self = this;
        const comboTree = self.comboTree;
        const comboCollideStrength = self.comboCollideStrength;
        const indexMap = self.indexMap;
        const nodeMap = self.nodeMap;
        (0,_util__WEBPACK_IMPORTED_MODULE_1__.traverseTreeUp)(comboTree, (treeNode) => {
            if (!comboMap[treeNode.id] &&
                !nodeMap[treeNode.id] &&
                treeNode.id !== "comboTreeRoot") {
                return false;
            } // means it is hidden
            const children = treeNode.children;
            // 同个子树下的子 combo 间两两对比
            if (children && children.length > 1) {
                children.forEach((v, i) => {
                    if (v.itemType === "node")
                        return false; // skip it
                    const cv = comboMap[v.id];
                    if (!cv)
                        return; // means it is hidden, skip it
                    children.forEach((u, j) => {
                        if (i <= j)
                            return false;
                        if (u.itemType === "node")
                            return false; // skip it
                        const cu = comboMap[u.id];
                        if (!cu)
                            return false; // means it is hidden, skip it
                        const vx = (cv.cx - cu.cx) || 0.005;
                        const vy = (cv.cy - cu.cy) || 0.005;
                        const l = vx * vx + vy * vy;
                        const rv = cv.r || 1;
                        const ru = cu.r || 1;
                        const r = rv + ru;
                        const ru2 = ru * ru;
                        const rv2 = rv * rv;
                        // overlapping
                        if (l < r * r) {
                            const vnodes = v.children;
                            if (!vnodes || vnodes.length === 0)
                                return false; // skip it
                            const unodes = u.children;
                            if (!unodes || unodes.length === 0)
                                return false; // skip it
                            const sqrtl = Math.sqrt(l);
                            const ll = ((r - sqrtl) / sqrtl) * comboCollideStrength;
                            const xl = vx * ll;
                            const yl = vy * ll;
                            const rratio = ru2 / (rv2 + ru2);
                            const irratio = 1 - rratio;
                            // 两兄弟 combo 的子节点上施加斥力
                            vnodes.forEach((vn) => {
                                if (vn.itemType !== "node")
                                    return false; // skip it
                                if (!nodeMap[vn.id])
                                    return; // means it is hidden, skip it
                                const vindex = indexMap[vn.id];
                                unodes.forEach((un) => {
                                    if (un.itemType !== "node")
                                        return false;
                                    if (!nodeMap[un.id])
                                        return false; // means it is hidden, skip it
                                    const uindex = indexMap[un.id];
                                    displacements[vindex].x += xl * rratio;
                                    displacements[vindex].y += yl * rratio;
                                    displacements[uindex].x -= xl * irratio;
                                    displacements[uindex].y -= yl * irratio;
                                });
                            });
                        }
                    });
                });
            }
            return true;
        });
    }
    /**
     * Calculate the repulsive force between each node pair
     * @param displacements The array stores the displacements for nodes
     * @param vecMap The map stores vector between each node pair
     */
    calRepulsive(displacements, vecMap) {
        const self = this;
        const nodes = self.nodes;
        const max = self.width * self.optimizeRangeFactor;
        const nodeStrength = self.nodeStrength;
        const alpha = self.alpha;
        const nodeCollideStrength = self.nodeCollideStrength;
        const preventNodeOverlap = self.preventNodeOverlap;
        const nodeSizeFunc = self.nodeSize;
        const nodeSpacingFunc = self.nodeSpacing;
        const scale = self.depthRepulsiveForceScale;
        const center = self.center;
        nodes.forEach((v, i) => {
            if (!v.x || !v.y)
                return;
            // center gravity
            if (center) {
                const gravity = self.gravity;
                const vecX = (v.x - center[0]) || 0.005;
                const vecY = (v.y - center[1]) || 0.005;
                const l = Math.sqrt(vecX * vecX + vecY * vecY);
                displacements[i].x -= (vecX * gravity * alpha) / l;
                displacements[i].y -= (vecY * gravity * alpha) / l;
            }
            nodes.forEach((u, j) => {
                if (i === j) {
                    return;
                }
                if (!u.x || !u.y)
                    return;
                const { vl2, vl } = vecMap[`${v.id}-${u.id}`];
                if (vl > max)
                    return;
                const { vx, vy } = vecMap[`${v.id}-${u.id}`];
                let depthDiff = Math.log(Math.abs(u.depth - v.depth) / 10) + 1 || 1;
                depthDiff = depthDiff < 1 ? 1 : depthDiff;
                if (u.comboId !== v.comboId)
                    depthDiff += 1;
                const depthParam = depthDiff ? Math.pow(scale, depthDiff) : 1;
                const params = ((nodeStrength(u) * alpha) / vl2) * depthParam;
                displacements[i].x += vx * params;
                displacements[i].y += vy * params;
                // prevent node overlappings
                if (i < j && preventNodeOverlap) {
                    const ri = (nodeSizeFunc(v) + nodeSpacingFunc(v)) || 1;
                    const rj = (nodeSizeFunc(u) + nodeSpacingFunc(u)) || 1;
                    const r = ri + rj;
                    if (vl2 < r * r) {
                        const ll = ((r - vl) / vl) * nodeCollideStrength;
                        const rj2 = rj * rj;
                        let rratio = rj2 / (ri * ri + rj2);
                        const xl = vx * ll;
                        const yl = vy * ll;
                        displacements[i].x += xl * rratio;
                        displacements[i].y += yl * rratio;
                        rratio = 1 - rratio;
                        displacements[j].x -= xl * rratio;
                        displacements[j].y -= yl * rratio;
                    }
                }
            });
        });
    }
    /**
     * Calculate the attractive force between the node pair with edge
     * @param displacements The array stores the displacements for nodes
     * @param vecMap The map stores vector between each node pair
     */
    calAttractive(displacements, vecMap) {
        const self = this;
        const edges = self.edges;
        const linkDistance = self.linkDistance;
        const alpha = self.alpha;
        const edgeStrength = self.edgeStrength;
        const bias = self.bias;
        const scale = self.depthAttractiveForceScale;
        edges.forEach((e, i) => {
            const source = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getEdgeTerminal)(e, 'source');
            const target = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getEdgeTerminal)(e, 'target');
            if (!source || !target || source === target)
                return;
            const uIndex = self.indexMap[source];
            const vIndex = self.indexMap[target];
            const u = self.nodeMap[source];
            const v = self.nodeMap[target];
            if (!u || !v)
                return;
            let depthDiff = u.depth === v.depth ? 0 : Math.log(Math.abs(u.depth - v.depth) / 10);
            if (u.comboId === v.comboId) {
                depthDiff = depthDiff / 2;
            }
            let depthParam = depthDiff ? Math.pow(scale, depthDiff) : 1;
            if (u.comboId !== v.comboId && depthParam === 1) {
                depthParam = scale / 2;
            }
            else if (u.comboId === v.comboId) {
                depthParam = 2;
            }
            if (!(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(v.x) || !(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(u.x) || !(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(v.y) || !(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(u.y)) {
                return;
            }
            const { vl, vx, vy } = vecMap[`${target}-${source}`];
            const l = ((vl - linkDistance(e)) / vl) * alpha * edgeStrength(e) * depthParam;
            const vecX = vx * l;
            const vecY = vy * l;
            const b = bias[i];
            displacements[vIndex].x -= vecX * b;
            displacements[vIndex].y -= vecY * b;
            displacements[uIndex].x += vecX * (1 - b);
            displacements[uIndex].y += vecY * (1 - b);
        });
    }
    getType() {
        return "comboForce";
    }
}
//# sourceMappingURL=comboForce.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/concentric.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/concentric.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConcentricLayout: () => (/* binding */ ConcentricLayout)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/layout/es/util/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./node_modules/@antv/layout/es/layout/base.js");
/**
 * @fileOverview concentric layout
 * @author shiwu.wyy@antfin.com
 * this algorithm refers to <cytoscape.js> - https://github.com/cytoscape/cytoscape.js/
 */


/**
 * 同心圆布局
 */
class ConcentricLayout extends _base__WEBPACK_IMPORTED_MODULE_1__.Base {
    constructor(options) {
        super();
        this.nodeSize = 30;
        /** min spacing between outside of nodes (used for radius adjustment) */
        this.minNodeSpacing = 10;
        /** same as minNodeSpacing. min spacing between outside of nodes (used for radius adjustment) */
        this.nodeSpacing = 10;
        /** prevents node overlap, may overflow boundingBox if not enough space */
        this.preventOverlap = false;
        /** whether levels have an equal radial distance betwen them, may cause bounding box overflow */
        this.equidistant = false;
        /** where nodes start in radians */
        this.startAngle = (3 / 2) * Math.PI;
        /** whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false) */
        this.clockwise = true;
        /** 根据 sortBy 指定的属性进行排布，数值高的放在中心，如果是 sortBy 则会计算节点度数，度数最高的放在中心 */
        this.sortBy = "degree";
        this.nodes = [];
        this.edges = [];
        this.width = 300;
        this.height = 300;
        /** 迭代结束的回调函数 */
        this.onLayoutEnd = () => { };
        this.updateCfg(options);
    }
    getDefaultCfg() {
        return {
            nodeSize: 30,
            minNodeSpacing: 10,
            nodeSpacing: 10,
            preventOverlap: false,
            sweep: undefined,
            equidistant: false,
            startAngle: (3 / 2) * Math.PI,
            clockwise: true,
            maxLevelDiff: undefined,
            sortBy: "degree"
        };
    }
    /**
     * 执行布局
     */
    execute() {
        var _a, _b;
        const self = this;
        const { nodes, edges } = self;
        const n = nodes.length;
        if (n === 0) {
            (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);
            return;
        }
        if (!self.width && typeof window !== "undefined") {
            self.width = window.innerWidth;
        }
        if (!self.height && typeof window !== "undefined") {
            self.height = window.innerHeight;
        }
        if (!self.center) {
            self.center = [self.width / 2, self.height / 2];
        }
        const center = self.center;
        if (n === 1) {
            nodes[0].x = center[0];
            nodes[0].y = center[1];
            (_b = self.onLayoutEnd) === null || _b === void 0 ? void 0 : _b.call(self);
            return;
        }
        const { nodeSize, nodeSpacing } = self;
        const layoutNodes = [];
        let maxNodeSize;
        let maxNodeSpacing = 0;
        if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(nodeSize)) {
            maxNodeSize = Math.max(nodeSize[0], nodeSize[1]);
        }
        else {
            maxNodeSize = nodeSize;
        }
        if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(nodeSpacing)) {
            maxNodeSpacing = Math.max(nodeSpacing[0], nodeSpacing[1]);
        }
        else if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isNumber)(nodeSpacing)) {
            maxNodeSpacing = nodeSpacing;
        }
        nodes.forEach((node) => {
            layoutNodes.push(node);
            let nodeSize = maxNodeSize;
            if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(node.size)) {
                nodeSize = Math.max(node.size[0], node.size[1]);
            }
            else if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isNumber)(node.size)) {
                nodeSize = node.size;
            }
            else if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(node.size)) {
                nodeSize = Math.max(node.size.width, node.size.height);
            }
            maxNodeSize = Math.max(maxNodeSize, nodeSize);
            if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(nodeSpacing)) {
                maxNodeSpacing = Math.max(nodeSpacing(node), maxNodeSpacing);
            }
        });
        self.clockwise =
            self.counterclockwise !== undefined
                ? !self.counterclockwise
                : self.clockwise;
        // layout
        const nodeMap = {};
        const indexMap = {};
        layoutNodes.forEach((node, i) => {
            nodeMap[node.id] = node;
            indexMap[node.id] = i;
        });
        // get the node degrees
        if (self.sortBy === "degree" ||
            !(0,_util__WEBPACK_IMPORTED_MODULE_0__.isString)(self.sortBy) ||
            layoutNodes[0][self.sortBy] === undefined) {
            self.sortBy = "degree";
            if (!(0,_util__WEBPACK_IMPORTED_MODULE_0__.isNumber)(nodes[0].degree)) {
                const values = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getDegree)(nodes.length, indexMap, edges);
                layoutNodes.forEach((node, i) => {
                    node.degree = values[i].all;
                });
            }
        }
        // sort nodes by value
        layoutNodes.sort((n1, n2) => n2[self.sortBy] - n1[self.sortBy]);
        self.maxValueNode = layoutNodes[0];
        self.maxLevelDiff =
            self.maxLevelDiff || self.maxValueNode[self.sortBy] / 4;
        // put the values into levels
        const levels = [[]];
        let currentLevel = levels[0];
        layoutNodes.forEach((node) => {
            if (currentLevel.length > 0) {
                const diff = Math.abs(currentLevel[0][self.sortBy] - node[self.sortBy]);
                if (self.maxLevelDiff && diff >= self.maxLevelDiff) {
                    currentLevel = [];
                    levels.push(currentLevel);
                }
            }
            currentLevel.push(node);
        });
        // create positions for levels
        let minDist = maxNodeSize + (maxNodeSpacing || self.minNodeSpacing); // min dist between nodes
        if (!self.preventOverlap) {
            // then strictly constrain to bb
            const firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;
            const maxR = Math.min(self.width, self.height) / 2 - minDist;
            const rStep = maxR / (levels.length + (firstLvlHasMulti ? 1 : 0));
            minDist = Math.min(minDist, rStep);
        }
        // find the metrics for each level
        let r = 0;
        levels.forEach((level) => {
            let sweep = self.sweep;
            if (sweep === undefined) {
                sweep = 2 * Math.PI - (2 * Math.PI) / level.length;
            }
            const dTheta = (level.dTheta = sweep / Math.max(1, level.length - 1));
            // calculate the radius
            if (level.length > 1 && self.preventOverlap) {
                // but only if more than one node (can't overlap)
                const dcos = Math.cos(dTheta) - Math.cos(0);
                const dsin = Math.sin(dTheta) - Math.sin(0);
                const rMin = Math.sqrt((minDist * minDist) / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping
                r = Math.max(rMin, r);
            }
            level.r = r;
            r += minDist;
        });
        if (self.equidistant) {
            let rDeltaMax = 0;
            let rr = 0;
            for (let i = 0; i < levels.length; i++) {
                const level = levels[i];
                const rDelta = level.r - rr;
                rDeltaMax = Math.max(rDeltaMax, rDelta);
            }
            rr = 0;
            levels.forEach((level, i) => {
                if (i === 0) {
                    rr = level.r;
                }
                level.r = rr;
                rr += rDeltaMax;
            });
        }
        // calculate the node positions
        levels.forEach((level) => {
            const dTheta = level.dTheta;
            const rr = level.r;
            level.forEach((node, j) => {
                const theta = self.startAngle + (self.clockwise ? 1 : -1) * dTheta * j;
                node.x = center[0] + rr * Math.cos(theta);
                node.y = center[1] + rr * Math.sin(theta);
            });
        });
        if (self.onLayoutEnd)
            self.onLayoutEnd();
        return {
            nodes,
            edges
        };
    }
    getType() {
        return "concentric";
    }
}
//# sourceMappingURL=concentric.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/constants.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/constants.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FORCE_LAYOUT_TYPE_MAP: () => (/* binding */ FORCE_LAYOUT_TYPE_MAP),
/* harmony export */   LAYOUT_MESSAGE: () => (/* binding */ LAYOUT_MESSAGE)
/* harmony export */ });
/** layout message type */
const LAYOUT_MESSAGE = {
    // run layout
    RUN: "LAYOUT_RUN",
    // layout ended with success
    END: "LAYOUT_END",
    // layout error
    ERROR: "LAYOUT_ERROR",
    // layout tick, used in force directed layout
    TICK: "LAYOUT_TICK",
    GPURUN: "GPU_LAYOUT_RUN",
    GPUEND: "GPU_LAYOUT_END"
};
const FORCE_LAYOUT_TYPE_MAP = {
    'gForce': true,
    'force2': true,
    'fruchterman': true,
    'forceAtlas2': true,
    'force': true,
    'graphin-force': true,
};
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/dagre.js":
/*!******************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/dagre.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DagreLayout: () => (/* binding */ DagreLayout)
/* harmony export */ });
/* harmony import */ var _dagre_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dagre/index */ "./node_modules/@antv/layout/es/layout/dagre/index.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/layout/es/util/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base */ "./node_modules/@antv/layout/es/layout/base.js");
/* harmony import */ var _dagre_graph__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dagre/graph */ "./node_modules/@antv/layout/es/layout/dagre/graph.js");
/**
 * @fileOverview dagre layout
 * @author shiwu.wyy@antfin.com
 */




/**
 * 层次布局
 */
class DagreLayout extends _base__WEBPACK_IMPORTED_MODULE_2__.Base {
    constructor(options) {
        super();
        /** layout 方向, 可选 TB, BT, LR, RL */
        this.rankdir = 'TB';
        /** 节点水平间距(px) */
        this.nodesep = 50;
        /** 每一层节点之间间距 */
        this.ranksep = 50;
        /** 是否保留布局连线的控制点 */
        this.controlPoints = false;
        /** 每层节点是否根据节点数据中的 comboId 进行排序，以防止同层 combo 重叠 */
        this.sortByCombo = false;
        /** 是否保留每条边上的dummy node */
        this.edgeLabelSpace = true;
        /** 是否基于 dagre 进行辐射布局，若是，第一层节点将被放置在最内环上，其余层依次向外辐射 */
        this.radial = false;
        this.nodes = [];
        this.edges = [];
        /** 迭代结束的回调函数 */
        this.onLayoutEnd = () => { };
        this.layoutNode = (nodeId) => {
            const self = this;
            const { nodes } = self;
            const node = nodes.find((node) => node.id === nodeId);
            if (node) {
                const layout = node.layout !== false;
                return layout;
            }
            return true;
        };
        this.updateCfg(options);
    }
    getDefaultCfg() {
        return {
            rankdir: 'TB',
            align: undefined,
            nodeSize: undefined,
            nodesepFunc: undefined,
            ranksepFunc: undefined,
            nodesep: 50,
            ranksep: 50,
            controlPoints: false,
            radial: false,
            focusNode: null, // radial 为 true 时生效，关注的节点
        };
    }
    /**
     * 执行布局
     */
    execute() {
        var _a, _b, _c, _d;
        const self = this;
        const { nodes, nodeSize, rankdir, combos, begin, radial, comboEdges = [], vedges = [], } = self;
        if (!nodes)
            return;
        const edges = self.edges || [];
        const g = new _dagre_graph__WEBPACK_IMPORTED_MODULE_3__.Graph({
            multigraph: true,
            compound: true,
        });
        // collect the nodes in their combo, to create virtual edges for comboEdges
        self.nodeMap = {};
        const nodeComboMap = {};
        nodes.forEach((node) => {
            self.nodeMap[node.id] = node;
            if (!node.comboId)
                return;
            nodeComboMap[node.comboId] = nodeComboMap[node.comboId] || [];
            nodeComboMap[node.comboId].push(node.id);
        });
        let sortedNodes = [];
        const visitedMap = {};
        if ((_a = self.nodeOrder) === null || _a === void 0 ? void 0 : _a.length) {
            self.nodeOrder.forEach((id) => {
                visitedMap[id] = true;
                sortedNodes.push(self.nodeMap[id]);
            });
            nodes.forEach((node) => {
                if (!visitedMap[node.id])
                    sortedNodes.push(node);
            });
        }
        else {
            sortedNodes = nodes;
        }
        let nodeSizeFunc;
        if (!nodeSize) {
            nodeSizeFunc = (d) => {
                if (d.size) {
                    if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(d.size)) {
                        return d.size;
                    }
                    if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isObject)(d.size)) {
                        return [d.size.width || 40, d.size.height || 40];
                    }
                    return [d.size, d.size];
                }
                return [40, 40];
            };
        }
        else if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(nodeSize)) {
            nodeSizeFunc = () => nodeSize;
        }
        else {
            nodeSizeFunc = () => [nodeSize, nodeSize];
        }
        const ranksepfunc = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getFunc)(self.ranksep, 50, self.ranksepFunc);
        const nodesepfunc = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getFunc)(self.nodesep, 50, self.nodesepFunc);
        let horisep = nodesepfunc;
        let vertisep = ranksepfunc;
        if (rankdir === 'LR' || rankdir === 'RL') {
            horisep = ranksepfunc;
            vertisep = nodesepfunc;
        }
        g.setDefaultEdgeLabel(() => ({}));
        g.setGraph(self);
        const comboMap = {};
        if (this.sortByCombo && combos) {
            combos.forEach((combo) => {
                comboMap[combo.id] = combo;
                // regard the collapsed combo as a node
                if (combo.collapsed) {
                    const size = nodeSizeFunc(combo);
                    const verti = vertisep(combo);
                    const hori = horisep(combo);
                    const width = size[0] + 2 * hori;
                    const height = size[1] + 2 * verti;
                    g.setNode(combo.id, { width, height });
                }
                if (!combo.parentId)
                    return;
                if (!comboMap[combo.parentId]) {
                    g.setNode(combo.parentId, {});
                }
                g.setParent(combo.id, combo.parentId);
            });
        }
        sortedNodes
            .filter((node) => node.layout !== false)
            .forEach((node) => {
            const size = nodeSizeFunc(node);
            const verti = vertisep(node);
            const hori = horisep(node);
            const width = size[0] + 2 * hori;
            const height = size[1] + 2 * verti;
            const layer = node.layer;
            if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(layer)) {
                // 如果有layer属性，加入到node的label中
                g.setNode(node.id, { width, height, layer });
            }
            else {
                g.setNode(node.id, { width, height });
            }
            if (this.sortByCombo && node.comboId) {
                if (!comboMap[node.comboId]) {
                    comboMap[node.comboId] = { id: node.comboId };
                    g.setNode(node.comboId, {});
                }
                g.setParent(node.id, node.comboId);
            }
        });
        edges.forEach((edge) => {
            // dagrejs Wiki https://github.com/dagrejs/dagre/wiki#configuring-the-layout
            const source = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getEdgeTerminal)(edge, 'source');
            const target = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getEdgeTerminal)(edge, 'target');
            if (this.layoutNode(source) && this.layoutNode(target)) {
                g.setEdge(source, target, {
                    weight: edge.weight || 1,
                });
            }
        });
        // create virtual edges from node to node for comboEdges
        (_b = comboEdges === null || comboEdges === void 0 ? void 0 : comboEdges.concat(vedges || [])) === null || _b === void 0 ? void 0 : _b.forEach((comboEdge) => {
            var _a, _b;
            const { source, target } = comboEdge;
            const sources = ((_a = comboMap[source]) === null || _a === void 0 ? void 0 : _a.collapsed)
                ? [source]
                : nodeComboMap[source] || [source];
            const targets = ((_b = comboMap[target]) === null || _b === void 0 ? void 0 : _b.collapsed)
                ? [target]
                : nodeComboMap[target] || [target];
            sources.forEach((s) => {
                targets.forEach((t) => {
                    g.setEdge(s, t, {
                        weight: comboEdge.weight || 1,
                    });
                });
            });
        });
        // 考虑增量图中的原始图
        let prevGraph = undefined;
        if ((_c = self.preset) === null || _c === void 0 ? void 0 : _c.nodes) {
            prevGraph = new _dagre_graph__WEBPACK_IMPORTED_MODULE_3__.Graph({
                multigraph: true,
                compound: true,
            });
            self.preset.nodes.forEach((node) => {
                prevGraph === null || prevGraph === void 0 ? void 0 : prevGraph.setNode(node.id, node);
            });
        }
        _dagre_index__WEBPACK_IMPORTED_MODULE_0__["default"].layout(g, {
            prevGraph,
            edgeLabelSpace: self.edgeLabelSpace,
            keepNodeOrder: Boolean(!!self.nodeOrder),
            nodeOrder: self.nodeOrder,
        });
        const dBegin = [0, 0];
        if (begin) {
            let minX = Infinity;
            let minY = Infinity;
            g.nodes().forEach((node) => {
                const coord = g.node(node);
                if (minX > coord.x)
                    minX = coord.x;
                if (minY > coord.y)
                    minY = coord.y;
            });
            g.edges().forEach((edge) => {
                var _a;
                const coord = g.edge(edge);
                (_a = coord.points) === null || _a === void 0 ? void 0 : _a.forEach((point) => {
                    if (minX > point.x)
                        minX = point.x;
                    if (minY > point.y)
                        minY = point.y;
                });
            });
            dBegin[0] = begin[0] - minX;
            dBegin[1] = begin[1] - minY;
        }
        const isHorizontal = rankdir === 'LR' || rankdir === 'RL';
        // 变形为辐射
        if (radial) {
            const { focusNode, ranksep, getRadialPos } = this;
            const focusId = (0,_util__WEBPACK_IMPORTED_MODULE_1__.isString)(focusNode) ? focusNode : focusNode === null || focusNode === void 0 ? void 0 : focusNode.id;
            const focusLayer = focusId ? (_d = g.node(focusId)) === null || _d === void 0 ? void 0 : _d._rank : 0;
            const layers = [];
            const dim = isHorizontal ? 'y' : 'x';
            const sizeDim = isHorizontal ? 'height' : 'width';
            // 找到整个图作为环的坐标维度（dim）的最大、最小值，考虑节点宽度
            let min = Infinity;
            let max = -Infinity;
            g.nodes().forEach((node) => {
                const coord = g.node(node);
                if (!self.nodeMap[node])
                    return;
                const currentNodesep = nodesepfunc(self.nodeMap[node]);
                if (focusLayer === 0) {
                    if (!layers[coord._rank]) {
                        layers[coord._rank] = {
                            nodes: [],
                            totalWidth: 0,
                            maxSize: -Infinity,
                        };
                    }
                    layers[coord._rank].nodes.push(node);
                    layers[coord._rank].totalWidth += currentNodesep * 2 + coord[sizeDim];
                    if (layers[coord._rank].maxSize < Math.max(coord.width, coord.height)) {
                        layers[coord._rank].maxSize = Math.max(coord.width, coord.height);
                    }
                }
                else {
                    const diffLayer = coord._rank - focusLayer;
                    if (diffLayer === 0) {
                        if (!layers[diffLayer]) {
                            layers[diffLayer] = {
                                nodes: [],
                                totalWidth: 0,
                                maxSize: -Infinity,
                            };
                        }
                        layers[diffLayer].nodes.push(node);
                        layers[diffLayer].totalWidth += currentNodesep * 2 + coord[sizeDim];
                        if (layers[diffLayer].maxSize < Math.max(coord.width, coord.height)) {
                            layers[diffLayer].maxSize = Math.max(coord.width, coord.height);
                        }
                    }
                    else {
                        const diffLayerAbs = Math.abs(diffLayer);
                        if (!layers[diffLayerAbs]) {
                            layers[diffLayerAbs] = {
                                left: [],
                                right: [],
                                totalWidth: 0,
                                maxSize: -Infinity,
                            };
                        }
                        layers[diffLayerAbs].totalWidth +=
                            currentNodesep * 2 + coord[sizeDim];
                        if (layers[diffLayerAbs].maxSize < Math.max(coord.width, coord.height)) {
                            layers[diffLayerAbs].maxSize = Math.max(coord.width, coord.height);
                        }
                        if (diffLayer < 0) {
                            layers[diffLayerAbs].left.push(node);
                        }
                        else {
                            layers[diffLayerAbs].right.push(node);
                        }
                    }
                }
                const leftPos = coord[dim] - coord[sizeDim] / 2 - currentNodesep;
                const rightPos = coord[dim] + coord[sizeDim] / 2 + currentNodesep;
                if (leftPos < min)
                    min = leftPos;
                if (rightPos > max)
                    max = rightPos;
            });
            // const padding = (max - min) * 0.1; // TODO
            // 初始化为第一圈的半径，后面根据每层 ranksep 叠加
            let radius = ranksep || 50; // TODO;
            const radiusMap = {};
            // 扩大最大最小值范围，以便为环上留出接缝处的空隙
            const rangeLength = (max - min) / 0.9;
            const range = [
                (min + max - rangeLength) * 0.5,
                (min + max + rangeLength) * 0.5,
            ];
            // 根据半径、分布比例，计算节点在环上的位置，并返回该组节点中最大的 ranksep 值
            const processNodes = (layerNodes, radius, propsMaxRanksep = -Infinity, arcRange = [0, 1]) => {
                let maxRanksep = propsMaxRanksep;
                layerNodes.forEach((node) => {
                    const coord = g.node(node);
                    radiusMap[node] = radius;
                    // 获取变形为 radial 后的直角坐标系坐标
                    const { x: newX, y: newY } = getRadialPos(coord[dim], range, rangeLength, radius, arcRange);
                    // 将新坐标写入源数据
                    if (!self.nodeMap[node])
                        return;
                    self.nodeMap[node].x = newX + dBegin[0];
                    self.nodeMap[node].y = newY + dBegin[1];
                    // @ts-ignore: pass layer order to data for increment layout use
                    self.nodeMap[node]._order = coord._order;
                    // 找到本层最大的一个 ranksep，作为下一层与本层的间隙，叠加到下一层的半径上
                    const currentNodeRanksep = ranksepfunc(self.nodeMap[node]);
                    if (maxRanksep < currentNodeRanksep)
                        maxRanksep = currentNodeRanksep;
                });
                return maxRanksep;
            };
            let isFirstLevel = true;
            const lastLayerMaxNodeSize = 0;
            layers.forEach((layerNodes) => {
                var _a, _b, _c, _d, _e, _f, _g;
                if (!((_a = layerNodes === null || layerNodes === void 0 ? void 0 : layerNodes.nodes) === null || _a === void 0 ? void 0 : _a.length) &&
                    !((_b = layerNodes === null || layerNodes === void 0 ? void 0 : layerNodes.left) === null || _b === void 0 ? void 0 : _b.length) &&
                    !((_c = layerNodes === null || layerNodes === void 0 ? void 0 : layerNodes.right) === null || _c === void 0 ? void 0 : _c.length)) {
                    return;
                }
                // 第一层只有一个节点，直接放在圆心，初始半径设定为 0
                if (isFirstLevel && layerNodes.nodes.length === 1) {
                    // 将新坐标写入源数据
                    const nodeId = layerNodes.nodes[0];
                    if (!self.nodeMap[nodeId])
                        return;
                    self.nodeMap[nodeId].x = dBegin[0];
                    self.nodeMap[nodeId].y = dBegin[1];
                    radiusMap[layerNodes.nodes[0]] = 0;
                    radius = ranksepfunc(self.nodeMap[nodeId]);
                    isFirstLevel = false;
                    return;
                }
                // 为接缝留出空隙，半径也需要扩大
                radius = Math.max(radius, layerNodes.totalWidth / (2 * Math.PI)); // / 0.9;
                let maxRanksep = -Infinity;
                if (focusLayer === 0 || ((_d = layerNodes.nodes) === null || _d === void 0 ? void 0 : _d.length)) {
                    maxRanksep = processNodes(layerNodes.nodes, radius, maxRanksep, [0, 1]); // 0.8
                }
                else {
                    const leftRatio = ((_e = layerNodes.left) === null || _e === void 0 ? void 0 : _e.length) /
                        (((_f = layerNodes.left) === null || _f === void 0 ? void 0 : _f.length) + ((_g = layerNodes.right) === null || _g === void 0 ? void 0 : _g.length));
                    maxRanksep = processNodes(layerNodes.left, radius, maxRanksep, [
                        0,
                        leftRatio,
                    ]); // 接缝留出 0.05 的缝隙
                    maxRanksep = processNodes(layerNodes.right, radius, maxRanksep, [
                        leftRatio + 0.05,
                        1,
                    ]); // 接缝留出 0.05 的缝隙
                }
                radius += maxRanksep;
                isFirstLevel = false;
                lastLayerMaxNodeSize - layerNodes.maxSize;
            });
            g.edges().forEach((edge) => {
                var _a, _b, _c;
                const coord = g.edge(edge);
                const i = edges.findIndex((it) => {
                    const source = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getEdgeTerminal)(it, 'source');
                    const target = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getEdgeTerminal)(it, 'target');
                    return source === edge.v && target === edge.w;
                });
                if (i <= -1)
                    return;
                if (self.edgeLabelSpace &&
                    self.controlPoints &&
                    edges[i].type !== 'loop') {
                    const otherDim = dim === 'x' ? 'y' : 'x';
                    const controlPoints = (_a = coord === null || coord === void 0 ? void 0 : coord.points) === null || _a === void 0 ? void 0 : _a.slice(1, coord.points.length - 1);
                    const newControlPoints = [];
                    const sourceOtherDimValue = (_b = g.node(edge.v)) === null || _b === void 0 ? void 0 : _b[otherDim];
                    const otherDimDist = sourceOtherDimValue - ((_c = g.node(edge.w)) === null || _c === void 0 ? void 0 : _c[otherDim]);
                    const sourceRadius = radiusMap[edge.v];
                    const radiusDist = sourceRadius - radiusMap[edge.w];
                    controlPoints === null || controlPoints === void 0 ? void 0 : controlPoints.forEach((point) => {
                        // 根据该边的起点、终点半径，及起点、终点、控制点位置关系，确定该控制点的半径
                        const cRadius = ((point[otherDim] - sourceOtherDimValue) / otherDimDist) *
                            radiusDist +
                            sourceRadius;
                        // 获取变形为 radial 后的直角坐标系坐标
                        const newPos = getRadialPos(point[dim], range, rangeLength, cRadius);
                        newControlPoints.push({
                            x: newPos.x + dBegin[0],
                            y: newPos.y + dBegin[1],
                        });
                    });
                    edges[i].controlPoints = newControlPoints;
                }
            });
        }
        else {
            const layerCoords = new Set();
            const isInvert = rankdir === 'BT' || rankdir === 'RL';
            const layerCoordSort = isInvert
                ? (a, b) => b - a
                : (a, b) => a - b;
            g.nodes().forEach((node) => {
                const coord = g.node(node);
                if (!coord)
                    return;
                let ndata = this.nodeMap[node];
                if (!ndata) {
                    ndata = combos === null || combos === void 0 ? void 0 : combos.find((it) => it.id === node);
                }
                if (!ndata)
                    return;
                ndata.x = coord.x + dBegin[0];
                ndata.y = coord.y + dBegin[1];
                // @ts-ignore: pass layer order to data for increment layout use
                ndata._order = coord._order;
                layerCoords.add(isHorizontal ? ndata.x : ndata.y);
            });
            const layerCoordsArr = Array.from(layerCoords).sort(layerCoordSort);
            // pre-define the isHorizontal related functions to avoid redundant calc in interations
            const isDifferentLayer = isHorizontal
                ? (point1, point2) => point1.x !== point2.x
                : (point1, point2) => point1.y !== point2.y;
            const filterControlPointsOutOfBoundary = isHorizontal
                ? (ps, point1, point2) => {
                    const max = Math.max(point1.y, point2.y);
                    const min = Math.min(point1.y, point2.y);
                    return ps.filter((point) => point.y <= max && point.y >= min);
                }
                : (ps, point1, point2) => {
                    const max = Math.max(point1.x, point2.x);
                    const min = Math.min(point1.x, point2.x);
                    return ps.filter((point) => point.x <= max && point.x >= min);
                };
            g.edges().forEach((edge) => {
                var _a;
                const coord = g.edge(edge);
                const i = edges.findIndex((it) => {
                    const source = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getEdgeTerminal)(it, 'source');
                    const target = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getEdgeTerminal)(it, 'target');
                    return source === edge.v && target === edge.w;
                });
                if (i <= -1)
                    return;
                if (self.edgeLabelSpace &&
                    self.controlPoints &&
                    edges[i].type !== 'loop') {
                    (_a = coord === null || coord === void 0 ? void 0 : coord.points) === null || _a === void 0 ? void 0 : _a.forEach((point) => {
                        point.x += dBegin[0];
                        point.y += dBegin[1];
                    });
                    const sourceNode = self.nodeMap[edge.v];
                    const targetNode = self.nodeMap[edge.w];
                    edges[i].controlPoints = getControlPoints(coord === null || coord === void 0 ? void 0 : coord.points, sourceNode, targetNode, layerCoordsArr, isHorizontal, isDifferentLayer, filterControlPointsOutOfBoundary);
                }
            });
        }
        if (self.onLayoutEnd)
            self.onLayoutEnd();
        return {
            nodes,
            edges,
        };
    }
    getRadialPos(dimValue, range, rangeLength, radius, arcRange = [0, 1]) {
        // dimRatio 占圆弧的比例
        let dimRatio = (dimValue - range[0]) / rangeLength;
        // 再进一步归一化到指定的范围上
        dimRatio = dimRatio * (arcRange[1] - arcRange[0]) + arcRange[0];
        // 使用最终归一化后的范围计算角度
        const angle = dimRatio * 2 * Math.PI; // 弧度
        // 将极坐标系转换为直角坐标系
        return {
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius,
        };
    }
    getType() {
        return 'dagre';
    }
}
/**
 * Format controlPoints to avoid polylines crossing nodes
 * @param points
 * @param sourceNode
 * @param targetNode
 * @param layerCoordsArr
 * @param isHorizontal
 * @returns
 */
const getControlPoints = (points, sourceNode, targetNode, layerCoordsArr, isHorizontal, isDifferentLayer, filterControlPointsOutOfBoundary) => {
    let controlPoints = (points === null || points === void 0 ? void 0 : points.slice(1, points.length - 1)) || []; // 去掉头尾
    // 酌情增加控制点，使折线不穿过跨层的节点
    if (sourceNode && targetNode) {
        let { x: sourceX, y: sourceY } = sourceNode;
        let { x: targetX, y: targetY } = targetNode;
        if (isHorizontal) {
            sourceX = sourceNode.y;
            sourceY = sourceNode.x;
            targetX = targetNode.y;
            targetY = targetNode.x;
        }
        // 为跨层级的边增加第一个控制点。忽略垂直的/横向的边。
        // 新控制点 = {
        //   x: 终点x,
        //   y: (起点y + 下一层y) / 2,   #下一层y可能不等于终点y
        // }
        if (targetY !== sourceY && sourceX !== targetX) {
            const sourceLayer = layerCoordsArr.indexOf(sourceY);
            const sourceNextLayerCoord = layerCoordsArr[sourceLayer + 1];
            if (sourceNextLayerCoord) {
                const firstControlPoint = controlPoints[0];
                const insertStartControlPoint = isHorizontal
                    ? {
                        x: (sourceY + sourceNextLayerCoord) / 2,
                        y: (firstControlPoint === null || firstControlPoint === void 0 ? void 0 : firstControlPoint.y) || targetX,
                    }
                    : {
                        x: (firstControlPoint === null || firstControlPoint === void 0 ? void 0 : firstControlPoint.x) || targetX,
                        y: (sourceY + sourceNextLayerCoord) / 2,
                    };
                // 当新增的控制点不存在（!=当前第一个控制点）时添加
                if (!firstControlPoint ||
                    isDifferentLayer(firstControlPoint, insertStartControlPoint)) {
                    controlPoints.unshift(insertStartControlPoint);
                }
            }
            const targetLayer = layerCoordsArr.indexOf(targetY);
            const layerDiff = Math.abs(targetLayer - sourceLayer);
            if (layerDiff === 1) {
                controlPoints = filterControlPointsOutOfBoundary(controlPoints, sourceNode, targetNode);
                // one controlPoint at least
                if (!controlPoints.length) {
                    controlPoints.push(isHorizontal
                        ? {
                            x: (sourceY + targetY) / 2,
                            y: sourceX,
                        }
                        : {
                            x: sourceX,
                            y: (sourceY + targetY) / 2,
                        });
                }
            }
            else if (layerDiff > 1) {
                const targetLastLayerCoord = layerCoordsArr[targetLayer - 1];
                if (targetLastLayerCoord) {
                    const lastControlPoints = controlPoints[controlPoints.length - 1];
                    const insertEndControlPoint = isHorizontal
                        ? {
                            x: (targetY + targetLastLayerCoord) / 2,
                            y: (lastControlPoints === null || lastControlPoints === void 0 ? void 0 : lastControlPoints.y) || targetX,
                        }
                        : {
                            x: (lastControlPoints === null || lastControlPoints === void 0 ? void 0 : lastControlPoints.x) || sourceX,
                            y: (targetY + targetLastLayerCoord) / 2,
                        };
                    // 当新增的控制点不存在（!=当前最后一个控制点）时添加
                    if (!lastControlPoints ||
                        isDifferentLayer(lastControlPoints, insertEndControlPoint)) {
                        controlPoints.push(insertEndControlPoint);
                    }
                }
            }
        }
    }
    return controlPoints;
};
//# sourceMappingURL=dagre.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/dagreCompound.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/dagreCompound.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DagreCompoundLayout: () => (/* binding */ DagreCompoundLayout)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./node_modules/@antv/layout/es/layout/base.js");
/* harmony import */ var dagre_compound__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dagre-compound */ "./node_modules/dagre-compound/dist/dagre-compound.es5.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/layout/es/util/index.js");



class DagreCompoundLayout extends _base__WEBPACK_IMPORTED_MODULE_0__.Base {
    constructor(options) {
        super();
        /** layout 方向, 可选 TB, BT, LR, RL */
        this.rankdir = 'TB';
        /** 节点水平间距(px) */
        this.nodesep = 50;
        /** 边水平间距(px) */
        this.edgesep = 5;
        /** 每一层节点之间间距 */
        this.ranksep = 50;
        /** 是否保留布局连线的控制点 */
        this.controlPoints = true;
        /** 是否保留使用布局计算的锚点 */
        this.anchorPoint = true;
        this.nodes = [];
        this.edges = [];
        this.combos = [];
        /** 迭代结束的回调函数 */
        this.onLayoutEnd = () => { };
        this.updateCfg(options);
    }
    getDefaultCfg() {
        return {
            rankdir: 'TB',
            align: undefined,
            begin: undefined,
            nodeSize: undefined,
            nodesep: 50,
            ranksep: 50,
            controlPoints: true,
            anchorPoint: true // 是否使用布局计算的锚点
        };
    }
    init(data) {
        const hiddenNodes = data.hiddenNodes || []; // 被隐藏的节点
        const hiddenEdges = data.hiddenEdges || []; // 被隐藏的边
        const hiddenCombos = data.hiddenCombos || []; // 赋值 hiddenCombos
        // 确保此次排序按照用户输入顺序
        this.nodes = this.getDataByOrder((data.nodes || []).concat(hiddenNodes));
        this.edges = this.getDataByOrder((data.edges || []).concat(hiddenEdges));
        this.combos = (data.combos || []).concat(hiddenCombos.map((hc) => (Object.assign(Object.assign({}, hc), { collapsed: true }))));
    }
    execute() {
        const self = this;
        const { nodes, edges } = self;
        if (!nodes)
            return;
        const { graphDef, graphOption, graphSettings } = self.getLayoutConfig();
        const renderInfo = (0,dagre_compound__WEBPACK_IMPORTED_MODULE_1__.buildGraph)(graphDef, graphOption, graphSettings);
        const flattenedRenderInfo = (0,dagre_compound__WEBPACK_IMPORTED_MODULE_1__.flatGraph)(renderInfo, true); // 打平数据进行遍历
        this.updatePosition(flattenedRenderInfo);
        if (self.onLayoutEnd)
            self.onLayoutEnd();
        return {
            nodes,
            edges
        };
    }
    /**
     * combo 模式下查找节点完整路径
     * @param nodeId
     * @private
     */
    getNodePath(nodeId) {
        const self = this;
        const { nodes, combos } = self;
        const targetNode = nodes.find((n) => n.id === nodeId);
        const findPath = (comboId, fullPath = []) => {
            const combo = combos.find((c) => c.id === comboId);
            if (combo) {
                fullPath.unshift(comboId);
                if (combo.parentId) {
                    return findPath(combo.parentId, fullPath);
                }
                return fullPath;
            }
            return fullPath;
        };
        if (targetNode && targetNode.comboId) {
            return findPath(targetNode.comboId, [nodeId]);
        }
        return [nodeId];
    }
    /** 准备 dagre-compound 布局参数 */
    getLayoutConfig() {
        var _a, _b, _c;
        const self = this;
        const { nodes, edges, combos, nodeSize, rankdir, align, edgesep, nodesep, ranksep, settings } = self;
        const compound = (combos || []).reduce((pre, cur) => {
            const matchedNodes = nodes.filter((n) => n.comboId === cur.id).map((n) => n.id);
            const matchedCombos = (combos || []).filter((n) => n.parentId === cur.id).map((n) => n.id);
            if (matchedNodes.length || matchedCombos.length) {
                pre[cur.id] = [...matchedNodes, ...matchedCombos];
            }
            return pre;
        }, {});
        /** 计算 nodeSize */
        let nodeSizeFunc;
        if (!nodeSize) {
            nodeSizeFunc = (d) => {
                if (d && d.size) {
                    if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(d.size)) {
                        return d.size;
                    }
                    if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isObject)(d.size)) {
                        return [d.size.width || 40, d.size.height || 40];
                    }
                    return [d.size, d.size];
                }
                return [40, 40];
            };
        }
        else if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(nodeSize)) {
            nodeSizeFunc = () => nodeSize;
        }
        else {
            nodeSizeFunc = () => [nodeSize, nodeSize];
        }
        /** 计算 comboSize */
        const comboSizeFunc = (d) => {
            if (d && d.size) {
                if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(d.size)) {
                    return d.size;
                }
                return [d.size, d.size];
            }
            return [80, 40];
        };
        // 接受 defaultCombo 设置的 size
        const [metaWidth, metaHeight] = comboSizeFunc(combos === null || combos === void 0 ? void 0 : combos[0]);
        // 初始化 padding
        const subSceneMeta = (_b = (_a = self.graphSettings) === null || _a === void 0 ? void 0 : _a.subScene) === null || _b === void 0 ? void 0 : _b.meta;
        const [paddingTop, paddingRight, paddingBottom, paddingLeft] = ((_c = combos.find((c) => !c.collapsed)) === null || _c === void 0 ? void 0 : _c.padding) || [20, 20, 20, 20];
        const graphDef = {
            compound,
            nodes: [
                ...(nodes || []).map((n) => {
                    const size = nodeSizeFunc(n);
                    const width = size[0];
                    const height = size[1];
                    return Object.assign(Object.assign({}, n), { width, height });
                })
            ],
            edges: [...(edges || []).map((e) => (Object.assign(Object.assign({}, e), { v: e.source, w: e.target })))]
        };
        // 需要展开的节点
        const graphOption = {
            expanded: (combos || []).filter((c) => !c.collapsed).map((c) => c.id)
        };
        // dagre-compound 布局参数
        const graphMetaConfig = {
            graph: {
                meta: {
                    align,
                    rankDir: rankdir,
                    nodeSep: nodesep,
                    edgeSep: edgesep,
                    rankSep: ranksep
                }
            },
            subScene: {
                meta: {
                    paddingTop: paddingTop || (subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingTop) || 20,
                    paddingRight: paddingRight || (subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingRight) || 20,
                    paddingBottom: paddingBottom || (subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingBottom) || 20,
                    paddingLeft: paddingLeft || (subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingLeft) || 20,
                    labelHeight: 0
                }
            },
            nodeSize: {
                meta: {
                    width: metaWidth,
                    height: metaHeight
                }
            }
        };
        // 合并用户输入的内容
        const graphSettings = (0,dagre_compound__WEBPACK_IMPORTED_MODULE_1__.mergeConfig)(settings, Object.assign({}, (0,dagre_compound__WEBPACK_IMPORTED_MODULE_1__.mergeConfig)(graphMetaConfig, dagre_compound__WEBPACK_IMPORTED_MODULE_1__.LAYOUT_CONFIG)));
        self.graphSettings = graphSettings;
        return {
            graphDef,
            graphOption,
            graphSettings
        };
    }
    /** 更新节点与边位置 */
    updatePosition(flattenedGraph) {
        const { nodes, edges } = flattenedGraph;
        this.updateNodePosition(nodes, edges);
        this.updateEdgePosition(nodes, edges);
    }
    getBegin(flattenedNodes, flattenedEdges) {
        const self = this;
        const { begin } = self;
        const dBegin = [0, 0];
        if (begin) {
            let minX = Infinity;
            let minY = Infinity;
            flattenedNodes.forEach((node) => {
                if (minX > node.x)
                    minX = node.x;
                if (minY > node.y)
                    minY = node.y;
            });
            flattenedEdges.forEach((edge) => {
                edge.points.forEach((point) => {
                    if (minX > point.x)
                        minX = point.x;
                    if (minY > point.y)
                        minY = point.y;
                });
            });
            dBegin[0] = begin[0] - minX;
            dBegin[1] = begin[1] - minY;
        }
        return dBegin;
    }
    updateNodePosition(flattenedNodes, flattenedEdges) {
        const self = this;
        const { combos, nodes, edges, anchorPoint, graphSettings } = self;
        const dBegin = this.getBegin(flattenedNodes, flattenedEdges);
        flattenedNodes.forEach((node) => {
            var _a;
            const { x, y, id, type, coreBox } = node;
            if (type === dagre_compound__WEBPACK_IMPORTED_MODULE_1__.HierarchyNodeType.META && id !== dagre_compound__WEBPACK_IMPORTED_MODULE_1__.ROOT_NAME) {
                const i = combos.findIndex((item) => item.id === id);
                const subSceneMeta = (_a = graphSettings === null || graphSettings === void 0 ? void 0 : graphSettings.subScene) === null || _a === void 0 ? void 0 : _a.meta;
                // 将布局生成的 combo 位置暂存至 offsetX offsetY
                combos[i].offsetX = x + dBegin[0];
                combos[i].offsetY = y + dBegin[1];
                combos[i].fixSize = [coreBox.width, coreBox.height];
                combos[i].fixCollapseSize = [coreBox.width, coreBox.height];
                // 如果设置了收起时隐藏 padding，则手动优化 combo padding 信息，展开的话则恢复
                if (!node.expanded) {
                    combos[i].padding = [0, 0, 0, 0];
                }
                else {
                    combos[i].padding = [
                        subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingTop,
                        subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingRight,
                        subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingBottom,
                        subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingLeft
                    ];
                }
            }
            else if (type === dagre_compound__WEBPACK_IMPORTED_MODULE_1__.HierarchyNodeType.OP) {
                const i = nodes.findIndex((item) => item.id === id);
                nodes[i].x = x + dBegin[0];
                nodes[i].y = y + dBegin[1];
                if (anchorPoint) {
                    const anchorPoints = [];
                    const outEdges = flattenedEdges.filter((e) => e.v === id);
                    const inEdges = flattenedEdges.filter((e) => e.w === id);
                    // 指定出边锚点，锚点中心点为 [0.5, 0.5]
                    if (outEdges.length > 0) {
                        outEdges.forEach((outEdge) => {
                            const firstPoint = outEdge.points[0];
                            const anchorPointX = (firstPoint.x - x) / node.width + 0.5;
                            const anchorPointY = (firstPoint.y - y) / node.height + 0.5;
                            anchorPoints.push([anchorPointX, anchorPointY]);
                            // 出边对应 source 边锚点
                            outEdge.baseEdgeList.forEach((baseEdge) => {
                                const edge = edges.find((e) => e.source === baseEdge.v && e.target === baseEdge.w);
                                if (edge) {
                                    edge.sourceAnchor = anchorPoints.length - 1;
                                }
                            });
                        });
                    }
                    // 指定入边锚点
                    if (inEdges.length > 0) {
                        inEdges.forEach((inEdge) => {
                            const lastPoint = inEdge.points[inEdge.points.length - 1];
                            const anchorPointX = (lastPoint.x - x) / node.width + 0.5;
                            const anchorPointY = (lastPoint.y - y) / node.height + 0.5;
                            anchorPoints.push([anchorPointX, anchorPointY]);
                            // 出边对应 source 锚点
                            inEdge.baseEdgeList.forEach((baseEdge) => {
                                const edge = edges.find((e) => e.source === baseEdge.v && e.target === baseEdge.w);
                                if (edge) {
                                    edge.targetAnchor = anchorPoints.length - 1;
                                }
                            });
                        });
                    }
                    nodes[i].anchorPoints = anchorPoints.length > 0 ? anchorPoints : nodes[i].anchorPoints || [];
                }
            }
        });
    }
    updateEdgePosition(flattenedNodes, flattenedEdges) {
        const self = this;
        const { combos, edges, controlPoints } = self;
        const dBegin = this.getBegin(flattenedNodes, flattenedEdges);
        if (controlPoints) {
            combos.forEach((combo) => {
                combo.inEdges = [];
                combo.outEdges = [];
            });
            edges.forEach((sourceEdge) => {
                var _a, _b, _c, _d;
                let sourceNode = flattenedNodes.find((v) => v.id === sourceEdge.source);
                let targetNode = flattenedNodes.find((v) => v.id === sourceEdge.target);
                // Combo 收起状态，dagre-compound 不会渲染该节点，边需要使用到 group 的边作为补充
                let points = [];
                let sortedEdges = [];
                if (sourceNode && targetNode) {
                    sortedEdges = (0,dagre_compound__WEBPACK_IMPORTED_MODULE_1__.getEdges)(sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.id, targetNode === null || targetNode === void 0 ? void 0 : targetNode.id, flattenedNodes);
                }
                else if (!sourceNode || !targetNode) {
                    /** 存在收起节点时，需要重新计算边的 controlPoints，确保线正常 */
                    // 情况1：目标节点被收起了，向上寻找该节点最近一个存在的父节点
                    const sourceNodePath = self.getNodePath(sourceEdge.source);
                    const targetNodePath = self.getNodePath(sourceEdge.target);
                    const lastExistingSource = sourceNodePath
                        .reverse()
                        .slice(!sourceNode ? 1 : 0)
                        .find((parentId) => flattenedNodes.find((fNode) => fNode.id === parentId));
                    const lastExistingTarget = targetNodePath
                        .reverse()
                        .slice(!targetNode ? 1 : 0)
                        .find((parentId) => flattenedNodes.find((fNode) => fNode.id === parentId));
                    sourceNode = flattenedNodes.find((v) => v.id === lastExistingSource);
                    targetNode = flattenedNodes.find((v) => v.id === lastExistingTarget);
                    sortedEdges = (0,dagre_compound__WEBPACK_IMPORTED_MODULE_1__.getEdges)(sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.id, targetNode === null || targetNode === void 0 ? void 0 : targetNode.id, flattenedNodes, { v: sourceEdge.source, w: sourceEdge.target });
                }
                points = sortedEdges.reduce((pre, cur) => {
                    return [
                        ...pre,
                        ...cur.points.map((p) => {
                            return Object.assign(Object.assign({}, p), { x: p.x + dBegin[0], y: p.y + dBegin[1] });
                        })
                    ];
                }, []);
                // 取消首尾节点
                points = points.slice(1, -1);
                sourceEdge.controlPoints = points;
                if ((targetNode === null || targetNode === void 0 ? void 0 : targetNode.type) === dagre_compound__WEBPACK_IMPORTED_MODULE_1__.NodeType.META) {
                    // combo 节点控制点
                    const i = combos.findIndex((item) => item.id === (targetNode === null || targetNode === void 0 ? void 0 : targetNode.id));
                    if (!combos[i] || ((_a = combos[i].inEdges) === null || _a === void 0 ? void 0 : _a.some((inEdge) => inEdge.source === sourceNode.id && inEdge.target === targetNode.id))) {
                        return;
                    }
                    (_b = combos[i].inEdges) === null || _b === void 0 ? void 0 : _b.push({
                        source: sourceNode.id,
                        target: targetNode.id,
                        controlPoints: points
                    });
                }
                if ((sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.type) === dagre_compound__WEBPACK_IMPORTED_MODULE_1__.NodeType.META) {
                    const i = combos.findIndex((item) => item.id === (sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.id));
                    if (!combos[i] || ((_c = combos[i].outEdges) === null || _c === void 0 ? void 0 : _c.some((oedge) => oedge.source === sourceNode.id && oedge.target === targetNode.id))) {
                        return;
                    }
                    (_d = combos[i].outEdges) === null || _d === void 0 ? void 0 : _d.push({
                        source: sourceNode.id,
                        target: targetNode.id,
                        controlPoints: points
                    });
                }
            });
        }
    }
    getType() {
        return 'dagreCompound';
    }
    /**
     * 确保布局使用的数据与用户输入数据顺序一致
     * 通过 layoutOrder 排序 节点 与 边
     * @param list
     * @private
     */
    getDataByOrder(list) {
        if (list.every((n) => n.layoutOrder !== undefined)) {
            // 所有数据均设置过索引，表示仅布局，数据未变化，无需处理
        }
        else {
            // 首次布局或动态添加删减节点时重新赋值
            list.forEach((n, i) => {
                n.layoutOrder = i;
            });
        }
        // 按照 layoutOrder 排序
        return list.sort((pre, cur) => pre.layoutOrder - cur.layoutOrder);
    }
}
//# sourceMappingURL=dagreCompound.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/dagre/graph.js":
/*!************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/dagre/graph.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Graph: () => (/* binding */ Graph)
/* harmony export */ });
/* harmony import */ var _antv_graphlib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/graphlib */ "./node_modules/@antv/graphlib/es/index.js");

class Graph extends _antv_graphlib__WEBPACK_IMPORTED_MODULE_0__.Graph {
}
//# sourceMappingURL=graph.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/dagre/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/dagre/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/layout */ "./node_modules/@antv/layout/es/layout/dagre/src/layout.js");
/* harmony import */ var _src_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/util */ "./node_modules/@antv/layout/es/layout/dagre/src/util.js");
/*
Copyright (c) 2012-2014 Chris Pettitt

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    layout: _src_layout__WEBPACK_IMPORTED_MODULE_0__["default"],
    util: {
        time: _src_util__WEBPACK_IMPORTED_MODULE_1__.time,
        notime: _src_util__WEBPACK_IMPORTED_MODULE_1__.notime
    },
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/dagre/src/acyclic.js":
/*!******************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/dagre/src/acyclic.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _greedy_fas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./greedy-fas */ "./node_modules/@antv/layout/es/layout/dagre/src/greedy-fas.js");

const run = (g) => {
    const weightFn = (g) => {
        return (e) => { var _a; return ((_a = g.edge(e)) === null || _a === void 0 ? void 0 : _a.weight) || 1; };
    };
    const fas = g.graph().acyclicer === "greedy" ? (0,_greedy_fas__WEBPACK_IMPORTED_MODULE_0__["default"])(g, weightFn(g)) : dfsFAS(g);
    fas === null || fas === void 0 ? void 0 : fas.forEach((e) => {
        const label = g.edge(e);
        g.removeEdgeObj(e);
        label.forwardName = e.name;
        label.reversed = true;
        g.setEdge(e.w, e.v, label, `rev-${Math.random()}`);
    });
};
const dfsFAS = (g) => {
    const fas = [];
    const stack = {};
    const visited = {};
    const dfs = (v) => {
        var _a;
        if (visited[v]) {
            return;
        }
        visited[v] = true;
        stack[v] = true;
        (_a = g.outEdges(v)) === null || _a === void 0 ? void 0 : _a.forEach((e) => {
            if (stack[e.w]) {
                fas.push(e);
            }
            else {
                dfs(e.w);
            }
        });
        delete stack[v];
    };
    g.nodes().forEach(dfs);
    return fas;
};
const undo = (g) => {
    g.edges().forEach((e) => {
        const label = g.edge(e);
        if (label.reversed) {
            g.removeEdgeObj(e);
            const forwardName = label.forwardName;
            delete label.reversed;
            delete label.forwardName;
            g.setEdge(e.w, e.v, label, forwardName);
        }
    });
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({ run, undo });
//# sourceMappingURL=acyclic.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/dagre/src/add-border-segments.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/dagre/src/add-border-segments.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/layout/es/layout/dagre/src/util.js");

const addBorderSegments = (g) => {
    var _a;
    const dfs = (v) => {
        const children = g.children(v);
        const node = g.node(v);
        if (children === null || children === void 0 ? void 0 : children.length) {
            children.forEach((child) => dfs(child));
        }
        if (node.hasOwnProperty("minRank")) {
            node.borderLeft = [];
            node.borderRight = [];
            for (let rank = node.minRank, maxRank = node.maxRank + 1; rank < maxRank; rank += 1) {
                addBorderNode(g, "borderLeft", "_bl", v, node, rank);
                addBorderNode(g, "borderRight", "_br", v, node, rank);
            }
        }
    };
    (_a = g.children()) === null || _a === void 0 ? void 0 : _a.forEach((child) => dfs(child));
};
const addBorderNode = (g, prop, prefix, sg, sgNode, rank) => {
    const label = { rank, borderType: prop, width: 0, height: 0 };
    const prev = sgNode[prop][rank - 1];
    const curr = (0,_util__WEBPACK_IMPORTED_MODULE_0__.addDummyNode)(g, "border", label, prefix);
    sgNode[prop][rank] = curr;
    g.setParent(curr, sg);
    if (prev) {
        g.setEdge(prev, curr, { weight: 1 });
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (addBorderSegments);
//# sourceMappingURL=add-border-segments.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/dagre/src/coordinate-system.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/dagre/src/coordinate-system.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const adjust = (g) => {
    var _a;
    const rankDir = (_a = g.graph().rankdir) === null || _a === void 0 ? void 0 : _a.toLowerCase();
    if (rankDir === "lr" || rankDir === "rl") {
        swapWidthHeight(g);
    }
};
const undo = (g) => {
    var _a;
    const rankDir = (_a = g.graph().rankdir) === null || _a === void 0 ? void 0 : _a.toLowerCase();
    if (rankDir === "bt" || rankDir === "rl") {
        reverseY(g);
    }
    if (rankDir === "lr" || rankDir === "rl") {
        swapXY(g);
        swapWidthHeight(g);
    }
};
const swapWidthHeight = (g) => {
    g.nodes().forEach((v) => {
        swapWidthHeightOne(g.node(v));
    });
    g.edges().forEach((e) => {
        swapWidthHeightOne(g.edge(e));
    });
};
const swapWidthHeightOne = (attrs) => {
    const w = attrs.width;
    attrs.width = attrs.height;
    attrs.height = w;
};
const reverseY = (g) => {
    g.nodes().forEach((v) => {
        reverseYOne(g.node(v));
    });
    g.edges().forEach((e) => {
        var _a;
        const edge = g.edge(e);
        (_a = edge.points) === null || _a === void 0 ? void 0 : _a.forEach((point) => reverseYOne(point));
        if (edge.hasOwnProperty("y")) {
            reverseYOne(edge);
        }
    });
};
const reverseYOne = (attrs) => {
    if (attrs === null || attrs === void 0 ? void 0 : attrs.y) {
        attrs.y = -attrs.y;
    }
};
const swapXY = (g) => {
    g.nodes().forEach((v) => {
        swapXYOne(g.node(v));
    });
    g.edges().forEach((e) => {
        var _a;
        const edge = g.edge(e);
        (_a = edge.points) === null || _a === void 0 ? void 0 : _a.forEach((point) => swapXYOne(point));
        if (edge.hasOwnProperty("x")) {
            swapXYOne(edge);
        }
    });
};
const swapXYOne = (attrs) => {
    const x = attrs.x;
    attrs.x = attrs.y;
    attrs.y = x;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({ adjust, undo });
//# sourceMappingURL=coordinate-system.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/dagre/src/data/list.js":
/*!********************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/dagre/src/data/list.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ List)
/* harmony export */ });
const filterOutLinks = (k, v) => {
    if (k !== "next" && k !== "prev") {
        return v;
    }
};
const unlink = (entry) => {
    entry.prev.next = entry.next;
    entry.next.prev = entry.prev;
    delete entry.next;
    delete entry.prev;
};
class List {
    constructor() {
        const shortcut = {};
        shortcut.prev = shortcut;
        shortcut.next = shortcut.prev;
        this.shortcut = shortcut;
    }
    dequeue() {
        const shortcut = this.shortcut;
        const entry = shortcut.prev;
        if (entry && entry !== shortcut) {
            unlink(entry);
            return entry;
        }
    }
    enqueue(entry) {
        const shortcut = this.shortcut;
        if (entry.prev && entry.next) {
            unlink(entry);
        }
        entry.next = shortcut.next;
        shortcut.next.prev = entry;
        shortcut.next = entry;
        entry.prev = shortcut;
    }
    toString() {
        const strs = [];
        const sentinel = this.shortcut;
        let curr = sentinel.prev;
        while (curr !== sentinel) {
            strs.push(JSON.stringify(curr, filterOutLinks));
            curr = curr === null || curr === void 0 ? void 0 : curr.prev;
        }
        return `[${strs.join(", ")}]`;
    }
}
//# sourceMappingURL=list.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/dagre/src/greedy-fas.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/dagre/src/greedy-fas.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _data_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data/list */ "./node_modules/@antv/layout/es/layout/dagre/src/data/list.js");
/* harmony import */ var _antv_graphlib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/graphlib */ "./node_modules/@antv/graphlib/es/index.js");


class List extends _data_list__WEBPACK_IMPORTED_MODULE_0__["default"] {
}
class StateGraph extends _antv_graphlib__WEBPACK_IMPORTED_MODULE_1__.Graph {
}
/*
 * A greedy heuristic for finding a feedback arc set for a graph. A feedback
 * arc set is a set of edges that can be removed to make a graph acyclic.
 * The algorithm comes from: P. Eades, X. Lin, and W. F. Smyth, "A fast and
 * effective heuristic for the feedback arc set problem." This implementation
 * adjusts that from the paper to allow for weighted edges.
 */
const DEFAULT_WEIGHT_FN = () => 1;
const greedyFAS = (g, weightFn) => {
    var _a;
    if (g.nodeCount() <= 1)
        return [];
    const state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);
    const results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);
    return (_a = results.map((e) => g.outEdges(e.v, e.w))) === null || _a === void 0 ? void 0 : _a.flat();
};
const doGreedyFAS = (g, buckets, zeroIdx) => {
    let results = [];
    const sources = buckets[buckets.length - 1];
    const sinks = buckets[0];
    let entry;
    while (g.nodeCount()) {
        while ((entry = sinks.dequeue())) {
            removeNode(g, buckets, zeroIdx, entry);
        }
        while ((entry = sources.dequeue())) {
            removeNode(g, buckets, zeroIdx, entry);
        }
        if (g.nodeCount()) {
            for (let i = buckets.length - 2; i > 0; --i) {
                entry = buckets[i].dequeue();
                if (entry) {
                    results = results.concat(removeNode(g, buckets, zeroIdx, entry, true));
                    break;
                }
            }
        }
    }
    return results;
};
const removeNode = (g, buckets, zeroIdx, entry, collectPredecessors) => {
    var _a, _b;
    const results = [];
    (_a = g.inEdges(entry.v)) === null || _a === void 0 ? void 0 : _a.forEach((edge) => {
        const weight = g.edge(edge);
        const uEntry = g.node(edge.v);
        if (collectPredecessors) {
            // this result not really care about in or out
            results.push({ v: edge.v, w: edge.w, in: 0, out: 0 });
        }
        if (uEntry.out === undefined)
            uEntry.out = 0;
        uEntry.out -= weight;
        assignBucket(buckets, zeroIdx, uEntry);
    });
    (_b = g.outEdges(entry.v)) === null || _b === void 0 ? void 0 : _b.forEach((edge) => {
        const weight = g.edge(edge);
        const w = edge.w;
        const wEntry = g.node(w);
        if (wEntry.in === undefined)
            wEntry.in = 0;
        wEntry.in -= weight;
        assignBucket(buckets, zeroIdx, wEntry);
    });
    g.removeNode(entry.v);
    return collectPredecessors ? results : undefined;
};
const buildState = (g, weightFn) => {
    const fasGraph = new StateGraph();
    let maxIn = 0;
    let maxOut = 0;
    g.nodes().forEach((v) => {
        fasGraph.setNode(v, { v, in: 0, out: 0 });
    });
    // Aggregate weights on nodes, but also sum the weights across multi-edges
    // into a single edge for the fasGraph.
    g.edges().forEach((e) => {
        const prevWeight = fasGraph.edge(e) || 0;
        const weight = (weightFn === null || weightFn === void 0 ? void 0 : weightFn(e)) || 1;
        const edgeWeight = prevWeight + weight;
        fasGraph.setEdge(e.v, e.w, edgeWeight);
        maxOut = Math.max(maxOut, (fasGraph.node(e.v).out += weight));
        maxIn = Math.max(maxIn, (fasGraph.node(e.w).in += weight));
    });
    const buckets = [];
    const rangeMax = maxOut + maxIn + 3;
    for (let i = 0; i < rangeMax; i++) {
        buckets.push(new List());
    }
    const zeroIdx = maxIn + 1;
    fasGraph.nodes().forEach((v) => {
        assignBucket(buckets, zeroIdx, fasGraph.node(v));
    });
    return { buckets, zeroIdx, graph: fasGraph };
};
const assignBucket = (buckets, zeroIdx, entry) => {
    if (!entry.out) {
        buckets[0].enqueue(entry);
    }
    else if (!entry["in"]) {
        buckets[buckets.length - 1].enqueue(entry);
    }
    else {
        buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (greedyFAS);
//# sourceMappingURL=greedy-fas.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/dagre/src/layout.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/dagre/src/layout.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _acyclic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./acyclic */ "./node_modules/@antv/layout/es/layout/dagre/src/acyclic.js");
/* harmony import */ var _normalize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./normalize */ "./node_modules/@antv/layout/es/layout/dagre/src/normalize.js");
/* harmony import */ var _rank__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rank */ "./node_modules/@antv/layout/es/layout/dagre/src/rank/index.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/layout/es/layout/dagre/src/util.js");
/* harmony import */ var _parent_dummy_chains__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./parent-dummy-chains */ "./node_modules/@antv/layout/es/layout/dagre/src/parent-dummy-chains.js");
/* harmony import */ var _nesting_graph__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./nesting-graph */ "./node_modules/@antv/layout/es/layout/dagre/src/nesting-graph.js");
/* harmony import */ var _add_border_segments__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./add-border-segments */ "./node_modules/@antv/layout/es/layout/dagre/src/add-border-segments.js");
/* harmony import */ var _coordinate_system__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./coordinate-system */ "./node_modules/@antv/layout/es/layout/dagre/src/coordinate-system.js");
/* harmony import */ var _order__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./order */ "./node_modules/@antv/layout/es/layout/dagre/src/order/index.js");
/* harmony import */ var _position__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./position */ "./node_modules/@antv/layout/es/layout/dagre/src/position/index.js");
/* harmony import */ var _order_init_data_order__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./order/init-data-order */ "./node_modules/@antv/layout/es/layout/dagre/src/order/init-data-order.js");
/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../graph */ "./node_modules/@antv/layout/es/layout/dagre/graph.js");












const layout = (g, opts) => {
    const time = opts && opts.debugTiming ? _util__WEBPACK_IMPORTED_MODULE_3__.time : _util__WEBPACK_IMPORTED_MODULE_3__.notime;
    time("layout", () => {
        // 如果在原图基础上修改，继承原图的order结果
        if (opts && !opts.keepNodeOrder && opts.prevGraph) {
            time("  inheritOrder", () => {
                inheritOrder(g, opts.prevGraph);
            });
        }
        const layoutGraph = time("  buildLayoutGraph", () => {
            return buildLayoutGraph(g);
        });
        // 控制是否为边的label留位置（这会影响是否在边中间添加dummy node）
        if (!(opts && opts.edgeLabelSpace === false)) {
            time("  makeSpaceForEdgeLabels", () => {
                makeSpaceForEdgeLabels(layoutGraph);
            });
        }
        // TODO: 暂时处理层级设置不正确时的异常报错，提示设置正确的层级
        try {
            time("  runLayout", () => {
                runLayout(layoutGraph, time, opts);
            });
        }
        catch (e) {
            if (e.message ===
                "Not possible to find intersection inside of the rectangle") {
                console.error("The following error may be caused by improper layer setting, please make sure your manual layer setting does not violate the graph's structure:\n", e);
                return;
            }
            throw e;
        }
        time("  updateInputGraph", () => {
            updateInputGraph(g, layoutGraph);
        });
    });
};
const runLayout = (g, time, opts) => {
    time("    removeSelfEdges", () => {
        removeSelfEdges(g);
    });
    time("    acyclic", () => {
        _acyclic__WEBPACK_IMPORTED_MODULE_0__["default"].run(g);
    });
    time("    nestingGraph.run", () => {
        _nesting_graph__WEBPACK_IMPORTED_MODULE_5__["default"].run(g);
    });
    time("    rank", () => {
        (0,_rank__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_util__WEBPACK_IMPORTED_MODULE_3__.asNonCompoundGraph)(g));
    });
    time("    injectEdgeLabelProxies", () => {
        injectEdgeLabelProxies(g);
    });
    time("    removeEmptyRanks", () => {
        (0,_util__WEBPACK_IMPORTED_MODULE_3__.removeEmptyRanks)(g);
    });
    time("    nestingGraph.cleanup", () => {
        _nesting_graph__WEBPACK_IMPORTED_MODULE_5__["default"].cleanup(g);
    });
    time("    normalizeRanks", () => {
        (0,_util__WEBPACK_IMPORTED_MODULE_3__.normalizeRanks)(g);
    });
    time("    assignRankMinMax", () => {
        assignRankMinMax(g);
    });
    time("    removeEdgeLabelProxies", () => {
        removeEdgeLabelProxies(g);
    });
    time("    normalize.run", () => {
        _normalize__WEBPACK_IMPORTED_MODULE_1__["default"].run(g);
    });
    time("    parentDummyChains", () => {
        (0,_parent_dummy_chains__WEBPACK_IMPORTED_MODULE_4__["default"])(g);
    });
    time("    addBorderSegments", () => {
        (0,_add_border_segments__WEBPACK_IMPORTED_MODULE_6__["default"])(g);
    });
    if (opts && opts.keepNodeOrder) {
        time("    initDataOrder", () => {
            (0,_order_init_data_order__WEBPACK_IMPORTED_MODULE_10__["default"])(g, opts.nodeOrder);
        });
    }
    time("    order", () => {
        (0,_order__WEBPACK_IMPORTED_MODULE_8__["default"])(g, opts === null || opts === void 0 ? void 0 : opts.keepNodeOrder);
    });
    time("    insertSelfEdges", () => {
        insertSelfEdges(g);
    });
    time("    adjustCoordinateSystem", () => {
        _coordinate_system__WEBPACK_IMPORTED_MODULE_7__["default"].adjust(g);
    });
    time("    position", () => {
        (0,_position__WEBPACK_IMPORTED_MODULE_9__["default"])(g);
    });
    time("    positionSelfEdges", () => {
        positionSelfEdges(g);
    });
    time("    removeBorderNodes", () => {
        removeBorderNodes(g);
    });
    time("    normalize.undo", () => {
        _normalize__WEBPACK_IMPORTED_MODULE_1__["default"].undo(g);
    });
    time("    fixupEdgeLabelCoords", () => {
        fixupEdgeLabelCoords(g);
    });
    time("    undoCoordinateSystem", () => {
        _coordinate_system__WEBPACK_IMPORTED_MODULE_7__["default"].undo(g);
    });
    time("    translateGraph", () => {
        translateGraph(g);
    });
    time("    assignNodeIntersects", () => {
        assignNodeIntersects(g);
    });
    time("    reversePoints", () => {
        reversePointsForReversedEdges(g);
    });
    time("    acyclic.undo", () => {
        _acyclic__WEBPACK_IMPORTED_MODULE_0__["default"].undo(g);
    });
};
/**
 * 继承上一个布局中的order，防止翻转
 * TODO: 暂时没有考虑涉及层级变动的布局，只保证原来布局层级和相对顺序不变
 */
const inheritOrder = (currG, prevG) => {
    currG.nodes().forEach((n) => {
        const node = currG.node(n);
        const prevNode = prevG.node(n);
        if (prevNode !== undefined) {
            node.fixorder = prevNode._order;
            delete prevNode._order;
        }
        else {
            delete node.fixorder;
        }
    });
};
/*
 * Copies final layout information from the layout graph back to the input
 * graph. This process only copies whitelisted attributes from the layout graph
 * to the input graph, so it serves as a good place to determine what
 * attributes can influence layout.
 */
const updateInputGraph = (inputGraph, layoutGraph) => {
    inputGraph.nodes().forEach((v) => {
        var _a;
        const inputLabel = inputGraph.node(v);
        if (inputLabel) {
            const layoutLabel = layoutGraph.node(v);
            inputLabel.x = layoutLabel.x;
            inputLabel.y = layoutLabel.y;
            inputLabel._order = layoutLabel.order;
            inputLabel._rank = layoutLabel.rank;
            if ((_a = layoutGraph.children(v)) === null || _a === void 0 ? void 0 : _a.length) {
                inputLabel.width = layoutLabel.width;
                inputLabel.height = layoutLabel.height;
            }
        }
    });
    inputGraph.edges().forEach((e) => {
        const inputLabel = inputGraph.edge(e);
        const layoutLabel = layoutGraph.edge(e);
        inputLabel.points = layoutLabel ? layoutLabel.points : [];
        if (layoutLabel && layoutLabel.hasOwnProperty("x")) {
            inputLabel.x = layoutLabel.x;
            inputLabel.y = layoutLabel.y;
        }
    });
    inputGraph.graph().width = layoutGraph.graph().width;
    inputGraph.graph().height = layoutGraph.graph().height;
};
const graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"];
const graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" };
const graphAttrs = ["acyclicer", "ranker", "rankdir", "align"];
const nodeNumAttrs = ["width", "height", "layer", "fixorder"]; // 需要传入layer, fixOrder作为参数参考
const nodeDefaults = { width: 0, height: 0 };
const edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"];
const edgeDefaults = {
    minlen: 1,
    weight: 1,
    width: 0,
    height: 0,
    labeloffset: 10,
    labelpos: "r",
};
const edgeAttrs = ["labelpos"];
/*
 * Constructs a new graph from the input graph, which can be used for layout.
 * This process copies only whitelisted attributes from the input graph to the
 * layout graph. Thus this function serves as a good place to determine what
 * attributes can influence layout.
 */
const buildLayoutGraph = (inputGraph) => {
    const g = new _graph__WEBPACK_IMPORTED_MODULE_11__.Graph({ multigraph: true, compound: true });
    const graph = canonicalize(inputGraph.graph());
    const pickedProperties = {};
    graphAttrs === null || graphAttrs === void 0 ? void 0 : graphAttrs.forEach((key) => {
        if (graph[key] !== undefined)
            pickedProperties[key] = graph[key];
    });
    g.setGraph(Object.assign({}, graphDefaults, selectNumberAttrs(graph, graphNumAttrs), pickedProperties));
    inputGraph.nodes().forEach((v) => {
        const node = canonicalize(inputGraph.node(v));
        const defaultNode = Object.assign(Object.assign({}, nodeDefaults), node);
        const defaultAttrs = selectNumberAttrs(defaultNode, nodeNumAttrs);
        g.setNode(v, defaultAttrs);
        g.setParent(v, inputGraph.parent(v));
    });
    inputGraph.edges().forEach((e) => {
        const edge = canonicalize(inputGraph.edge(e));
        const pickedProperties = {};
        edgeAttrs === null || edgeAttrs === void 0 ? void 0 : edgeAttrs.forEach((key) => {
            if (edge[key] !== undefined)
                pickedProperties[key] = edge[key];
        });
        g.setEdgeObj(e, Object.assign({}, edgeDefaults, selectNumberAttrs(edge, edgeNumAttrs), pickedProperties));
    });
    return g;
};
/*
 * This idea comes from the Gansner paper: to account for edge labels in our
 * layout we split each rank in half by doubling minlen and halving ranksep.
 * Then we can place labels at these mid-points between nodes.
 *
 * We also add some minimal padding to the width to push the label for the edge
 * away from the edge itself a bit.
 */
const makeSpaceForEdgeLabels = (g) => {
    const graph = g.graph();
    if (!graph.ranksep)
        graph.ranksep = 0;
    graph.ranksep /= 2;
    g.nodes().forEach((n) => {
        const node = g.node(n);
        if (!isNaN(node.layer)) {
            if (!node.layer)
                node.layer = 0;
        }
    });
    g.edges().forEach((e) => {
        var _a;
        const edge = g.edge(e);
        edge.minlen *= 2;
        if (((_a = edge.labelpos) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== "c") {
            if (graph.rankdir === "TB" || graph.rankdir === "BT") {
                edge.width += edge.labeloffset;
            }
            else {
                edge.height += edge.labeloffset;
            }
        }
    });
};
/*
 * Creates temporary dummy nodes that capture the rank in which each edge's
 * label is going to, if it has one of non-zero width and height. We do this
 * so that we can safely remove empty ranks while preserving balance for the
 * label's position.
 */
const injectEdgeLabelProxies = (g) => {
    g.edges().forEach((e) => {
        const edge = g.edge(e);
        if (edge.width && edge.height) {
            const v = g.node(e.v);
            const w = g.node(e.w);
            const label = {
                e,
                rank: (w.rank - v.rank) / 2 + v.rank,
            };
            (0,_util__WEBPACK_IMPORTED_MODULE_3__.addDummyNode)(g, "edge-proxy", label, "_ep");
        }
    });
};
const assignRankMinMax = (g) => {
    let maxRank = 0;
    g.nodes().forEach((v) => {
        var _a, _b;
        const node = g.node(v);
        if (node.borderTop) {
            node.minRank = (_a = g.node(node.borderTop)) === null || _a === void 0 ? void 0 : _a.rank;
            node.maxRank = (_b = g.node(node.borderBottom)) === null || _b === void 0 ? void 0 : _b.rank;
            maxRank = Math.max(maxRank, node.maxRank || -Infinity);
        }
    });
    g.graph().maxRank = maxRank;
};
const removeEdgeLabelProxies = (g) => {
    g.nodes().forEach((v) => {
        const node = g.node(v);
        if (node.dummy === "edge-proxy") {
            g.edge(node.e).labelRank = node.rank;
            g.removeNode(v);
        }
    });
};
const translateGraph = (g) => {
    let minX;
    let maxX = 0;
    let minY;
    let maxY = 0;
    const graphLabel = g.graph();
    const marginX = graphLabel.marginx || 0;
    const marginY = graphLabel.marginy || 0;
    const getExtremes = (attrs) => {
        if (!attrs)
            return;
        const x = attrs.x;
        const y = attrs.y;
        const w = attrs.width;
        const h = attrs.height;
        if (!isNaN(x) && !isNaN(w)) {
            if (minX === undefined) {
                minX = x - w / 2;
            }
            minX = Math.min(minX, x - w / 2);
            maxX = Math.max(maxX, x + w / 2);
        }
        if (!isNaN(y) && !isNaN(h)) {
            if (minY === undefined) {
                minY = y - h / 2;
            }
            minY = Math.min(minY, y - h / 2);
            maxY = Math.max(maxY, y + h / 2);
        }
    };
    g.nodes().forEach((v) => {
        getExtremes(g.node(v));
    });
    g.edges().forEach((e) => {
        const edge = g.edge(e);
        if (edge === null || edge === void 0 ? void 0 : edge.hasOwnProperty("x")) {
            getExtremes(edge);
        }
    });
    minX -= marginX;
    minY -= marginY;
    g.nodes().forEach((v) => {
        const node = g.node(v);
        if (node) {
            node.x -= minX;
            node.y -= minY;
        }
    });
    g.edges().forEach((e) => {
        var _a;
        const edge = g.edge(e);
        (_a = edge.points) === null || _a === void 0 ? void 0 : _a.forEach((p) => {
            p.x -= minX;
            p.y -= minY;
        });
        if (edge.hasOwnProperty("x")) {
            edge.x -= minX;
        }
        if (edge.hasOwnProperty("y")) {
            edge.y -= minY;
        }
    });
    graphLabel.width = maxX - minX + marginX;
    graphLabel.height = maxY - minY + marginY;
};
const assignNodeIntersects = (g) => {
    g.edges().forEach((e) => {
        const edge = g.edge(e);
        const nodeV = g.node(e.v);
        const nodeW = g.node(e.w);
        let p1;
        let p2;
        if (!edge.points) {
            edge.points = [];
            p1 = nodeW;
            p2 = nodeV;
        }
        else {
            p1 = edge.points[0];
            p2 = edge.points[edge.points.length - 1];
        }
        edge.points.unshift((0,_util__WEBPACK_IMPORTED_MODULE_3__.intersectRect)(nodeV, p1));
        edge.points.push((0,_util__WEBPACK_IMPORTED_MODULE_3__.intersectRect)(nodeW, p2));
    });
};
const fixupEdgeLabelCoords = (g) => {
    g.edges().forEach((e) => {
        const edge = g.edge(e);
        if (edge === null || edge === void 0 ? void 0 : edge.hasOwnProperty("x")) {
            if (edge.labelpos === "l" || edge.labelpos === "r") {
                edge.width -= edge.labeloffset;
            }
            switch (edge.labelpos) {
                case "l":
                    edge.x -= edge.width / 2 + edge.labeloffset;
                    break;
                case "r":
                    edge.x += edge.width / 2 + edge.labeloffset;
                    break;
            }
        }
    });
};
const reversePointsForReversedEdges = (g) => {
    g.edges().forEach((e) => {
        var _a;
        const edge = g.edge(e);
        if (edge.reversed) {
            (_a = edge.points) === null || _a === void 0 ? void 0 : _a.reverse();
        }
    });
};
const removeBorderNodes = (g) => {
    g.nodes().forEach((v) => {
        var _a, _b, _c;
        if ((_a = g.children(v)) === null || _a === void 0 ? void 0 : _a.length) {
            const node = g.node(v);
            const t = g.node(node.borderTop);
            const b = g.node(node.borderBottom);
            const l = g.node(node.borderLeft[((_b = node.borderLeft) === null || _b === void 0 ? void 0 : _b.length) - 1]);
            const r = g.node(node.borderRight[((_c = node.borderRight) === null || _c === void 0 ? void 0 : _c.length) - 1]);
            node.width = Math.abs((r === null || r === void 0 ? void 0 : r.x) - (l === null || l === void 0 ? void 0 : l.x)) || 10;
            node.height = Math.abs((b === null || b === void 0 ? void 0 : b.y) - (t === null || t === void 0 ? void 0 : t.y)) || 10;
            node.x = ((l === null || l === void 0 ? void 0 : l.x) || 0) + node.width / 2;
            node.y = ((t === null || t === void 0 ? void 0 : t.y) || 0) + node.height / 2;
        }
    });
    g.nodes().forEach((v) => {
        var _a;
        if (((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.dummy) === "border") {
            g.removeNode(v);
        }
    });
};
const removeSelfEdges = (g) => {
    g.edges().forEach((e) => {
        if (e.v === e.w) {
            const node = g.node(e.v);
            if (!node.selfEdges) {
                node.selfEdges = [];
            }
            node.selfEdges.push({ e, label: g.edge(e) });
            g.removeEdgeObj(e);
        }
    });
};
const insertSelfEdges = (g) => {
    const layers = (0,_util__WEBPACK_IMPORTED_MODULE_3__.buildLayerMatrix)(g);
    layers === null || layers === void 0 ? void 0 : layers.forEach((layer) => {
        let orderShift = 0;
        layer === null || layer === void 0 ? void 0 : layer.forEach((v, i) => {
            var _a;
            const node = g.node(v);
            node.order = i + orderShift;
            (_a = node.selfEdges) === null || _a === void 0 ? void 0 : _a.forEach((selfEdge) => {
                (0,_util__WEBPACK_IMPORTED_MODULE_3__.addDummyNode)(g, "selfedge", {
                    width: selfEdge.label.width,
                    height: selfEdge.label.height,
                    rank: node.rank,
                    order: i + ++orderShift,
                    e: selfEdge.e,
                    label: selfEdge.label,
                }, "_se");
            });
            delete node.selfEdges;
        });
    });
};
const positionSelfEdges = (g) => {
    g.nodes().forEach((v) => {
        const node = g.node(v);
        if (node.dummy === "selfedge") {
            const selfNode = g.node(node.e.v);
            const x = selfNode.x + selfNode.width / 2;
            const y = selfNode.y;
            const dx = node.x - x;
            const dy = selfNode.height / 2;
            g.setEdgeObj(node.e, node.label);
            g.removeNode(v);
            node.label.points = [
                { x: x + (2 * dx) / 3, y: y - dy },
                { x: x + (5 * dx) / 6, y: y - dy },
                { y, x: x + dx },
                { x: x + (5 * dx) / 6, y: y + dy },
                { x: x + (2 * dx) / 3, y: y + dy },
            ];
            node.label.x = node.x;
            node.label.y = node.y;
        }
    });
};
const selectNumberAttrs = (obj, attrs) => {
    const pickedProperties = {};
    attrs === null || attrs === void 0 ? void 0 : attrs.forEach((key) => {
        if (obj[key] === undefined)
            return;
        pickedProperties[key] = (+obj[key]);
    });
    return pickedProperties;
};
const canonicalize = (attrs = {}) => {
    const newAttrs = {};
    Object.keys(attrs).forEach((k) => {
        newAttrs[k.toLowerCase()] = attrs[k];
    });
    return newAttrs;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (layout);
//# sourceMappingURL=layout.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/dagre/src/nesting-graph.js":
/*!************************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/dagre/src/nesting-graph.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/layout/es/layout/dagre/src/util.js");

/*
 * A nesting graph creates dummy nodes for the tops and bottoms of subgraphs,
 * adds appropriate edges to ensure that all cluster nodes are placed between
 * these boundries, and ensures that the graph is connected.
 *
 * In addition we ensure, through the use of the minlen property, that nodes
 * and subgraph border nodes to not end up on the same rank.
 *
 * Preconditions:
 *
 *    1. Input graph is a DAG
 *    2. Nodes in the input graph has a minlen attribute
 *
 * Postconditions:
 *
 *    1. Input graph is connected.
 *    2. Dummy nodes are added for the tops and bottoms of subgraphs.
 *    3. The minlen attribute for nodes is adjusted to ensure nodes do not
 *       get placed on the same rank as subgraph border nodes.
 *
 * The nesting graph idea comes from Sander, "Layout of Compound Directed
 * Graphs."
 */
const run = (g) => {
    var _a;
    const root = (0,_util__WEBPACK_IMPORTED_MODULE_0__.addDummyNode)(g, "root", {}, "_root");
    const depths = treeDepths(g);
    let maxDepth = Math.max(...Object.values(depths));
    if (Math.abs(maxDepth) === Infinity) {
        maxDepth = 1;
    }
    const height = maxDepth - 1; // Note: depths is an Object not an array
    const nodeSep = 2 * height + 1;
    g.graph().nestingRoot = root;
    // Multiply minlen by nodeSep to align nodes on non-border ranks.
    g.edges().forEach((e) => {
        g.edge(e).minlen *= nodeSep;
    });
    // Calculate a weight that is sufficient to keep subgraphs vertically compact
    const weight = sumWeights(g) + 1;
    // Create border nodes and link them up
    (_a = g.children()) === null || _a === void 0 ? void 0 : _a.forEach((child) => {
        dfs(g, root, nodeSep, weight, height, depths, child);
    });
    // Save the multiplier for node layers for later removal of empty border
    // layers.
    g.graph().nodeRankFactor = nodeSep;
};
const dfs = (g, root, nodeSep, weight, height, depths, v) => {
    const children = g.children(v);
    if (!(children === null || children === void 0 ? void 0 : children.length)) {
        if (v !== root) {
            g.setEdge(root, v, { weight: 0, minlen: nodeSep });
        }
        return;
    }
    const top = (0,_util__WEBPACK_IMPORTED_MODULE_0__.addBorderNode)(g, "_bt");
    const bottom = (0,_util__WEBPACK_IMPORTED_MODULE_0__.addBorderNode)(g, "_bb");
    const label = g.node(v);
    g.setParent(top, v);
    label.borderTop = top;
    g.setParent(bottom, v);
    label.borderBottom = bottom;
    children === null || children === void 0 ? void 0 : children.forEach((child) => {
        dfs(g, root, nodeSep, weight, height, depths, child);
        const childNode = g.node(child);
        const childTop = childNode.borderTop ? childNode.borderTop : child;
        const childBottom = childNode.borderBottom ? childNode.borderBottom : child;
        const thisWeight = childNode.borderTop ? weight : 2 * weight;
        const minlen = childTop !== childBottom ? 1 : height - depths[v] + 1;
        g.setEdge(top, childTop, {
            minlen,
            weight: thisWeight,
            nestingEdge: true,
        });
        g.setEdge(childBottom, bottom, {
            minlen,
            weight: thisWeight,
            nestingEdge: true,
        });
    });
    if (!g.parent(v)) {
        g.setEdge(root, top, { weight: 0, minlen: height + depths[v] });
    }
};
const treeDepths = (g) => {
    var _a;
    const depths = {};
    const dfs = (v, depth) => {
        const children = g.children(v);
        children === null || children === void 0 ? void 0 : children.forEach((child) => dfs(child, depth + 1));
        depths[v] = depth;
    };
    (_a = g.children()) === null || _a === void 0 ? void 0 : _a.forEach((v) => dfs(v, 1));
    return depths;
};
const sumWeights = (g) => {
    let result = 0;
    g.edges().forEach((e) => {
        result += g.edge(e).weight;
    });
    return result;
};
const cleanup = (g) => {
    const graphLabel = g.graph();
    graphLabel.nestingRoot && g.removeNode(graphLabel.nestingRoot);
    delete graphLabel.nestingRoot;
    g.edges().forEach((e) => {
        const edge = g.edge(e);
        if (edge.nestingEdge) {
            g.removeEdgeObj(e);
        }
    });
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({ run, cleanup });
//# sourceMappingURL=nesting-graph.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/dagre/src/normalize.js":
/*!********************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/dagre/src/normalize.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/layout/es/layout/dagre/src/util.js");

/*
 * Breaks any long edges in the graph into short segments that span 1 layer
 * each. This operation is undoable with the denormalize function.
 *
 * Pre-conditions:
 *
 *    1. The input graph is a DAG.
 *    2. Each node in the graph has a "rank" property.
 *
 * Post-condition:
 *
 *    1. All edges in the graph have a length of 1.
 *    2. Dummy nodes are added where edges have been split into segments.
 *    3. The graph is augmented with a "dummyChains" attribute which contains
 *       the first dummy in each chain of dummy nodes produced.
 */
const run = (g) => {
    g.graph().dummyChains = [];
    g.edges().forEach((edge) => normalizeEdge(g, edge));
};
const normalizeEdge = (g, e) => {
    let v = e.v;
    let vRank = g.node(v).rank;
    const w = e.w;
    const wRank = g.node(w).rank;
    const name = e.name;
    const edgeLabel = g.edge(e);
    const labelRank = edgeLabel.labelRank;
    if (wRank === vRank + 1)
        return;
    g.removeEdgeObj(e);
    const graph = g.graph();
    let dummy;
    let attrs;
    let i;
    for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {
        edgeLabel.points = [];
        attrs = {
            edgeLabel,
            width: 0,
            height: 0,
            edgeObj: e,
            rank: vRank,
        };
        dummy = (0,_util__WEBPACK_IMPORTED_MODULE_0__.addDummyNode)(g, "edge", attrs, "_d");
        if (vRank === labelRank) {
            attrs.width = edgeLabel.width;
            attrs.height = edgeLabel.height;
            attrs.dummy = "edge-label";
            attrs.labelpos = edgeLabel.labelpos;
        }
        g.setEdge(v, dummy, { weight: edgeLabel.weight }, name);
        if (i === 0) {
            if (!graph.dummyChains)
                graph.dummyChains = [];
            graph.dummyChains.push(dummy);
        }
        v = dummy;
    }
    g.setEdge(v, w, { weight: edgeLabel.weight }, name);
};
const undo = (g) => {
    var _a;
    (_a = g.graph().dummyChains) === null || _a === void 0 ? void 0 : _a.forEach((v) => {
        let node = g.node(v);
        const origLabel = node.edgeLabel;
        let w;
        if (node.edgeObj) {
            g.setEdgeObj(node.edgeObj, origLabel);
        }
        let currentV = v;
        while (node.dummy) {
            w = g.successors(currentV)[0];
            g.removeNode(currentV);
            origLabel.points.push({ x: node.x, y: node.y });
            if (node.dummy === "edge-label") {
                origLabel.x = node.x;
                origLabel.y = node.y;
                origLabel.width = node.width;
                origLabel.height = node.height;
            }
            currentV = w;
            node = g.node(currentV);
        }
    });
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({ run, undo });
//# sourceMappingURL=normalize.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/dagre/src/order/add-subgraph-constraints.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/dagre/src/order/add-subgraph-constraints.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const addSubgraphConstraints = (g, cg, vs) => {
    const prev = {};
    let rootPrev;
    vs === null || vs === void 0 ? void 0 : vs.forEach((v) => {
        let child = g.parent(v);
        let parent;
        let prevChild;
        while (child) {
            parent = g.parent(child);
            if (parent) {
                prevChild = prev[parent];
                prev[parent] = child;
            }
            else {
                prevChild = rootPrev;
                rootPrev = child;
            }
            if (prevChild && prevChild !== child) {
                cg.setEdge(prevChild, child);
                return;
            }
            child = parent;
        }
    });
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (addSubgraphConstraints);
//# sourceMappingURL=add-subgraph-constraints.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/dagre/src/order/barycenter.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/dagre/src/order/barycenter.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const barycenter = (g, movable) => {
    return movable.map((v) => {
        const inV = g.inEdges(v);
        if (!(inV === null || inV === void 0 ? void 0 : inV.length)) {
            return { v };
        }
        {
            const result = { sum: 0, weight: 0 };
            inV === null || inV === void 0 ? void 0 : inV.forEach((e) => {
                const edge = g.edge(e);
                const nodeU = g.node(e.v);
                result.sum += (edge.weight * nodeU.order);
                result.weight += edge.weight;
            });
            return {
                v,
                barycenter: result.sum / result.weight,
                weight: result.weight
            };
        }
    });
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (barycenter);
//# sourceMappingURL=barycenter.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/dagre/src/order/build-layer-graph.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/dagre/src/order/build-layer-graph.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../graph */ "./node_modules/@antv/layout/es/layout/dagre/graph.js");

/*
 * Constructs a graph that can be used to sort a layer of nodes. The graph will
 * contain all base and subgraph nodes from the request layer in their original
 * hierarchy and any edges that are incident on these nodes and are of the type
 * requested by the "relationship" parameter.
 *
 * Nodes from the requested rank that do not have parents are assigned a root
 * node in the output graph, which is set in the root graph attribute. This
 * makes it easy to walk the hierarchy of movable nodes during ordering.
 *
 * Pre-conditions:
 *
 *    1. Input graph is a DAG
 *    2. Base nodes in the input graph have a rank attribute
 *    3. Subgraph nodes in the input graph has minRank and maxRank attributes
 *    4. Edges have an assigned weight
 *
 * Post-conditions:
 *
 *    1. Output graph has all nodes in the movable rank with preserved
 *       hierarchy.
 *    2. Root nodes in the movable layer are made children of the node
 *       indicated by the root attribute of the graph.
 *    3. Non-movable nodes incident on movable nodes, selected by the
 *       relationship parameter, are included in the graph (without hierarchy).
 *    4. Edges incident on movable nodes, selected by the relationship
 *       parameter, are added to the output graph.
 *    5. The weights for copied edges are aggregated as need, since the output
 *       graph is not a multi-graph.
 */
const buildLayerGraph = (g, rank, relationship) => {
    const root = createRootNode(g);
    const result = new _graph__WEBPACK_IMPORTED_MODULE_0__.Graph({ compound: true })
        .setGraph({ root })
        .setDefaultNodeLabel((v) => {
        return g.node(v);
    });
    g.nodes().forEach((v) => {
        var _a;
        const node = g.node(v);
        const parent = g.parent(v);
        if (node.rank === rank ||
            (node.minRank <= rank && rank <= node.maxRank)) {
            result.setNode(v);
            result.setParent(v, parent || root);
            // This assumes we have only short edges!
            (_a = g[relationship](v)) === null || _a === void 0 ? void 0 : _a.forEach((e) => {
                const u = e.v === v ? e.w : e.v;
                const edge = result.edgeFromArgs(u, v);
                const weight = edge !== undefined ? edge.weight : 0;
                result.setEdge(u, v, { weight: g.edge(e).weight + weight });
            });
            if (node.hasOwnProperty("minRank")) {
                result.setNode(v, {
                    borderLeft: node.borderLeft[rank],
                    borderRight: node.borderRight[rank],
                });
            }
        }
    });
    return result;
};
const createRootNode = (g) => {
    let v;
    while (g.hasNode((v = `_root${Math.random()}`)))
        ;
    return v;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (buildLayerGraph);
//# sourceMappingURL=build-layer-graph.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/dagre/src/order/cross-count.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/dagre/src/order/cross-count.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/layout/es/layout/dagre/src/util.js");
/*
 * A function that takes a layering (an array of layers, each with an array of
 * ordererd nodes) and a graph and returns a weighted crossing count.
 *
 * Pre-conditions:
 *
 *    1. Input graph must be simple (not a multigraph), directed, and include
 *       only simple edges.
 *    2. Edges in the input graph must have assigned weights.
 *
 * Post-conditions:
 *
 *    1. The graph and layering matrix are left unchanged.
 *
 * This algorithm is derived from Barth, et al., "Bilayer Cross Counting."
 */

const twoLayerCrossCount = (g, northLayer, southLayer) => {
    // Sort all of the edges between the north and south layers by their position
    // in the north layer and then the south. Map these edges to the position of
    // their head in the south layer.
    const southPos = (0,_util__WEBPACK_IMPORTED_MODULE_0__.zipObject)(southLayer, southLayer.map((v, i) => i));
    const unflat = northLayer.map((v) => {
        var _a;
        const unsort = (_a = g.outEdges(v)) === null || _a === void 0 ? void 0 : _a.map((e) => {
            return { pos: southPos[e.w] || 0, weight: g.edge(e).weight };
        });
        return unsort === null || unsort === void 0 ? void 0 : unsort.sort((a, b) => a.pos - b.pos);
    });
    const southEntries = unflat.flat().filter((entry) => entry !== undefined);
    // Build the accumulator tree
    let firstIndex = 1;
    while (firstIndex < southLayer.length)
        firstIndex <<= 1;
    const treeSize = 2 * firstIndex - 1;
    firstIndex -= 1;
    const tree = Array(treeSize).fill(0, 0, treeSize);
    // Calculate the weighted crossings
    let cc = 0;
    southEntries === null || southEntries === void 0 ? void 0 : southEntries.forEach((entry) => {
        if (entry) {
            let index = entry.pos + firstIndex;
            tree[index] += entry.weight;
            let weightSum = 0;
            while (index > 0) {
                if (index % 2) {
                    weightSum += tree[index + 1];
                }
                index = (index - 1) >> 1;
                tree[index] += entry.weight;
            }
            cc += entry.weight * weightSum;
        }
    });
    return cc;
};
const crossCount = (g, layering) => {
    let cc = 0;
    for (let i = 1; i < (layering === null || layering === void 0 ? void 0 : layering.length); i += 1) {
        cc += twoLayerCrossCount(g, layering[i - 1], layering[i]);
    }
    return cc;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (crossCount);
//# sourceMappingURL=cross-count.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/dagre/src/order/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/dagre/src/order/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _init_order__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./init-order */ "./node_modules/@antv/layout/es/layout/dagre/src/order/init-order.js");
/* harmony import */ var _cross_count__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cross-count */ "./node_modules/@antv/layout/es/layout/dagre/src/order/cross-count.js");
/* harmony import */ var _build_layer_graph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./build-layer-graph */ "./node_modules/@antv/layout/es/layout/dagre/src/order/build-layer-graph.js");
/* harmony import */ var _add_subgraph_constraints__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./add-subgraph-constraints */ "./node_modules/@antv/layout/es/layout/dagre/src/order/add-subgraph-constraints.js");
/* harmony import */ var _sort_subgraph__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sort-subgraph */ "./node_modules/@antv/layout/es/layout/dagre/src/order/sort-subgraph.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../util */ "./node_modules/@antv/layout/es/util/index.js");
/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../graph */ "./node_modules/@antv/layout/es/layout/dagre/graph.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/layout/es/layout/dagre/src/util.js");








/*
 * Applies heuristics to minimize edge crossings in the graph and sets the best
 * order solution as an order attribute on each node.
 *
 * Pre-conditions:
 *
 *    1. Graph must be DAG
 *    2. Graph nodes must be objects with a "rank" attribute
 *    3. Graph edges must have the "weight" attribute
 *
 * Post-conditions:
 *
 *    1. Graph nodes will have an "order" attribute based on the results of the
 *       algorithm.
 */
const order = (g, keepNodeOrder) => {
    const mxRank = (0,_util__WEBPACK_IMPORTED_MODULE_7__.maxRank)(g);
    const range1 = [];
    const range2 = [];
    for (let i = 1; i < mxRank + 1; i++)
        range1.push(i);
    for (let i = mxRank - 1; i > -1; i--)
        range2.push(i);
    const downLayerGraphs = buildLayerGraphs(g, range1, "inEdges");
    const upLayerGraphs = buildLayerGraphs(g, range2, "outEdges");
    let layering = (0,_init_order__WEBPACK_IMPORTED_MODULE_0__["default"])(g);
    assignOrder(g, layering);
    let bestCC = Number.POSITIVE_INFINITY;
    let best;
    for (let i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {
        sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2, false, keepNodeOrder);
        layering = (0,_util__WEBPACK_IMPORTED_MODULE_7__.buildLayerMatrix)(g);
        const cc = (0,_cross_count__WEBPACK_IMPORTED_MODULE_1__["default"])(g, layering);
        if (cc < bestCC) {
            lastBest = 0;
            best = (0,_util__WEBPACK_IMPORTED_MODULE_5__.clone)(layering);
            bestCC = cc;
        }
    }
    // consider use previous result, maybe somewhat reduendant
    layering = (0,_init_order__WEBPACK_IMPORTED_MODULE_0__["default"])(g);
    assignOrder(g, layering);
    for (let i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {
        sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2, true, keepNodeOrder);
        layering = (0,_util__WEBPACK_IMPORTED_MODULE_7__.buildLayerMatrix)(g);
        const cc = (0,_cross_count__WEBPACK_IMPORTED_MODULE_1__["default"])(g, layering);
        if (cc < bestCC) {
            lastBest = 0;
            best = (0,_util__WEBPACK_IMPORTED_MODULE_5__.clone)(layering);
            bestCC = cc;
        }
    }
    assignOrder(g, best);
};
const buildLayerGraphs = (g, ranks, relationship) => {
    return ranks.map((rank) => {
        return (0,_build_layer_graph__WEBPACK_IMPORTED_MODULE_2__["default"])(g, rank, relationship);
    });
};
const sweepLayerGraphs = (layerGraphs, biasRight, usePrev, keepNodeOrder) => {
    const cg = new _graph__WEBPACK_IMPORTED_MODULE_6__.Graph();
    layerGraphs === null || layerGraphs === void 0 ? void 0 : layerGraphs.forEach((lg) => {
        var _a;
        const root = lg.graph().root;
        const sorted = (0,_sort_subgraph__WEBPACK_IMPORTED_MODULE_4__["default"])(lg, root, cg, biasRight, usePrev, keepNodeOrder);
        for (let i = 0; i < ((_a = sorted.vs) === null || _a === void 0 ? void 0 : _a.length) || 0; i++) {
            const lnode = lg.node(sorted.vs[i]);
            if (lnode) {
                lnode.order = i;
            }
        }
        (0,_add_subgraph_constraints__WEBPACK_IMPORTED_MODULE_3__["default"])(lg, cg, sorted.vs);
    });
};
const assignOrder = (g, layering) => {
    layering === null || layering === void 0 ? void 0 : layering.forEach((layer) => {
        layer === null || layer === void 0 ? void 0 : layer.forEach((v, i) => {
            g.node(v).order = i;
        });
    });
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (order);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/dagre/src/order/init-data-order.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/dagre/src/order/init-data-order.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * 按照数据中的结果设置fixorder
 */
const initDataOrder = (g, nodeOrder) => {
    const simpleNodes = g.nodes().filter((v) => {
        var _a;
        return !((_a = g.children(v)) === null || _a === void 0 ? void 0 : _a.length);
    });
    const ranks = simpleNodes.map((v) => g.node(v).rank);
    const maxRank = Math.max(...ranks);
    const layers = [];
    for (let i = 0; i < maxRank + 1; i++) {
        layers[i] = [];
    }
    nodeOrder === null || nodeOrder === void 0 ? void 0 : nodeOrder.forEach((n) => {
        const node = g.node(n);
        // 只考虑原有节点，dummy节点需要按照后续算法排出
        if (!node || (node === null || node === void 0 ? void 0 : node.dummy)) {
            return;
        }
        if (!isNaN(node.rank)) {
            node.fixorder = layers[node.rank].length; // 设置fixorder为当层的顺序
            layers[node.rank].push(n);
        }
    });
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (initDataOrder);
//# sourceMappingURL=init-data-order.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/dagre/src/order/init-order.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/dagre/src/order/init-order.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/util */ "./node_modules/@antv/util/esm/lodash/max.js");

/*
 * Assigns an initial order value for each node by performing a DFS search
 * starting from nodes in the first rank. Nodes are assigned an order in their
 * rank as they are first visited.
 *
 * This approach comes from Gansner, et al., "A Technique for Drawing Directed
 * Graphs."
 *
 * Returns a layering matrix with an array per layer and each layer sorted by
 * the order of its nodes.
 */
const initOrder = (g) => {
    const visited = {};
    const simpleNodes = g.nodes().filter((v) => {
        var _a;
        return !((_a = g.children(v)) === null || _a === void 0 ? void 0 : _a.length);
    });
    const nodeRanks = simpleNodes.map((v) => g.node(v).rank);
    const maxRank = (0,_antv_util__WEBPACK_IMPORTED_MODULE_0__["default"])(nodeRanks);
    const layers = [];
    for (let i = 0; i < maxRank + 1; i++) {
        layers.push([]);
    }
    const dfs = (v) => {
        var _a;
        if (visited.hasOwnProperty(v))
            return;
        visited[v] = true;
        const node = g.node(v);
        if (!isNaN(node.rank)) {
            layers[node.rank].push(v);
        }
        (_a = g.successors(v)) === null || _a === void 0 ? void 0 : _a.forEach((child) => dfs(child));
    };
    const orderedVs = simpleNodes.sort((a, b) => g.node(a).rank - g.node(b).rank);
    // const orderedVs = _.sortBy(simpleNodes, function(v) { return g.node(v)!.rank; });
    // 有fixOrder的，直接排序好放进去
    const beforeSort = orderedVs.filter((n) => {
        return g.node(n).fixorder !== undefined;
    });
    const fixOrderNodes = beforeSort.sort((a, b) => g.node(a).fixorder - g.node(b).fixorder);
    fixOrderNodes === null || fixOrderNodes === void 0 ? void 0 : fixOrderNodes.forEach((n) => {
        if (!isNaN(g.node(n).rank)) {
            layers[g.node(n).rank].push(n);
        }
        visited[n] = true;
    });
    orderedVs === null || orderedVs === void 0 ? void 0 : orderedVs.forEach(dfs);
    return layers;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (initOrder);
//# sourceMappingURL=init-order.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/dagre/src/order/resolve-conflicts.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/dagre/src/order/resolve-conflicts.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const resolveConflicts = (entries, cg) => {
    var _a, _b, _c;
    const mappedEntries = {};
    entries === null || entries === void 0 ? void 0 : entries.forEach((entry, i) => {
        mappedEntries[entry.v] = {
            i,
            indegree: 0,
            in: [],
            out: [],
            vs: [entry.v],
        };
        const tmp = mappedEntries[entry.v];
        if (entry.barycenter !== undefined) {
            tmp.barycenter = entry.barycenter;
            tmp.weight = entry.weight;
        }
    });
    (_a = cg.edges()) === null || _a === void 0 ? void 0 : _a.forEach((e) => {
        const entryV = mappedEntries[e.v];
        const entryW = mappedEntries[e.w];
        if (entryV !== undefined && entryW !== undefined) {
            entryW.indegree++;
            entryV.out.push(mappedEntries[e.w]);
        }
    });
    const sourceSet = (_c = (_b = Object.values(mappedEntries)).filter) === null || _c === void 0 ? void 0 : _c.call(_b, (entry) => !entry.indegree);
    return doResolveConflicts(sourceSet);
};
const doResolveConflicts = (sourceSet) => {
    var _a, _b;
    const entries = [];
    const handleIn = (vEntry) => {
        return (uEntry) => {
            if (uEntry.merged)
                return;
            if (uEntry.barycenter === undefined ||
                vEntry.barycenter === undefined ||
                uEntry.barycenter >= vEntry.barycenter) {
                mergeEntries(vEntry, uEntry);
            }
        };
    };
    const handleOut = (vEntry) => {
        return (wEntry) => {
            wEntry["in"].push(vEntry);
            if (--wEntry.indegree === 0) {
                sourceSet.push(wEntry);
            }
        };
    };
    while (sourceSet === null || sourceSet === void 0 ? void 0 : sourceSet.length) {
        const entry = sourceSet.pop();
        entries.push(entry);
        (_a = entry["in"].reverse()) === null || _a === void 0 ? void 0 : _a.forEach((e) => handleIn(entry)(e));
        (_b = entry.out) === null || _b === void 0 ? void 0 : _b.forEach((e) => handleOut(entry)(e));
    }
    const filtered = entries.filter((entry) => !entry.merged);
    const keys = [
        "vs",
        "i",
        "barycenter",
        "weight",
    ];
    return filtered.map((entry) => {
        const picked = {};
        keys === null || keys === void 0 ? void 0 : keys.forEach((key) => {
            if (entry[key] === undefined)
                return;
            picked[key] = entry[key];
        });
        return picked;
    });
};
const mergeEntries = (target, source) => {
    var _a;
    let sum = 0;
    let weight = 0;
    if (target.weight) {
        sum += target.barycenter * target.weight;
        weight += target.weight;
    }
    if (source.weight) {
        sum += source.barycenter * source.weight;
        weight += source.weight;
    }
    target.vs = (_a = source.vs) === null || _a === void 0 ? void 0 : _a.concat(target.vs);
    target.barycenter = sum / weight;
    target.weight = weight;
    target.i = Math.min(source.i, target.i);
    source.merged = true;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (resolveConflicts);
//# sourceMappingURL=resolve-conflicts.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/dagre/src/order/sort-subgraph.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/dagre/src/order/sort-subgraph.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _barycenter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./barycenter */ "./node_modules/@antv/layout/es/layout/dagre/src/order/barycenter.js");
/* harmony import */ var _resolve_conflicts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resolve-conflicts */ "./node_modules/@antv/layout/es/layout/dagre/src/order/resolve-conflicts.js");
/* harmony import */ var _sort__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sort */ "./node_modules/@antv/layout/es/layout/dagre/src/order/sort.js");



const sortSubgraph = (g, v, cg, biasRight, usePrev, keepNodeOrder) => {
    var _a, _b, _c, _d;
    let movable = g.children(v);
    // fixorder的点不参与排序（这个方案不合适，只排了新增节点，和原来的分离）
    const node = g.node(v);
    const bl = node ? node.borderLeft : undefined;
    const br = node ? node.borderRight : undefined;
    const subgraphs = {};
    if (bl) {
        movable = movable === null || movable === void 0 ? void 0 : movable.filter((w) => {
            return w !== bl && w !== br;
        });
    }
    const barycenters = (0,_barycenter__WEBPACK_IMPORTED_MODULE_0__["default"])(g, movable || []);
    barycenters === null || barycenters === void 0 ? void 0 : barycenters.forEach((entry) => {
        var _a;
        if ((_a = g.children(entry.v)) === null || _a === void 0 ? void 0 : _a.length) {
            const subgraphResult = sortSubgraph(g, entry.v, cg, biasRight, keepNodeOrder);
            subgraphs[entry.v] = subgraphResult;
            if (subgraphResult.hasOwnProperty("barycenter")) {
                mergeBarycenters(entry, subgraphResult);
            }
        }
    });
    const entries = (0,_resolve_conflicts__WEBPACK_IMPORTED_MODULE_1__["default"])(barycenters, cg);
    expandSubgraphs(entries, subgraphs);
    // 添加fixorder信息到entries里边
    // TODO: 不考虑复合情况，只用第一个点的fixorder信息，后续考虑更完备的实现
    (_a = entries
        .filter((e) => e.vs.length > 0)) === null || _a === void 0 ? void 0 : _a.forEach((e) => {
        const node = g.node(e.vs[0]);
        if (node) {
            e.fixorder = node.fixorder;
            e.order = node.order;
        }
    });
    const result = (0,_sort__WEBPACK_IMPORTED_MODULE_2__["default"])(entries, biasRight, usePrev, keepNodeOrder);
    if (bl) {
        result.vs = [bl, result.vs, br].flat();
        if ((_b = g.predecessors(bl)) === null || _b === void 0 ? void 0 : _b.length) {
            const blPred = g.node(((_c = g.predecessors(bl)) === null || _c === void 0 ? void 0 : _c[0]) || "");
            const brPred = g.node(((_d = g.predecessors(br)) === null || _d === void 0 ? void 0 : _d[0]) || "");
            if (!result.hasOwnProperty("barycenter")) {
                result.barycenter = 0;
                result.weight = 0;
            }
            result.barycenter =
                (result.barycenter * result.weight +
                    blPred.order +
                    brPred.order) /
                    (result.weight + 2);
            result.weight += 2;
        }
    }
    return result;
};
const expandSubgraphs = (entries, subgraphs) => {
    entries === null || entries === void 0 ? void 0 : entries.forEach((entry) => {
        var _a;
        const vss = (_a = entry.vs) === null || _a === void 0 ? void 0 : _a.map((v) => {
            if (subgraphs[v]) {
                return subgraphs[v].vs;
            }
            return v;
        });
        entry.vs = vss.flat();
    });
};
const mergeBarycenters = (target, other) => {
    if (target.barycenter !== undefined) {
        target.barycenter =
            (target.barycenter * target.weight + other.barycenter * other.weight) /
                (target.weight + other.weight);
        target.weight += other.weight;
    }
    else {
        target.barycenter = other.barycenter;
        target.weight = other.weight;
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sortSubgraph);
//# sourceMappingURL=sort-subgraph.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/dagre/src/order/sort.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/dagre/src/order/sort.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/layout/es/layout/dagre/src/util.js");

const sort = (entries, biasRight, usePrev, keepNodeOrder) => {
    const parts = (0,_util__WEBPACK_IMPORTED_MODULE_0__.partition)(entries, (entry) => {
        const hasFixOrder = entry.hasOwnProperty("fixorder") && !isNaN(entry.fixorder);
        if (keepNodeOrder)
            return !hasFixOrder && entry.hasOwnProperty("barycenter");
        // NOTE: 有fixorder的也可以排
        return hasFixOrder || entry.hasOwnProperty("barycenter");
    });
    const sortable = parts.lhs;
    const unsortable = parts.rhs.sort((a, b) => -a.i - (-b.i));
    const vs = [];
    let sum = 0;
    let weight = 0;
    let vsIndex = 0;
    sortable === null || sortable === void 0 ? void 0 : sortable.sort(compareWithBias(!!biasRight, !!usePrev));
    vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
    sortable === null || sortable === void 0 ? void 0 : sortable.forEach((entry) => {
        var _a;
        vsIndex += (_a = entry.vs) === null || _a === void 0 ? void 0 : _a.length;
        vs.push(entry.vs);
        sum += entry.barycenter * entry.weight;
        weight += entry.weight;
        vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
    });
    const result = { vs: vs.flat() };
    if (weight) {
        result.barycenter = sum / weight;
        result.weight = weight;
    }
    return result;
};
const consumeUnsortable = (vs, unsortable, index) => {
    let iindex = index;
    let last;
    while (unsortable.length && (last = unsortable[unsortable.length - 1]).i <= iindex) {
        unsortable.pop();
        vs === null || vs === void 0 ? void 0 : vs.push(last.vs);
        iindex++;
    }
    return iindex;
};
/**
 * 配置是否考虑使用之前的布局结果
 */
const compareWithBias = (bias, usePrev) => {
    return (entryV, entryW) => {
        // 排序的时候先判断fixorder，不行再判断重心
        if (entryV.fixorder !== undefined && entryW.fixorder !== undefined) {
            return entryV.fixorder - entryW.fixorder;
        }
        if (entryV.barycenter < entryW.barycenter) {
            return -1;
        }
        if (entryV.barycenter > entryW.barycenter) {
            return 1;
        }
        // 重心相同，考虑之前排好的顺序
        if (usePrev && entryV.order !== undefined && entryW.order !== undefined) {
            if (entryV.order < entryW.order) {
                return -1;
            }
            if (entryV.order > entryW.order) {
                return 1;
            }
        }
        return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
    };
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sort);
//# sourceMappingURL=sort.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/dagre/src/parent-dummy-chains.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/dagre/src/parent-dummy-chains.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// deep first search with both order low for pre, lim for post
const dfsBothOrder = (g) => {
    var _a;
    const result = {};
    let lim = 0;
    const dfs = (v) => {
        var _a;
        const low = lim;
        (_a = g.children(v)) === null || _a === void 0 ? void 0 : _a.forEach(dfs);
        result[v] = { low, lim: lim++ };
    };
    (_a = g.children()) === null || _a === void 0 ? void 0 : _a.forEach(dfs);
    return result;
};
// Find a path from v to w through the lowest common ancestor (LCA). Return the
// full path and the LCA.
const findPath = (g, postorderNums, v, w) => {
    const vPath = [];
    const wPath = [];
    const low = Math.min(postorderNums[v].low, postorderNums[w].low);
    const lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);
    let parent;
    let lca;
    // Traverse up from v to find the LCA
    parent = v;
    do {
        parent = g.parent(parent);
        vPath.push(parent);
    } while (parent &&
        (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
    lca = parent;
    // Traverse from w to LCA
    parent = w;
    while (parent && parent !== lca) {
        wPath.push(parent);
        parent = g.parent(parent);
    }
    return { lca, path: vPath.concat(wPath.reverse()) };
};
const parentDummyChains = (g) => {
    var _a;
    const postorderNums = dfsBothOrder(g);
    (_a = g.graph().dummyChains) === null || _a === void 0 ? void 0 : _a.forEach((startV) => {
        var _a, _b;
        let v = startV;
        let node = g.node(v);
        const edgeObj = node.edgeObj;
        if (!edgeObj)
            return;
        const pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);
        const path = pathData.path;
        const lca = pathData.lca;
        let pathIdx = 0;
        let pathV = path[pathIdx];
        let ascending = true;
        while (v !== edgeObj.w) {
            node = g.node(v);
            if (ascending) {
                while (pathV !== lca && ((_a = g.node(pathV)) === null || _a === void 0 ? void 0 : _a.maxRank) < node.rank) {
                    pathIdx++;
                    pathV = path[pathIdx];
                }
                if (pathV === lca) {
                    ascending = false;
                }
            }
            if (!ascending) {
                while (pathIdx < path.length - 1 &&
                    ((_b = g.node(path[pathIdx + 1])) === null || _b === void 0 ? void 0 : _b.minRank) <=
                        node.rank) {
                    pathIdx++;
                }
                pathV = path[pathIdx];
            }
            g.setParent(v, pathV);
            v = g.successors(v)[0];
        }
    });
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parentDummyChains);
//# sourceMappingURL=parent-dummy-chains.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/dagre/src/position/bk.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/dagre/src/position/bk.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addConflict: () => (/* binding */ addConflict),
/* harmony export */   alignCoordinates: () => (/* binding */ alignCoordinates),
/* harmony export */   balance: () => (/* binding */ balance),
/* harmony export */   buildBlockGraph: () => (/* binding */ buildBlockGraph),
/* harmony export */   findOtherInnerSegmentNode: () => (/* binding */ findOtherInnerSegmentNode),
/* harmony export */   findSmallestWidthAlignment: () => (/* binding */ findSmallestWidthAlignment),
/* harmony export */   findType1Conflicts: () => (/* binding */ findType1Conflicts),
/* harmony export */   findType2Conflicts: () => (/* binding */ findType2Conflicts),
/* harmony export */   hasConflict: () => (/* binding */ hasConflict),
/* harmony export */   horizontalCompaction: () => (/* binding */ horizontalCompaction),
/* harmony export */   positionX: () => (/* binding */ positionX),
/* harmony export */   sep: () => (/* binding */ sep),
/* harmony export */   verticalAlignment: () => (/* binding */ verticalAlignment),
/* harmony export */   width: () => (/* binding */ width)
/* harmony export */ });
/* harmony import */ var _antv_graphlib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/graphlib */ "./node_modules/@antv/graphlib/es/index.js");
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @antv/util */ "./node_modules/@antv/util/esm/lodash/min.js");
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @antv/util */ "./node_modules/@antv/util/esm/lodash/max.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/layout/es/layout/dagre/src/util.js");
/*
 * This module provides coordinate assignment based on Brandes and Köpf, "Fast
 * and Simple Horizontal Coordinate Assignment."
 */



class BlockGraph extends _antv_graphlib__WEBPACK_IMPORTED_MODULE_0__.Graph {
}
const findType1Conflicts = (g, layering) => {
    const conflicts = {};
    const visitLayer = (prevLayer, layer) => {
        // last visited node in the previous layer that is incident on an inner
        // segment.
        let k0 = 0;
        // Tracks the last node in this layer scanned for crossings with a type-1
        // segment.
        let scanPos = 0;
        const prevLayerLength = prevLayer.length;
        const lastNode = layer === null || layer === void 0 ? void 0 : layer[(layer === null || layer === void 0 ? void 0 : layer.length) - 1];
        layer === null || layer === void 0 ? void 0 : layer.forEach((v, i) => {
            var _a;
            const w = findOtherInnerSegmentNode(g, v);
            const k1 = w ? g.node(w).order : prevLayerLength;
            if (w || v === lastNode) {
                (_a = layer.slice(scanPos, i + 1)) === null || _a === void 0 ? void 0 : _a.forEach((scanNode) => {
                    var _a;
                    (_a = g.predecessors(scanNode)) === null || _a === void 0 ? void 0 : _a.forEach((u) => {
                        var _a;
                        const uLabel = g.node(u);
                        const uPos = uLabel.order;
                        if ((uPos < k0 || k1 < uPos) &&
                            !(uLabel.dummy && ((_a = g.node(scanNode)) === null || _a === void 0 ? void 0 : _a.dummy))) {
                            addConflict(conflicts, u, scanNode);
                        }
                    });
                });
                scanPos = i + 1;
                k0 = k1;
            }
        });
        return layer;
    };
    if (layering === null || layering === void 0 ? void 0 : layering.length) {
        layering.reduce(visitLayer);
    }
    return conflicts;
};
const findType2Conflicts = (g, layering) => {
    const conflicts = {};
    function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
        var _a, _b;
        let v;
        for (let i = southPos; i < southEnd; i++) {
            v = south[i];
            if ((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.dummy) {
                (_b = g.predecessors(v)) === null || _b === void 0 ? void 0 : _b.forEach((u) => {
                    const uNode = g.node(u);
                    if (uNode.dummy &&
                        (uNode.order < prevNorthBorder ||
                            uNode.order > nextNorthBorder)) {
                        addConflict(conflicts, u, v);
                    }
                });
            }
        }
    }
    ;
    function getScannedKey(params) {
        // south数组可能很大，不适合做key
        return JSON.stringify(params.slice(1));
    }
    function scanIfNeeded(params, scanCache) {
        const cacheKey = getScannedKey(params);
        if (scanCache.get(cacheKey))
            return;
        scan(...params);
        scanCache.set(cacheKey, true);
    }
    const visitLayer = (north, south) => {
        let prevNorthPos = -1;
        let nextNorthPos;
        let southPos = 0;
        const scanned = new Map();
        south === null || south === void 0 ? void 0 : south.forEach((v, southLookahead) => {
            var _a;
            if (((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.dummy) === "border") {
                const predecessors = g.predecessors(v) || [];
                if (predecessors.length) {
                    nextNorthPos = g.node(predecessors[0]).order;
                    scanIfNeeded([south, southPos, southLookahead, prevNorthPos, nextNorthPos], scanned);
                    southPos = southLookahead;
                    prevNorthPos = nextNorthPos;
                }
            }
            scanIfNeeded([south, southPos, south.length, nextNorthPos, north.length], scanned);
        });
        return south;
    };
    if (layering === null || layering === void 0 ? void 0 : layering.length) {
        layering.reduce(visitLayer);
    }
    return conflicts;
};
const findOtherInnerSegmentNode = (g, v) => {
    var _a, _b;
    if ((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.dummy) {
        return (_b = g.predecessors(v)) === null || _b === void 0 ? void 0 : _b.find((u) => g.node(u).dummy);
    }
};
const addConflict = (conflicts, v, w) => {
    let vv = v;
    let ww = w;
    if (vv > ww) {
        const tmp = vv;
        vv = ww;
        ww = tmp;
    }
    let conflictsV = conflicts[vv];
    if (!conflictsV) {
        conflicts[vv] = conflictsV = {};
    }
    conflictsV[ww] = true;
};
const hasConflict = (conflicts, v, w) => {
    let vv = v;
    let ww = w;
    if (vv > ww) {
        const tmp = v;
        vv = ww;
        ww = tmp;
    }
    return !!conflicts[vv];
};
/*
 * Try to align nodes into vertical "blocks" where possible. This algorithm
 * attempts to align a node with one of its median neighbors. If the edge
 * connecting a neighbor is a type-1 conflict then we ignore that possibility.
 * If a previous node has already formed a block with a node after the node
 * we're trying to form a block with, we also ignore that possibility - our
 * blocks would be split in that scenario.
 */
const verticalAlignment = (g, layering, conflicts, neighborFn) => {
    const root = {};
    const align = {};
    const pos = {};
    // We cache the position here based on the layering because the graph and
    // layering may be out of sync. The layering matrix is manipulated to
    // generate different extreme alignments.
    layering === null || layering === void 0 ? void 0 : layering.forEach((layer) => {
        layer === null || layer === void 0 ? void 0 : layer.forEach((v, order) => {
            root[v] = v;
            align[v] = v;
            pos[v] = order;
        });
    });
    layering === null || layering === void 0 ? void 0 : layering.forEach((layer) => {
        let prevIdx = -1;
        layer === null || layer === void 0 ? void 0 : layer.forEach((v) => {
            let ws = neighborFn(v);
            if (ws.length) {
                ws = ws.sort((a, b) => pos[a] - pos[b]);
                const mp = (ws.length - 1) / 2;
                for (let i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {
                    const w = ws[i];
                    if (align[v] === v &&
                        prevIdx < pos[w] &&
                        !hasConflict(conflicts, v, w)) {
                        align[w] = v;
                        align[v] = root[v] = root[w];
                        prevIdx = pos[w];
                    }
                }
            }
        });
    });
    return { root, align };
};
const horizontalCompaction = (g, layering, root, align, reverseSep) => {
    var _a;
    // This portion of the algorithm differs from BK due to a number of problems.
    // Instead of their algorithm we construct a new block graph and do two
    // sweeps. The first sweep places blocks with the smallest possible
    // coordinates. The second sweep removes unused space by moving blocks to the
    // greatest coordinates without violating separation.
    const xs = {};
    const blockG = buildBlockGraph(g, layering, root, reverseSep);
    const borderType = reverseSep ? "borderLeft" : "borderRight";
    const iterate = (setXsFunc, nextNodesFunc) => {
        let stack = blockG.nodes();
        let elem = stack.pop();
        const visited = {};
        while (elem) {
            if (visited[elem]) {
                setXsFunc(elem);
            }
            else {
                visited[elem] = true;
                stack.push(elem);
                stack = stack.concat(nextNodesFunc(elem));
            }
            elem = stack.pop();
        }
    };
    // First pass, assign smallest coordinates
    const pass1 = (elem) => {
        xs[elem] = (blockG.inEdges(elem) || []).reduce((acc, e) => {
            return Math.max(acc, (xs[e.v] || 0) + blockG.edge(e));
        }, 0);
    };
    // Second pass, assign greatest coordinates
    const pass2 = (elem) => {
        const min = (blockG.outEdges(elem) || []).reduce((acc, e) => {
            return Math.min(acc, (xs[e.w] || 0) - blockG.edge(e));
        }, Number.POSITIVE_INFINITY);
        const node = g.node(elem);
        if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {
            xs[elem] = Math.max(xs[elem], min);
        }
    };
    iterate(pass1, blockG.predecessors.bind(blockG));
    iterate(pass2, blockG.successors.bind(blockG));
    // Assign x coordinates to all nodes
    (_a = Object.values(align)) === null || _a === void 0 ? void 0 : _a.forEach((v) => {
        xs[v] = xs[root[v]];
    });
    return xs;
};
const buildBlockGraph = (g, layering, root, reverseSep) => {
    const blockGraph = new BlockGraph();
    const graphLabel = g.graph();
    const sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);
    layering === null || layering === void 0 ? void 0 : layering.forEach((layer) => {
        let u;
        layer === null || layer === void 0 ? void 0 : layer.forEach((v) => {
            const vRoot = root[v];
            blockGraph.setNode(vRoot);
            if (u) {
                const uRoot = root[u];
                const prevMax = blockGraph.edgeFromArgs(uRoot, vRoot);
                blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));
            }
            u = v;
        });
    });
    return blockGraph;
};
/*
 * Returns the alignment that has the smallest width of the given alignments.
 */
const findSmallestWidthAlignment = (g, xss) => {
    return (0,_util__WEBPACK_IMPORTED_MODULE_1__.minBy)(Object.values(xss), (xs) => {
        var _a;
        let max = Number.NEGATIVE_INFINITY;
        let min = Number.POSITIVE_INFINITY;
        (_a = Object.keys(xs)) === null || _a === void 0 ? void 0 : _a.forEach((v) => {
            const x = xs[v];
            const halfWidth = width(g, v) / 2;
            max = Math.max(x + halfWidth, max);
            min = Math.min(x - halfWidth, min);
        });
        return max - min;
    });
};
/*
 * Align the coordinates of each of the layout alignments such that
 * left-biased alignments have their minimum coordinate at the same point as
 * the minimum coordinate of the smallest width alignment and right-biased
 * alignments have their maximum coordinate at the same point as the maximum
 * coordinate of the smallest width alignment.
 */
function alignCoordinates(xss, alignTo) {
    const alignToVals = Object.values(alignTo);
    const alignToMin = (0,_antv_util__WEBPACK_IMPORTED_MODULE_2__["default"])(alignToVals);
    const alignToMax = (0,_antv_util__WEBPACK_IMPORTED_MODULE_3__["default"])(alignToVals);
    ["u", "d"].forEach((vert) => {
        ["l", "r"].forEach((horiz) => {
            const alignment = vert + horiz;
            const xs = xss[alignment];
            let delta;
            if (xs === alignTo)
                return;
            const xsVals = Object.values(xs);
            delta =
                horiz === "l"
                    ? alignToMin - (0,_antv_util__WEBPACK_IMPORTED_MODULE_2__["default"])(xsVals)
                    : alignToMax - (0,_antv_util__WEBPACK_IMPORTED_MODULE_3__["default"])(xsVals);
            if (delta) {
                xss[alignment] = {};
                Object.keys(xs).forEach((key) => {
                    xss[alignment][key] = xs[key] + delta;
                });
            }
        });
    });
}
const balance = (xss, align) => {
    const result = {};
    Object.keys(xss.ul).forEach((key) => {
        if (align) {
            result[key] = xss[align.toLowerCase()][key];
        }
        else {
            const values = Object.values(xss).map((x) => x[key]);
            result[key] = (values[0] + values[1]) / 2; // (ur + ul) / 2
        }
    });
    return result;
};
const positionX = (g) => {
    const layering = (0,_util__WEBPACK_IMPORTED_MODULE_1__.buildLayerMatrix)(g);
    const conflicts = Object.assign(findType1Conflicts(g, layering), findType2Conflicts(g, layering));
    const xss = {};
    let adjustedLayering;
    ["u", "d"].forEach((vert) => {
        adjustedLayering =
            vert === "u" ? layering : Object.values(layering).reverse();
        ["l", "r"].forEach((horiz) => {
            if (horiz === "r") {
                adjustedLayering = adjustedLayering.map((inner) => Object.values(inner).reverse());
            }
            const neighborFn = (vert === "u" ? g.predecessors : g.successors).bind(g);
            const align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);
            const xs = horizontalCompaction(g, adjustedLayering, align.root, align.align, horiz === "r");
            if (horiz === "r") {
                Object.keys(xs).forEach((key) => {
                    xs[key] = -xs[key];
                });
            }
            xss[vert + horiz] = xs;
        });
    });
    const smallestWidth = findSmallestWidthAlignment(g, xss);
    alignCoordinates(xss, smallestWidth);
    return balance(xss, g.graph().align);
};
const sep = (nodeSep, edgeSep, reverseSep) => {
    return (g, v, w) => {
        const vLabel = g.node(v);
        const wLabel = g.node(w);
        let sum = 0;
        let delta;
        sum += vLabel.width / 2;
        if (vLabel.hasOwnProperty("labelpos")) {
            switch ((vLabel.labelpos || "").toLowerCase()) {
                case "l":
                    delta = -vLabel.width / 2;
                    break;
                case "r":
                    delta = vLabel.width / 2;
                    break;
            }
        }
        if (delta) {
            sum += reverseSep ? delta : -delta;
        }
        delta = 0;
        sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;
        sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;
        sum += wLabel.width / 2;
        if (wLabel.labelpos) {
            switch ((wLabel.labelpos || "").toLowerCase()) {
                case "l":
                    delta = wLabel.width / 2;
                    break;
                case "r":
                    delta = -wLabel.width / 2;
                    break;
            }
        }
        if (delta) {
            sum += reverseSep ? delta : -delta;
        }
        delta = 0;
        return sum;
    };
};
const width = (g, v) => g.node(v).width || 0;
//# sourceMappingURL=bk.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/dagre/src/position/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/dagre/src/position/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/layout/es/layout/dagre/src/util.js");
/* harmony import */ var _bk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bk */ "./node_modules/@antv/layout/es/layout/dagre/src/position/bk.js");


const positionY = (g) => {
    const layering = (0,_util__WEBPACK_IMPORTED_MODULE_0__.buildLayerMatrix)(g);
    const rankSep = g.graph().ranksep;
    let prevY = 0;
    layering === null || layering === void 0 ? void 0 : layering.forEach((layer) => {
        const heights = layer.map((v) => g.node(v).height);
        const maxHeight = Math.max(...heights, 0);
        layer === null || layer === void 0 ? void 0 : layer.forEach((v) => {
            g.node(v).y = prevY + maxHeight / 2;
        });
        prevY += maxHeight + rankSep;
    });
};
const positionX = (g) => {
    const layering = (0,_util__WEBPACK_IMPORTED_MODULE_0__.buildLayerMatrix)(g);
    const conflicts = Object.assign((0,_bk__WEBPACK_IMPORTED_MODULE_1__.findType1Conflicts)(g, layering), (0,_bk__WEBPACK_IMPORTED_MODULE_1__.findType2Conflicts)(g, layering));
    const xss = {};
    let adjustedLayering = [];
    ["u", "d"].forEach((vert) => {
        adjustedLayering =
            vert === "u" ? layering : Object.values(layering).reverse();
        ["l", "r"].forEach((horiz) => {
            if (horiz === "r") {
                adjustedLayering = adjustedLayering.map((inner) => Object.values(inner).reverse());
            }
            const neighborFn = (vert === "u" ? g.predecessors : g.successors).bind(g);
            const align = (0,_bk__WEBPACK_IMPORTED_MODULE_1__.verticalAlignment)(g, adjustedLayering, conflicts, neighborFn);
            const xs = (0,_bk__WEBPACK_IMPORTED_MODULE_1__.horizontalCompaction)(g, adjustedLayering, align.root, align.align, horiz === "r");
            if (horiz === "r") {
                Object.keys(xs).forEach((xsKey) => (xs[xsKey] = -xs[xsKey]));
            }
            xss[vert + horiz] = xs;
        });
    });
    const smallestWidth = (0,_bk__WEBPACK_IMPORTED_MODULE_1__.findSmallestWidthAlignment)(g, xss);
    smallestWidth && (0,_bk__WEBPACK_IMPORTED_MODULE_1__.alignCoordinates)(xss, smallestWidth);
    return (0,_bk__WEBPACK_IMPORTED_MODULE_1__.balance)(xss, g.graph().align);
};
const position = (g) => {
    var _a;
    const ng = (0,_util__WEBPACK_IMPORTED_MODULE_0__.asNonCompoundGraph)(g);
    positionY(ng);
    const xs = positionX(ng);
    (_a = Object.keys(xs)) === null || _a === void 0 ? void 0 : _a.forEach((key) => {
        ng.node(key).x = xs[key];
    });
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (position);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/dagre/src/rank/feasible-tree.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/dagre/src/rank/feasible-tree.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   feasibleTree: () => (/* binding */ feasibleTree),
/* harmony export */   feasibleTreeWithLayer: () => (/* binding */ feasibleTreeWithLayer)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/layout/es/layout/dagre/src/rank/util.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/layout/es/layout/dagre/src/util.js");
/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../graph */ "./node_modules/@antv/layout/es/layout/dagre/graph.js");



/*
 * Constructs a spanning tree with tight edges and adjusted the input node's
 * ranks to achieve this. A tight edge is one that is has a length that matches
 * its "minlen" attribute.
 *
 * The basic structure for this function is derived from Gansner, et al., "A
 * Technique for Drawing Directed Graphs."
 *
 * Pre-conditions:
 *
 *    1. Graph must be a DAG.
 *    2. Graph must be connected.
 *    3. Graph must have at least one node.
 *    5. Graph nodes must have been previously assigned a "rank" property that
 *       respects the "minlen" property of incident edges.
 *    6. Graph edges must have a "minlen" property.
 *
 * Post-conditions:
 *
 *    - Graph nodes will have their rank adjusted to ensure that all edges are
 *      tight.
 *
 * Returns a tree (undirected graph) that is constructed using only "tight"
 * edges.
 */
const feasibleTree = (g) => {
    const t = new _graph__WEBPACK_IMPORTED_MODULE_2__.Graph({ directed: false });
    // Choose arbitrary node from which to start our tree
    const start = g.nodes()[0];
    const size = g.nodeCount();
    t.setNode(start, {});
    let edge;
    let delta;
    while (tightTree(t, g) < size) {
        edge = findMinSlackEdge(t, g);
        delta = t.hasNode(edge.v) ? (0,_util__WEBPACK_IMPORTED_MODULE_0__.slack)(g, edge) : -(0,_util__WEBPACK_IMPORTED_MODULE_0__.slack)(g, edge);
        shiftRanks(t, g, delta);
    }
    return t;
};
/*
 * Finds a maximal tree of tight edges and returns the number of nodes in the
 * tree.
 */
const tightTree = (t, g) => {
    const dfs = (v) => {
        g.nodeEdges(v).forEach((e) => {
            const edgeV = e.v;
            const w = (v === edgeV) ? e.w : edgeV;
            if (!t.hasNode(w) && !(0,_util__WEBPACK_IMPORTED_MODULE_0__.slack)(g, e)) {
                t.setNode(w, {});
                t.setEdge(v, w, {});
                dfs(w);
            }
        });
    };
    t.nodes().forEach(dfs);
    return t.nodeCount();
};
/*
 * Constructs a spanning tree with tight edges and adjusted the input node's
 * ranks to achieve this. A tight edge is one that is has a length that matches
 * its "minlen" attribute.
 *
 * The basic structure for this function is derived from Gansner, et al., "A
 * Technique for Drawing Directed Graphs."
 *
 * Pre-conditions:
 *
 *    1. Graph must be a DAG.
 *    2. Graph must be connected.
 *    3. Graph must have at least one node.
 *    5. Graph nodes must have been previously assigned a "rank" property that
 *       respects the "minlen" property of incident edges.
 *    6. Graph edges must have a "minlen" property.
 *
 * Post-conditions:
 *
 *    - Graph nodes will have their rank adjusted to ensure that all edges are
 *      tight.
 *
 * Returns a tree (undirected graph) that is constructed using only "tight"
 * edges.
 */
const feasibleTreeWithLayer = (g) => {
    const t = new _graph__WEBPACK_IMPORTED_MODULE_2__.Graph({ directed: false });
    // Choose arbitrary node from which to start our tree
    const start = g.nodes()[0];
    const size = g.nodes().filter((n) => !!g.node(n)).length;
    t.setNode(start, {});
    let edge;
    let delta;
    while (tightTreeWithLayer(t, g) < size) {
        edge = findMinSlackEdge(t, g);
        delta = t.hasNode(edge.v) ? (0,_util__WEBPACK_IMPORTED_MODULE_0__.slack)(g, edge) : -(0,_util__WEBPACK_IMPORTED_MODULE_0__.slack)(g, edge);
        shiftRanks(t, g, delta);
    }
    return t;
};
/*
 * Finds a maximal tree of tight edges and returns the number of nodes in the
 * tree.
 */
const tightTreeWithLayer = (t, g) => {
    const dfs = (v) => {
        var _a;
        (_a = g.nodeEdges(v)) === null || _a === void 0 ? void 0 : _a.forEach((e) => {
            const edgeV = e.v;
            const w = (v === edgeV) ? e.w : edgeV;
            // 对于指定layer的，直接加入tight-tree，不参与调整
            if (!t.hasNode(w) && (g.node(w).layer !== undefined || !(0,_util__WEBPACK_IMPORTED_MODULE_0__.slack)(g, e))) {
                t.setNode(w, {});
                t.setEdge(v, w, {});
                dfs(w);
            }
        });
    };
    t.nodes().forEach(dfs);
    return t.nodeCount();
};
/*
 * Finds the edge with the smallest slack that is incident on tree and returns
 * it.
 */
const findMinSlackEdge = (t, g) => {
    return (0,_util__WEBPACK_IMPORTED_MODULE_1__.minBy)(g.edges(), (e) => {
        if (t.hasNode(e.v) !== t.hasNode(e.w)) {
            return (0,_util__WEBPACK_IMPORTED_MODULE_0__.slack)(g, e);
        }
        return Infinity;
    });
};
const shiftRanks = (t, g, delta) => {
    t.nodes().forEach((v) => {
        if (!g.node(v).rank)
            g.node(v).rank = 0;
        g.node(v).rank += delta;
    });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    feasibleTree,
    feasibleTreeWithLayer
});
//# sourceMappingURL=feasible-tree.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/dagre/src/rank/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/dagre/src/rank/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/layout/es/layout/dagre/src/rank/util.js");
/* harmony import */ var _feasible_tree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./feasible-tree */ "./node_modules/@antv/layout/es/layout/dagre/src/rank/feasible-tree.js");
/* harmony import */ var _network_simplex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./network-simplex */ "./node_modules/@antv/layout/es/layout/dagre/src/rank/network-simplex.js");
// "use strict";
// var rankUtil = require("./util");
// var longestPath = rankUtil.longestPathWithLayer;
// var feasibleTree = require("./feasible-tree").feasibleTreeWithLayer;
// var networkSimplex = require("./network-simplex");



/*
 * Assigns a rank to each node in the input graph that respects the "minlen"
 * constraint specified on edges between nodes.
 *
 * This basic structure is derived from Gansner, et al., "A Technique for
 * Drawing Directed Graphs."
 *
 * Pre-conditions:
 *
 *    1. Graph must be a connected DAG
 *    2. Graph nodes must be objects
 *    3. Graph edges must have "weight" and "minlen" attributes
 *
 * Post-conditions:
 *
 *    1. Graph nodes will have a "rank" attribute based on the results of the
 *       algorithm. Ranks can start at any index (including negative), we'll
 *       fix them up later.
 */
const rank = (g) => {
    switch (g.graph().ranker) {
        case "network-simplex":
            networkSimplexRanker(g);
            break;
        case "tight-tree":
            tightTreeRanker(g);
            break;
        case "longest-path":
            longestPathRanker(g);
            break;
        // default: networkSimplexRanker(g);
        default: tightTreeRanker(g);
    }
};
// A fast and simple ranker, but results are far from optimal.
const longestPathRanker = _util__WEBPACK_IMPORTED_MODULE_0__.longestPath;
const tightTreeRanker = (g) => {
    (0,_util__WEBPACK_IMPORTED_MODULE_0__.longestPathWithLayer)(g);
    (0,_feasible_tree__WEBPACK_IMPORTED_MODULE_1__.feasibleTreeWithLayer)(g);
};
const networkSimplexRanker = (g) => {
    (0,_network_simplex__WEBPACK_IMPORTED_MODULE_2__["default"])(g);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (rank);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/dagre/src/rank/network-simplex.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/dagre/src/rank/network-simplex.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   calcCutValue: () => (/* binding */ calcCutValue),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   enterEdge: () => (/* binding */ enterEdge),
/* harmony export */   exchangeEdges: () => (/* binding */ exchangeEdges),
/* harmony export */   initCutValues: () => (/* binding */ initCutValues),
/* harmony export */   initLowLimValues: () => (/* binding */ initLowLimValues),
/* harmony export */   leaveEdge: () => (/* binding */ leaveEdge)
/* harmony export */ });
/* harmony import */ var _feasible_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./feasible-tree */ "./node_modules/@antv/layout/es/layout/dagre/src/rank/feasible-tree.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/layout/es/layout/dagre/src/rank/util.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/layout/es/layout/dagre/src/util.js");
/* harmony import */ var _antv_graphlib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @antv/graphlib */ "./node_modules/@antv/graphlib/es/index.js");




const { preorder, postorder } = _antv_graphlib__WEBPACK_IMPORTED_MODULE_3__.algorithm;
/*
 * The network simplex algorithm assigns ranks to each node in the input graph
 * and iteratively improves the ranking to reduce the length of edges.
 *
 * Preconditions:
 *
 *    1. The input graph must be a DAG.
 *    2. All nodes in the graph must have an object value.
 *    3. All edges in the graph must have "minlen" and "weight" attributes.
 *
 * Postconditions:
 *
 *    1. All nodes in the graph will have an assigned "rank" attribute that has
 *       been optimized by the network simplex algorithm. Ranks start at 0.
 *
 *
 * A rough sketch of the algorithm is as follows:
 *
 *    1. Assign initial ranks to each node. We use the longest path algorithm,
 *       which assigns ranks to the lowest position possible. In general this
 *       leads to very wide bottom ranks and unnecessarily long edges.
 *    2. Construct a feasible tight tree. A tight tree is one such that all
 *       edges in the tree have no slack (difference between length of edge
 *       and minlen for the edge). This by itself greatly improves the assigned
 *       rankings by shorting edges.
 *    3. Iteratively find edges that have negative cut values. Generally a
 *       negative cut value indicates that the edge could be removed and a new
 *       tree edge could be added to produce a more compact graph.
 *
 * Much of the algorithms here are derived from Gansner, et al., "A Technique
 * for Drawing Directed Graphs." The structure of the file roughly follows the
 * structure of the overall algorithm.
 */
const networkSimplex = (og) => {
    const g = (0,_util__WEBPACK_IMPORTED_MODULE_2__.simplify)(og);
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.longestPath)(g);
    const t = (0,_feasible_tree__WEBPACK_IMPORTED_MODULE_0__.feasibleTree)(g);
    initLowLimValues(t);
    initCutValues(t, g);
    let e;
    let f;
    while ((e = leaveEdge(t))) {
        f = enterEdge(t, g, e);
        exchangeEdges(t, g, e, f);
    }
};
/*
 * Initializes cut values for all edges in the tree.
 */
const initCutValues = (t, g) => {
    let vs = postorder(t, t.nodes());
    vs = vs === null || vs === void 0 ? void 0 : vs.slice(0, (vs === null || vs === void 0 ? void 0 : vs.length) - 1);
    vs === null || vs === void 0 ? void 0 : vs.forEach((v) => {
        assignCutValue(t, g, v);
    });
};
const assignCutValue = (t, g, child) => {
    const childLab = t.node(child);
    const parent = childLab.parent;
    t.edgeFromArgs(child, parent).cutvalue = calcCutValue(t, g, child);
};
/*
 * Given the tight tree, its graph, and a child in the graph calculate and
 * return the cut value for the edge between the child and its parent.
 */
const calcCutValue = (t, g, child) => {
    var _a;
    const childLab = t.node(child);
    const parent = childLab.parent;
    // True if the child is on the tail end of the edge in the directed graph
    let childIsTail = true;
    // The graph's view of the tree edge we're inspecting
    let graphEdge = g.edgeFromArgs(child, parent);
    // The accumulated cut value for the edge between this node and its parent
    let cutValue = 0;
    if (!graphEdge) {
        childIsTail = false;
        graphEdge = g.edgeFromArgs(parent, child);
    }
    cutValue = graphEdge.weight;
    (_a = g.nodeEdges(child)) === null || _a === void 0 ? void 0 : _a.forEach((e) => {
        const isOutEdge = e.v === child;
        const other = isOutEdge ? e.w : e.v;
        if (other !== parent) {
            const pointsToHead = isOutEdge === childIsTail;
            const otherWeight = g.edge(e).weight;
            cutValue += pointsToHead ? otherWeight : -otherWeight;
            if (isTreeEdge(t, child, other)) {
                const otherCutValue = t.edgeFromArgs(child, other).cutvalue;
                cutValue += pointsToHead ? -otherCutValue : otherCutValue;
            }
        }
    });
    return cutValue;
};
const initLowLimValues = (tree, root = tree.nodes()[0]) => {
    dfsAssignLowLim(tree, {}, 1, root);
};
const dfsAssignLowLim = (tree, visited, nextLim, v, parent) => {
    var _a;
    const low = nextLim;
    let useNextLim = nextLim;
    const label = tree.node(v);
    visited[v] = true;
    (_a = tree.neighbors(v)) === null || _a === void 0 ? void 0 : _a.forEach((w) => {
        if (!visited[w]) {
            useNextLim = dfsAssignLowLim(tree, visited, useNextLim, w, v);
        }
    });
    label.low = low;
    label.lim = useNextLim++;
    if (parent) {
        label.parent = parent;
    }
    else {
        // TODO should be able to remove this when we incrementally update low lim
        delete label.parent;
    }
    return useNextLim;
};
const leaveEdge = (tree) => {
    return tree.edges().find((e) => {
        return tree.edge(e).cutvalue < 0;
    });
};
const enterEdge = (t, g, edge) => {
    let v = edge.v;
    let w = edge.w;
    // For the rest of this function we assume that v is the tail and w is the
    // head, so if we don't have this edge in the graph we should flip it to
    // match the correct orientation.
    if (!g.hasEdge(v, w)) {
        v = edge.w;
        w = edge.v;
    }
    const vLabel = t.node(v);
    const wLabel = t.node(w);
    let tailLabel = vLabel;
    let flip = false;
    // If the root is in the tail of the edge then we need to flip the logic that
    // checks for the head and tail nodes in the candidates function below.
    if (vLabel.lim > wLabel.lim) {
        tailLabel = wLabel;
        flip = true;
    }
    const candidates = g.edges().filter((edge) => {
        return flip === isDescendant(t, t.node(edge.v), tailLabel) &&
            flip !== isDescendant(t, t.node(edge.w), tailLabel);
    });
    return (0,_util__WEBPACK_IMPORTED_MODULE_2__.minBy)(candidates, (edge) => { return (0,_util__WEBPACK_IMPORTED_MODULE_1__.slack)(g, edge); });
};
const exchangeEdges = (t, g, e, f) => {
    const v = e.v;
    const w = e.w;
    t.removeEdge(v, w);
    t.setEdge(f.v, f.w, {});
    initLowLimValues(t);
    initCutValues(t, g);
    updateRanks(t, g);
};
const updateRanks = (t, g) => {
    const root = t.nodes().find((v) => { var _a; return !((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.parent); });
    let vs = preorder(t, root);
    vs = vs === null || vs === void 0 ? void 0 : vs.slice(1);
    vs === null || vs === void 0 ? void 0 : vs.forEach((v) => {
        const parent = t.node(v).parent;
        let edge = g.edgeFromArgs(v, parent);
        let flipped = false;
        if (!edge) {
            edge = g.edgeFromArgs(parent, v);
            flipped = true;
        }
        g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
    });
};
/*
 * Returns true if the edge is in the tree.
 */
const isTreeEdge = (tree, u, v) => {
    return tree.hasEdge(u, v);
};
/*
 * Returns true if the specified node is descendant of the root node per the
 * assigned low and lim attributes in the tree.
 */
const isDescendant = (tree, vLabel, rootLabel) => {
    return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (networkSimplex);
//# sourceMappingURL=network-simplex.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/dagre/src/rank/util.js":
/*!********************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/dagre/src/rank/util.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   longestPath: () => (/* binding */ longestPath),
/* harmony export */   longestPathWithLayer: () => (/* binding */ longestPathWithLayer),
/* harmony export */   slack: () => (/* binding */ slack)
/* harmony export */ });
/*
 * Initializes ranks for the input graph using the longest path algorithm. This
 * algorithm scales well and is fast in practice, it yields rather poor
 * solutions. Nodes are pushed to the lowest layer possible, leaving the bottom
 * ranks wide and leaving edges longer than necessary. However, due to its
 * speed, this algorithm is good for getting an initial ranking that can be fed
 * into other algorithms.
 *
 * This algorithm does not normalize layers because it will be used by other
 * algorithms in most cases. If using this algorithm directly, be sure to
 * run normalize at the end.
 *
 * Pre-conditions:
 *
 *    1. Input graph is a DAG.
 *    2. Input graph node labels can be assigned properties.
 *
 * Post-conditions:
 *
 *    1. Each node will be assign an (unnormalized) "rank" property.
 */
const longestPath = (g) => {
    var _a;
    const visited = {};
    const dfs = (v) => {
        var _a;
        const label = g.node(v);
        if (!label)
            return 0;
        if (visited[v]) {
            return label.rank;
        }
        visited[v] = true;
        let rank;
        (_a = g.outEdges(v)) === null || _a === void 0 ? void 0 : _a.forEach((edgeObj) => {
            const wRank = dfs(edgeObj.w);
            const minLen = g.edge(edgeObj).minlen;
            const r = wRank - minLen;
            if (r) {
                if (rank === undefined || r < rank) {
                    rank = r;
                }
            }
        });
        if (!rank) {
            rank = 0;
        }
        label.rank = rank;
        return rank;
    };
    (_a = g.sources()) === null || _a === void 0 ? void 0 : _a.forEach((source) => dfs(source));
};
const longestPathWithLayer = (g) => {
    var _a;
    // 用longest path，找出最深的点
    const visited = {};
    let minRank;
    const dfs = (v) => {
        var _a;
        const label = g.node(v);
        if (!label)
            return 0;
        if (visited[v]) {
            return label.rank;
        }
        visited[v] = true;
        let rank;
        (_a = g.outEdges(v)) === null || _a === void 0 ? void 0 : _a.forEach((edgeObj) => {
            const wRank = dfs(edgeObj.w);
            const minLen = g.edge(edgeObj).minlen;
            const r = wRank - minLen;
            if (r) {
                if (rank === undefined || r < rank) {
                    rank = r;
                }
            }
        });
        if (!rank) {
            rank = 0;
        }
        if (minRank === undefined || rank < minRank) {
            minRank = rank;
        }
        label.rank = rank;
        return rank;
    };
    (_a = g.sources()) === null || _a === void 0 ? void 0 : _a.forEach((source) => {
        if (g.node(source))
            dfs(source);
    });
    if (minRank === undefined) {
        minRank = 0;
    }
    // minRank += 1; // NOTE: 最小的层级是dummy root，+1
    // forward一遍，赋值层级
    const forwardVisited = {};
    const dfsForward = (v, nextRank) => {
        var _a;
        const label = g.node(v);
        const currRank = (!isNaN(label.layer) ? label.layer : nextRank);
        // 没有指定，取最大值
        if (label.rank === undefined || label.rank < currRank) {
            label.rank = currRank;
        }
        if (forwardVisited[v])
            return;
        forwardVisited[v] = true;
        // DFS遍历子节点
        (_a = g.outEdges(v)) === null || _a === void 0 ? void 0 : _a.map((e) => {
            dfsForward(e.w, currRank + g.edge(e).minlen);
        });
    };
    // 指定层级的，更新下游
    g.nodes().forEach((n) => {
        const label = g.node(n);
        if (!label)
            return;
        if (!isNaN(label.layer)) {
            dfsForward(n, label.layer); // 默认的dummy root所在层的rank是-1
        }
        else {
            label.rank -= minRank;
        }
    });
};
/*
 * Returns the amount of slack for the given edge. The slack is defined as the
 * difference between the length of the edge and its minimum length.
 */
const slack = (g, e) => {
    return (g.node(e.w).rank -
        g.node(e.v).rank -
        g.edge(e).minlen);
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    longestPath,
    longestPathWithLayer,
    slack,
});
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/dagre/src/util.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/dagre/src/util.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addBorderNode: () => (/* binding */ addBorderNode),
/* harmony export */   addDummyNode: () => (/* binding */ addDummyNode),
/* harmony export */   asNonCompoundGraph: () => (/* binding */ asNonCompoundGraph),
/* harmony export */   buildLayerMatrix: () => (/* binding */ buildLayerMatrix),
/* harmony export */   intersectRect: () => (/* binding */ intersectRect),
/* harmony export */   maxRank: () => (/* binding */ maxRank),
/* harmony export */   minBy: () => (/* binding */ minBy),
/* harmony export */   normalizeRanks: () => (/* binding */ normalizeRanks),
/* harmony export */   notime: () => (/* binding */ notime),
/* harmony export */   partition: () => (/* binding */ partition),
/* harmony export */   predecessorWeights: () => (/* binding */ predecessorWeights),
/* harmony export */   removeEmptyRanks: () => (/* binding */ removeEmptyRanks),
/* harmony export */   simplify: () => (/* binding */ simplify),
/* harmony export */   successorWeights: () => (/* binding */ successorWeights),
/* harmony export */   time: () => (/* binding */ time),
/* harmony export */   zipObject: () => (/* binding */ zipObject)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util */ "./node_modules/@antv/layout/es/util/index.js");
/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../graph */ "./node_modules/@antv/layout/es/layout/dagre/graph.js");


const safeSort = (valueA, valueB) => {
    return Number(valueA) - Number(valueB);
};
/*
 * Adds a dummy node to the graph and return v.
 */
const addDummyNode = (g, type, attrs, name) => {
    let v;
    do {
        v = `${name}${Math.random()}`;
    } while (g.hasNode(v));
    attrs.dummy = type;
    g.setNode(v, attrs);
    return v;
};
/*
 * Returns a new graph with only simple edges. Handles aggregation of data
 * associated with multi-edges.
 */
const simplify = (g) => {
    const simplified = new _graph__WEBPACK_IMPORTED_MODULE_1__.Graph().setGraph(g.graph());
    g.nodes().forEach((v) => { simplified.setNode(v, g.node(v)); });
    g.edges().forEach((e) => {
        const simpleLabel = simplified.edgeFromArgs(e.v, e.w) || { weight: 0, minlen: 1 };
        const label = g.edge(e);
        simplified.setEdge(e.v, e.w, {
            weight: simpleLabel.weight + label.weight,
            minlen: Math.max(simpleLabel.minlen, label.minlen)
        });
    });
    return simplified;
};
const asNonCompoundGraph = (g) => {
    const simplified = new _graph__WEBPACK_IMPORTED_MODULE_1__.Graph({ multigraph: g.isMultigraph() }).setGraph(g.graph());
    g.nodes().forEach((node) => {
        var _a;
        if (!((_a = g.children(node)) === null || _a === void 0 ? void 0 : _a.length)) {
            simplified.setNode(node, g.node(node));
        }
    });
    g.edges().forEach((edge) => {
        simplified.setEdgeObj(edge, g.edge(edge));
    });
    return simplified;
};
const zipObject = (keys, values) => {
    return keys === null || keys === void 0 ? void 0 : keys.reduce((obj, key, i) => {
        obj[key] = values[i];
        return obj;
    }, {});
};
const successorWeights = (g) => {
    const weightsMap = {};
    g.nodes().forEach((node) => {
        var _a;
        const sucs = {};
        (_a = g.outEdges(node)) === null || _a === void 0 ? void 0 : _a.forEach((e) => {
            var _a;
            sucs[e.w] = (sucs[e.w] || 0) + (((_a = g.edge(e)) === null || _a === void 0 ? void 0 : _a.weight) || 0);
        });
        weightsMap[node] = sucs;
    });
    return weightsMap;
};
const predecessorWeights = (g) => {
    const nodes = g.nodes();
    const weightMap = nodes.map((v) => {
        var _a;
        const preds = {};
        (_a = g.inEdges(v)) === null || _a === void 0 ? void 0 : _a.forEach((e) => {
            preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;
        });
        return preds;
    });
    return zipObject(nodes, weightMap);
};
/*
 * Finds where a line starting at point ({x, y}) would intersect a rectangle
 * ({x, y, width, height}) if it were pointing at the rectangle's center.
 */
const intersectRect = (rect, point) => {
    const x = Number(rect.x);
    const y = Number(rect.y);
    // Rectangle intersection algorithm from:
    // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes
    const dx = Number(point.x) - x;
    const dy = Number(point.y) - y;
    let w = Number(rect.width) / 2;
    let h = Number(rect.height) / 2;
    if (!dx && !dy) {
        // completely overlapped directly, then return points its self
        return { x: 0, y: 0 };
    }
    let sx;
    let sy;
    if (Math.abs(dy) * w > Math.abs(dx) * h) {
        // Intersection is top or bottom of rect.
        if (dy < 0) {
            h = -h;
        }
        sx = (h * dx) / dy;
        sy = h;
    }
    else {
        // Intersection is left or right of rect.
        if (dx < 0) {
            w = -w;
        }
        sx = w;
        sy = (w * dy) / dx;
    }
    return { x: x + sx, y: y + sy };
};
/*
 * Given a DAG with each node assigned "rank" and "order" properties, this
 * const will produce a matrix with the ids of each node.
 */
const buildLayerMatrix = (g) => {
    const layeringNodes = [];
    const rankMax = maxRank(g) + 1;
    for (let i = 0; i < rankMax; i++) {
        layeringNodes.push([]);
    }
    // const layering = _.map(_.range(maxRank(g) + 1), function() { return []; });
    g.nodes().forEach((v) => {
        const node = g.node(v);
        if (!node)
            return;
        const rank = node.rank;
        if (rank !== undefined && layeringNodes[rank]) {
            layeringNodes[rank].push(v);
        }
    });
    for (let i = 0; i < rankMax; i++) {
        layeringNodes[i] = layeringNodes[i].sort((va, vb) => { var _a, _b; return safeSort((_a = g.node(va)) === null || _a === void 0 ? void 0 : _a.order, (_b = g.node(vb)) === null || _b === void 0 ? void 0 : _b.order); });
    }
    return layeringNodes;
};
/*
 * Adjusts the ranks for all nodes in the graph such that all nodes v have
 * rank(v) >= 0 and at least one node w has rank(w) = 0.
 */
const normalizeRanks = (g) => {
    const nodeRanks = g
        .nodes()
        .filter((v) => { var _a; return ((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.rank) !== undefined; })
        .map((v) => g.node(v).rank);
    const min = Math.min(...nodeRanks);
    g.nodes().forEach((v) => {
        const node = g.node(v);
        if (node.hasOwnProperty("rank") && min !== Infinity) {
            node.rank -= min;
        }
    });
};
const removeEmptyRanks = (g) => {
    // Ranks may not start at 0, so we need to offset them
    const nodes = g.nodes();
    const nodeRanks = nodes
        .filter((v) => { var _a; return ((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.rank) !== undefined; })
        .map((v) => g.node(v).rank);
    const offset = Math.min(...nodeRanks);
    const layers = [];
    nodes.forEach((v) => {
        var _a;
        const rank = (((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.rank) || 0) - offset;
        if (!layers[rank]) {
            layers[rank] = [];
        }
        layers[rank].push(v);
    });
    let delta = 0;
    const nodeRankFactor = g.graph().nodeRankFactor || 0;
    for (let i = 0; i < layers.length; i++) {
        const vs = layers[i];
        if (vs === undefined) {
            if (i % nodeRankFactor !== 0) {
                delta -= 1;
            }
        }
        else if (delta) {
            vs === null || vs === void 0 ? void 0 : vs.forEach((v) => {
                const node = g.node(v);
                if (node) {
                    node.rank = node.rank || 0;
                    node.rank += delta;
                }
            });
        }
    }
};
const addBorderNode = (g, prefix, rank, order) => {
    const node = {
        width: 0,
        height: 0
    };
    if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isNumber)(rank) && (0,_util__WEBPACK_IMPORTED_MODULE_0__.isNumber)(order)) {
        node.rank = rank;
        node.order = order;
    }
    return addDummyNode(g, "border", node, prefix);
};
const maxRank = (g) => {
    let maxRank;
    g.nodes().forEach((v) => {
        var _a;
        const rank = (_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.rank;
        if (rank !== undefined) {
            if (maxRank === undefined || rank > maxRank) {
                maxRank = rank;
            }
        }
    });
    if (!maxRank) {
        maxRank = 0;
    }
    return maxRank;
};
/*
 * Partition a collection into two groups: `lhs` and `rhs`. If the supplied
 * const returns true for an entry it goes into `lhs`. Otherwise it goes
 * into `rhs.
 */
const partition = (collection, fn) => {
    const result = { lhs: [], rhs: [] };
    collection === null || collection === void 0 ? void 0 : collection.forEach((value) => {
        if (fn(value)) {
            result.lhs.push(value);
        }
        else {
            result.rhs.push(value);
        }
    });
    return result;
};
/*
 * Returns a new const that wraps `fn` with a timer. The wrapper logs the
 * time it takes to execute the function.
 */
const time = (name, fn) => {
    const start = Date.now();
    try {
        return fn();
    }
    finally {
        console.log(`${name} time: ${Date.now() - start}ms`);
    }
};
const notime = (name, fn) => {
    return fn();
};
const minBy = (array, func) => {
    return array.reduce((a, b) => {
        const valA = func(a);
        const valB = func(b);
        return valA > valB ? b : a;
    });
};
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/er/core.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/er/core.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ layout)
/* harmony export */ });
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/simulation.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/link.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/manyBody.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/center.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/x.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/y.js");
/* harmony import */ var _forceGrid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./forceGrid */ "./node_modules/@antv/layout/es/layout/er/forceGrid.js");
/* harmony import */ var _mysqlWorkbench__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mysqlWorkbench */ "./node_modules/@antv/layout/es/layout/er/mysqlWorkbench.js");
/* harmony import */ var _dagre__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dagre */ "./node_modules/@antv/layout/es/layout/dagre.js");




function layout(data, options) {
    const { nodes, edges } = data;
    const width = options.width;
    const height = options.height;
    if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length))
        return Promise.resolve();
    // 筛选非叶子节点，做Dagre布局
    const noLeafNodes = [];
    nodes.forEach((node) => {
        const relateEdges = edges.filter((edge) => {
            return edge.source === node.id || edge.target === node.id;
        });
        if (relateEdges.length > 1) {
            const temp = Object.assign({}, node);
            delete temp.size;
            noLeafNodes.push(temp);
        }
    });
    const noLeafEdge = [];
    edges.forEach((edge) => {
        const sourceNode = noLeafNodes.find((node) => node.id === edge.source);
        const targetNode = noLeafNodes.find((node) => node.id === edge.target);
        if (sourceNode && targetNode) {
            noLeafEdge.push(edge);
        }
    });
    const graphLayout = new _dagre__WEBPACK_IMPORTED_MODULE_2__.DagreLayout({
        type: 'dagre',
        ranksep: options.nodeMinGap,
        nodesep: options.nodeMinGap,
    });
    const { nodes: nodesTmp } = graphLayout.layout({
        nodes: noLeafNodes,
        edges: noLeafEdge,
    });
    // 布局后，坐标同步
    nodes.forEach((n) => {
        const found = (nodesTmp || []).find((temp) => temp.id === n.id);
        n.x = (found === null || found === void 0 ? void 0 : found.x) || width / 2;
        n.y = (found === null || found === void 0 ? void 0 : found.y) || height / 2;
    });
    const copyNodes = JSON.parse(JSON.stringify(nodes));
    const copyEdges = JSON.parse(JSON.stringify(edges));
    const simulation = d3_force__WEBPACK_IMPORTED_MODULE_3__["default"]().nodes(copyNodes)
        .force("link", d3_force__WEBPACK_IMPORTED_MODULE_4__["default"](copyEdges).id((d) => d.id).distance((d) => {
        const edgeInfo = noLeafEdge.find((edge) => edge.source === d.source && edge.target === d.target);
        if (edgeInfo) {
            return 30;
        }
        return 20;
    }))
        .force("charge", d3_force__WEBPACK_IMPORTED_MODULE_5__["default"]())
        .force("center", d3_force__WEBPACK_IMPORTED_MODULE_6__["default"](width / 2, height / 2))
        .force("x", d3_force__WEBPACK_IMPORTED_MODULE_7__["default"](width / 2))
        .force("y", d3_force__WEBPACK_IMPORTED_MODULE_8__["default"](height / 2))
        .alpha(0.3)
        .alphaDecay(0.08)
        .alphaMin(0.001);
    const layoutPromise = new Promise((resolve) => {
        simulation.on('end', () => {
            // 坐标信息同步到nodes,edges中
            nodes.forEach((node) => {
                const nodeInfo = copyNodes.find((item) => item.id === node.id);
                if (nodeInfo) {
                    node.x = nodeInfo.x;
                    node.y = nodeInfo.y;
                }
            });
            const minX = Math.min(...nodes.map((node) => node.x));
            const maxX = Math.max(...nodes.map((node) => node.x));
            const minY = Math.min(...nodes.map((node) => node.y));
            const maxY = Math.max(...nodes.map((node) => node.y));
            const scalex = width / (maxX - minX);
            const scaley = height / (maxY - minY);
            nodes.forEach((node) => {
                if (node.x !== undefined && scalex < 1) {
                    node.x = (node.x - minX) * scalex;
                }
                if (node.y !== undefined && scaley < 1) {
                    node.y = (node.y - minY) * scaley;
                }
            });
            // 这一步就执行缩小空间。且不考虑节点size
            nodes.forEach((node) => {
                node.sizeTemp = node.size;
                node.size = [10, 10];
            });
            (0,_mysqlWorkbench__WEBPACK_IMPORTED_MODULE_1__["default"])(nodes, edges);
            nodes.forEach((node) => {
                node.size = node.sizeTemp || [];
                delete node.sizeTemp;
            });
            // 进行网格对齐+节点大小扩增
            (0,_forceGrid__WEBPACK_IMPORTED_MODULE_0__["default"])({
                nodes,
                edges,
            }, options);
            resolve();
        });
    });
    return layoutPromise;
}
//# sourceMappingURL=core.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/er/forceGrid.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/er/forceGrid.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ layout)
/* harmony export */ });
/* harmony import */ var _grid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./grid */ "./node_modules/@antv/layout/es/layout/er/grid.js");

function layout(data, options) {
    if (!data.nodes || data.nodes.length === 0)
        return data;
    const width = options.width;
    const height = options.height;
    const nodeMinGap = options.nodeMinGap;
    // 2. 网格布局
    let CELL_W = 10000;
    let CELL_H = 10000;
    data.nodes.forEach((node) => {
        const nodeWidth = node.size[0] || 50;
        const nodeHeight = node.size[1] || 50;
        CELL_W = Math.min(nodeWidth, CELL_W);
        CELL_H = Math.min(nodeHeight, CELL_H);
    });
    const grid = new _grid__WEBPACK_IMPORTED_MODULE_0__["default"]();
    grid.init(width, height, {
        CELL_H,
        CELL_W,
    });
    data.nodes.forEach((d) => {
        const gridpoint = grid.occupyNearest(d);
        if (gridpoint) {
            gridpoint.node = {
                id: d.id,
                size: d.size,
            };
            d.x = gridpoint.x;
            d.y = gridpoint.y;
            d.dx = gridpoint.dx;
            d.dy = gridpoint.dy;
        }
    });
    // 加入节点size
    for (let i = 0; i < data.nodes.length; i++) {
        //  节点宽度大于网格宽度，则往当前网格的右边插入列
        const node = data.nodes[i];
        const result = grid.findGridByNodeId(node.id);
        if (!result)
            throw new Error("can not find node cell");
        const { column, row } = result;
        if ((node.size[0] + nodeMinGap) > CELL_W) {
            const addGridSize = Math.ceil((node.size[0] + nodeMinGap) / CELL_W) - 1;
            let realAdd = addGridSize;
            // 优化，假设同一列，不同行存在两个size为2的节点，遍历到第一个节点的时候，会往右插入两列，遍历到第二个节点，又往右插入。就会导致多余的网格
            for (let j = 0; j < addGridSize; j++) {
                const hasColumn = grid.additionColumn.indexOf(column + j + 1) > -1;
                if (hasColumn && !grid.cells[column + j + 1][row].node) {
                    realAdd--;
                }
                else {
                    break;
                }
            }
            grid.insertColumn(column, realAdd);
        }
        // 节点高度大于网格宽度，则往当前网格的下边插入行
        if ((node.size[1] + nodeMinGap) > CELL_H) {
            const addGridSize = Math.ceil((node.size[1] + nodeMinGap) / CELL_H) - 1;
            let realAdd = addGridSize;
            for (let j = 0; j < addGridSize; j++) {
                const hasColumn = grid.additionRow.indexOf(row + j + 1) > -1;
                if (hasColumn && !grid.cells[column][row + j + 1].node) {
                    realAdd--;
                }
                else {
                    break;
                }
            }
            grid.insertRow(row, realAdd);
        }
    }
    // 同步节点坐标
    for (let i = 0; i < grid.columnNum; i++) {
        for (let j = 0; j < grid.rowNum; j++) {
            const cell = grid.cells[i][j];
            if (cell.node) {
                const node = data.nodes.find((node) => { var _a; return node.id === ((_a = cell === null || cell === void 0 ? void 0 : cell.node) === null || _a === void 0 ? void 0 : _a.id); });
                if (node) {
                    node.x = cell.x + node.size[0] / 2;
                    node.y = cell.y + node.size[1] / 2;
                }
            }
        }
    }
}
//# sourceMappingURL=forceGrid.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/er/grid.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/er/grid.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Grid)
/* harmony export */ });
class Grid {
    constructor() {
        this.cells = [];
        this.columnNum = 0;
        this.rowNum = 0;
        this.additionColumn = [];
        this.additionRow = [];
    }
    init(width, height, gridSize) {
        this.cells = [];
        this.CELL_W = gridSize.CELL_W || Grid.DEFAULT_CELL_W;
        this.CELL_H = gridSize.CELL_H || Grid.DEFAULT_CELL_H;
        this.columnNum = Math.ceil(width / this.CELL_W);
        this.rowNum = Math.ceil(height / this.CELL_H);
        Grid.MIN_DIST = Math.pow(width, 2) + Math.pow(height, 2);
        for (let i = 0; i < this.columnNum; i++) {
            const tmp = [];
            for (let j = 0; j < this.rowNum; j++) {
                const cell = {
                    dx: i,
                    dy: j,
                    x: i * this.CELL_W,
                    y: j * this.CELL_H,
                    occupied: false
                };
                tmp.push(cell);
            }
            this.cells.push(tmp);
        }
    }
    findGridByNodeId(nodeId) {
        var _a, _b;
        for (let i = 0; i < this.columnNum; i++) {
            for (let j = 0; j < this.rowNum; j++) {
                if (this.cells[i][j].node) {
                    if (((_b = (_a = this.cells[i][j]) === null || _a === void 0 ? void 0 : _a.node) === null || _b === void 0 ? void 0 : _b.id) === nodeId) {
                        return { column: i, row: j };
                    }
                }
            }
        }
        return null;
    }
    sqdist(a, b) {
        return Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);
    }
    occupyNearest(p) {
        let minDist = Grid.MIN_DIST;
        let d;
        let candidate = null;
        for (let i = 0; i < this.columnNum; i++) {
            for (let j = 0; j < this.rowNum; j++) {
                if (!this.cells[i][j].occupied && (d = this.sqdist(p, this.cells[i][j])) < minDist) {
                    minDist = d;
                    candidate = this.cells[i][j];
                }
            }
        }
        if (candidate) {
            candidate.occupied = true;
        }
        return candidate;
    }
    insertColumn(columnIndex, length) {
        if (length <= 0)
            return;
        // 插入空列
        for (let i = 0; i < length; i++) {
            this.cells[i + this.columnNum] = [];
            for (let j = 0; j < this.rowNum; j++) {
                this.cells[i + this.columnNum][j] = {
                    dx: i,
                    dy: j,
                    x: i * this.CELL_W,
                    y: j * this.CELL_H,
                    occupied: false,
                    node: null,
                };
            }
        }
        // 交换数据
        for (let i = (this.columnNum - 1); i > columnIndex; i--) {
            for (let j = 0; j < this.rowNum; j++) {
                this.cells[i + length][j] = Object.assign(Object.assign({}, this.cells[i][j]), { x: (i + length) * this.CELL_W, y: j * this.CELL_H });
                this.cells[i][j] = {
                    x: i * this.CELL_W,
                    y: j * this.CELL_H,
                    occupied: true,
                    node: null,
                };
            }
        }
        // 已有行列的处理
        for (let j = 0; j < this.additionColumn.length; j++) {
            if (this.additionColumn[j] >= columnIndex) {
                this.additionColumn[j] += length;
            }
        }
        // 记录新增的行列
        for (let i = 0; i < length; i++) {
            this.additionColumn.push(columnIndex + i + 1);
        }
        this.columnNum += length;
    }
    insertRow(rowIndex, length) {
        if (length <= 0)
            return;
        // 插入空行
        for (let j = 0; j < length; j++) {
            for (let i = 0; i < this.columnNum; i++) {
                this.cells[i][j + this.rowNum] = {
                    dx: i,
                    dy: j,
                    x: i * this.CELL_W,
                    y: j * this.CELL_H,
                    occupied: false,
                    node: null,
                };
            }
        }
        // 交换数据
        for (let i = 0; i < this.columnNum; i++) {
            for (let j = (this.rowNum - 1); j > rowIndex; j--) {
                this.cells[i][j + length] = Object.assign(Object.assign({}, this.cells[i][j]), { dx: i, dy: j + length, x: i * this.CELL_W, y: (j + length) * this.CELL_H });
                this.cells[i][j] = {
                    dx: i,
                    dy: j,
                    x: i * this.CELL_W,
                    y: j * this.CELL_H,
                    occupied: false,
                    node: null,
                };
            }
        }
        // 已有行列的处理
        for (let j = 0; j < this.additionRow.length; j++) {
            if (this.additionRow[j] >= rowIndex) {
                this.additionRow[j] += length;
            }
        }
        // 记录新增的行列
        for (let i = 0; i < length; i++) {
            this.additionRow.push(rowIndex + i + 1);
        }
        this.rowNum += length;
    }
    getNodes() {
        const nodes = [];
        for (let i = 0; i < this.columnNum; i++) {
            for (let j = 0; j < this.rowNum; j++) {
                if (this.cells[i][j].node) {
                    nodes.push(this.cells[i][j]);
                }
            }
        }
        return nodes;
    }
}
Grid.MIN_DIST = 50;
Grid.DEFAULT_CELL_W = 80;
Grid.DEFAULT_CELL_H = 80;
//# sourceMappingURL=grid.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/er/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/er/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ERLayout: () => (/* binding */ ERLayout)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./node_modules/@antv/layout/es/layout/base.js");
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core */ "./node_modules/@antv/layout/es/layout/er/core.js");
/**
 * @fileOverview Force Layout Grid Align layout
 * @author wenyanqi
 */


class ERLayout extends _base__WEBPACK_IMPORTED_MODULE_0__.Base {
    constructor(options) {
        super();
        this.width = 300;
        this.height = 300;
        this.nodeMinGap = 50;
        /** 迭代结束的回调函数 */
        this.onLayoutEnd = () => { };
        if (options) {
            this.updateCfg(options);
        }
    }
    getDefaultCfg() {
        return {
            width: 300,
            height: 300,
            nodeMinGap: 50,
        };
    }
    /**
     * 执行布局
     */
    execute() {
        const self = this;
        const nodes = self.nodes;
        const edges = self.edges;
        // 节点初始化，size初始化
        nodes === null || nodes === void 0 ? void 0 : nodes.forEach((node) => {
            if (!node.size) {
                node.size = [50, 50];
            }
        });
        return (0,_core__WEBPACK_IMPORTED_MODULE_1__["default"])({
            nodes, edges,
        }, {
            width: this.width,
            height: this.height,
            nodeMinGap: this.nodeMinGap,
        }).then(() => {
            if (self.onLayoutEnd)
                self.onLayoutEnd();
        });
    }
    getType() {
        return "er";
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/er/mysqlWorkbench.js":
/*!******************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/er/mysqlWorkbench.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const graphWidth = 1200;
const graphHeight = 800;
const OVERLAP_QUOT = 10000000;
const MIN_DIST = 10;
const M_PI = 3.14159265358979323846;
const M_PI_2 = 1.57079632679489661923;
const PI_38 = M_PI * 0.375;
const PI_58 = M_PI * 0.625;
const nodeEdgeMap = new Map();
const CELL_W = 10;
const CELL_H = 10;
let T = 0.8;
const T_MIN = 0.1;
const R = 0.5;
function distanceToNode(node1, node2, isHoriz) {
    const x11 = node1.x - node1.size[0] / 2;
    const y11 = node1.y - node1.size[1] / 2;
    const x12 = node1.x + node1.size[0] / 2;
    const y12 = node1.y + node1.size[1] / 2;
    const x21 = node2.x - node2.size[0] / 2;
    const y21 = node2.y - node2.size[1] / 2;
    const x22 = node2.x + node2.size[0] / 2;
    const y22 = node2.y + node2.size[1] / 2;
    const cx1 = node1.x;
    const cy1 = node1.y;
    const cx2 = node2.x;
    const cy2 = node2.y;
    const dcx = cx2 - cx1;
    // 两个节点间的方位角  
    const qr = Math.atan2(dcx, (cy2 - cy1));
    let dx = 0;
    let dy = 0;
    let l1 = 0;
    let l2 = 0;
    if (qr > M_PI_2) {
        dy = y11 - y22;
        dx = x21 - x12;
        l1 = parseFloat(dy ? (dy / Math.cos(qr)).toFixed(2) : (dx).toFixed(2));
        l2 = parseFloat(dx ? (dx / Math.sin(qr)).toFixed(2) : (dy).toFixed(2));
    }
    else if (0.0 < qr && qr <= M_PI_2) {
        dy = y21 - y12;
        dx = x21 - x12;
        if (dy > dx) {
            l1 = l2 = parseFloat(dy ? (dy / Math.cos(qr)).toFixed(2) : (dx).toFixed(2));
        }
        else {
            l1 = l2 = parseFloat(dx ? (dx / Math.sin(qr)).toFixed(2) : (dy).toFixed(2));
        }
    }
    else if (qr < -M_PI_2) {
        dy = y11 - y22;
        dx = -(x22 - x11);
        if (dy > dx) {
            l1 = l2 = parseFloat(dy ? (dy / Math.cos(qr)).toFixed(2) : (dx).toFixed(2));
        }
        else {
            l1 = l2 = parseFloat(dx ? (dx / Math.sin(qr)).toFixed(2) : (dy).toFixed(2));
        }
    }
    else {
        dy = y21 - y12;
        if (Math.abs(dcx) > (x12 - x11) / 2) {
            dx = x11 - x22;
        }
        else {
            dx = dcx;
        }
        if (dy > dx) {
            l1 = l2 = parseFloat(dy ? (dy / Math.cos(qr)).toFixed(2) : (dx).toFixed(2));
        }
        else {
            l1 = l2 = parseFloat((dx && qr !== 0.0) ? (dx / Math.sin(qr)).toFixed(2) : (dy).toFixed(2));
        }
    }
    const aqr = parseFloat(qr.toFixed(2));
    // 判断是否水平，角度
    let newHoriz = isHoriz;
    if (isHoriz) {
        newHoriz = PI_38 < aqr && aqr < PI_58;
    }
    return {
        distance: Math.abs(l1 < l2 ? l1 : l2),
        isHoriz: newHoriz,
    };
}
function calcNodePair(nodeA, nodeB) {
    // 确定两个节点间是否存在连线
    const edges = nodeEdgeMap.get(nodeA.id) || [];
    const isLinked = edges.find((edge) => {
        return edge.source === nodeB.id || edge.target === nodeB.id;
    });
    const areaA = nodeA.size[0] * nodeA.size[1];
    const areaB = nodeB.size[0] * nodeB.size[1];
    const node1 = areaA > areaB ? nodeB : nodeA;
    const node2 = areaA > areaB ? nodeA : nodeB;
    const x11 = node1.x - node1.size[0] / 2;
    const y11 = node1.y - node1.size[1] / 2;
    const x12 = node1.x + node1.size[0] / 2;
    const y12 = node1.y + node1.size[1] / 2;
    const x21 = node2.x - node2.size[0] / 2;
    const y21 = node2.y - node2.size[1] / 2;
    const x22 = node2.x + node2.size[0] / 2;
    const y22 = node2.y + node2.size[1] / 2;
    const cx1 = node1.x;
    const cy1 = node1.y;
    const cx2 = node2.x;
    const cy2 = node2.y;
    // Detect if nodes overlap  检查节点之间是否存在覆盖问题
    const isoverlap = ((x12 >= x21) && (x22 >= x11) && (y12 >= y21) && (y22 >= y11));
    let e = 0;
    let distance = 0;
    if (isoverlap) {
        distance = Math.sqrt(Math.pow((cx2 - cx1), 2) + Math.pow((cy2 - cy1), 2));
        // calc area of overlap 计算重复区域的坐标和面积
        const sx1 = x11 > x21 ? x11 : x21;
        const sy1 = y11 > y21 ? y11 : y21;
        const sx2 = x12 < x22 ? x12 : x22;
        const sy2 = y12 < y22 ? y12 : y22;
        const dsx = sx2 - sx1;
        const dsy = sy2 - sy1;
        const sov = dsx * dsy;
        if (distance === 0.0) {
            distance = 0.0000001;
        }
        e = MIN_DIST * 1 / distance * 100 + sov;
        e *= OVERLAP_QUOT;
    }
    else {
        let isHoriz = false;
        const res = distanceToNode(node1, node2, isHoriz);
        distance = res.distance;
        isHoriz = res.isHoriz;
        if (distance <= MIN_DIST) {
            if (distance !== 0) {
                if (isLinked) {
                    e += MIN_DIST + OVERLAP_QUOT * 1 / distance;
                }
                else {
                    e += MIN_DIST + OVERLAP_QUOT * MIN_DIST / distance;
                }
            }
            else {
                e += OVERLAP_QUOT;
            }
        }
        else {
            e += distance;
            if (isLinked) {
                e += distance * distance;
            }
        }
    }
    return e;
}
function calcEnergy(nodes) {
    let energy = 0;
    for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if ((node.x < 0) || (node.y < 0) || (node.x > graphWidth) || (node.y > graphHeight)) {
            energy += 1000000000000;
        }
        for (let j = i + 1; j < nodes.length; j++) {
            energy += calcNodePair(node, nodes[j]);
        }
    }
    return energy;
}
function isCorrectPosition(node, newPosition, nodes, edges) {
    const nodeIdxMap = new Map();
    nodes.forEach((o, i) => {
        nodeIdxMap.set(o.id, o);
    });
    const relateEdges = edges.filter((edge) => edge.source === node.id || edge.target === node.id) || [];
    const relateNodes = [];
    relateEdges.forEach((edge) => {
        const otherNodeId = edge.source === node.id ? edge.target : edge.source;
        const otherNode = nodeIdxMap.get(otherNodeId);
        if (otherNode) {
            relateNodes.push(otherNode);
        }
    });
    let flag = true;
    for (let i = 0; i < relateNodes.length; i++) {
        const item = relateNodes[i];
        // 判断条件调整，节点的坐标不需要完全一致。可以根据节点间的夹角来判断
        const delta = Math.atan((node.y - item.y) / (item.x - node.y)) * 180;
        const newDelta = Math.atan((newPosition.y - item.y) / (item.x - newPosition.y)) * 180;
        const isHor = delta < 30 || delta > 150;
        const newIsHor = newDelta < 30 || newDelta > 150;
        const isVer = delta > 70 && delta < 110;
        const newIsVer = newDelta > 70 && newDelta < 110;
        // 定义四个相似角度区间，0-15度，75-90度，90到105度，165到180度。
        if (isHor && !newIsHor || ((delta * newDelta) < 0)) {
            flag = false;
            break;
        }
        else if (isVer && !newIsVer || ((delta * newDelta) < 0)) {
            flag = false;
            break;
        }
        else if ((item.x - node.x) * (item.x - newPosition.x) < 0) {
            flag = false;
            break;
        }
        else if ((item.y - node.y) * (item.y - newPosition.y) < 0) {
            flag = false;
            break;
        }
    }
    return flag;
}
function shuffle(nodes, edges) {
    let foundSmallerEnergy = false;
    // 多次测试发现step为1时的效果最佳。
    const step = 1;
    const wstep = CELL_W * step;
    const hstep = CELL_H * step;
    const wsteps = [wstep, -wstep, 0, 0,];
    const hsteps = [0, 0, hstep, -hstep,];
    for (let i = 0; i < nodes.length; ++i) {
        const node = nodes[i];
        let nodeEnergy = calcNodeEnergy(node, nodes);
        for (let ns = 0; ns < wsteps.length; ns++) {
            // 判断新位置与其他连线节点的位置关系是否违规
            const flag = isCorrectPosition(node, { x: node.x + wsteps[ns], y: node.y + hsteps[ns] }, nodes, edges);
            if (flag) {
                // 节点朝上下左右四个方向移动，找到能量最小的那个位置
                node.x += wsteps[ns];
                node.y += hsteps[ns];
                // 计算移动后节点的能量
                const energy = calcNodeEnergy(node, nodes);
                const rdm = Math.random();
                if (energy < nodeEnergy) {
                    nodeEnergy = energy;
                    foundSmallerEnergy = true;
                }
                else if (rdm < T && rdm > T_MIN) {
                    nodeEnergy = energy;
                    foundSmallerEnergy = true;
                }
                else {
                    // 回归原位
                    node.x -= wsteps[ns];
                    node.y -= hsteps[ns];
                }
            }
        }
    }
    if (T > T_MIN) {
        T *= R;
    }
    // 重新计算图整体的能量
    if (foundSmallerEnergy) {
        return calcEnergy(nodes);
    }
    return 0;
}
// 计算节点的能量，
function calcNodeEnergy(node, nodes) {
    let e = 0.0;
    if ((node.x < 0) || (node.y < 0) ||
        (node.x + node.size[0] + 20 > graphWidth) ||
        (node.y + node.size[1] + 20 > graphHeight)) {
        e += 1000000000000.0;
    }
    for (let i = 0; i < nodes.length; ++i) {
        if (node.id !== nodes[i].id) {
            e += calcNodePair(node, nodes[i]);
        }
    }
    return e;
}
function layout(nodes, edges) {
    if (nodes.length === 0) {
        return { nodes, edges };
    }
    nodes.forEach((node) => {
        const relateEdge = edges.filter((edge) => edge.source === node.id || edge.target === node.id);
        nodeEdgeMap.set(node, relateEdge);
    });
    // 1. 初始化
    // 将node按照连接数进行排序
    nodes.sort((node1, node2) => {
        var _a, _b;
        return ((_a = nodeEdgeMap.get(node1.id)) === null || _a === void 0 ? void 0 : _a.length) - ((_b = nodeEdgeMap.get(node2.id)) === null || _b === void 0 ? void 0 : _b.length);
    });
    // 2. 计算图能量
    let minEnergy = calcEnergy(nodes);
    let deSameCount = 20; // de=0 count
    let de = 1; // energy delta
    let prevEnergy = 0;
    // 定义总的迭代次数。超过就停掉，防止死循环
    const MAX_COUNT = 50;
    let count = 0;
    while (deSameCount > 0) {
        count++;
        if (count >= MAX_COUNT) {
            break;
        }
        const ea = shuffle(nodes, edges);
        if (ea !== 0) {
            prevEnergy = ea;
        }
        de = prevEnergy - minEnergy;
        minEnergy = prevEnergy;
        if (de === 0) {
            --deSameCount;
        }
        else {
            deSameCount = 20;
        }
    }
    nodes.forEach((node) => {
        node.x = node.x - node.size[0] / 2;
        node.y = node.y - node.size[1] / 2;
    });
    return {
        nodes,
        edges,
    };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (layout);
//# sourceMappingURL=mysqlWorkbench.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/force2/ForceNBody.js":
/*!******************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/force2/ForceNBody.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forceNBody: () => (/* binding */ forceNBody)
/* harmony export */ });
/* harmony import */ var d3_quadtree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-quadtree */ "./node_modules/d3-quadtree/src/quadtree.js");

const theta2 = 0.81; // Barnes-Hut approximation threshold
const epsilon = 0.1; // 为了防止出现除0的情况，加一个epsilon
function forceNBody(nodes, nodeMap, factor, coulombDisScale2, accArray) {
    const weightParam = factor / coulombDisScale2;
    const data = nodes.map((n, i) => {
        // @ts-ignore
        const mappedNode = nodeMap[n.id];
        // @ts-ignore
        const { data: nodeData, x, y, size } = mappedNode;
        const { nodeStrength } = nodeData.layout.force;
        return {
            x,
            y,
            size,
            index: i,
            vx: 0,
            vy: 0,
            weight: weightParam * nodeStrength,
        };
    });
    const tree = (0,d3_quadtree__WEBPACK_IMPORTED_MODULE_0__["default"])(data, (d) => d.x, (d) => d.y).visitAfter(accumulate); // init internal node
    data.forEach((n) => {
        // @ts-ignore
        computeForce(n, tree);
    });
    data.map((n, i) => {
        // @ts-ignore
        const mappedNode = nodeMap[nodes[i].id];
        // @ts-ignore
        const { mass = 1 } = mappedNode.data.layout.force;
        // 从 0 开始，= 初始化 + 加斥力
        accArray[2 * i] = n.vx / mass;
        accArray[2 * i + 1] = n.vy / mass;
    });
    return accArray;
}
// @ts-ignore
function accumulate(quad) {
    let accWeight = 0;
    let accX = 0;
    let accY = 0;
    if (quad.length) {
        // internal node, accumulate 4 child quads
        for (let i = 0; i < 4; i++) {
            const q = quad[i];
            if (q && q.weight) {
                accWeight += q.weight;
                accX += q.x * q.weight;
                accY += q.y * q.weight;
            }
        }
        quad.x = accX / accWeight;
        quad.y = accY / accWeight;
        quad.weight = accWeight;
    }
    else {
        // leaf node
        const q = quad;
        quad.x = q.data.x;
        quad.y = q.data.y;
        quad.weight = q.data.weight;
    }
}
// @ts-ignore
const apply = (quad, x1, y1, x2, y2, node) => {
    const dx = (node.x - quad.x) || epsilon;
    const dy = (node.y - quad.y) || epsilon;
    const width = x2 - x1;
    const len2 = dx * dx + dy * dy;
    const len3 = Math.sqrt(len2) * len2;
    // far node, apply Barnes-Hut approximation
    if ((width * width) * theta2 < len2) {
        const param = quad.weight / len3;
        node.vx += dx * param;
        node.vy += dy * param;
        return true;
    }
    // near quad, compute force directly
    if (quad.length)
        return false; // internal node, visit children
    // leaf node
    if (quad.data !== node) {
        const param = quad.data.weight / len3;
        node.vx += dx * param;
        node.vy += dy * param;
    }
};
// @ts-ignore
function computeForce(node, tree) {
    // @ts-ignore
    tree.visit((quad, x1, y1, x2, y2) => apply(quad, x1, y1, x2, y2, node));
}
//# sourceMappingURL=ForceNBody.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/force2/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/force2/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Force2Layout: () => (/* binding */ Force2Layout)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./node_modules/@antv/layout/es/layout/base.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util */ "./node_modules/@antv/layout/es/util/index.js");
/* harmony import */ var _ForceNBody__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ForceNBody */ "./node_modules/@antv/layout/es/layout/force2/ForceNBody.js");
/**
 * @fileOverview fruchterman layout
 * @author shiwu.wyy@antfin.com
 */



const proccessToFunc = (value, defaultV) => {
    let func;
    if (!value) {
        func = (d) => {
            return defaultV || 1;
        };
    }
    else if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(value)) {
        func = (d) => {
            return value;
        };
    }
    else {
        func = value;
    }
    return func;
};
/**
 * graphin 中的 force 布局
 */
class Force2Layout extends _base__WEBPACK_IMPORTED_MODULE_0__.Base {
    constructor(options) {
        super();
        /** 停止迭代的最大迭代数 */
        this.maxIteration = 1000;
        /** 是否启动 worker */
        this.workerEnabled = false;
        /** 弹簧引力系数 */
        this.edgeStrength = 200;
        /** 斥力系数 */
        this.nodeStrength = 1000;
        /** 库伦系数 */
        this.coulombDisScale = 0.005;
        /** 阻尼系数 */
        this.damping = 0.9;
        /** 最大速度 */
        this.maxSpeed = 500;
        /** 一次迭代的平均移动距离小于该值时停止迭代 */
        this.minMovement = 0.4;
        /** 迭代中衰减 */
        this.interval = 0.02;
        /** 斥力的一个系数 */
        this.factor = 1;
        /** 理想边长 */
        this.linkDistance = 200;
        /** 重力大小 */
        this.gravity = 0;
        /** 节点聚类作用力系数 */
        this.clusterNodeStrength = 20;
        /** 是否防止重叠 */
        this.preventOverlap = true;
        /** 阈值的使用条件，mean 代表平均移动距离小于 minMovement 时停止迭代，max 代表最大移动距离大时 minMovement 时停时迭代。默认为 mean */
        this.distanceThresholdMode = 'mean';
        /** 每次迭代结束的回调函数 */
        this.tick = () => { };
        this.nodes = [];
        this.edges = [];
        this.width = 300;
        this.height = 300;
        this.nodeMap = {};
        this.nodeIdxMap = {};
        this.judgingDistance = 0;
        /** 默认的向心配置 */
        this.centripetalOptions = {
            leaf: 2,
            single: 2,
            others: 1,
            // eslint-disable-next-line
            center: (n) => {
                return {
                    x: this.width / 2,
                    y: this.height / 2,
                };
            },
        };
        const { getMass } = options;
        this.propsGetMass = getMass;
        this.updateCfg(options);
    }
    getCentripetalOptions() {
        const { leafCluster, clustering, nodeClusterBy, nodes, nodeMap, clusterNodeStrength: propsClusterNodeStrength, } = this;
        const getClusterNodeStrength = (node) => typeof propsClusterNodeStrength === 'function'
            ? propsClusterNodeStrength(node)
            : propsClusterNodeStrength;
        let centripetalOptions = {};
        let sameTypeLeafMap;
        // 如果传入了需要叶子节点聚类
        if (leafCluster) {
            sameTypeLeafMap = this.getSameTypeLeafMap() || {};
            const relativeNodesType = Array.from(new Set(nodes === null || nodes === void 0 ? void 0 : nodes.map((node) => node[nodeClusterBy]))) || [];
            centripetalOptions = {
                single: 100,
                leaf: (node, nodes, edges) => {
                    // 找出与它关联的边的起点或终点出发的所有一度节点中同类型的叶子节点
                    const { relativeLeafNodes, sameTypeLeafNodes } = sameTypeLeafMap[node.id] || {};
                    // 如果都是同一类型或者每种类型只有1个，则施加默认向心力
                    if ((sameTypeLeafNodes === null || sameTypeLeafNodes === void 0 ? void 0 : sameTypeLeafNodes.length) === (relativeLeafNodes === null || relativeLeafNodes === void 0 ? void 0 : relativeLeafNodes.length) ||
                        (relativeNodesType === null || relativeNodesType === void 0 ? void 0 : relativeNodesType.length) === 1) {
                        return 1;
                    }
                    return getClusterNodeStrength(node);
                },
                others: 1,
                center: (node, nodes, edges) => {
                    var _a;
                    const { degree } = ((_a = node.data) === null || _a === void 0 ? void 0 : _a.layout) || {};
                    // 孤点默认给1个远离的中心点
                    if (!degree) {
                        return {
                            x: 100,
                            y: 100,
                        };
                    }
                    let centerNode;
                    if (degree === 1) {
                        // 如果为叶子节点
                        // 找出与它关联的边的起点出发的所有一度节点中同类型的叶子节点
                        const { sameTypeLeafNodes = [] } = sameTypeLeafMap[node.id] || {};
                        if (sameTypeLeafNodes.length === 1) {
                            // 如果同类型的叶子节点只有1个，中心节点置为undefined
                            centerNode = undefined;
                        }
                        else if (sameTypeLeafNodes.length > 1) {
                            // 找出同类型节点平均位置节点的距离最近的节点作为中心节点
                            centerNode = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getAvgNodePosition)(sameTypeLeafNodes);
                        }
                    }
                    else {
                        centerNode = undefined;
                    }
                    return {
                        x: centerNode === null || centerNode === void 0 ? void 0 : centerNode.x,
                        y: centerNode === null || centerNode === void 0 ? void 0 : centerNode.y,
                    };
                },
            };
        }
        // 如果传入了全局节点聚类
        if (clustering) {
            if (!sameTypeLeafMap)
                sameTypeLeafMap = this.getSameTypeLeafMap();
            const clusters = Array.from(new Set(nodes.map((node, i) => {
                return node[nodeClusterBy];
            }))).filter((item) => item !== undefined);
            const centerNodeInfo = {};
            clusters.forEach((cluster) => {
                const sameTypeNodes = nodes
                    .filter((item) => item[nodeClusterBy] === cluster)
                    .map((node) => nodeMap[node.id]);
                // 找出同类型节点平均位置节点的距离最近的节点作为中心节点
                centerNodeInfo[cluster] = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getAvgNodePosition)(sameTypeNodes);
            });
            centripetalOptions = {
                single: (node) => getClusterNodeStrength(node),
                leaf: (node) => getClusterNodeStrength(node),
                others: (node) => getClusterNodeStrength(node),
                center: (node, nodes, edges) => {
                    // 找出同类型节点平均位置节点的距离最近的节点作为中心节点
                    const centerNode = centerNodeInfo[node[nodeClusterBy]];
                    return {
                        x: centerNode === null || centerNode === void 0 ? void 0 : centerNode.x,
                        y: centerNode === null || centerNode === void 0 ? void 0 : centerNode.y,
                    };
                },
            };
        }
        this.centripetalOptions = Object.assign(Object.assign({}, this.centripetalOptions), centripetalOptions);
        const { leaf, single, others } = this.centripetalOptions;
        if (leaf && typeof leaf !== 'function')
            this.centripetalOptions.leaf = () => leaf;
        if (single && typeof single !== 'function')
            this.centripetalOptions.single = () => single;
        if (others && typeof others !== 'function')
            this.centripetalOptions.others = () => others;
    }
    updateCfg(cfg) {
        if (cfg)
            Object.assign(this, cfg);
    }
    getDefaultCfg() {
        return {
            maxIteration: 500,
            gravity: 10,
            enableTick: true,
            animate: true,
        };
    }
    /**
     * 执行布局
     */
    execute() {
        const self = this;
        self.stop();
        const { nodes, edges, defSpringLen } = self;
        self.judgingDistance = 0;
        if (!nodes || nodes.length === 0) {
            self.onLayoutEnd([]);
            return;
        }
        if (!self.width && typeof window !== 'undefined') {
            self.width = window.innerWidth;
        }
        if (!self.height && typeof window !== 'undefined') {
            self.height = window.innerHeight;
        }
        if (!self.center) {
            self.center = [self.width / 2, self.height / 2];
        }
        const center = self.center;
        if (nodes.length === 1) {
            nodes[0].x = center[0];
            nodes[0].y = center[1];
            self.onLayoutEnd([Object.assign({}, nodes[0])]);
            return;
        }
        self.degreesMap = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getDegreeMap)(nodes, edges);
        if (self.propsGetMass) {
            self.getMass = self.propsGetMass;
        }
        else {
            self.getMass = (d) => {
                let massWeight = 1;
                if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(d.mass))
                    massWeight = d.mass;
                const degree = self.degreesMap[d.id].all;
                return !degree || degree < 5 ? massWeight : degree * 5 * massWeight;
            };
        }
        // node size function
        const nodeSize = self.nodeSize;
        let nodeSizeFunc;
        if (self.preventOverlap) {
            const nodeSpacing = self.nodeSpacing;
            let nodeSpacingFunc;
            if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(nodeSpacing)) {
                nodeSpacingFunc = () => nodeSpacing;
            }
            else if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(nodeSpacing)) {
                nodeSpacingFunc = nodeSpacing;
            }
            else {
                nodeSpacingFunc = () => 0;
            }
            if (!nodeSize) {
                nodeSizeFunc = (d) => {
                    if (d.size) {
                        if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(d.size)) {
                            return Math.max(d.size[0], d.size[1]) + nodeSpacingFunc(d);
                        }
                        else if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isObject)(d.size)) {
                            return Math.max(d.size.width, d.size.height) + nodeSpacingFunc(d);
                        }
                        return d.size + nodeSpacingFunc(d);
                    }
                    return 10 + nodeSpacingFunc(d);
                };
            }
            else if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(nodeSize)) {
                nodeSizeFunc = (d) => {
                    return Math.max(nodeSize[0], nodeSize[1]) + nodeSpacingFunc(d);
                };
            }
            else {
                nodeSizeFunc = (d) => nodeSize + nodeSpacingFunc(d);
            }
        }
        self.nodeSize = nodeSizeFunc;
        self.linkDistance = proccessToFunc(self.linkDistance, 1);
        self.nodeStrength = proccessToFunc(self.nodeStrength, 1);
        self.edgeStrength = proccessToFunc(self.edgeStrength, 1);
        const nodeMap = {};
        const nodeIdxMap = {};
        nodes.forEach((node, i) => {
            if (!(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(node.x))
                node.x = Math.random() * self.width;
            if (!(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(node.y))
                node.y = Math.random() * self.height;
            const degree = self.degreesMap[node.id];
            nodeMap[node.id] = Object.assign(Object.assign({}, node), { data: Object.assign(Object.assign({}, node.data), { size: self.nodeSize(node) || 30, layout: {
                        inDegree: degree.in,
                        outDegree: degree.out,
                        degree: degree.all,
                        tDegree: degree.in,
                        sDegree: degree.out,
                        force: {
                            mass: self.getMass(node),
                            nodeStrength: self.nodeStrength(node, edges),
                        },
                    } }) });
            nodeIdxMap[node.id] = i;
        });
        self.nodeMap = nodeMap;
        self.nodeIdxMap = nodeIdxMap;
        self.edgeInfos = [];
        edges === null || edges === void 0 ? void 0 : edges.forEach((edge) => {
            const sourceNode = nodeMap[edge.source];
            const targetNode = nodeMap[edge.target];
            if (!sourceNode || !targetNode) {
                elf.edgeInfos.push({});
            }
            else {
                self.edgeInfos.push({
                    edgeStrength: self.edgeStrength(edge),
                    linkDistance: defSpringLen
                        ? defSpringLen(Object.assign(Object.assign({}, edge), { source: sourceNode, target: targetNode }), sourceNode, targetNode)
                        : self.linkDistance(edge, sourceNode, targetNode) ||
                            1 + (nodeSize(sourceNode) + nodeSize(sourceNode) || 0) / 2,
                });
            }
        });
        this.getCentripetalOptions();
        self.onLayoutEnd = self.onLayoutEnd || (() => { });
        self.run();
    }
    run() {
        const self = this;
        const { maxIteration, nodes, edges, workerEnabled, minMovement, animate, nodeMap, height, } = self;
        self.currentMinY = 0;
        self.currentMaxY = height;
        if (!nodes)
            return;
        const velArray = [];
        nodes.forEach((_, i) => {
            velArray[2 * i] = 0;
            velArray[2 * i + 1] = 0;
        });
        if (this.defSideCoe && typeof this.defSideCoe === 'function') {
            const relatedEdges = {};
            edges.forEach((edge) => {
                const { source, target } = edge;
                relatedEdges[source] = relatedEdges[source] || [];
                relatedEdges[source].push(edge);
                relatedEdges[target] = relatedEdges[target] || [];
                relatedEdges[target].push(edge);
            });
            this.relatedEdges = relatedEdges;
        }
        const maxIter = maxIteration;
        const silence = !animate;
        if (workerEnabled || silence) {
            let usedIter = 0;
            for (let i = 0; (self.judgingDistance > minMovement || i < 1) && i < maxIter; i++) {
                usedIter = i;
                self.runOneStep(i, velArray);
            }
            self.onLayoutEnd(Object.values(nodeMap));
        }
        else {
            if (typeof window === 'undefined')
                return;
            let iter = 0;
            // interval for render the result after each iteration
            this.timeInterval = window.setInterval(() => {
                if (!nodes)
                    return;
                self.runOneStep(iter, velArray);
                iter++;
                if (iter >= maxIter || self.judgingDistance < minMovement) {
                    self.onLayoutEnd(Object.values(nodeMap));
                    window.clearInterval(self.timeInterval);
                }
            }, 0);
        }
    }
    runOneStep(iter, velArray) {
        var _a;
        const self = this;
        const { nodes, edges, nodeMap, monitor } = self;
        const accArray = [];
        if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length))
            return;
        self.calRepulsive(accArray);
        if (edges)
            self.calAttractive(accArray);
        self.calGravity(accArray);
        self.attractToSide(accArray);
        const stepInterval = self.interval; // Math.max(0.02, self.interval - iter * 0.002);
        self.updateVelocity(accArray, velArray, stepInterval);
        self.updatePosition(velArray, stepInterval);
        (_a = self.tick) === null || _a === void 0 ? void 0 : _a.call(self);
        /** 如果需要监控信息，则提供给用户 */
        if (monitor) {
            const energy = this.calTotalEnergy(accArray);
            monitor({ energy, nodes, edges, iterations: iter });
        }
    }
    calTotalEnergy(accArray) {
        const { nodes, nodeMap } = this;
        if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length))
            return 0;
        let energy = 0.0;
        nodes.forEach((node, i) => {
            const vx = accArray[2 * i];
            const vy = accArray[2 * i + 1];
            const speed2 = vx * vx + vy * vy;
            const { mass = 1 } = nodeMap[node.id].data.layout.force;
            energy += mass * speed2 * 0.5; // p = 1/2*(mv^2)
        });
        return energy;
    }
    // coulombs law
    calRepulsive(accArray) {
        const self = this;
        const { nodes, nodeMap, factor, coulombDisScale } = self;
        const nodeSize = self.nodeSize;
        (0,_ForceNBody__WEBPACK_IMPORTED_MODULE_2__.forceNBody)(nodes, nodeMap, factor, coulombDisScale * coulombDisScale, accArray);
    }
    // hooks law
    calAttractive(accArray) {
        const self = this;
        const { edges, nodeMap, nodeIdxMap, edgeInfos } = self;
        const nodeSize = self.nodeSize;
        edges.forEach((edge, i) => {
            const source = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getEdgeTerminal)(edge, 'source');
            const target = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getEdgeTerminal)(edge, 'target');
            const sourceNode = nodeMap[source];
            const targetNode = nodeMap[target];
            if (!sourceNode || !targetNode)
                return;
            let vecX = targetNode.x - sourceNode.x;
            let vecY = targetNode.y - sourceNode.y;
            if (!vecX && !vecY) {
                vecX = Math.random() * 0.01;
                vecY = Math.random() * 0.01;
            }
            const vecLength = Math.sqrt(vecX * vecX + vecY * vecY);
            const direX = vecX / vecLength;
            const direY = vecY / vecLength;
            // @ts-ignore
            const { linkDistance = 200, edgeStrength = 200 } = edgeInfos[i] || {};
            const diff = linkDistance - vecLength;
            const param = diff * edgeStrength;
            const massSource = sourceNode.data.layout.force.mass || 1;
            const massTarget = targetNode.data.layout.force.mass || 1;
            // 质量占比越大，对另一端影响程度越大
            const sourceMassRatio = 1 / massSource;
            const targetMassRatio = 1 / massTarget;
            const disX = direX * param;
            const disY = direY * param;
            const sourceIdx = 2 * nodeIdxMap[source];
            const targetIdx = 2 * nodeIdxMap[target];
            accArray[sourceIdx] -= disX * sourceMassRatio;
            accArray[sourceIdx + 1] -= disY * sourceMassRatio;
            accArray[targetIdx] += disX * targetMassRatio;
            accArray[targetIdx + 1] += disY * targetMassRatio;
        });
    }
    // attract to center
    calGravity(accArray) {
        var _a;
        const self = this;
        const { nodes, edges = [], nodeMap, width, height, center, gravity: defaultGravity, degreesMap, centripetalOptions, } = self;
        if (!nodes)
            return;
        const nodeLength = nodes.length;
        for (let i = 0; i < nodeLength; i++) {
            const idx = 2 * i;
            const node = nodeMap[nodes[i].id];
            const { mass = 1 } = node.data.layout.force;
            let vecX = 0;
            let vecY = 0;
            let gravity = defaultGravity;
            const { in: inDegree, out: outDegree, all: degree } = degreesMap[node.id];
            const forceCenter = (_a = self.getCenter) === null || _a === void 0 ? void 0 : _a.call(self, node, degree);
            if (forceCenter) {
                const [centerX, centerY, strength] = forceCenter;
                vecX = node.x - centerX;
                vecY = node.y - centerY;
                gravity = strength;
            }
            else {
                vecX = node.x - center[0];
                vecY = node.y - center[1];
            }
            if (gravity) {
                accArray[idx] -= (gravity * vecX) / mass;
                accArray[idx + 1] -= (gravity * vecY) / mass;
            }
            if (centripetalOptions) {
                const { leaf, single, others, center: centriCenter, } = centripetalOptions;
                const { x: centriX, y: centriY, centerStrength, } = (centriCenter === null || centriCenter === void 0 ? void 0 : centriCenter(node, nodes, edges, width, height)) || {
                    x: 0,
                    y: 0,
                    centerStrength: 0,
                };
                if (!(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(centriX) || !(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(centriY))
                    continue;
                const vx = (node.x - centriX) / mass;
                const vy = (node.y - centriY) / mass;
                if (centerStrength) {
                    accArray[idx] -= centerStrength * vx;
                    accArray[idx + 1] -= centerStrength * vy;
                }
                // 孤点
                if (degree === 0) {
                    const singleStrength = single(node);
                    if (!singleStrength)
                        continue;
                    accArray[idx] -= singleStrength * vx;
                    accArray[idx + 1] -= singleStrength * vy;
                    continue;
                }
                // 没有出度或没有入度，都认为是叶子节点
                if (inDegree === 0 || outDegree === 0) {
                    const leafStrength = leaf(node, nodes, edges);
                    if (!leafStrength)
                        continue;
                    accArray[idx] -= leafStrength * vx;
                    accArray[idx + 1] -= leafStrength * vy;
                    continue;
                }
                /** others */
                const othersStrength = others(node);
                if (!othersStrength)
                    continue;
                accArray[idx] -= othersStrength * vx;
                accArray[idx + 1] -= othersStrength * vy;
            }
        }
    }
    /**
     * Attract forces to the top and bottom.
     * @param accArray
     * @returns
     */
    attractToSide(accArray) {
        const { defSideCoe, height, nodes, relatedEdges, currentMinY = 0, currentMaxY = this.height, } = this;
        if (!defSideCoe || typeof defSideCoe !== 'function' || !(nodes === null || nodes === void 0 ? void 0 : nodes.length))
            return;
        nodes.forEach((node, i) => {
            const sideCoe = defSideCoe(node, relatedEdges[node.id] || []);
            if (sideCoe === 0)
                return;
            const targetY = sideCoe < 0 ? currentMinY : currentMaxY;
            const strength = Math.abs(sideCoe);
            accArray[2 * i + 1] -= strength * (node.y - targetY);
        });
    }
    updateVelocity(accArray, velArray, stepInterval) {
        const self = this;
        const { nodes, damping, maxSpeed } = self;
        if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length))
            return;
        nodes.forEach((_, i) => {
            let vx = (velArray[2 * i] + accArray[2 * i] * stepInterval) * damping || 0.01;
            let vy = (velArray[2 * i + 1] + accArray[2 * i + 1] * stepInterval) * damping ||
                0.01;
            const vLength = Math.sqrt(vx * vx + vy * vy);
            if (vLength > maxSpeed) {
                const param2 = maxSpeed / vLength;
                vx = param2 * vx;
                vy = param2 * vy;
            }
            velArray[2 * i] = vx;
            velArray[2 * i + 1] = vy;
        });
    }
    updatePosition(velArray, stepInterval) {
        const self = this;
        const { nodes, distanceThresholdMode, nodeMap } = self;
        if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length)) {
            this.judgingDistance = 0;
            return;
        }
        let sum = 0;
        if (distanceThresholdMode === 'max')
            self.judgingDistance = -Infinity;
        else if (distanceThresholdMode === 'min')
            self.judgingDistance = Infinity;
        let currentMinY = Infinity;
        let currentMaxY = -Infinity;
        nodes.forEach((node, i) => {
            const mappedNode = nodeMap[node.id];
            if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(node.fx) && (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(node.fy)) {
                node.x = node.fx;
                node.y = node.fy;
                mappedNode.x = node.x;
                mappedNode.y = node.y;
                return;
            }
            const distX = velArray[2 * i] * stepInterval;
            const distY = velArray[2 * i + 1] * stepInterval;
            node.x += distX;
            node.y += distY;
            mappedNode.x = node.x;
            mappedNode.y = node.y;
            if (node.y < currentMinY)
                currentMinY = node.y;
            if (node.y > currentMaxY)
                currentMaxY = node.y;
            const distanceMagnitude = Math.sqrt(distX * distX + distY * distY);
            switch (distanceThresholdMode) {
                case 'max':
                    if (self.judgingDistance < distanceMagnitude)
                        self.judgingDistance = distanceMagnitude;
                    break;
                case 'min':
                    if (self.judgingDistance > distanceMagnitude)
                        self.judgingDistance = distanceMagnitude;
                    break;
                default:
                    sum = sum + distanceMagnitude;
                    break;
            }
        });
        this.currentMinY = currentMinY;
        this.currentMaxY = currentMaxY;
        if (!distanceThresholdMode || distanceThresholdMode === 'mean')
            self.judgingDistance = sum / nodes.length;
    }
    stop() {
        if (this.timeInterval && typeof window !== 'undefined') {
            window.clearInterval(this.timeInterval);
        }
    }
    destroy() {
        const self = this;
        self.stop();
        self.tick = null;
        self.nodes = null;
        self.edges = null;
        self.destroyed = true;
    }
    getType() {
        return 'force2';
    }
    getSameTypeLeafMap() {
        const { nodeClusterBy, nodes, edges, nodeMap, degreesMap } = this;
        if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length))
            return;
        // eslint-disable-next-line
        const sameTypeLeafMap = {};
        nodes.forEach((node, i) => {
            const degree = degreesMap[node.id].all;
            if (degree === 1) {
                sameTypeLeafMap[node.id] = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getCoreNodeAndRelativeLeafNodes)('leaf', node, edges, nodeClusterBy, degreesMap, nodeMap);
            }
        });
        return sameTypeLeafMap;
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/forceAtlas2/body.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/forceAtlas2/body.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Body)
/* harmony export */ });
// represents a body(a point mass) and its position
class Body {
    constructor(params) {
        /**
         * the id of this body, the same with the node id
         * @type  {number}
         */
        this.id = params.id || 0;
        /**
         * the position of this body
         * @type  {number}
         */
        this.rx = params.rx;
        /**
         * the position of this body
         * @type  {number}
         */
        this.ry = params.ry;
        /**
         * the force acting on this body
         * @type  {number}
         */
        this.fx = 0;
        /**
         * the force acting on this body
         * @type  {number}
         */
        this.fy = 0;
        /**
         * the mass of this body, =1 for a node
         * @type  {number}
         */
        this.mass = params.mass;
        /**
         * the degree of the node represented by this body
         * @type  {number}
         */
        this.degree = params.degree;
        /**
         * the parameter for repulsive force, = kr
         * @type  {number}
         */
        this.g = params.g || 0;
    }
    // returns the euclidean distance
    distanceTo(bo) {
        const dx = this.rx - bo.rx;
        const dy = this.ry - bo.ry;
        return Math.hypot(dx, dy);
    }
    setPos(x, y) {
        this.rx = x;
        this.ry = y;
    }
    // resets the forces
    resetForce() {
        this.fx = 0;
        this.fy = 0;
    }
    addForce(b) {
        const dx = b.rx - this.rx;
        const dy = b.ry - this.ry;
        let dist = Math.hypot(dx, dy);
        dist = dist < 0.0001 ? 0.0001 : dist;
        // the repulsive defined by force atlas 2
        const F = (this.g * (this.degree + 1) * (b.degree + 1)) / dist;
        this.fx += F * dx / dist;
        this.fy += F * dy / dist;
    }
    // if quad contains this body
    in(quad) {
        return quad.contains(this.rx, this.ry);
    }
    // returns a new body
    add(bo) {
        const nenwMass = this.mass + bo.mass;
        const x = (this.rx * this.mass + bo.rx * bo.mass) / nenwMass;
        const y = (this.ry * this.mass + bo.ry * bo.mass) / nenwMass;
        const dg = this.degree + bo.degree;
        const params = {
            rx: x,
            ry: y,
            mass: nenwMass,
            degree: dg
        };
        return new Body(params);
    }
}
//# sourceMappingURL=body.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/forceAtlas2/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/forceAtlas2/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ForceAtlas2Layout: () => (/* binding */ ForceAtlas2Layout)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./node_modules/@antv/layout/es/layout/base.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util */ "./node_modules/@antv/layout/es/util/index.js");
/* harmony import */ var _body__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./body */ "./node_modules/@antv/layout/es/layout/forceAtlas2/body.js");
/* harmony import */ var _quad__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./quad */ "./node_modules/@antv/layout/es/layout/forceAtlas2/quad.js");
/* harmony import */ var _quadTree__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./quadTree */ "./node_modules/@antv/layout/es/layout/forceAtlas2/quadTree.js");





class ForceAtlas2Layout extends _base__WEBPACK_IMPORTED_MODULE_0__.Base {
    constructor(options) {
        super();
        /** 布局中心 */
        this.center = [0, 0];
        /** 宽度 */
        this.width = 300;
        /** 高度 */
        this.height = 300;
        this.nodes = [];
        this.edges = [];
        /**
         * the parameter for repulsive forces,
         * it will scale the layout but won't change the layout
         * larger the kr, looser the layout
         * @type  {number}
         */
        this.kr = 5;
        /**
         * the parameter for gravity forces
         * @type  {number}
         */
        this.kg = 1;
        /**
         * modes:
         * 'normal' for normal using
         * 'linlog' for compact clusters.
         * @type  {string}
         */
        this.mode = 'normal';
        /**
         * whether preventing the node overlapping
         * @type  {boolean}
         */
        this.preventOverlap = false;
        /**
         * whether active the dissuade hub mode
         * true: grant authorities (nodes with a high indegree)
         * a more central position than hubs (nodes with a high outdegree)
         * @type  {boolean}
         */
        this.dissuadeHubs = false;
        /**
         * whether active the barnes hut optimization on computing repulsive forces
         * @type  {boolean}
         */
        this.barnesHut = undefined;
        /**
         * the max iteration number
         * @type  {number}
         */
        this.maxIteration = 0;
        /**
         * control the global velocity
         * defualt: 0.1(gephi)
         * @type  {number}
         */
        this.ks = 0.1;
        /**
         * the max global velocity
         * @type  {number}
         */
        this.ksmax = 10;
        /**
         * the tolerance for the global swinging
         * @type  {number}
         */
        this.tao = 0.1;
        /**
         * the function of layout complete listener, display the legend and minimap after layout
         * @type  {function}
         */
        this.onLayoutEnd = () => { };
        /**
         * activate prune or not.
         * prune the leaves during most iterations, layout the leaves in the last 50 iteraitons.
         * if prune === '', it will be activated when the nodes number > 100
         * note that it will reduce the quality of the layout
         * @type  {boolean}
         */
        this.prune = undefined;
        this.updateCfg(options);
    }
    getDefaultCfg() {
        return {};
    }
    // execute the layout
    execute() {
        const self = this;
        const { nodes, onLayoutEnd, prune, } = self;
        let maxIteration = self.maxIteration;
        if (!self.width && typeof window !== "undefined") {
            self.width = window.innerWidth;
        }
        if (!self.height && typeof window !== "undefined") {
            self.height = window.innerHeight;
        }
        // the whidth of each nodes
        const sizes = [];
        const nodeNum = nodes.length;
        for (let i = 0; i < nodeNum; i += 1) {
            const node = nodes[i];
            let nodeWidth = 10;
            let nodeHeight = 10;
            if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(node.size)) {
                nodeWidth = node.size;
                nodeHeight = node.size;
            }
            if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(node.size)) {
                if (!isNaN(node.size[0]))
                    nodeWidth = node.size[0];
                if (!isNaN(node.size[1]))
                    nodeHeight = node.size[1];
            }
            else if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isObject)(node.size)) {
                nodeWidth = node.size.width;
                nodeHeight = node.size.height;
            }
            if (self.getWidth && !isNaN(self.getWidth(node)))
                nodeHeight = self.getWidth(node);
            if (self.getHeight && !isNaN(self.getHeight(node)))
                nodeWidth = self.getHeight(node);
            const maxSize = Math.max(nodeWidth, nodeHeight);
            sizes.push(maxSize);
        }
        if (self.barnesHut === undefined && nodeNum > 250)
            self.barnesHut = true;
        if (self.prune === undefined && nodeNum > 100)
            self.prune = true;
        if (this.maxIteration === 0 && !self.prune) {
            maxIteration = 250;
            if (nodeNum <= 200 && nodeNum > 100)
                maxIteration = 1000;
            else if (nodeNum > 200)
                maxIteration = 1200;
            this.maxIteration = maxIteration;
        }
        else if (this.maxIteration === 0 && prune) {
            maxIteration = 100;
            if (nodeNum <= 200 && nodeNum > 100)
                maxIteration = 500;
            else if (nodeNum > 200)
                maxIteration = 950;
            this.maxIteration = maxIteration;
        }
        if (!self.kr) {
            self.kr = 50;
            if (nodeNum > 100 && nodeNum <= 500)
                self.kr = 20;
            else if (nodeNum > 500)
                self.kr = 1;
        }
        if (!self.kg) {
            self.kg = 20;
            if (nodeNum > 100 && nodeNum <= 500)
                self.kg = 10;
            else if (nodeNum > 500)
                self.kg = 1;
        }
        this.nodes = self.updateNodesByForces(sizes);
        onLayoutEnd();
    }
    updateNodesByForces(sizes) {
        const self = this;
        const { edges, maxIteration } = self;
        let nodes = self.nodes;
        const nonLoopEdges = edges.filter((edge) => {
            const source = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getEdgeTerminal)(edge, 'source');
            const target = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getEdgeTerminal)(edge, 'target');
            return source !== target;
        });
        const size = nodes.length;
        const esize = nonLoopEdges.length;
        const degrees = [];
        const idMap = {};
        const edgeEndsIdMap = {};
        // tslint:disable-next-line
        const Es = [];
        for (let i = 0; i < size; i += 1) {
            idMap[nodes[i].id] = i;
            degrees[i] = 0;
            if (nodes[i].x === undefined || isNaN(nodes[i].x)) {
                nodes[i].x = Math.random() * 1000;
            }
            if (nodes[i].y === undefined || isNaN(nodes[i].y)) {
                nodes[i].y = Math.random() * 1000;
            }
            Es.push({ x: nodes[i].x, y: nodes[i].y });
        }
        for (let i = 0; i < esize; i += 1) {
            let node1;
            let node2;
            let sIdx = 0;
            let tIdx = 0;
            for (let j = 0; j < size; j += 1) {
                const source = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getEdgeTerminal)(nonLoopEdges[i], 'source');
                const target = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getEdgeTerminal)(nonLoopEdges[i], 'target');
                if (nodes[j].id === source) {
                    node1 = nodes[j];
                    sIdx = j;
                }
                else if (nodes[j].id === target) {
                    node2 = nodes[j];
                    tIdx = j;
                }
                edgeEndsIdMap[i] = { sourceIdx: sIdx, targetIdx: tIdx };
            }
            if (node1)
                degrees[idMap[node1.id]] += 1;
            if (node2)
                degrees[idMap[node2.id]] += 1;
        }
        let iteration = maxIteration;
        nodes = this.iterate(iteration, idMap, edgeEndsIdMap, esize, degrees, sizes);
        // if prune, place the leaves around their parents, and then re-layout for several iterations.
        if (self.prune) {
            for (let j = 0; j < esize; j += 1) {
                if (degrees[edgeEndsIdMap[j].sourceIdx] <= 1) {
                    nodes[edgeEndsIdMap[j].sourceIdx].x = nodes[edgeEndsIdMap[j].targetIdx].x;
                    nodes[edgeEndsIdMap[j].sourceIdx].y = nodes[edgeEndsIdMap[j].targetIdx].y;
                }
                else if (degrees[edgeEndsIdMap[j].targetIdx] <= 1) {
                    nodes[edgeEndsIdMap[j].targetIdx].x = nodes[edgeEndsIdMap[j].sourceIdx].x;
                    nodes[edgeEndsIdMap[j].targetIdx].y = nodes[edgeEndsIdMap[j].sourceIdx].y;
                }
            }
            self.prune = false;
            self.barnesHut = false;
            iteration = 100;
            nodes = this.iterate(iteration, idMap, edgeEndsIdMap, esize, degrees, sizes);
        }
        return nodes;
    }
    iterate(iteration, idMap, edgeEndsIdMap, esize, degrees, sizes) {
        const self = this;
        let { nodes } = self;
        const { kr, preventOverlap } = self;
        const { barnesHut } = self;
        const nodeNum = nodes.length;
        let sg = 0;
        const krPrime = 100;
        let iter = iteration;
        const prevoIter = 50;
        let forces = [];
        const preForces = [];
        const bodies = [];
        for (let i = 0; i < nodeNum; i += 1) {
            forces[2 * i] = 0;
            forces[2 * i + 1] = 0;
            if (barnesHut) {
                const params = {
                    id: i,
                    rx: nodes[i].x,
                    ry: nodes[i].y,
                    mass: 1,
                    g: kr,
                    degree: degrees[i]
                };
                bodies[i] = new _body__WEBPACK_IMPORTED_MODULE_2__["default"](params);
            }
        }
        while (iter > 0) {
            for (let i = 0; i < nodeNum; i += 1) {
                preForces[2 * i] = forces[2 * i];
                preForces[2 * i + 1] = forces[2 * i + 1];
                forces[2 * i] = 0;
                forces[2 * i + 1] = 0;
            }
            // attractive forces, existing on every actual edge
            forces = this.getAttrForces(iter, prevoIter, esize, idMap, edgeEndsIdMap, degrees, sizes, forces);
            // repulsive forces and Gravity, existing on every node pair
            // if preventOverlap, using the no-optimized method in the last prevoIter instead.
            if (barnesHut && ((preventOverlap && iter > prevoIter) || !preventOverlap)) {
                forces = this.getOptRepGraForces(forces, bodies, degrees);
            }
            else {
                forces = this.getRepGraForces(iter, prevoIter, forces, krPrime, sizes, degrees);
            }
            // update the positions
            const res = this.updatePos(forces, preForces, sg, degrees);
            nodes = res.nodes;
            sg = res.sg;
            iter--;
            if (self.tick)
                self.tick();
        }
        return nodes;
    }
    getAttrForces(iter, prevoIter, esize, idMap, edgeEndsIdMap, degrees, sizes, forces) {
        const self = this;
        const { nodes, preventOverlap, dissuadeHubs, mode, prune } = self;
        for (let i = 0; i < esize; i += 1) {
            const sourceNode = nodes[edgeEndsIdMap[i].sourceIdx];
            const sourceIdx = edgeEndsIdMap[i].sourceIdx;
            const targetNode = nodes[edgeEndsIdMap[i].targetIdx];
            const targetIdx = edgeEndsIdMap[i].targetIdx;
            if (prune && (degrees[sourceIdx] <= 1 || degrees[targetIdx] <= 1))
                continue;
            const dir = [targetNode.x - sourceNode.x, targetNode.y - sourceNode.y];
            let eucliDis = Math.hypot(dir[0], dir[1]);
            eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;
            dir[0] = dir[0] / eucliDis;
            dir[1] = dir[1] / eucliDis;
            if (preventOverlap && iter < prevoIter)
                eucliDis = eucliDis - sizes[sourceIdx] - sizes[targetIdx];
            let Fa1 = eucliDis; // tslint:disable-line
            let Fa2 = Fa1; // tslint:disable-line
            if (mode === 'linlog') {
                Fa1 = Math.log(1 + eucliDis);
                Fa2 = Fa1;
            }
            if (dissuadeHubs) {
                Fa1 = eucliDis / degrees[sourceIdx];
                Fa2 = eucliDis / degrees[targetIdx];
            }
            if (preventOverlap && iter < prevoIter && eucliDis <= 0) {
                Fa1 = 0;
                Fa2 = 0;
            }
            else if (preventOverlap && iter < prevoIter && eucliDis > 0) {
                Fa1 = eucliDis;
                Fa2 = eucliDis;
            }
            forces[2 * idMap[sourceNode.id]] += Fa1 * dir[0];
            forces[2 * idMap[targetNode.id]] -= Fa2 * dir[0];
            forces[2 * idMap[sourceNode.id] + 1] += Fa1 * dir[1];
            forces[2 * idMap[targetNode.id] + 1] -= Fa2 * dir[1];
        }
        return forces;
    }
    getRepGraForces(iter, prevoIter, forces, krPrime, sizes, degrees) {
        const self = this;
        const { nodes, preventOverlap, kr, kg, center, prune } = self;
        const nodeNum = nodes.length;
        for (let i = 0; i < nodeNum; i += 1) {
            for (let j = i + 1; j < nodeNum; j += 1) {
                if (prune && (degrees[i] <= 1 || degrees[j] <= 1))
                    continue;
                const dir = [nodes[j].x - nodes[i].x, nodes[j].y - nodes[i].y];
                let eucliDis = Math.hypot(dir[0], dir[1]);
                eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;
                dir[0] = dir[0] / eucliDis;
                dir[1] = dir[1] / eucliDis;
                if (preventOverlap && iter < prevoIter)
                    eucliDis = eucliDis - sizes[i] - sizes[j];
                let Fr = kr * (degrees[i] + 1) * (degrees[j] + 1) / eucliDis; // tslint:disable-line
                if (preventOverlap && iter < prevoIter && eucliDis < 0) {
                    Fr = krPrime * (degrees[i] + 1) * (degrees[j] + 1);
                }
                else if (preventOverlap && iter < prevoIter && eucliDis === 0) {
                    Fr = 0;
                }
                else if (preventOverlap && iter < prevoIter && eucliDis > 0) {
                    Fr = kr * (degrees[i] + 1) * (degrees[j] + 1) / eucliDis;
                }
                forces[2 * i] -= Fr * dir[0];
                forces[2 * j] += Fr * dir[0];
                forces[2 * i + 1] -= Fr * dir[1];
                forces[2 * j + 1] += Fr * dir[1];
            }
            // gravity
            const dir = [nodes[i].x - center[0], nodes[i].y - center[1]];
            const eucliDis = Math.hypot(dir[0], dir[1]);
            dir[0] = dir[0] / eucliDis;
            dir[1] = dir[1] / eucliDis;
            const Fg = kg * (degrees[i] + 1); // tslint:disable-line
            forces[2 * i] -= Fg * dir[0];
            forces[2 * i + 1] -= Fg * dir[1];
        }
        return forces;
    }
    getOptRepGraForces(forces, bodies, degrees) {
        const self = this;
        const { nodes, kg, center, prune } = self;
        const nodeNum = nodes.length;
        let minx = 9e10;
        let maxx = -9e10;
        let miny = 9e10;
        let maxy = -9e10;
        for (let i = 0; i < nodeNum; i += 1) {
            if (prune && (degrees[i] <= 1))
                continue;
            bodies[i].setPos(nodes[i].x, nodes[i].y);
            if (nodes[i].x >= maxx)
                maxx = nodes[i].x;
            if (nodes[i].x <= minx)
                minx = nodes[i].x;
            if (nodes[i].y >= maxy)
                maxy = nodes[i].y;
            if (nodes[i].y <= miny)
                miny = nodes[i].y;
        }
        const width = Math.max(maxx - minx, maxy - miny);
        const quadParams = {
            xmid: (maxx + minx) / 2,
            ymid: (maxy + miny) / 2,
            length: width,
            massCenter: center,
            mass: nodeNum
        };
        const quad = new _quad__WEBPACK_IMPORTED_MODULE_3__["default"](quadParams);
        const quadTree = new _quadTree__WEBPACK_IMPORTED_MODULE_4__["default"](quad);
        // build the tree, insert the nodes(quads) into the tree
        for (let i = 0; i < nodeNum; i += 1) {
            if (prune && (degrees[i] <= 1))
                continue;
            if (bodies[i].in(quad))
                quadTree.insert(bodies[i]);
        }
        // update the repulsive forces and the gravity.
        for (let i = 0; i < nodeNum; i += 1) {
            if (prune && (degrees[i] <= 1))
                continue;
            bodies[i].resetForce();
            quadTree.updateForce(bodies[i]);
            forces[2 * i] -= bodies[i].fx;
            forces[2 * i + 1] -= bodies[i].fy;
            // gravity
            const dir = [nodes[i].x - center[0], nodes[i].y - center[1]];
            let eucliDis = Math.hypot(dir[0], dir[1]);
            eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;
            dir[0] = dir[0] / eucliDis;
            dir[1] = dir[1] / eucliDis;
            const Fg = kg * (degrees[i] + 1); // tslint:disable-line
            forces[2 * i] -= Fg * dir[0];
            forces[2 * i + 1] -= Fg * dir[1];
        }
        return forces;
    }
    updatePos(forces, preForces, sg, degrees) {
        const self = this;
        const { nodes, ks, tao, prune, ksmax } = self;
        const nodeNum = nodes.length;
        const swgns = [];
        const trans = [];
        // swg(G) and tra(G)
        let swgG = 0;
        let traG = 0;
        for (let i = 0; i < nodeNum; i += 1) {
            if (prune && (degrees[i] <= 1))
                continue;
            const minus = [forces[2 * i] - preForces[2 * i],
                forces[2 * i + 1] - preForces[2 * i + 1]
            ];
            const minusNorm = Math.hypot(minus[0], minus[1]);
            const add = [forces[2 * i] + preForces[2 * i],
                forces[2 * i + 1] + preForces[2 * i + 1]
            ];
            const addNorm = Math.hypot(add[0], add[1]);
            swgns[i] = minusNorm;
            trans[i] = addNorm / 2;
            swgG += (degrees[i] + 1) * swgns[i];
            traG += (degrees[i] + 1) * trans[i];
        }
        const preSG = sg;
        sg = tao * traG / swgG; // tslint:disable-line
        if (preSG !== 0) {
            sg = sg > (1.5 * preSG) ? (1.5 * preSG) : sg; // tslint:disable-line
        }
        // update the node positions
        for (let i = 0; i < nodeNum; i += 1) {
            if (prune && (degrees[i] <= 1))
                continue;
            if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(nodes[i].fx) && (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(nodes[i].fy))
                continue;
            let sn = ks * sg / (1 + sg * Math.sqrt(swgns[i]));
            let absForce = Math.hypot(forces[2 * i], forces[2 * i + 1]);
            absForce = absForce < 0.0001 ? 0.0001 : absForce;
            const max = ksmax / absForce;
            sn = sn > max ? max : sn;
            const dnx = sn * forces[2 * i];
            const dny = sn * forces[2 * i + 1];
            nodes[i].x += dnx;
            nodes[i].y += dny;
        }
        return { nodes, sg };
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/forceAtlas2/quad.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/forceAtlas2/quad.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Quad)
/* harmony export */ });
class Quad {
    constructor(params) {
        /**
         * the center position of this quad
         * @type  {number}
         */
        this.xmid = params.xmid;
        /**
         * the center position of this quad
         * @type  {number}
         */
        this.ymid = params.ymid;
        /**
         * the length of this quad
         * @type  {number}
         */
        this.length = params.length;
        /**
         * the mass center of this quad
         * @type  {number}
         */
        this.massCenter = params.massCenter || [0, 0];
        /**
         * the mass of this quad
         * @type  {number}
         */
        this.mass = params.mass || 1;
    }
    getLength() {
        return this.length;
    }
    contains(x, y) {
        const halfLen = this.length / 2;
        return (x <= this.xmid + halfLen &&
            x >= this.xmid - halfLen &&
            y <= this.ymid + halfLen &&
            y >= this.ymid - halfLen);
    }
    // northwest quadrant
    // tslint:disable-next-line
    NW() {
        const x = this.xmid - this.length / 4;
        const y = this.ymid + this.length / 4;
        const len = this.length / 2;
        const params = {
            xmid: x,
            ymid: y,
            length: len
        };
        const NW = new Quad(params);
        return NW;
    }
    // northeast
    // tslint:disable-next-line
    NE() {
        const x = this.xmid + this.length / 4;
        const y = this.ymid + this.length / 4;
        const len = this.length / 2;
        const params = {
            xmid: x,
            ymid: y,
            length: len
        };
        const NE = new Quad(params);
        return NE;
    }
    // southwest
    // tslint:disable-next-line
    SW() {
        const x = this.xmid - this.length / 4;
        const y = this.ymid - this.length / 4;
        const len = this.length / 2;
        const params = {
            xmid: x,
            ymid: y,
            length: len
        };
        const SW = new Quad(params);
        return SW;
    }
    // southeast
    // tslint:disable-next-line
    SE() {
        const x = this.xmid + this.length / 4;
        const y = this.ymid - this.length / 4;
        const len = this.length / 2;
        const params = {
            xmid: x,
            ymid: y,
            length: len
        };
        const SE = new Quad(params);
        return SE;
    }
}
//# sourceMappingURL=quad.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/forceAtlas2/quadTree.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/forceAtlas2/quadTree.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ QuadTree)
/* harmony export */ });
/**
 * @fileOverview quadTree
 * @author shiwu.wyy@antfin.com
 */
class QuadTree {
    // each quadtree represents a quadrant and an aggregate body
    // that represents all bodies inside the quadrant
    constructor(param) {
        /**
         * (aggregated) body in this quad
         * @type  {object}
         */
        this.body = null;
        /**
         * tree representing the northwest quadrant
         * @type  {object}
         */
        this.quad = null;
        this.NW = null;
        this.NE = null;
        this.SW = null;
        this.SE = null;
        /**
         * threshold
         * @type  {number}
         */
        this.theta = 0.5;
        if (param != null)
            this.quad = param;
    }
    // insert a body(node) into the tree
    insert(bo) {
        // if this node does not contain a body, put the new body bo here
        if (this.body == null) {
            this.body = bo;
            return;
        }
        // internal node
        if (!this._isExternal()) {
            // update mass info
            this.body = this.body.add(bo);
            // insert body into quadrant
            this._putBody(bo);
        }
        else { // external node
            // divide this region into four children
            if (this.quad) {
                this.NW = new QuadTree(this.quad.NW());
                this.NE = new QuadTree(this.quad.NE());
                this.SW = new QuadTree(this.quad.SW());
                this.SE = new QuadTree(this.quad.SE());
            }
            // insert this body and bo
            this._putBody(this.body);
            this._putBody(bo);
            // update the mass info
            this.body = this.body.add(bo);
        }
    }
    // inserts bo into a quad
    // tslint:disable-next-line
    _putBody(bo) {
        if (!this.quad)
            return;
        if (bo.in(this.quad.NW()) && this.NW)
            this.NW.insert(bo);
        else if (bo.in(this.quad.NE()) && this.NE)
            this.NE.insert(bo);
        else if (bo.in(this.quad.SW()) && this.SW)
            this.SW.insert(bo);
        else if (bo.in(this.quad.SE()) && this.SE)
            this.SE.insert(bo);
    }
    // tslint:disable-next-line
    _isExternal() {
        // four children are null
        return (this.NW == null && this.NE == null && this.SW == null && this.SE == null);
    }
    // update the forces
    updateForce(bo) {
        if (this.body == null || bo === this.body) {
            return;
        }
        // if the current node is external
        if (this._isExternal())
            bo.addForce(this.body);
        // internal nodes
        else {
            const s = this.quad ? this.quad.getLength() : 0;
            const d = this.body.distanceTo(bo);
            // b is far enough
            if ((s / d) < this.theta)
                bo.addForce(this.body);
            else {
                this.NW && this.NW.updateForce(bo);
                this.NE && this.NE.updateForce(bo);
                this.SW && this.SW.updateForce(bo);
                this.SE && this.SE.updateForce(bo);
            }
        }
    }
}
//# sourceMappingURL=quadTree.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/force/force-in-a-box.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/force/force-in-a-box.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ forceInABox)
/* harmony export */ });
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/simulation.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/x.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/y.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/collide.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/manyBody.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/link.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ "./node_modules/@antv/layout/es/util/index.js");


// https://github.com/john-guerra/forceInABox/blob/master/src/forceInABox.js
function forceInABox() {
    function constant(_) {
        return () => _;
    }
    let groupBy = (d) => {
        return d.cluster;
    };
    let forceNodeSize = constant(1);
    let forceCharge = constant(-1);
    let forceLinkDistance = constant(100);
    let forceLinkStrength = constant(0.1);
    let offset = [0, 0];
    let nodes = [];
    let nodesMap = {};
    let links = [];
    let centerX = 100;
    let centerY = 100;
    let foci = {
        none: {
            x: 0,
            y: 0,
        },
    };
    let templateNodes = [];
    let templateForce;
    let template = 'force';
    let enableGrouping = true;
    let strength = 0.1;
    function force(alpha) {
        if (!enableGrouping) {
            return force;
        }
        templateForce.tick();
        getFocisFromTemplate();
        for (let i = 0, n = nodes.length, node, k = alpha * strength; i < n; ++i) {
            node = nodes[i];
            node.vx += (foci[groupBy(node)].x - node.x) * k;
            node.vy += (foci[groupBy(node)].y - node.y) * k;
        }
    }
    function initialize() {
        if (!nodes)
            return;
        initializeWithForce();
    }
    function initializeWithForce() {
        if (!nodes || !nodes.length) {
            return;
        }
        if (groupBy(nodes[0]) === undefined) {
            throw Error("Couldnt find the grouping attribute for the nodes. Make sure to set it up with forceInABox.groupBy('clusterAttr') before calling .links()");
        }
        // checkLinksAsObjects();
        const net = getGroupsGraph();
        templateForce = d3_force__WEBPACK_IMPORTED_MODULE_1__["default"](net.nodes)
            .force('x', d3_force__WEBPACK_IMPORTED_MODULE_2__["default"](centerX).strength(0.1))
            .force('y', d3_force__WEBPACK_IMPORTED_MODULE_3__["default"](centerY).strength(0.1))
            .force('collide', d3_force__WEBPACK_IMPORTED_MODULE_4__["default"]((d) => d.r).iterations(4))
            .force('charge', d3_force__WEBPACK_IMPORTED_MODULE_5__["default"]().strength(forceCharge))
            .force('links', d3_force__WEBPACK_IMPORTED_MODULE_6__["default"](net.nodes.length ? net.links : [])
            .distance(forceLinkDistance)
            .strength(forceLinkStrength));
        templateNodes = templateForce.nodes();
        getFocisFromTemplate();
    }
    function getGroupsGraph() {
        const gnodes = [];
        const glinks = [];
        const dNodes = {};
        let clustersList = [];
        let clustersCounts = {};
        let clustersLinks = [];
        clustersCounts = computeClustersNodeCounts(nodes);
        clustersLinks = computeClustersLinkCounts(links);
        clustersList = Object.keys(clustersCounts);
        clustersList.forEach((key, index) => {
            const val = clustersCounts[key];
            // Uses approx meta-node size
            gnodes.push({
                id: key,
                size: val.count,
                r: Math.sqrt(val.sumforceNodeSize / Math.PI),
            });
            dNodes[key] = index;
        });
        clustersLinks.forEach((l) => {
            const sourceTerminal = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getEdgeTerminal)(l, 'source');
            const targetTerminal = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getEdgeTerminal)(l, 'target');
            const source = dNodes[sourceTerminal];
            const target = dNodes[targetTerminal];
            if (source !== undefined && target !== undefined) {
                glinks.push({
                    source,
                    target,
                    count: l.count,
                });
            }
        });
        return {
            nodes: gnodes,
            links: glinks,
        };
    }
    function computeClustersNodeCounts(nodes) {
        const clustersCounts = {};
        nodes.forEach((d) => {
            const key = groupBy(d);
            if (!clustersCounts[key]) {
                clustersCounts[key] = {
                    count: 0,
                    sumforceNodeSize: 0,
                };
            }
        });
        nodes.forEach((d) => {
            const key = groupBy(d);
            const nodeSize = forceNodeSize(d);
            const tmpCount = clustersCounts[key];
            tmpCount.count = tmpCount.count + 1;
            tmpCount.sumforceNodeSize =
                tmpCount.sumforceNodeSize + Math.PI * (nodeSize * nodeSize) * 1.3;
            clustersCounts[key] = tmpCount;
        });
        return clustersCounts;
    }
    function computeClustersLinkCounts(links) {
        const dClusterLinks = {};
        const clusterLinks = [];
        links.forEach((l) => {
            const key = getLinkKey(l);
            let count = 0;
            if (dClusterLinks[key] !== undefined) {
                count = dClusterLinks[key];
            }
            count += 1;
            dClusterLinks[key] = count;
        });
        // @ts-ignore
        const entries = Object.entries(dClusterLinks);
        entries.forEach(([key, count]) => {
            const source = key.split('~')[0];
            const target = key.split('~')[1];
            if (source !== undefined && target !== undefined) {
                clusterLinks.push({
                    source,
                    target,
                    count,
                });
            }
        });
        return clusterLinks;
    }
    function getFocisFromTemplate() {
        foci = {
            none: {
                x: 0,
                y: 0,
            },
        };
        templateNodes.forEach((d) => {
            foci[d.id] = {
                x: d.x - offset[0],
                y: d.y - offset[1],
            };
        });
        return foci;
    }
    function getLinkKey(l) {
        const source = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getEdgeTerminal)(l, 'source');
        const target = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getEdgeTerminal)(l, 'target');
        const sourceID = groupBy(nodesMap[source]);
        const targetID = groupBy(nodesMap[target]);
        return sourceID <= targetID
            ? `${sourceID}~${targetID}`
            : `${targetID}~${sourceID}`;
    }
    function genNodesMap(nodes) {
        nodesMap = {};
        nodes.forEach((node) => {
            nodesMap[node.id] = node;
        });
    }
    function setTemplate(x) {
        if (!arguments.length)
            return template;
        template = x;
        initialize();
        return force;
    }
    function setGroupBy(x) {
        if (!arguments.length)
            return groupBy;
        if (typeof x === 'string') {
            groupBy = (d) => {
                return d[x];
            };
            return force;
        }
        groupBy = x;
        return force;
    }
    function setEnableGrouping(x) {
        if (!arguments.length)
            return enableGrouping;
        enableGrouping = x;
        return force;
    }
    function setStrength(x) {
        if (!arguments.length)
            return strength;
        strength = x;
        return force;
    }
    function setCenterX(_) {
        if (arguments.length) {
            centerX = _;
            return force;
        }
        return centerX;
    }
    function setCenterY(_) {
        if (arguments.length) {
            centerY = _;
            return force;
        }
        return centerY;
    }
    function setNodes(_) {
        if (arguments.length) {
            genNodesMap(_ || []);
            nodes = _ || [];
            return force;
        }
        return nodes;
    }
    function setLinks(_) {
        if (arguments.length) {
            links = _ || [];
            initialize();
            return force;
        }
        return links;
    }
    function setForceNodeSize(_) {
        if (arguments.length) {
            if (typeof _ === 'function') {
                forceNodeSize = _;
            }
            else {
                forceNodeSize = constant(+_);
            }
            initialize();
            return force;
        }
        return forceNodeSize;
    }
    function setForceCharge(_) {
        if (arguments.length) {
            if (typeof _ === 'function') {
                forceCharge = _;
            }
            else {
                forceCharge = constant(+_);
            }
            initialize();
            return force;
        }
        return forceCharge;
    }
    function setForceLinkDistance(_) {
        if (arguments.length) {
            if (typeof _ === 'function') {
                forceLinkDistance = _;
            }
            else {
                forceLinkDistance = constant(+_);
            }
            initialize();
            return force;
        }
        return forceLinkDistance;
    }
    function setForceLinkStrength(_) {
        if (arguments.length) {
            if (typeof _ === 'function') {
                forceLinkStrength = _;
            }
            else {
                forceLinkStrength = constant(+_);
            }
            initialize();
            return force;
        }
        return forceLinkStrength;
    }
    function setOffset(_) {
        if (arguments.length) {
            offset = _;
            return force;
        }
        return offset;
    }
    force.initialize = (_) => {
        nodes = _;
        initialize();
    };
    force.template = setTemplate;
    force.groupBy = setGroupBy;
    force.enableGrouping = setEnableGrouping;
    force.strength = setStrength;
    force.centerX = setCenterX;
    force.centerY = setCenterY;
    force.nodes = setNodes;
    force.links = setLinks;
    force.forceNodeSize = setForceNodeSize;
    // Legacy support
    force.nodeSize = force.forceNodeSize;
    force.forceCharge = setForceCharge;
    force.forceLinkDistance = setForceLinkDistance;
    force.forceLinkStrength = setForceLinkStrength;
    force.offset = setOffset;
    force.getFocis = getFocisFromTemplate;
    return force;
}
//# sourceMappingURL=force-in-a-box.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/force/force.js":
/*!************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/force/force.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ForceLayout: () => (/* binding */ ForceLayout)
/* harmony export */ });
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/manyBody.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/simulation.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/center.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/link.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/collide.js");
/* harmony import */ var _force_in_a_box__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./force-in-a-box */ "./node_modules/@antv/layout/es/layout/force/force-in-a-box.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util */ "./node_modules/@antv/layout/es/util/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base */ "./node_modules/@antv/layout/es/layout/base.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants */ "./node_modules/@antv/layout/es/layout/constants.js");
/**
 * @fileOverview random layout
 * @author shiwu.wyy@antfin.com
 */





/**
 * 经典力导布局 force-directed
 */
class ForceLayout extends _base__WEBPACK_IMPORTED_MODULE_2__.Base {
    constructor(options) {
        super();
        /** 向心力作用点 */
        this.center = [0, 0];
        /** 节点作用力 */
        this.nodeStrength = null;
        /** 边的作用力, 默认为根据节点的入度出度自适应 */
        this.edgeStrength = null;
        /** 是否防止节点相互覆盖 */
        this.preventOverlap = false;
        /** 聚类节点作用力 */
        this.clusterNodeStrength = null;
        /** 聚类边作用力 */
        this.clusterEdgeStrength = null;
        /** 聚类边长度 */
        this.clusterEdgeDistance = null;
        /** 聚类节点大小 / 直径，直径越大，越分散 */
        this.clusterNodeSize = null;
        /** 用于 foci 的力 */
        this.clusterFociStrength = null;
        /** 默认边长度 */
        this.linkDistance = 50;
        /** 迭代阈值的衰减率 [0, 1]，0.028 对应最大迭代数为 300 */
        this.alphaDecay = 0.028;
        /** 停止迭代的阈值 */
        this.alphaMin = 0.001;
        /** 当前阈值 */
        this.alpha = 0.3;
        /** 防止重叠的力强度 */
        this.collideStrength = 1;
        /** 是否启用web worker。前提是在web worker里执行布局，否则无效	*/
        this.workerEnabled = false;
        this.tick = () => { };
        /** 布局完成回调 */
        this.onLayoutEnd = () => { };
        /** 是否正在布局 */
        this.ticking = undefined;
        if (options) {
            this.updateCfg(options);
        }
    }
    getDefaultCfg() {
        return {
            center: [0, 0],
            nodeStrength: null,
            edgeStrength: null,
            preventOverlap: false,
            nodeSize: undefined,
            nodeSpacing: undefined,
            linkDistance: 50,
            forceSimulation: null,
            alphaDecay: 0.028,
            alphaMin: 0.001,
            alpha: 0.3,
            collideStrength: 1,
            clustering: false,
            clusterNodeStrength: -1,
            clusterEdgeStrength: 0.1,
            clusterEdgeDistance: 100,
            clusterFociStrength: 0.8,
            clusterNodeSize: 10,
            tick() { },
            onLayoutEnd() { },
            // 是否启用web worker。前提是在web worker里执行布局，否则无效
            workerEnabled: false
        };
    }
    /**
     * 初始化
     * @param {object} data 数据
     */
    init(data) {
        const self = this;
        self.nodes = data.nodes || [];
        const edges = data.edges || [];
        self.edges = edges.map((edge) => {
            const res = {};
            const expectKeys = ["targetNode", "sourceNode", "startPoint", "endPoint"];
            Object.keys(edge).forEach((key) => {
                if (!(expectKeys.indexOf(key) > -1)) {
                    res[key] = edge[key];
                }
            });
            return res;
        });
        self.ticking = false;
    }
    /**
     * 执行布局
     */
    execute(reloadData) {
        const self = this;
        const nodes = self.nodes;
        const edges = self.edges;
        // 如果正在布局，忽略布局请求
        if (self.ticking) {
            return;
        }
        let simulation = self.forceSimulation;
        const alphaMin = self.alphaMin;
        const alphaDecay = self.alphaDecay;
        const alpha = self.alpha;
        if (!simulation) {
            try {
                // 定义节点的力
                const nodeForce = d3_force__WEBPACK_IMPORTED_MODULE_4__["default"]();
                if (self.nodeStrength) {
                    nodeForce.strength(self.nodeStrength);
                }
                simulation = d3_force__WEBPACK_IMPORTED_MODULE_5__["default"]().nodes(nodes);
                if (self.clustering) {
                    const clusterForce = (0,_force_in_a_box__WEBPACK_IMPORTED_MODULE_0__["default"])();
                    clusterForce
                        .centerX(self.center[0])
                        .centerY(self.center[1])
                        .template("force")
                        .strength(self.clusterFociStrength);
                    if (edges) {
                        clusterForce.links(edges);
                    }
                    if (nodes) {
                        clusterForce.nodes(nodes);
                    }
                    clusterForce
                        .forceLinkDistance(self.clusterEdgeDistance)
                        .forceLinkStrength(self.clusterEdgeStrength)
                        .forceCharge(self.clusterNodeStrength)
                        .forceNodeSize(self.clusterNodeSize);
                    self.clusterForce = clusterForce;
                    simulation.force("group", clusterForce);
                }
                simulation
                    .force("center", d3_force__WEBPACK_IMPORTED_MODULE_6__["default"](self.center[0], self.center[1]))
                    .force("charge", nodeForce)
                    .alpha(alpha)
                    .alphaDecay(alphaDecay)
                    .alphaMin(alphaMin);
                if (self.preventOverlap) {
                    self.overlapProcess(simulation);
                }
                // 如果有边，定义边的力
                if (edges) {
                    // d3 的 forceLayout 会重新生成边的数据模型，为了避免污染源数据
                    const edgeForce = d3_force__WEBPACK_IMPORTED_MODULE_7__["default"]()
                        .id((d) => d.id)
                        .links(edges);
                    if (self.edgeStrength) {
                        edgeForce.strength(self.edgeStrength);
                    }
                    if (self.linkDistance) {
                        edgeForce.distance(self.linkDistance);
                    }
                    self.edgeForce = edgeForce;
                    simulation.force("link", edgeForce);
                }
                if (self.workerEnabled && !isInWorker()) {
                    // 如果不是运行在web worker里，不用web worker布局
                    self.workerEnabled = false;
                    console.warn("workerEnabled option is only supported when running in web worker.");
                }
                if (!self.workerEnabled) {
                    simulation
                        .on("tick", () => {
                        self.tick();
                    })
                        .on("end", () => {
                        self.ticking = false;
                        if (self.onLayoutEnd)
                            self.onLayoutEnd();
                    });
                    self.ticking = true;
                }
                else {
                    // worker is enabled
                    simulation.stop();
                    const totalTicks = getSimulationTicks(simulation);
                    for (let currentTick = 1; currentTick <= totalTicks; currentTick++) {
                        simulation.tick();
                        // currentTick starts from 1.
                        postMessage({
                            nodes,
                            currentTick,
                            totalTicks,
                            type: _constants__WEBPACK_IMPORTED_MODULE_3__.LAYOUT_MESSAGE.TICK
                        }, undefined);
                    }
                    self.ticking = false;
                }
                self.forceSimulation = simulation;
                self.ticking = true;
            }
            catch (e) {
                self.ticking = false;
                console.warn(e);
            }
        }
        else {
            if (reloadData) {
                if (self.clustering && self.clusterForce) {
                    self.clusterForce.nodes(nodes);
                    self.clusterForce.links(edges);
                }
                simulation.nodes(nodes);
                if (edges && self.edgeForce)
                    self.edgeForce.links(edges);
                else if (edges && !self.edgeForce) {
                    // d3 的 forceLayout 会重新生成边的数据模型，为了避免污染源数据
                    const edgeForce = d3_force__WEBPACK_IMPORTED_MODULE_7__["default"]()
                        .id((d) => d.id)
                        .links(edges);
                    if (self.edgeStrength) {
                        edgeForce.strength(self.edgeStrength);
                    }
                    if (self.linkDistance) {
                        edgeForce.distance(self.linkDistance);
                    }
                    self.edgeForce = edgeForce;
                    simulation.force("link", edgeForce);
                }
            }
            if (self.preventOverlap) {
                self.overlapProcess(simulation);
            }
            simulation.alpha(alpha).restart();
            this.ticking = true;
        }
    }
    /**
     * 防止重叠
     * @param {object} simulation 力模拟模型
     */
    overlapProcess(simulation) {
        const self = this;
        const nodeSize = self.nodeSize;
        const nodeSpacing = self.nodeSpacing;
        let nodeSizeFunc;
        let nodeSpacingFunc;
        const collideStrength = self.collideStrength;
        if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(nodeSpacing)) {
            nodeSpacingFunc = () => nodeSpacing;
        }
        else if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(nodeSpacing)) {
            nodeSpacingFunc = nodeSpacing;
        }
        else {
            nodeSpacingFunc = () => 0;
        }
        if (!nodeSize) {
            nodeSizeFunc = (d) => {
                if (d.size) {
                    if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(d.size)) {
                        const res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];
                        return res / 2 + nodeSpacingFunc(d);
                    }
                    if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isObject)(d.size)) {
                        const res = d.size.width > d.size.height ? d.size.width : d.size.height;
                        return res / 2 + nodeSpacingFunc(d);
                    }
                    return d.size / 2 + nodeSpacingFunc(d);
                }
                return 10 + nodeSpacingFunc(d);
            };
        }
        else if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(nodeSize)) {
            nodeSizeFunc = (d) => {
                const size = nodeSize(d);
                return size + nodeSpacingFunc(d);
            };
        }
        else if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(nodeSize)) {
            const larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];
            const radius = larger / 2;
            nodeSizeFunc = (d) => radius + nodeSpacingFunc(d);
        }
        else if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(nodeSize)) {
            const radius = nodeSize / 2;
            nodeSizeFunc = (d) => radius + nodeSpacingFunc(d);
        }
        else {
            nodeSizeFunc = () => 10;
        }
        // forceCollide's parameter is a radius
        simulation.force("collisionForce", d3_force__WEBPACK_IMPORTED_MODULE_8__["default"](nodeSizeFunc).strength(collideStrength));
    }
    /**
     * 更新布局配置，但不执行布局
     * @param {object} cfg 需要更新的配置项
     */
    updateCfg(cfg) {
        const self = this;
        if (self.ticking) {
            self.forceSimulation.stop();
            self.ticking = false;
        }
        self.forceSimulation = null;
        Object.assign(self, cfg);
    }
    destroy() {
        const self = this;
        if (self.ticking) {
            self.forceSimulation.stop();
            self.ticking = false;
        }
        self.nodes = null;
        self.edges = null;
        self.destroyed = true;
    }
}
// Return total ticks of d3-force simulation
function getSimulationTicks(simulation) {
    const alphaMin = simulation.alphaMin();
    const alphaTarget = simulation.alphaTarget();
    const alpha = simulation.alpha();
    const totalTicksFloat = Math.log((alphaMin - alphaTarget) / (alpha - alphaTarget)) /
        Math.log(1 - simulation.alphaDecay());
    const totalTicks = Math.ceil(totalTicksFloat);
    return totalTicks;
}
// 判断是否运行在web worker里
function isInWorker() {
    // eslint-disable-next-line no-undef
    return (typeof WorkerGlobalScope !== "undefined" &&
        self instanceof WorkerGlobalScope);
}
//# sourceMappingURL=force.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/force/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/force/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ForceLayout: () => (/* reexport safe */ _force__WEBPACK_IMPORTED_MODULE_0__.ForceLayout)
/* harmony export */ });
/* harmony import */ var _force__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./force */ "./node_modules/@antv/layout/es/layout/force/force.js");

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/fruchterman.js":
/*!************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/fruchterman.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FruchtermanLayout: () => (/* binding */ FruchtermanLayout)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./node_modules/@antv/layout/es/layout/base.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/layout/es/util/index.js");
/**
 * @fileOverview fruchterman layout
 * @author shiwu.wyy@antfin.com
 */


const SPEED_DIVISOR = 800;
/**
 * fruchterman 布局
 */
class FruchtermanLayout extends _base__WEBPACK_IMPORTED_MODULE_0__.Base {
    constructor(options) {
        super();
        /** 停止迭代的最大迭代数 */
        this.maxIteration = 1000;
        /** 是否启动 worker */
        this.workerEnabled = false;
        /** 重力大小，影响图的紧凑程度 */
        this.gravity = 10;
        /** 速度 */
        this.speed = 5;
        /** 是否产生聚类力 */
        this.clustering = false;
        /** 聚类力大小 */
        this.clusterGravity = 10;
        this.nodes = [];
        this.edges = [];
        this.width = 300;
        this.height = 300;
        this.nodeMap = {};
        this.nodeIdxMap = {};
        /** 迭代结束的回调函数 */
        this.onLayoutEnd = () => { };
        /** 每次迭代结束的回调函数 */
        this.tick = () => { };
        /** 是否使用 window.setInterval 运行迭代 */
        this.animate = true;
        this.updateCfg(options);
    }
    getDefaultCfg() {
        return {
            maxIteration: 1000,
            gravity: 10,
            speed: 1,
            clustering: false,
            clusterGravity: 10,
            animate: true
        };
    }
    /**
     * 执行布局
     */
    execute() {
        var _a, _b;
        const self = this;
        const nodes = self.nodes;
        if (self.timeInterval !== undefined && typeof window !== "undefined") {
            window.clearInterval(self.timeInterval);
        }
        if (!nodes || nodes.length === 0) {
            (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);
            return;
        }
        if (!self.width && typeof window !== "undefined") {
            self.width = window.innerWidth;
        }
        if (!self.height && typeof window !== "undefined") {
            self.height = window.innerHeight;
        }
        if (!self.center) {
            self.center = [self.width / 2, self.height / 2];
        }
        const center = self.center;
        if (nodes.length === 1) {
            nodes[0].x = center[0];
            nodes[0].y = center[1];
            (_b = self.onLayoutEnd) === null || _b === void 0 ? void 0 : _b.call(self);
            return;
        }
        const nodeMap = {};
        const nodeIdxMap = {};
        nodes.forEach((node, i) => {
            if (!(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(node.x))
                node.x = Math.random() * this.width;
            if (!(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(node.y))
                node.y = Math.random() * this.height;
            nodeMap[node.id] = node;
            nodeIdxMap[node.id] = i;
        });
        self.nodeMap = nodeMap;
        self.nodeIdxMap = nodeIdxMap;
        // layout
        return self.run();
    }
    run() {
        var _a;
        const self = this;
        const nodes = self.nodes;
        if (!nodes)
            return;
        const { edges, maxIteration, workerEnabled, clustering, animate } = self;
        const clusterMap = {};
        if (clustering) {
            nodes.forEach((n) => {
                if (clusterMap[n.cluster] === undefined) {
                    clusterMap[n.cluster] = {
                        name: n.cluster,
                        cx: 0,
                        cy: 0,
                        count: 0
                    };
                }
            });
        }
        if (workerEnabled || !animate) {
            for (let i = 0; i < maxIteration; i++) {
                self.runOneStep(clusterMap);
            }
            (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);
        }
        else {
            if (typeof window === "undefined")
                return;
            let iter = 0;
            // interval for render the result after each iteration
            this.timeInterval = window.setInterval(() => {
                var _a;
                self.runOneStep(clusterMap);
                iter++;
                if (iter >= maxIteration) {
                    (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);
                    window.clearInterval(self.timeInterval);
                }
            }, 0);
        }
        return {
            nodes,
            edges
        };
    }
    runOneStep(clusterMap) {
        var _a;
        const self = this;
        const nodes = self.nodes;
        if (!nodes)
            return;
        const { edges, center, gravity, speed, clustering } = self;
        const area = self.height * self.width;
        const maxDisplace = Math.sqrt(area) / 10;
        const k2 = area / (nodes.length + 1);
        const k = Math.sqrt(k2);
        const displacements = [];
        nodes.forEach((_, j) => {
            displacements[j] = { x: 0, y: 0 };
        });
        self.applyCalculate(nodes, edges, displacements, k, k2);
        // gravity for clusters
        if (clustering) {
            // re-compute the clustering centers
            for (const key in clusterMap) {
                clusterMap[key].cx = 0;
                clusterMap[key].cy = 0;
                clusterMap[key].count = 0;
            }
            nodes.forEach((n) => {
                const c = clusterMap[n.cluster];
                if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(n.x)) {
                    c.cx += n.x;
                }
                if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(n.y)) {
                    c.cy += n.y;
                }
                c.count++;
            });
            for (const key in clusterMap) {
                clusterMap[key].cx /= clusterMap[key].count;
                clusterMap[key].cy /= clusterMap[key].count;
            }
            // compute the cluster gravity forces
            const clusterGravity = self.clusterGravity || gravity;
            nodes.forEach((n, j) => {
                if (!(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(n.x) || !(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(n.y))
                    return;
                const c = clusterMap[n.cluster];
                const distLength = Math.sqrt((n.x - c.cx) * (n.x - c.cx) + (n.y - c.cy) * (n.y - c.cy));
                const gravityForce = k * clusterGravity;
                displacements[j].x -= (gravityForce * (n.x - c.cx)) / distLength;
                displacements[j].y -= (gravityForce * (n.y - c.cy)) / distLength;
            });
        }
        // gravity
        nodes.forEach((n, j) => {
            if (!(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(n.x) || !(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(n.y))
                return;
            const gravityForce = 0.01 * k * gravity;
            displacements[j].x -= gravityForce * (n.x - center[0]);
            displacements[j].y -= gravityForce * (n.y - center[1]);
        });
        // move
        nodes.forEach((n, j) => {
            if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(n.fx) && (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(n.fy)) {
                n.x = n.fx;
                n.y = n.fy;
                return;
            }
            if (!(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(n.x) || !(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(n.y))
                return;
            const distLength = Math.sqrt(displacements[j].x * displacements[j].x +
                displacements[j].y * displacements[j].y);
            if (distLength > 0) {
                // && !n.isFixed()
                const limitedDist = Math.min(maxDisplace * (speed / SPEED_DIVISOR), distLength);
                n.x += (displacements[j].x / distLength) * limitedDist;
                n.y += (displacements[j].y / distLength) * limitedDist;
            }
        });
        (_a = self.tick) === null || _a === void 0 ? void 0 : _a.call(self);
    }
    applyCalculate(nodes, edges, displacements, k, k2) {
        const self = this;
        self.calRepulsive(nodes, displacements, k2);
        if (edges)
            self.calAttractive(edges, displacements, k);
    }
    calRepulsive(nodes, displacements, k2) {
        nodes.forEach((v, i) => {
            displacements[i] = { x: 0, y: 0 };
            nodes.forEach((u, j) => {
                if (i === j) {
                    return;
                }
                if (!(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(v.x) ||
                    !(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(u.x) ||
                    !(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(v.y) ||
                    !(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(u.y)) {
                    return;
                }
                let vecX = v.x - u.x;
                let vecY = v.y - u.y;
                let vecLengthSqr = vecX * vecX + vecY * vecY;
                if (vecLengthSqr === 0) {
                    vecLengthSqr = 1;
                    const sign = i > j ? 1 : -1;
                    vecX = 0.01 * sign;
                    vecY = 0.01 * sign;
                }
                const common = k2 / vecLengthSqr;
                displacements[i].x += vecX * common;
                displacements[i].y += vecY * common;
            });
        });
    }
    calAttractive(edges, displacements, k) {
        edges.forEach((e) => {
            const source = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getEdgeTerminal)(e, 'source');
            const target = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getEdgeTerminal)(e, 'target');
            if (!source || !target)
                return;
            const uIndex = this.nodeIdxMap[source];
            const vIndex = this.nodeIdxMap[target];
            if (uIndex === vIndex) {
                return;
            }
            const u = this.nodeMap[source];
            const v = this.nodeMap[target];
            if (!(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(v.x) || !(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(u.x) || !(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(v.y) || !(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(u.y)) {
                return;
            }
            const vecX = v.x - u.x;
            const vecY = v.y - u.y;
            const vecLength = Math.sqrt(vecX * vecX + vecY * vecY);
            const common = (vecLength * vecLength) / k;
            displacements[vIndex].x -= (vecX / vecLength) * common;
            displacements[vIndex].y -= (vecY / vecLength) * common;
            displacements[uIndex].x += (vecX / vecLength) * common;
            displacements[uIndex].y += (vecY / vecLength) * common;
        });
    }
    stop() {
        if (this.timeInterval && typeof window !== "undefined") {
            window.clearInterval(this.timeInterval);
        }
    }
    destroy() {
        const self = this;
        self.stop();
        self.tick = null;
        self.nodes = null;
        self.edges = null;
        self.destroyed = true;
    }
    getType() {
        return "fruchterman";
    }
}
//# sourceMappingURL=fruchterman.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/gForce.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/gForce.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GForceLayout: () => (/* binding */ GForceLayout)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./node_modules/@antv/layout/es/layout/base.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/layout/es/util/index.js");
/**
 * @fileOverview fruchterman layout
 * @author shiwu.wyy@antfin.com
 */


const proccessToFunc = (value, defaultV) => {
    let func;
    if (!value) {
        func = (d) => {
            return defaultV || 1;
        };
    }
    else if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(value)) {
        func = (d) => {
            return value;
        };
    }
    else {
        func = value;
    }
    return func;
};
/**
 * graphin 中的 force 布局
 */
class GForceLayout extends _base__WEBPACK_IMPORTED_MODULE_0__.Base {
    constructor(options) {
        super();
        /** 停止迭代的最大迭代数 */
        this.maxIteration = 500;
        /** 是否启动 worker */
        this.workerEnabled = false;
        /** 弹簧引力系数 */
        this.edgeStrength = 200;
        /** 斥力系数 */
        this.nodeStrength = 1000;
        /** 库伦系数 */
        this.coulombDisScale = 0.005;
        /** 阻尼系数 */
        this.damping = 0.9;
        /** 最大速度 */
        this.maxSpeed = 1000;
        /** 一次迭代的平均移动距离小于该值时停止迭代 */
        this.minMovement = 0.5;
        /** 迭代中衰减 */
        this.interval = 0.02;
        /** 斥力的一个系数 */
        this.factor = 1;
        /** 理想边长 */
        this.linkDistance = 1;
        /** 重力大小 */
        this.gravity = 10;
        /** 是否防止重叠 */
        this.preventOverlap = true;
        /** 防止重叠的力大小参数 */
        this.collideStrength = 1;
        /** 每次迭代结束的回调函数 */
        this.tick = () => { };
        this.nodes = [];
        this.edges = [];
        this.width = 300;
        this.height = 300;
        this.nodeMap = {};
        this.nodeIdxMap = {};
        /** 是否使用 window.setInterval 运行迭代 */
        this.animate = true;
        this.updateCfg(options);
    }
    getDefaultCfg() {
        return {
            maxIteration: 500,
            gravity: 10,
            enableTick: true,
            animate: true,
        };
    }
    /**
     * 执行布局
     */
    execute() {
        var _a, _b;
        const self = this;
        const nodes = self.nodes;
        if (self.timeInterval !== undefined && typeof window !== "undefined") {
            window.clearInterval(self.timeInterval);
        }
        if (!nodes || nodes.length === 0) {
            (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);
            return;
        }
        if (!self.width && typeof window !== "undefined") {
            self.width = window.innerWidth;
        }
        if (!self.height && typeof window !== "undefined") {
            self.height = window.innerHeight;
        }
        if (!self.center) {
            self.center = [self.width / 2, self.height / 2];
        }
        const center = self.center;
        if (nodes.length === 1) {
            nodes[0].x = center[0];
            nodes[0].y = center[1];
            (_b = self.onLayoutEnd) === null || _b === void 0 ? void 0 : _b.call(self);
            return;
        }
        const nodeMap = {};
        const nodeIdxMap = {};
        nodes.forEach((node, i) => {
            if (!(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(node.x))
                node.x = Math.random() * self.width;
            if (!(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(node.y))
                node.y = Math.random() * self.height;
            nodeMap[node.id] = node;
            nodeIdxMap[node.id] = i;
        });
        self.nodeMap = nodeMap;
        self.nodeIdxMap = nodeIdxMap;
        self.linkDistance = proccessToFunc(self.linkDistance, 1);
        self.nodeStrength = proccessToFunc(self.nodeStrength, 1);
        self.edgeStrength = proccessToFunc(self.edgeStrength, 1);
        // node size function
        const nodeSize = self.nodeSize;
        let nodeSizeFunc;
        if (self.preventOverlap) {
            const nodeSpacing = self.nodeSpacing;
            let nodeSpacingFunc;
            if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(nodeSpacing)) {
                nodeSpacingFunc = () => nodeSpacing;
            }
            else if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(nodeSpacing)) {
                nodeSpacingFunc = nodeSpacing;
            }
            else {
                nodeSpacingFunc = () => 0;
            }
            if (!nodeSize) {
                nodeSizeFunc = (d) => {
                    if (d.size) {
                        if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(d.size)) {
                            return Math.max(d.size[0], d.size[1]) + nodeSpacingFunc(d);
                        }
                        if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isObject)(d.size)) {
                            return Math.max(d.size.width, d.size.height) + nodeSpacingFunc(d);
                        }
                        return d.size + nodeSpacingFunc(d);
                    }
                    return 10 + nodeSpacingFunc(d);
                };
            }
            else if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(nodeSize)) {
                nodeSizeFunc = (d) => {
                    return Math.max(nodeSize[0], nodeSize[1]) + nodeSpacingFunc(d);
                };
            }
            else {
                nodeSizeFunc = (d) => nodeSize + nodeSpacingFunc(d);
            }
        }
        self.nodeSize = nodeSizeFunc;
        const edges = self.edges;
        self.degrees = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getDegree)(nodes.length, self.nodeIdxMap, edges);
        if (!self.getMass) {
            self.getMass = (d) => {
                const mass = d.mass || self.degrees[self.nodeIdxMap[d.id]].all || 1;
                return mass;
            };
        }
        // layout
        self.run();
    }
    run() {
        var _a;
        const self = this;
        const { maxIteration, nodes, workerEnabled, minMovement, animate } = self;
        if (!nodes)
            return;
        if (workerEnabled || !animate) {
            for (let i = 0; i < maxIteration; i++) {
                const previousPos = self.runOneStep(i);
                if (self.reachMoveThreshold(nodes, previousPos, minMovement)) {
                    break;
                }
            }
            (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);
        }
        else {
            if (typeof window === "undefined")
                return;
            let iter = 0;
            // interval for render the result after each iteration
            this.timeInterval = window.setInterval(() => {
                var _a, _b;
                if (!nodes)
                    return;
                const previousPos = self.runOneStep(iter) || [];
                if (self.reachMoveThreshold(nodes, previousPos, minMovement)) {
                    (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);
                    window.clearInterval(self.timeInterval);
                }
                iter++;
                if (iter >= maxIteration) {
                    (_b = self.onLayoutEnd) === null || _b === void 0 ? void 0 : _b.call(self);
                    window.clearInterval(self.timeInterval);
                }
            }, 0);
        }
    }
    reachMoveThreshold(nodes, previousPos, minMovement) {
        // whether to stop the iteration
        let movement = 0;
        nodes.forEach((node, j) => {
            const vx = node.x - previousPos[j].x;
            const vy = node.y - previousPos[j].y;
            movement += Math.sqrt(vx * vx + vy * vy);
        });
        movement /= nodes.length;
        return movement < minMovement;
    }
    runOneStep(iter) {
        var _a;
        const self = this;
        const { nodes, edges } = self;
        const accArray = [];
        const velArray = [];
        if (!nodes)
            return;
        nodes.forEach((_, i) => {
            accArray[2 * i] = 0;
            accArray[2 * i + 1] = 0;
            velArray[2 * i] = 0;
            velArray[2 * i + 1] = 0;
        });
        self.calRepulsive(accArray, nodes);
        if (edges)
            self.calAttractive(accArray, edges);
        self.calGravity(accArray, nodes);
        const stepInterval = Math.max(0.02, self.interval - iter * 0.002);
        self.updateVelocity(accArray, velArray, stepInterval, nodes);
        const previousPos = [];
        nodes.forEach((node) => {
            previousPos.push({
                x: node.x,
                y: node.y
            });
        });
        self.updatePosition(velArray, stepInterval, nodes);
        (_a = self.tick) === null || _a === void 0 ? void 0 : _a.call(self);
        return previousPos;
    }
    calRepulsive(accArray, nodes) {
        const self = this;
        const { getMass, factor, coulombDisScale, preventOverlap, collideStrength = 1 } = self;
        const nodeStrength = self.nodeStrength;
        const nodeSize = self.nodeSize;
        nodes.forEach((ni, i) => {
            const massi = getMass ? getMass(ni) : 1;
            nodes.forEach((nj, j) => {
                if (i >= j)
                    return;
                // if (!accArray[j]) accArray[j] = 0;
                let vecX = ni.x - nj.x;
                let vecY = ni.y - nj.y;
                if (vecX === 0 && vecY === 0) {
                    vecX = Math.random() * 0.01;
                    vecY = Math.random() * 0.01;
                }
                const lengthSqr = vecX * vecX + vecY * vecY;
                const vecLength = Math.sqrt(lengthSqr);
                const nVecLength = (vecLength + 0.1) * coulombDisScale;
                const direX = vecX / vecLength;
                const direY = vecY / vecLength;
                const param = (((nodeStrength(ni) + nodeStrength(nj)) * 0.5) * factor) /
                    (nVecLength * nVecLength);
                const massj = getMass ? getMass(nj) : 1;
                accArray[2 * i] += (direX * param);
                accArray[2 * i + 1] += (direY * param);
                accArray[2 * j] -= (direX * param);
                accArray[2 * j + 1] -= (direY * param);
                if (preventOverlap && (nodeSize(ni) + nodeSize(nj)) / 2 > vecLength) {
                    const paramOverlap = collideStrength * (nodeStrength(ni) + nodeStrength(nj)) * 0.5 / lengthSqr;
                    accArray[2 * i] += (direX * paramOverlap) / massi;
                    accArray[2 * i + 1] += (direY * paramOverlap) / massi;
                    accArray[2 * j] -= (direX * paramOverlap) / massj;
                    accArray[2 * j + 1] -= (direY * paramOverlap) / massj;
                }
            });
        });
    }
    calAttractive(accArray, edges) {
        const self = this;
        const { nodeMap, nodeIdxMap, linkDistance, edgeStrength } = self;
        const nodeSize = self.nodeSize;
        const getMass = self.getMass;
        edges.forEach((edge, i) => {
            const source = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getEdgeTerminal)(edge, 'source');
            const target = (0,_util__WEBPACK_IMPORTED_MODULE_1__.getEdgeTerminal)(edge, 'target');
            const sourceNode = nodeMap[source];
            const targetNode = nodeMap[target];
            let vecX = targetNode.x - sourceNode.x;
            let vecY = targetNode.y - sourceNode.y;
            if (vecX === 0 && vecY === 0) {
                vecX = Math.random() * 0.01;
                vecY = Math.random() * 0.01;
            }
            const vecLength = Math.sqrt(vecX * vecX + vecY * vecY);
            const direX = vecX / vecLength;
            const direY = vecY / vecLength;
            const length = linkDistance(edge, sourceNode, targetNode) || 1 + ((nodeSize(sourceNode) + nodeSize(targetNode)) || 0) / 2;
            const diff = length - vecLength;
            const param = diff * edgeStrength(edge);
            const sourceIdx = nodeIdxMap[source];
            const targetIdx = nodeIdxMap[target];
            const massSource = getMass ? getMass(sourceNode) : 1;
            const massTarget = getMass ? getMass(targetNode) : 1;
            accArray[2 * sourceIdx] -= (direX * param) / massSource;
            accArray[2 * sourceIdx + 1] -= (direY * param) / massSource;
            accArray[2 * targetIdx] += (direX * param) / massTarget;
            accArray[2 * targetIdx + 1] += (direY * param) / massTarget;
        });
    }
    calGravity(accArray, nodes) {
        const self = this;
        // const nodes = self.nodes;
        const center = self.center;
        const defaultGravity = self.gravity;
        const degrees = self.degrees;
        const nodeLength = nodes.length;
        for (let i = 0; i < nodeLength; i++) {
            const node = nodes[i];
            let vecX = node.x - center[0];
            let vecY = node.y - center[1];
            let gravity = defaultGravity;
            if (self.getCenter) {
                const customCenterOpt = self.getCenter(node, degrees[i].all);
                if (customCenterOpt &&
                    (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(customCenterOpt[0]) &&
                    (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(customCenterOpt[1]) &&
                    (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(customCenterOpt[2])) {
                    vecX = node.x - customCenterOpt[0];
                    vecY = node.y - customCenterOpt[1];
                    gravity = customCenterOpt[2];
                }
            }
            if (!gravity)
                continue;
            accArray[2 * i] -= gravity * vecX;
            accArray[2 * i + 1] -= gravity * vecY;
        }
    }
    updateVelocity(accArray, velArray, stepInterval, nodes) {
        const self = this;
        const param = stepInterval * self.damping;
        // const nodes = self.nodes;
        nodes.forEach((node, i) => {
            let vx = accArray[2 * i] * param || 0.01;
            let vy = accArray[2 * i + 1] * param || 0.01;
            const vLength = Math.sqrt(vx * vx + vy * vy);
            if (vLength > self.maxSpeed) {
                const param2 = self.maxSpeed / vLength;
                vx = param2 * vx;
                vy = param2 * vy;
            }
            velArray[2 * i] = vx;
            velArray[2 * i + 1] = vy;
        });
    }
    updatePosition(velArray, stepInterval, nodes) {
        nodes.forEach((node, i) => {
            if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(node.fx) && (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(node.fy)) {
                node.x = node.fx;
                node.y = node.fy;
                return;
            }
            const distX = velArray[2 * i] * stepInterval;
            const distY = velArray[2 * i + 1] * stepInterval;
            node.x += distX;
            node.y += distY;
        });
    }
    stop() {
        if (this.timeInterval && typeof window !== "undefined") {
            window.clearInterval(this.timeInterval);
        }
    }
    destroy() {
        const self = this;
        self.stop();
        self.tick = null;
        self.nodes = null;
        self.edges = null;
        self.destroyed = true;
    }
    getType() {
        return "gForce";
    }
}
//# sourceMappingURL=gForce.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/gpu/fruchterman.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/gpu/fruchterman.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FruchtermanGPULayout: () => (/* binding */ FruchtermanGPULayout)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./node_modules/@antv/layout/es/layout/base.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util */ "./node_modules/@antv/layout/es/util/index.js");
/* harmony import */ var _antv_g_webgpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @antv/g-webgpu */ "./node_modules/@antv/g-webgpu/es/index.js");
/* harmony import */ var _util_gpu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/gpu */ "./node_modules/@antv/layout/es/util/gpu.js");
/* harmony import */ var _fruchtermanShader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./fruchtermanShader */ "./node_modules/@antv/layout/es/layout/gpu/fruchtermanShader.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constants */ "./node_modules/@antv/layout/es/layout/constants.js");
// @ts-nocheck
/**
 * @fileOverview fruchterman layout
 * @author shiwu.wyy@antfin.com
 */
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


// @ts-ignore

// compile at runtime in dev mode

// use compiled bundle in prod mode


/**
 * fruchterman 布局
 */
class FruchtermanGPULayout extends _base__WEBPACK_IMPORTED_MODULE_0__.Base {
    constructor(options) {
        super();
        /** 停止迭代的最大迭代数 */
        this.maxIteration = 1000;
        /** 重力大小，影响图的紧凑程度 */
        this.gravity = 10;
        /** 速度 */
        this.speed = 1;
        /** 是否产生聚类力 */
        this.clustering = false;
        /** 根据哪个字段聚类 */
        this.clusterField = "cluster";
        /** 聚类力大小 */
        this.clusterGravity = 10;
        /** 是否启用web worker。前提是在web worker里执行布局，否则无效	*/
        this.workerEnabled = false;
        this.nodes = [];
        this.edges = [];
        this.width = 300;
        this.height = 300;
        this.nodeMap = {};
        this.nodeIdxMap = {};
        this.updateCfg(options);
    }
    getDefaultCfg() {
        return {
            maxIteration: 1000,
            gravity: 10,
            speed: 1,
            clustering: false,
            clusterGravity: 10
        };
    }
    /**
     * 执行布局
     */
    execute() {
        return __awaiter(this, void 0, void 0, function* () {
            const self = this;
            const nodes = self.nodes;
            if (!nodes || nodes.length === 0) {
                if (self.onLayoutEnd)
                    self.onLayoutEnd();
                return;
            }
            if (!self.width && typeof window !== "undefined") {
                self.width = window.innerWidth;
            }
            if (!self.height && typeof window !== "undefined") {
                self.height = window.innerHeight;
            }
            if (!self.center) {
                self.center = [self.width / 2, self.height / 2];
            }
            const center = self.center;
            if (nodes.length === 1) {
                nodes[0].x = center[0];
                nodes[0].y = center[1];
                if (self.onLayoutEnd)
                    self.onLayoutEnd();
                return;
            }
            const nodeMap = {};
            const nodeIdxMap = {};
            nodes.forEach((node, i) => {
                if (!(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(node.x))
                    node.x = Math.random() * this.width;
                if (!(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(node.y))
                    node.y = Math.random() * this.height;
                nodeMap[node.id] = node;
                nodeIdxMap[node.id] = i;
            });
            self.nodeMap = nodeMap;
            self.nodeIdxMap = nodeIdxMap;
            // layout
            yield self.run();
        });
    }
    executeWithWorker(canvas, ctx) {
        return __awaiter(this, void 0, void 0, function* () {
            const self = this;
            const nodes = self.nodes;
            const center = self.center;
            if (!nodes || nodes.length === 0) {
                return;
            }
            if (nodes.length === 1) {
                nodes[0].x = center[0];
                nodes[0].y = center[1];
                return;
            }
            const nodeMap = {};
            const nodeIdxMap = {};
            nodes.forEach((node, i) => {
                if (!(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(node.x))
                    node.x = Math.random() * this.width;
                if (!(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(node.y))
                    node.y = Math.random() * this.height;
                nodeMap[node.id] = node;
                nodeIdxMap[node.id] = i;
            });
            self.nodeMap = nodeMap;
            self.nodeIdxMap = nodeIdxMap;
            // layout
            yield self.run(canvas, ctx);
        });
    }
    run(canvas, ctx) {
        return __awaiter(this, void 0, void 0, function* () {
            const self = this;
            const nodes = self.nodes;
            const edges = self.edges;
            const maxIteration = self.maxIteration;
            const center = self.center;
            const area = self.height * self.width;
            let maxDisplace = Math.sqrt(area) / 10;
            const k2 = area / (nodes.length + 1);
            const k = Math.sqrt(k2);
            const speed = self.speed;
            const clustering = self.clustering;
            const { array: attributeArray, count: clusterCount } = (0,_util_gpu__WEBPACK_IMPORTED_MODULE_3__.attributesToTextureData)([self.clusterField], nodes);
            // pushing the fx and fy
            nodes.forEach((node, i) => {
                let fx = 0;
                let fy = 0;
                if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(node.fx) && (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(node.fy)) {
                    fx = node.fx || 0.001;
                    fy = node.fy || 0.001;
                }
                attributeArray[4 * i + 1] = fx;
                attributeArray[4 * i + 2] = fy;
            });
            const numParticles = nodes.length;
            const { maxEdgePerVetex, array: nodesEdgesArray } = (0,_util_gpu__WEBPACK_IMPORTED_MODULE_3__.buildTextureData)(nodes, edges);
            const workerEnabled = self.workerEnabled;
            let world;
            if (workerEnabled) {
                world = _antv_g_webgpu__WEBPACK_IMPORTED_MODULE_2__.World.create({
                    canvas,
                    engineOptions: {
                        supportCompute: true
                    }
                });
            }
            else {
                world = _antv_g_webgpu__WEBPACK_IMPORTED_MODULE_2__.World.create({
                    engineOptions: {
                        supportCompute: true
                    }
                });
            }
            // compile at runtime in dev mode
            // const compiler = new Compiler()
            // const fruchtermanBundle = compiler.compileBundle(fruchtermanCode)
            // const clusterBundle = compiler.compileBundle(clusterCode)
            // use compiled bundle in prod mode
            // console.log(fruchtermanBundle.toString())
            // console.log(clusterBundle.toString())
            const onLayoutEnd = self.onLayoutEnd;
            const clusterCenters = [];
            for (let i = 0; i < clusterCount; i++) {
                clusterCenters.push(0, 0, 0, 0);
            }
            const kernelFruchterman = world
                .createKernel(_fruchtermanShader__WEBPACK_IMPORTED_MODULE_4__.fruchtermanBundle)
                .setDispatch([numParticles, 1, 1])
                .setBinding({
                u_Data: nodesEdgesArray,
                u_K: k,
                u_K2: k2,
                u_Gravity: self.gravity,
                u_ClusterGravity: self.clusterGravity || self.gravity || 1,
                u_Speed: speed,
                u_MaxDisplace: maxDisplace,
                u_Clustering: clustering ? 1 : 0,
                u_Center: center,
                u_AttributeArray: attributeArray,
                u_ClusterCenters: clusterCenters,
                MAX_EDGE_PER_VERTEX: maxEdgePerVetex,
                VERTEX_COUNT: numParticles
            });
            let kernelCluster;
            if (clustering) {
                kernelCluster = world
                    .createKernel(_fruchtermanShader__WEBPACK_IMPORTED_MODULE_4__.clusterBundle)
                    .setDispatch([clusterCount, 1, 1])
                    .setBinding({
                    u_Data: nodesEdgesArray,
                    u_NodeAttributes: attributeArray,
                    u_ClusterCenters: clusterCenters,
                    VERTEX_COUNT: numParticles,
                    CLUSTER_COUNT: clusterCount
                });
            }
            const execute = () => __awaiter(this, void 0, void 0, function* () {
                for (let i = 0; i < maxIteration; i++) {
                    // eslint-disable-next-line no-await-in-loop
                    yield kernelFruchterman.execute();
                    if (clustering) {
                        kernelCluster.setBinding({
                            u_Data: kernelFruchterman
                        });
                        // eslint-disable-next-line no-await-in-loop
                        yield kernelCluster.execute();
                        kernelFruchterman.setBinding({
                            u_ClusterCenters: kernelCluster
                        });
                    }
                    kernelFruchterman.setBinding({
                        u_MaxDisplace: maxDisplace *= 0.99
                    });
                }
                const finalParticleData = yield kernelFruchterman.getOutput();
                if (canvas) {
                    // 传递数据给主线程
                    ctx.postMessage({
                        type: _constants__WEBPACK_IMPORTED_MODULE_5__.LAYOUT_MESSAGE.GPUEND,
                        vertexEdgeData: finalParticleData
                        // edgeIndexBufferData,
                    });
                }
                else {
                    nodes.forEach((node, i) => {
                        const x = finalParticleData[4 * i];
                        const y = finalParticleData[4 * i + 1];
                        node.x = x;
                        node.y = y;
                    });
                }
                if (onLayoutEnd)
                    onLayoutEnd();
            });
            yield execute();
        });
    }
    getType() {
        return "fruchterman-gpu";
    }
}
//# sourceMappingURL=fruchterman.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/gpu/fruchtermanShader.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/gpu/fruchtermanShader.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clusterBundle: () => (/* binding */ clusterBundle),
/* harmony export */   clusterCode: () => (/* binding */ clusterCode),
/* harmony export */   fruchtermanBundle: () => (/* binding */ fruchtermanBundle),
/* harmony export */   fruchtermanCode: () => (/* binding */ fruchtermanCode)
/* harmony export */ });
const fruchtermanCode = `
import { globalInvocationID } from 'g-webgpu';
const MAX_EDGE_PER_VERTEX;
const VERTEX_COUNT;
@numthreads(1, 1, 1)
class Fruchterman {
  @in @out
  u_Data: vec4[];
  @in
  u_K: float;
  @in
  u_K2: float;
  
  @in
  u_Center: vec2;
  @in
  u_Gravity: float;
  @in
  u_ClusterGravity: float;
  @in
  u_Speed: float;
  @in
  u_MaxDisplace: float;
  @in
  u_Clustering: float;
  @in
  u_AttributeArray: vec4[];
  @in
  u_ClusterCenters: vec4[];
  calcRepulsive(i: int, currentNode: vec4): vec2 {
    let dx = 0, dy = 0;
    for (let j = 0; j < VERTEX_COUNT; j++) {
      if (i != j) {
        const nextNode = this.u_Data[j];
        const xDist = currentNode[0] - nextNode[0];
        const yDist = currentNode[1] - nextNode[1];
        const dist = (xDist * xDist + yDist * yDist) + 0.01;
        let param = this.u_K2 / dist;
        
        if (dist > 0.0) {
          dx += param * xDist;
          dy += param * yDist;
          if (xDist == 0 && yDist == 0) {
            const sign = i < j ? 1 : -1;
            dx += param * sign;
            dy += param * sign;
          }
        }
      }
    }
    return [dx, dy];
  }
  calcGravity(currentNode: vec4, nodeAttributes: vec4): vec2 { // 
    let dx = 0, dy = 0;
    const vx = currentNode[0] - this.u_Center[0];
    const vy = currentNode[1] - this.u_Center[1];
    const gf = 0.01 * this.u_K * this.u_Gravity;
    dx = gf * vx;
    dy = gf * vy;
    if (this.u_Clustering == 1) {
      const clusterIdx = int(nodeAttributes[0]);
      const center = this.u_ClusterCenters[clusterIdx];
      const cvx = currentNode[0] - center[0];
      const cvy = currentNode[1] - center[1];
      const dist = sqrt(cvx * cvx + cvy * cvy) + 0.01;
      const parma = this.u_K * this.u_ClusterGravity / dist;
      dx += parma * cvx;
      dy += parma * cvy;
    }
    return [dx, dy];
  }
  calcAttractive(i: int, currentNode: vec4): vec2 {
    let dx = 0, dy = 0;
    const arr_offset = int(floor(currentNode[2] + 0.5));
    const length = int(floor(currentNode[3] + 0.5));
    const node_buffer: vec4;
    for (let p = 0; p < MAX_EDGE_PER_VERTEX; p++) {
      if (p >= length) break;
      const arr_idx = arr_offset + p;
      // when arr_idx % 4 == 0 update currentNodedx_buffer
      const buf_offset = arr_idx - arr_idx / 4 * 4;
      if (p == 0 || buf_offset == 0) {
        node_buffer = this.u_Data[int(arr_idx / 4)];
      }
      const float_j = buf_offset == 0 ? node_buffer[0] :
                      buf_offset == 1 ? node_buffer[1] :
                      buf_offset == 2 ? node_buffer[2] :
                                        node_buffer[3];
      const nextNode = this.u_Data[int(float_j)];
      const xDist = currentNode[0] - nextNode[0];
      const yDist = currentNode[1] - nextNode[1];
      const dist = sqrt(xDist * xDist + yDist * yDist) + 0.01;
      let attractiveF = dist / this.u_K;
    
      if (dist > 0.0) {
        dx -= xDist * attractiveF;
        dy -= yDist * attractiveF;
        if (xDist == 0 && yDist == 0) {
          const sign = i < int(float_j) ? 1 : -1;
          dx -= sign * attractiveF;
          dy -= sign * attractiveF;
        }
      }
    }
    return [dx, dy];
  }
  @main
  compute() {
    const i = globalInvocationID.x;
    const currentNode = this.u_Data[i];
    let dx = 0, dy = 0;
    if (i >= VERTEX_COUNT) {
      this.u_Data[i] = currentNode;
      return;
    }

    // [gravity, fx, fy, 0]
    const nodeAttributes = this.u_AttributeArray[i];

    if (nodeAttributes[1] != 0 && nodeAttributes[2] != 0) {
      // the node is fixed
      this.u_Data[i] = [
        nodeAttributes[1],
        nodeAttributes[2],
        currentNode[2],
        currentNode[3]
      ];
      return;
    }

    // repulsive
    const repulsive = this.calcRepulsive(i, currentNode);
    dx += repulsive[0];
    dy += repulsive[1];
    // attractive
    const attractive = this.calcAttractive(i, currentNode);
    dx += attractive[0];
    dy += attractive[1];
    // gravity
    const gravity = this.calcGravity(currentNode, nodeAttributes);
    dx -= gravity[0];
    dy -= gravity[1];
    // speed
    dx *= this.u_Speed;
    dy *= this.u_Speed;

    // move
    const distLength = sqrt(dx * dx + dy * dy);
    if (distLength > 0.0) {
      const limitedDist = min(this.u_MaxDisplace * this.u_Speed, distLength);
      this.u_Data[i] = [
        currentNode[0] + dx / distLength * limitedDist,
        currentNode[1] + dy / distLength * limitedDist,
        currentNode[2],
        currentNode[3]
      ];
    }
  }
}
`;
const fruchtermanBundle = `{"shaders":{"WGSL":"","GLSL450":"","GLSL100":"\\n\\nfloat epsilon = 0.00001;\\nvec2 addrTranslation_1Dto2D(float address1D, vec2 texSize) {\\n  vec2 conv_const = vec2(1.0 / texSize.x, 1.0 / (texSize.x * texSize.y));\\n  vec2 normAddr2D = float(address1D) * conv_const;\\n  return vec2(fract(normAddr2D.x + epsilon), normAddr2D.y);\\n}\\n\\nvoid barrier() {}\\n  \\n\\nuniform vec2 u_OutputTextureSize;\\nuniform int u_OutputTexelCount;\\nvarying vec2 v_TexCoord;\\n\\nbool gWebGPUDebug = false;\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\n\\n#define MAX_EDGE_PER_VERTEX __DefineValuePlaceholder__MAX_EDGE_PER_VERTEX\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\n\\nuniform sampler2D u_Data;\\nuniform vec2 u_DataSize;\\nvec4 getDatau_Data(vec2 address2D) {\\n  return vec4(texture2D(u_Data, address2D).rgba);\\n}\\nvec4 getDatau_Data(float address1D) {\\n  return getDatau_Data(addrTranslation_1Dto2D(address1D, u_DataSize));\\n}\\nvec4 getDatau_Data(int address1D) {\\n  return getDatau_Data(float(address1D));\\n}\\nuniform float u_K;\\nuniform float u_K2;\\nuniform vec2 u_Center;\\nuniform float u_Gravity;\\nuniform float u_ClusterGravity;\\nuniform float u_Speed;\\nuniform float u_MaxDisplace;\\nuniform float u_Clustering;\\nuniform sampler2D u_AttributeArray;\\nuniform vec2 u_AttributeArraySize;\\nvec4 getDatau_AttributeArray(vec2 address2D) {\\n  return vec4(texture2D(u_AttributeArray, address2D).rgba);\\n}\\nvec4 getDatau_AttributeArray(float address1D) {\\n  return getDatau_AttributeArray(addrTranslation_1Dto2D(address1D, u_AttributeArraySize));\\n}\\nvec4 getDatau_AttributeArray(int address1D) {\\n  return getDatau_AttributeArray(float(address1D));\\n}\\nuniform sampler2D u_ClusterCenters;\\nuniform vec2 u_ClusterCentersSize;\\nvec4 getDatau_ClusterCenters(vec2 address2D) {\\n  return vec4(texture2D(u_ClusterCenters, address2D).rgba);\\n}\\nvec4 getDatau_ClusterCenters(float address1D) {\\n  return getDatau_ClusterCenters(addrTranslation_1Dto2D(address1D, u_ClusterCentersSize));\\n}\\nvec4 getDatau_ClusterCenters(int address1D) {\\n  return getDatau_ClusterCenters(float(address1D));\\n}\\nvec2 calcRepulsive(int i, vec4 currentNode) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat dx = 0.0;\\nfloat dy = 0.0;\\nfor (int j = 0; j < VERTEX_COUNT; j++) {if (i != j) {vec4 nextNode = getDatau_Data(j);\\nfloat xDist = currentNode.x - nextNode.x;\\nfloat yDist = currentNode.y - nextNode.y;\\nfloat dist = ((xDist * xDist) + (yDist * yDist)) + 0.01;\\nfloat param = u_K2 / dist;\\nif (dist > 0.0) {dx += param * xDist;\\ndy += param * yDist;\\nif ((xDist == 0.0) && (yDist == 0.0)) {float sign = (i < j) ? (1.0) : (-1.0);\\ndx += param * sign;\\ndy += param * sign;}}}}\\nreturn vec2(dx, dy);}\\nvec2 calcGravity(vec4 currentNode, vec4 nodeAttributes) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat dx = 0.0;\\nfloat dy = 0.0;\\nfloat vx = currentNode.x - u_Center.x;\\nfloat vy = currentNode.y - u_Center.y;\\nfloat gf = (0.01 * u_K) * u_Gravity;\\ndx = gf * vx;\\ndy = gf * vy;\\nif (u_Clustering == 1.0) {int clusterIdx = int(nodeAttributes.x);\\nvec4 center = getDatau_ClusterCenters(clusterIdx);\\nfloat cvx = currentNode.x - center.x;\\nfloat cvy = currentNode.y - center.y;\\nfloat dist = sqrt((cvx * cvx) + (cvy * cvy)) + 0.01;\\nfloat parma = (u_K * u_ClusterGravity) / dist;\\ndx += parma * cvx;\\ndy += parma * cvy;}\\nreturn vec2(dx, dy);}\\nvec2 calcAttractive(int i, vec4 currentNode) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat dx = 0.0;\\nfloat dy = 0.0;\\nint arr_offset = int(floor(currentNode.z + 0.5));\\nint length = int(floor(currentNode.w + 0.5));\\nvec4 node_buffer;\\nfor (int p = 0; p < MAX_EDGE_PER_VERTEX; p++) {if (p >= length) {break;}\\nint arr_idx = arr_offset + int(p);\\nint buf_offset = arr_idx - ((arr_idx / 4) * 4);\\nif ((p == 0) || (buf_offset == 0)) {node_buffer = getDatau_Data(int(arr_idx / 4));}\\nfloat float_j = (buf_offset == 0) ? (node_buffer.x) : ((buf_offset == 1) ? (node_buffer.y) : ((buf_offset == 2) ? (node_buffer.z) : (node_buffer.w)));\\nvec4 nextNode = getDatau_Data(int(float_j));\\nfloat xDist = currentNode.x - nextNode.x;\\nfloat yDist = currentNode.y - nextNode.y;\\nfloat dist = sqrt((xDist * xDist) + (yDist * yDist)) + 0.01;\\nfloat attractiveF = dist / u_K;\\nif (dist > 0.0) {dx -= xDist * attractiveF;\\ndy -= yDist * attractiveF;\\nif ((xDist == 0.0) && (yDist == 0.0)) {float sign = (i < int(float_j)) ? (1.0) : (-1.0);\\ndx -= sign * attractiveF;\\ndy -= sign * attractiveF;}}}\\nreturn vec2(dx, dy);}\\nvoid main() {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nint i = globalInvocationID.x;\\nvec4 currentNode = getDatau_Data(i);\\nfloat dx = 0.0;\\nfloat dy = 0.0;\\nif (i >= VERTEX_COUNT) {gl_FragColor = vec4(currentNode);\\nreturn ;}\\nvec4 nodeAttributes = getDatau_AttributeArray(i);\\nif ((nodeAttributes.y != 0.0) && (nodeAttributes.z != 0.0)) {gl_FragColor = vec4(vec4(nodeAttributes.y, nodeAttributes.z, currentNode.z, currentNode.w));\\nreturn ;}\\nvec2 repulsive = calcRepulsive(i, currentNode);\\ndx += repulsive.x;\\ndy += repulsive.y;\\nvec2 attractive = calcAttractive(i, currentNode);\\ndx += attractive.x;\\ndy += attractive.y;\\nvec2 gravity = calcGravity(currentNode, nodeAttributes);\\ndx -= gravity.x;\\ndy -= gravity.y;\\ndx *= u_Speed;\\ndy *= u_Speed;\\nfloat distLength = sqrt((dx * dx) + (dy * dy));\\nif (distLength > 0.0) {float limitedDist = min(u_MaxDisplace * u_Speed, distLength);\\ngl_FragColor = vec4(vec4(currentNode.x + ((dx / distLength) * limitedDist), currentNode.y + ((dy / distLength) * limitedDist), currentNode.z, currentNode.w));}if (gWebGPUDebug) {\\n  gl_FragColor = gWebGPUDebugOutput;\\n}}\\n"},"context":{"name":"","dispatch":[1,1,1],"threadGroupSize":[1,1,1],"maxIteration":1,"defines":[{"name":"MAX_EDGE_PER_VERTEX","type":"Float","runtime":true},{"name":"VERTEX_COUNT","type":"Float","runtime":true}],"uniforms":[{"name":"u_Data","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":false,"writeonly":false,"size":[1,1]},{"name":"u_K","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_K2","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_Center","type":"vec2<f32>","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_Gravity","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_ClusterGravity","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_Speed","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_MaxDisplace","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_Clustering","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_AttributeArray","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_ClusterCenters","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]}],"globalDeclarations":[],"output":{"name":"u_Data","size":[1,1],"length":1},"needPingpong":true}}`;
const clusterCode = `
import { globalInvocationID } from 'g-webgpu';
const VERTEX_COUNT;
const CLUSTER_COUNT;
@numthreads(1, 1, 1)
class CalcCenter {
  @in
  u_Data: vec4[];
  @in
  u_NodeAttributes: vec4[]; // [[clusterIdx, 0, 0, 0], ...]
  @in @out
  u_ClusterCenters: vec4[]; // [[cx, cy, nodeCount, clusterIdx], ...]
  @main
  compute() {
    const i = globalInvocationID.x;
    const center = this.u_ClusterCenters[i];
    let sumx = 0;
    let sumy = 0;
    let count = 0;
    for (let j = 0; j < VERTEX_COUNT; j++) {
      const attributes = this.u_NodeAttributes[j];
      const clusterIdx = int(attributes[0]);
      const vertex = this.u_Data[j];
      if (clusterIdx == i) {
        sumx += vertex.x;
        sumy += vertex.y;
        count += 1;
      }
    }
    this.u_ClusterCenters[i] = [
      sumx / count,
      sumy / count,
      count,
      i
    ];
  }
}
`;
const clusterBundle = `{"shaders":{"WGSL":"","GLSL450":"","GLSL100":"\\n\\nfloat epsilon = 0.00001;\\nvec2 addrTranslation_1Dto2D(float address1D, vec2 texSize) {\\n  vec2 conv_const = vec2(1.0 / texSize.x, 1.0 / (texSize.x * texSize.y));\\n  vec2 normAddr2D = float(address1D) * conv_const;\\n  return vec2(fract(normAddr2D.x + epsilon), normAddr2D.y);\\n}\\n\\nvoid barrier() {}\\n  \\n\\nuniform vec2 u_OutputTextureSize;\\nuniform int u_OutputTexelCount;\\nvarying vec2 v_TexCoord;\\n\\nbool gWebGPUDebug = false;\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\n\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\n#define CLUSTER_COUNT __DefineValuePlaceholder__CLUSTER_COUNT\\n\\nuniform sampler2D u_Data;\\nuniform vec2 u_DataSize;\\nvec4 getDatau_Data(vec2 address2D) {\\n  return vec4(texture2D(u_Data, address2D).rgba);\\n}\\nvec4 getDatau_Data(float address1D) {\\n  return getDatau_Data(addrTranslation_1Dto2D(address1D, u_DataSize));\\n}\\nvec4 getDatau_Data(int address1D) {\\n  return getDatau_Data(float(address1D));\\n}\\nuniform sampler2D u_NodeAttributes;\\nuniform vec2 u_NodeAttributesSize;\\nvec4 getDatau_NodeAttributes(vec2 address2D) {\\n  return vec4(texture2D(u_NodeAttributes, address2D).rgba);\\n}\\nvec4 getDatau_NodeAttributes(float address1D) {\\n  return getDatau_NodeAttributes(addrTranslation_1Dto2D(address1D, u_NodeAttributesSize));\\n}\\nvec4 getDatau_NodeAttributes(int address1D) {\\n  return getDatau_NodeAttributes(float(address1D));\\n}\\nuniform sampler2D u_ClusterCenters;\\nuniform vec2 u_ClusterCentersSize;\\nvec4 getDatau_ClusterCenters(vec2 address2D) {\\n  return vec4(texture2D(u_ClusterCenters, address2D).rgba);\\n}\\nvec4 getDatau_ClusterCenters(float address1D) {\\n  return getDatau_ClusterCenters(addrTranslation_1Dto2D(address1D, u_ClusterCentersSize));\\n}\\nvec4 getDatau_ClusterCenters(int address1D) {\\n  return getDatau_ClusterCenters(float(address1D));\\n}\\nvoid main() {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nint i = globalInvocationID.x;\\nvec4 center = getDatau_ClusterCenters(i);\\nfloat sumx = 0.0;\\nfloat sumy = 0.0;\\nfloat count = 0.0;\\nfor (int j = 0; j < VERTEX_COUNT; j++) {vec4 attributes = getDatau_NodeAttributes(j);\\nint clusterIdx = int(attributes.x);\\nvec4 vertex = getDatau_Data(j);\\nif (clusterIdx == i) {sumx += vertex.x;\\nsumy += vertex.y;\\ncount += 1.0;}}\\ngl_FragColor = vec4(vec4(sumx / count, sumy / count, count, i));if (gWebGPUDebug) {\\n  gl_FragColor = gWebGPUDebugOutput;\\n}}\\n"},"context":{"name":"","dispatch":[1,1,1],"threadGroupSize":[1,1,1],"maxIteration":1,"defines":[{"name":"VERTEX_COUNT","type":"Float","runtime":true},{"name":"CLUSTER_COUNT","type":"Float","runtime":true}],"uniforms":[{"name":"u_Data","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_NodeAttributes","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_ClusterCenters","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":false,"writeonly":false,"size":[1,1]}],"globalDeclarations":[],"output":{"name":"u_ClusterCenters","size":[1,1],"length":1},"needPingpong":true}}`;
//# sourceMappingURL=fruchtermanShader.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/gpu/gForce.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/gpu/gForce.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GForceGPULayout: () => (/* binding */ GForceGPULayout)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./node_modules/@antv/layout/es/layout/base.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util */ "./node_modules/@antv/layout/es/util/index.js");
/* harmony import */ var _antv_g_webgpu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @antv/g-webgpu */ "./node_modules/@antv/g-webgpu/es/index.js");
/* harmony import */ var _util_gpu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/gpu */ "./node_modules/@antv/layout/es/util/gpu.js");
/* harmony import */ var _util_math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/math */ "./node_modules/@antv/layout/es/util/math.js");
/* harmony import */ var _gForceShader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./gForceShader */ "./node_modules/@antv/layout/es/layout/gpu/gForceShader.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../constants */ "./node_modules/@antv/layout/es/layout/constants.js");
// @ts-nocheck
/**
 * @fileOverview fruchterman layout
 * @author shiwu.wyy@antfin.com
 */
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


// @ts-ignore





/**
 * graphin 中的 force 布局
 */
class GForceGPULayout extends _base__WEBPACK_IMPORTED_MODULE_0__.Base {
    constructor(options) {
        super();
        /** 停止迭代的最大迭代数 */
        this.maxIteration = 1000;
        /** 弹簧引力系数 */
        this.edgeStrength = 200;
        /** 斥力系数 */
        this.nodeStrength = 1000;
        /** 库伦系数 */
        this.coulombDisScale = 0.005;
        /** 阻尼系数 */
        this.damping = 0.9;
        /** 最大速度 */
        this.maxSpeed = 1000;
        /** 一次迭代的平均移动距离小于该值时停止迭代 */
        this.minMovement = 0.5;
        /** 迭代中衰减 */
        this.interval = 0.02;
        /** 斥力的一个系数 */
        this.factor = 1;
        /** 理想边长 */
        this.linkDistance = 1;
        /** 重力大小 */
        this.gravity = 10;
        /** 是否启用web worker。前提是在web worker里执行布局，否则无效	*/
        this.workerEnabled = false;
        this.nodes = [];
        this.edges = [];
        this.width = 300;
        this.height = 300;
        this.nodeMap = {};
        this.nodeIdxMap = {};
        this.updateCfg(options);
    }
    getDefaultCfg() {
        return {
            maxIteration: 2000,
            gravity: 10,
            clustering: false,
            clusterGravity: 10
        };
    }
    /**
     * 执行布局
     */
    execute() {
        return __awaiter(this, void 0, void 0, function* () {
            const self = this;
            const nodes = self.nodes;
            if (!nodes || nodes.length === 0) {
                if (self.onLayoutEnd)
                    self.onLayoutEnd();
                return;
            }
            if (!self.width && typeof window !== "undefined") {
                self.width = window.innerWidth;
            }
            if (!self.height && typeof window !== "undefined") {
                self.height = window.innerHeight;
            }
            if (!self.center) {
                self.center = [self.width / 2, self.height / 2];
            }
            const center = self.center;
            if (nodes.length === 1) {
                nodes[0].x = center[0];
                nodes[0].y = center[1];
                if (self.onLayoutEnd)
                    self.onLayoutEnd();
                return;
            }
            const nodeMap = {};
            const nodeIdxMap = {};
            nodes.forEach((node, i) => {
                if (!(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(node.x))
                    node.x = Math.random() * self.width;
                if (!(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(node.y))
                    node.y = Math.random() * self.height;
                nodeMap[node.id] = node;
                nodeIdxMap[node.id] = i;
            });
            self.nodeMap = nodeMap;
            self.nodeIdxMap = nodeIdxMap;
            self.nodeStrength = (0,_util_gpu__WEBPACK_IMPORTED_MODULE_3__.proccessToFunc)(self.nodeStrength, 1);
            self.edgeStrength = (0,_util_gpu__WEBPACK_IMPORTED_MODULE_3__.proccessToFunc)(self.edgeStrength, 1);
            // layout
            yield self.run();
        });
    }
    executeWithWorker(canvas, ctx) {
        const self = this;
        const nodes = self.nodes;
        const center = self.center;
        if (!nodes || nodes.length === 0) {
            return;
        }
        if (nodes.length === 1) {
            nodes[0].x = center[0];
            nodes[0].y = center[1];
            return;
        }
        const nodeMap = {};
        const nodeIdxMap = {};
        nodes.forEach((node, i) => {
            if (!(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(node.x))
                node.x = Math.random() * self.width;
            if (!(0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(node.y))
                node.y = Math.random() * self.height;
            nodeMap[node.id] = node;
            nodeIdxMap[node.id] = i;
        });
        self.nodeMap = nodeMap;
        self.nodeIdxMap = nodeIdxMap;
        self.nodeStrength = (0,_util_gpu__WEBPACK_IMPORTED_MODULE_3__.proccessToFunc)(self.nodeStrength, 1);
        self.edgeStrength = (0,_util_gpu__WEBPACK_IMPORTED_MODULE_3__.proccessToFunc)(self.edgeStrength, 1);
        // layout
        self.run(canvas, ctx);
    }
    run(canvas, ctx) {
        return __awaiter(this, void 0, void 0, function* () {
            const self = this;
            const nodes = self.nodes;
            const edges = self.edges;
            const maxIteration = self.maxIteration;
            if (!self.width && typeof window !== "undefined") {
                self.width = window.innerWidth;
            }
            if (!self.height && typeof window !== "undefined") {
                self.height = window.innerHeight;
            }
            const numParticles = nodes.length;
            self.linkDistance = (0,_util_gpu__WEBPACK_IMPORTED_MODULE_3__.proccessToFunc)(self.linkDistance);
            self.edgeStrength = (0,_util_gpu__WEBPACK_IMPORTED_MODULE_3__.proccessToFunc)(self.edgeStrength);
            const { maxEdgePerVetex, array: nodesEdgesArray } = (0,_util_gpu__WEBPACK_IMPORTED_MODULE_3__.buildTextureDataWithTwoEdgeAttr)(nodes, edges, self.linkDistance, self.edgeStrength);
            // init degree for mass
            self.degrees = (0,_util_math__WEBPACK_IMPORTED_MODULE_4__.getDegree)(nodes.length, self.nodeIdxMap, edges).map((degree) => degree.all);
            const masses = [];
            const nodeStrengths = [];
            const centerXs = [];
            const centerYs = [];
            const centerGravities = [];
            const fxs = [];
            const fys = [];
            if (!self.getMass) {
                self.getMass = (d) => {
                    return self.degrees[self.nodeIdxMap[d.id]] || 1;
                };
            }
            const gravity = self.gravity;
            const center = self.center;
            nodes.forEach((node, i) => {
                masses.push(self.getMass(node));
                nodeStrengths.push(self.nodeStrength(node));
                if (!self.degrees[i])
                    self.degrees[i] = 0;
                let nodeGravity = [center[0], center[1], gravity];
                if (self.getCenter) {
                    const customCenter = self.getCenter(node, self.degrees[i]);
                    if (customCenter &&
                        (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(customCenter[0]) &&
                        (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(customCenter[1]) &&
                        (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(customCenter[2])) {
                        nodeGravity = customCenter;
                    }
                }
                centerXs.push(nodeGravity[0]);
                centerYs.push(nodeGravity[1]);
                centerGravities.push(nodeGravity[2]);
                if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(node.fx) && (0,_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(node.fy)) {
                    fxs.push(node.fx || 0.001);
                    fys.push(node.fy || 0.001);
                }
                else {
                    fxs.push(0);
                    fys.push(0);
                }
            });
            // 每个节点的额外属性占两个数组各一格，nodeAttributeArray1 中是：mass, degree, nodeSterngth, 0
            const nodeAttributeArray1 = (0,_util_gpu__WEBPACK_IMPORTED_MODULE_3__.arrayToTextureData)([
                masses,
                self.degrees,
                nodeStrengths,
                fxs
            ]);
            // nodeAttributeArray2 中是：centerX, centerY, gravity, 0,
            const nodeAttributeArray2 = (0,_util_gpu__WEBPACK_IMPORTED_MODULE_3__.arrayToTextureData)([
                centerXs,
                centerYs,
                centerGravities,
                fys
            ]);
            const workerEnabled = self.workerEnabled;
            let world;
            if (workerEnabled) {
                world = _antv_g_webgpu__WEBPACK_IMPORTED_MODULE_2__.World.create({
                    canvas,
                    engineOptions: {
                        supportCompute: true
                    }
                });
            }
            else {
                world = _antv_g_webgpu__WEBPACK_IMPORTED_MODULE_2__.World.create({
                    engineOptions: {
                        supportCompute: true
                    }
                });
            }
            // TODO: 最终的预编译代码放入到 gForceShader.ts 中直接引入，不再需要下面三行
            // const compiler = new Compiler();
            // const gForceBundle = compiler.compileBundle(gForceCode);
            // console.log(gForceBundle.toString());
            const onLayoutEnd = self.onLayoutEnd;
            const initPreviousData = [];
            nodesEdgesArray.forEach((value) => {
                initPreviousData.push(value);
            });
            for (let i = 0; i < 4; i++) {
                initPreviousData.push(0);
            }
            const kernelGForce = world
                .createKernel(_gForceShader__WEBPACK_IMPORTED_MODULE_5__.gForceBundle)
                .setDispatch([numParticles, 1, 1])
                .setBinding({
                u_Data: nodesEdgesArray,
                u_damping: self.damping,
                u_maxSpeed: self.maxSpeed,
                u_minMovement: self.minMovement,
                u_coulombDisScale: self.coulombDisScale,
                u_factor: self.factor,
                u_NodeAttributeArray1: nodeAttributeArray1,
                u_NodeAttributeArray2: nodeAttributeArray2,
                MAX_EDGE_PER_VERTEX: maxEdgePerVetex,
                VERTEX_COUNT: numParticles,
                u_AveMovement: initPreviousData,
                u_interval: self.interval // 每次迭代更新，首次设置为 interval，在 onIterationCompleted 中更新
            });
            // const aveMovementBundle = compiler.compileBundle(aveMovementCode);
            // console.log(aveMovementBundle.toString());
            const kernelAveMovement = world
                .createKernel(_gForceShader__WEBPACK_IMPORTED_MODULE_5__.aveMovementBundle)
                .setDispatch([1, 1, 1])
                .setBinding({
                u_Data: nodesEdgesArray,
                VERTEX_COUNT: numParticles,
                u_AveMovement: [0, 0, 0, 0]
            });
            // 执行迭代
            // let midRes = nodesEdgesArray;
            const execute = () => __awaiter(this, void 0, void 0, function* () {
                for (let i = 0; i < maxIteration; i++) {
                    // TODO: 似乎都来自 kernelGForce 是一个引用
                    // 当前坐标作为下一次迭代的 PreviousData
                    // if (i > 0) {
                    //   kernelAveMovement.setBinding({
                    //     u_PreviousData: kernelGForce
                    //   });
                    // }
                    // eslint-disable-next-line no-await-in-loop
                    yield kernelGForce.execute();
                    // midRes = await kernelGForce.getOutput();
                    // 每次迭代完成后
                    // 计算平均位移，用于提前终止迭代
                    kernelAveMovement.setBinding({
                        u_Data: kernelGForce
                    });
                    // eslint-disable-next-line no-await-in-loop
                    yield kernelAveMovement.execute();
                    // 更新衰减函数
                    const stepInterval = Math.max(0.02, self.interval - i * 0.002);
                    kernelGForce.setBinding({
                        u_interval: stepInterval,
                        u_AveMovement: kernelAveMovement
                    });
                }
                const finalParticleData = yield kernelGForce.getOutput();
                // 所有迭代完成后
                if (canvas) {
                    // 传递数据给主线程
                    ctx.postMessage({
                        type: _constants__WEBPACK_IMPORTED_MODULE_6__.LAYOUT_MESSAGE.GPUEND,
                        vertexEdgeData: finalParticleData
                        // edgeIndexBufferData,
                    });
                }
                else {
                    nodes.forEach((node, i) => {
                        const x = finalParticleData[4 * i];
                        const y = finalParticleData[4 * i + 1];
                        node.x = x;
                        node.y = y;
                    });
                }
                if (onLayoutEnd)
                    onLayoutEnd();
            });
            yield execute();
        });
    }
    getType() {
        return "gForce-gpu";
    }
}
//# sourceMappingURL=gForce.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/gpu/gForceShader.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/gpu/gForceShader.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   aveMovementBundle: () => (/* binding */ aveMovementBundle),
/* harmony export */   aveMovementCode: () => (/* binding */ aveMovementCode),
/* harmony export */   gForceBundle: () => (/* binding */ gForceBundle),
/* harmony export */   gForceCode: () => (/* binding */ gForceCode)
/* harmony export */ });
const gForceCode = `
import { globalInvocationID } from 'g-webgpu';

const MAX_EDGE_PER_VERTEX;
const VERTEX_COUNT;
const SHIFT_20 = 1048576;

@numthreads(1, 1, 1)
class GGForce {
  @in @out
  u_Data: vec4[];

  @in
  u_damping: float;
  
  @in
  u_maxSpeed: float;

  @in
  u_minMovement: float;

  @in
  u_AveMovement: vec4[];

  @in
  u_coulombDisScale: float;

  @in
  u_factor: float;

  @in
  u_NodeAttributeArray1: vec4[];

  @in
  u_NodeAttributeArray2: vec4[];

  @in
  u_interval: float;

  unpack_float(packedValue: float): ivec2 {
    const packedIntValue = int(packedValue);
    const v0 = packedIntValue / SHIFT_20;
    return [v0, packedIntValue - v0 * SHIFT_20];
  }

  calcRepulsive(i: int, currentNode: vec4): vec2 {
    let ax = 0, ay = 0;
    for (let j: int = 0; j < VERTEX_COUNT; j++) {
      if (i != j) {
        const nextNode = this.u_Data[j];
        const vx = currentNode[0] - nextNode[0];
        const vy = currentNode[1] - nextNode[1];
        const dist = sqrt(vx * vx + vy * vy) + 0.01;
        const n_dist = (dist + 0.1) * this.u_coulombDisScale;
        const direx = vx / dist;
        const direy = vy / dist;
        const attributesi = this.u_NodeAttributeArray1[i];
        const attributesj = this.u_NodeAttributeArray1[j];
        const massi = attributesi[0];
        const nodeStrengthi = attributesi[2];
        const nodeStrengthj = attributesj[2];
        const nodeStrength = (nodeStrengthi + nodeStrengthj) / 2;
        // const param = nodeStrength * this.u_factor / (n_dist * n_dist * massi);
        const param = nodeStrength * this.u_factor / (n_dist * n_dist);
        ax += direx * param;
        ay += direy * param;
      }
    }
    return [ax, ay];
  }

  calcGravity(i: int, currentNode: vec4, attributes2: vec4): vec2 {
    // note: attributes2 = [centerX, centerY, gravity, 0]

    const vx = currentNode[0] - attributes2[0];
    const vy = currentNode[1] - attributes2[1];
    
    const ax = vx * attributes2[2];
    const ay = vy * attributes2[2];
    
    return [ax, ay];
  }

  calcAttractive(i: int, currentNode: vec4, attributes1: vec4): vec2 {
    // note: attributes1 = [mass, degree, nodeSterngth, 0]

    const mass = attributes1[0];
    let ax = 0, ay = 0;
    // const arr_offset = int(floor(currentNode[2] + 0.5));
    // const length = int(floor(currentNode[3] + 0.5));

    const compressed = this.unpack_float(currentNode[2]);
    const length = compressed[0];
    const arr_offset = compressed[1];

    const node_buffer: vec4;
    for (let p: int = 0; p < MAX_EDGE_PER_VERTEX; p++) {
      if (p >= length) break;
      const arr_idx = arr_offset + 4 * p; // i 节点的第 p 条边开始的小格子位置
      const buf_offset = arr_idx - arr_idx / 4 * 4;
      if (p == 0 || buf_offset == 0) {
        node_buffer = this.u_Data[int(arr_idx / 4)]; // 大格子，大格子位置=小个子位置 / 4，
      }

      let float_j: float = node_buffer[0];

      const nextNode = this.u_Data[int(float_j)];
      const vx = nextNode[0] - currentNode[0];
      const vy = nextNode[1] - currentNode[1];
      const dist = sqrt(vx * vx + vy * vy) + 0.01;
      const direx = vx / dist;
      const direy = vy / dist;
      const edgeLength = node_buffer[1];
      const edgeStrength = node_buffer[2];
      const diff: float = edgeLength - dist;//edgeLength
      // const param = diff * this.u_stiffness / mass; //
      const param = diff * edgeStrength / mass; // 
      ax -= direx * param;
      ay -= direy * param;
    }
    return [ax, ay];
  }

  @main
  compute() {
    const i = globalInvocationID.x;
    const currentNode = this.u_Data[i];
    const movement = u_AveMovement[0];
    let ax = 0, ay = 0;

    if (i >= VERTEX_COUNT || movement.x < u_minMovement) {
      this.u_Data[i] = currentNode;
      return;
    }

    // 每个节点属性占两个数组中各一格
    // [mass, degree, nodeStrength, fx]
    const nodeAttributes1 = this.u_NodeAttributeArray1[i];
    // [centerX, centerY, centerGravity, fy]
    const nodeAttributes2 = this.u_NodeAttributeArray2[i];

    // repulsive
    const repulsive = this.calcRepulsive(i, currentNode);
    ax += repulsive[0];
    ay += repulsive[1];

    // attractive
    const attractive = this.calcAttractive(i, currentNode, nodeAttributes1);
    ax += attractive[0];
    ay += attractive[1];

    // gravity
    const gravity = this.calcGravity(i, currentNode, nodeAttributes2);
    ax -= gravity[0];
    ay -= gravity[1];

    // speed
    const param = this.u_interval * this.u_damping;
    let vx = ax * param;
    let vy = ay * param;
    const vlength = sqrt(vx * vx + vy * vy) + 0.0001;
    if (vlength > this.u_maxSpeed) {
      const param2 = this.u_maxSpeed / vlength;
      vx = param2 * vx;
      vy = param2 * vy;
    }

    // move
    if (nodeAttributes1[3] != 0 && nodeAttributes2[3] != 0) {
      this.u_Data[i] = [
        nodeAttributes1[3],
        nodeAttributes2[3],
        currentNode[2],
        0
      ];
    } else {
      const distx = vx * this.u_interval;
      const disty = vy * this.u_interval;
      const distLength = sqrt(distx * distx + disty * disty);
      this.u_Data[i] = [
        currentNode[0] + distx,
        currentNode[1] + disty,
        currentNode[2],
        distLength
      ];
    }
    
    // the avarage move distance
    // need to share memory
    
  }
}
`;
const gForceBundle = `{"shaders":{"WGSL":"","GLSL450":"","GLSL100":"\\n\\nfloat epsilon = 0.00001;\\nvec2 addrTranslation_1Dto2D(float address1D, vec2 texSize) {\\n  vec2 conv_const = vec2(1.0 / texSize.x, 1.0 / (texSize.x * texSize.y));\\n  vec2 normAddr2D = float(address1D) * conv_const;\\n  return vec2(fract(normAddr2D.x + epsilon), normAddr2D.y);\\n}\\n\\nvoid barrier() {}\\n  \\n\\nuniform vec2 u_OutputTextureSize;\\nuniform int u_OutputTexelCount;\\nvarying vec2 v_TexCoord;\\n\\nbool gWebGPUDebug = false;\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\n\\n#define MAX_EDGE_PER_VERTEX __DefineValuePlaceholder__MAX_EDGE_PER_VERTEX\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\n#define SHIFT_20 1048576.0\\n\\nuniform sampler2D u_Data;\\nuniform vec2 u_DataSize;\\nvec4 getDatau_Data(vec2 address2D) {\\n  return vec4(texture2D(u_Data, address2D).rgba);\\n}\\nvec4 getDatau_Data(float address1D) {\\n  return getDatau_Data(addrTranslation_1Dto2D(address1D, u_DataSize));\\n}\\nvec4 getDatau_Data(int address1D) {\\n  return getDatau_Data(float(address1D));\\n}\\nuniform float u_damping;\\nuniform float u_maxSpeed;\\nuniform float u_minMovement;\\nuniform sampler2D u_AveMovement;\\nuniform vec2 u_AveMovementSize;\\nvec4 getDatau_AveMovement(vec2 address2D) {\\n  return vec4(texture2D(u_AveMovement, address2D).rgba);\\n}\\nvec4 getDatau_AveMovement(float address1D) {\\n  return getDatau_AveMovement(addrTranslation_1Dto2D(address1D, u_AveMovementSize));\\n}\\nvec4 getDatau_AveMovement(int address1D) {\\n  return getDatau_AveMovement(float(address1D));\\n}\\nuniform float u_coulombDisScale;\\nuniform float u_factor;\\nuniform sampler2D u_NodeAttributeArray1;\\nuniform vec2 u_NodeAttributeArray1Size;\\nvec4 getDatau_NodeAttributeArray1(vec2 address2D) {\\n  return vec4(texture2D(u_NodeAttributeArray1, address2D).rgba);\\n}\\nvec4 getDatau_NodeAttributeArray1(float address1D) {\\n  return getDatau_NodeAttributeArray1(addrTranslation_1Dto2D(address1D, u_NodeAttributeArray1Size));\\n}\\nvec4 getDatau_NodeAttributeArray1(int address1D) {\\n  return getDatau_NodeAttributeArray1(float(address1D));\\n}\\nuniform sampler2D u_NodeAttributeArray2;\\nuniform vec2 u_NodeAttributeArray2Size;\\nvec4 getDatau_NodeAttributeArray2(vec2 address2D) {\\n  return vec4(texture2D(u_NodeAttributeArray2, address2D).rgba);\\n}\\nvec4 getDatau_NodeAttributeArray2(float address1D) {\\n  return getDatau_NodeAttributeArray2(addrTranslation_1Dto2D(address1D, u_NodeAttributeArray2Size));\\n}\\nvec4 getDatau_NodeAttributeArray2(int address1D) {\\n  return getDatau_NodeAttributeArray2(float(address1D));\\n}\\nuniform float u_interval;\\nivec2 unpack_float(float packedValue) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nint packedIntValue = int(packedValue);\\nint v0 = packedIntValue / int(SHIFT_20);\\nreturn ivec2(v0, packedIntValue - (v0 * int(SHIFT_20)));}\\nvec2 calcRepulsive(int i, vec4 currentNode) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat ax = 0.0;\\nfloat ay = 0.0;\\nfor (int j = 0; j < VERTEX_COUNT; j++) {if (i != j) {vec4 nextNode = getDatau_Data(j);\\nfloat vx = currentNode.x - nextNode.x;\\nfloat vy = currentNode.y - nextNode.y;\\nfloat dist = sqrt((vx * vx) + (vy * vy)) + 0.01;\\nfloat n_dist = (dist + 0.1) * u_coulombDisScale;\\nfloat direx = vx / dist;\\nfloat direy = vy / dist;\\nvec4 attributesi = getDatau_NodeAttributeArray1(i);\\nvec4 attributesj = getDatau_NodeAttributeArray1(j);\\nfloat massi = attributesi.x;\\nfloat nodeStrengthi = attributesi.z;\\nfloat nodeStrengthj = attributesj.z;\\nfloat nodeStrength = (nodeStrengthi + nodeStrengthj) / 2.0;\\nfloat param = (nodeStrength * u_factor) / (n_dist * n_dist);\\nax += direx * param;\\nay += direy * param;}}\\nreturn vec2(ax, ay);}\\nvec2 calcGravity(int i, vec4 currentNode, vec4 attributes2) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat vx = currentNode.x - attributes2.x;\\nfloat vy = currentNode.y - attributes2.y;\\nfloat ax = vx * attributes2.z;\\nfloat ay = vy * attributes2.z;\\nreturn vec2(ax, ay);}\\nvec2 calcAttractive(int i, vec4 currentNode, vec4 attributes1) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat mass = attributes1.x;\\nfloat ax = 0.0;\\nfloat ay = 0.0;\\nivec2 compressed = unpack_float(currentNode.z);\\nint length = compressed.x;\\nint arr_offset = compressed.y;\\nvec4 node_buffer;\\nfor (int p = 0; p < MAX_EDGE_PER_VERTEX; p++) {if (p >= length) {break;}\\nint arr_idx = arr_offset + (4 * p);\\nint buf_offset = arr_idx - ((arr_idx / 4) * 4);\\nif ((p == 0) || (buf_offset == 0)) {node_buffer = getDatau_Data(int(arr_idx / 4));}\\nfloat float_j = node_buffer.x;\\nvec4 nextNode = getDatau_Data(int(float_j));\\nfloat vx = nextNode.x - currentNode.x;\\nfloat vy = nextNode.y - currentNode.y;\\nfloat dist = sqrt((vx * vx) + (vy * vy)) + 0.01;\\nfloat direx = vx / dist;\\nfloat direy = vy / dist;\\nfloat edgeLength = node_buffer.y;\\nfloat edgeStrength = node_buffer.z;\\nfloat diff = edgeLength - dist;\\nfloat param = (diff * edgeStrength) / mass;\\nax -= direx * param;\\nay -= direy * param;}\\nreturn vec2(ax, ay);}\\nvoid main() {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nint i = globalInvocationID.x;\\nvec4 currentNode = getDatau_Data(i);\\nvec4 movement = getDatau_AveMovement(0.0);\\nfloat ax = 0.0;\\nfloat ay = 0.0;\\nif ((i >= VERTEX_COUNT) || (movement.x < u_minMovement)) {gl_FragColor = vec4(currentNode);\\nreturn ;}\\nvec4 nodeAttributes1 = getDatau_NodeAttributeArray1(i);\\nvec4 nodeAttributes2 = getDatau_NodeAttributeArray2(i);\\nvec2 repulsive = calcRepulsive(i, currentNode);\\nax += repulsive.x;\\nay += repulsive.y;\\nvec2 attractive = calcAttractive(i, currentNode, nodeAttributes1);\\nax += attractive.x;\\nay += attractive.y;\\nvec2 gravity = calcGravity(i, currentNode, nodeAttributes2);\\nax -= gravity.x;\\nay -= gravity.y;\\nfloat param = u_interval * u_damping;\\nfloat vx = ax * param;\\nfloat vy = ay * param;\\nfloat vlength = sqrt((vx * vx) + (vy * vy)) + 0.0001;\\nif (vlength > u_maxSpeed) {float param2 = u_maxSpeed / vlength;\\nvx = param2 * vx;\\nvy = param2 * vy;}\\nif ((nodeAttributes1.w != 0.0) && (nodeAttributes2.w != 0.0)) {gl_FragColor = vec4(vec4(nodeAttributes1.w, nodeAttributes2.w, currentNode.z, 0.0));}else {float distx = vx * u_interval;\\nfloat disty = vy * u_interval;\\nfloat distLength = sqrt((distx * distx) + (disty * disty));\\ngl_FragColor = vec4(vec4(currentNode.x + distx, currentNode.y + disty, currentNode.z, distLength));}if (gWebGPUDebug) {\\n  gl_FragColor = gWebGPUDebugOutput;\\n}}\\n"},"context":{"name":"","dispatch":[1,1,1],"threadGroupSize":[1,1,1],"maxIteration":1,"defines":[{"name":"MAX_EDGE_PER_VERTEX","type":"Float","runtime":true},{"name":"VERTEX_COUNT","type":"Float","runtime":true},{"name":"SHIFT_20","type":"Float","value":1048576,"runtime":false}],"uniforms":[{"name":"u_Data","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":false,"writeonly":false,"size":[1,1]},{"name":"u_damping","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_maxSpeed","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_minMovement","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_AveMovement","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_coulombDisScale","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_factor","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_NodeAttributeArray1","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_NodeAttributeArray2","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_interval","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]}],"globalDeclarations":[],"output":{"name":"u_Data","size":[1,1],"length":1},"needPingpong":true}}`;
const aveMovementCode = `
const VERTEX_COUNT;
@numthreads(1, 1, 1)
class CalcAveMovement {
  @in
  u_Data: vec4[];
  @in
  u_iter: float;
  @in @out
  u_AveMovement: vec4[];
  @main
  compute() {
    let movement = 0;
    for (let j: int = 0; j < VERTEX_COUNT; j++) {
      const vertex = this.u_Data[j];
      movement += vertex[3];
    }
    movement = movement / float(VERTEX_COUNT);
    this.u_AveMovement[0] = [movement, 0, 0, 0];
  }
}
`;
const aveMovementBundle = `{"shaders":{"WGSL":"","GLSL450":"","GLSL100":"\\n\\nfloat epsilon = 0.00001;\\nvec2 addrTranslation_1Dto2D(float address1D, vec2 texSize) {\\n  vec2 conv_const = vec2(1.0 / texSize.x, 1.0 / (texSize.x * texSize.y));\\n  vec2 normAddr2D = float(address1D) * conv_const;\\n  return vec2(fract(normAddr2D.x + epsilon), normAddr2D.y);\\n}\\n\\nvoid barrier() {}\\n  \\n\\nuniform vec2 u_OutputTextureSize;\\nuniform int u_OutputTexelCount;\\nvarying vec2 v_TexCoord;\\n\\nbool gWebGPUDebug = false;\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\n\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\n\\nuniform sampler2D u_Data;\\nuniform vec2 u_DataSize;\\nvec4 getDatau_Data(vec2 address2D) {\\n  return vec4(texture2D(u_Data, address2D).rgba);\\n}\\nvec4 getDatau_Data(float address1D) {\\n  return getDatau_Data(addrTranslation_1Dto2D(address1D, u_DataSize));\\n}\\nvec4 getDatau_Data(int address1D) {\\n  return getDatau_Data(float(address1D));\\n}\\nuniform float u_iter;\\nuniform sampler2D u_AveMovement;\\nuniform vec2 u_AveMovementSize;\\nvec4 getDatau_AveMovement(vec2 address2D) {\\n  return vec4(texture2D(u_AveMovement, address2D).rgba);\\n}\\nvec4 getDatau_AveMovement(float address1D) {\\n  return getDatau_AveMovement(addrTranslation_1Dto2D(address1D, u_AveMovementSize));\\n}\\nvec4 getDatau_AveMovement(int address1D) {\\n  return getDatau_AveMovement(float(address1D));\\n}\\nvoid main() {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat movement = 0.0;\\nfor (int j = 0; j < VERTEX_COUNT; j++) {vec4 vertex = getDatau_Data(j);\\nmovement += vertex.w;}\\nmovement = movement / float(VERTEX_COUNT);\\ngl_FragColor = vec4(vec4(movement, 0.0, 0.0, 0.0));if (gWebGPUDebug) {\\n  gl_FragColor = gWebGPUDebugOutput;\\n}}\\n"},"context":{"name":"","dispatch":[1,1,1],"threadGroupSize":[1,1,1],"maxIteration":1,"defines":[{"name":"VERTEX_COUNT","type":"Float","runtime":true}],"uniforms":[{"name":"u_Data","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_iter","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_AveMovement","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":false,"writeonly":false,"size":[1,1]}],"globalDeclarations":[],"output":{"name":"u_AveMovement","size":[1,1],"length":1},"needPingpong":true}}`;
//# sourceMappingURL=gForceShader.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/grid.js":
/*!*****************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/grid.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GridLayout: () => (/* binding */ GridLayout)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/layout/es/util/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./node_modules/@antv/layout/es/layout/base.js");
/**
 * @fileOverview grid layout
 * @author shiwu.wyy@antfin.com
 * this algorithm refers to <cytoscape.js> - https://github.com/cytoscape/cytoscape.js/
 */


/**
 * 网格布局
 */
class GridLayout extends _base__WEBPACK_IMPORTED_MODULE_1__.Base {
    constructor(options) {
        super();
        /** 布局起始点 */
        this.begin = [0, 0];
        /** prevents node overlap, may overflow boundingBox if not enough space */
        this.preventOverlap = true;
        /** extra spacing around nodes when preventOverlap: true */
        this.preventOverlapPadding = 10;
        /** uses all available space on false, uses minimal space on true */
        this.condense = false;
        /** a sorting function to order the nodes; e.g. function(a, b){ return a.datapublic ('weight') - b.data('weight') } */
        this.sortBy = "degree";
        this.nodes = [];
        this.edges = [];
        this.width = 300;
        this.height = 300;
        this.row = 0;
        this.col = 0;
        this.cellWidth = 0;
        this.cellHeight = 0;
        this.cellUsed = {};
        this.id2manPos = {};
        /** 迭代结束的回调函数 */
        this.onLayoutEnd = () => { };
        this.updateCfg(options);
    }
    getDefaultCfg() {
        return {
            begin: [0, 0],
            preventOverlap: true,
            preventOverlapPadding: 10,
            condense: false,
            rows: undefined,
            cols: undefined,
            position: undefined,
            sortBy: "degree",
            nodeSize: 30
        };
    }
    /**
     * 执行布局
     */
    execute() {
        const self = this;
        const { nodes, edges, begin } = self;
        const n = nodes.length;
        if (n === 0) {
            if (self.onLayoutEnd)
                self.onLayoutEnd();
            return {
                nodes,
                edges
            };
        }
        if (n === 1) {
            nodes[0].x = begin[0];
            nodes[0].y = begin[1];
            if (self.onLayoutEnd)
                self.onLayoutEnd();
            return {
                nodes,
                edges,
            };
        }
        let { sortBy, width, height } = self;
        const { condense, preventOverlapPadding, preventOverlap, nodeSpacing: paramNodeSpacing, nodeSize: paramNodeSize } = self;
        const layoutNodes = [];
        nodes.forEach((node) => {
            layoutNodes.push(node);
        });
        const nodeIdxMap = {};
        layoutNodes.forEach((node, i) => {
            nodeIdxMap[node.id] = i;
        });
        if (sortBy === "degree" ||
            !(0,_util__WEBPACK_IMPORTED_MODULE_0__.isString)(sortBy) ||
            layoutNodes[0][sortBy] === undefined) {
            sortBy = "degree";
            if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isNaN)(nodes[0].degree)) {
                const values = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getDegree)(layoutNodes.length, nodeIdxMap, edges);
                layoutNodes.forEach((node, i) => {
                    node.degree = values[i].all;
                });
            }
        }
        // sort nodes by value
        layoutNodes.sort((n1, n2) => n2[sortBy] - n1[sortBy]);
        if (!width && typeof window !== "undefined") {
            width = window.innerWidth;
        }
        if (!height && typeof window !== "undefined") {
            height = window.innerHeight;
        }
        const oRows = self.rows;
        const oCols = self.cols != null ? self.cols : self.columns;
        self.cells = n;
        // if rows or columns were set in self, use those values
        if (oRows != null && oCols != null) {
            self.rows = oRows;
            self.cols = oCols;
        }
        else if (oRows != null && oCols == null) {
            self.rows = oRows;
            self.cols = Math.ceil(self.cells / self.rows);
        }
        else if (oRows == null && oCols != null) {
            self.cols = oCols;
            self.rows = Math.ceil(self.cells / self.cols);
        }
        else {
            // otherwise use the automatic values and adjust accordingly	      // otherwise use the automatic values and adjust accordingly
            // width/height * splits^2 = cells where splits is number of times to split width
            self.splits = Math.sqrt((self.cells * self.height) / self.width);
            self.rows = Math.round(self.splits);
            self.cols = Math.round((self.width / self.height) * self.splits);
        }
        self.rows = Math.max(self.rows, 1);
        self.cols = Math.max(self.cols, 1);
        if (self.cols * self.rows > self.cells) {
            // otherwise use the automatic values and adjust accordingly
            // if rounding was up, see if we can reduce rows or columns
            const sm = self.small();
            const lg = self.large();
            // reducing the small side takes away the most cells, so try it first
            if ((sm - 1) * lg >= self.cells) {
                self.small(sm - 1);
            }
            else if ((lg - 1) * sm >= self.cells) {
                self.large(lg - 1);
            }
        }
        else {
            // if rounding was too low, add rows or columns
            while (self.cols * self.rows < self.cells) {
                const sm = self.small();
                const lg = self.large();
                // try to add to larger side first (adds less in multiplication)
                if ((lg + 1) * sm >= self.cells) {
                    self.large(lg + 1);
                }
                else {
                    self.small(sm + 1);
                }
            }
        }
        self.cellWidth = width / self.cols;
        self.cellHeight = height / self.rows;
        if (condense) {
            self.cellWidth = 0;
            self.cellHeight = 0;
        }
        if (preventOverlap || paramNodeSpacing) {
            const nodeSpacing = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getFuncByUnknownType)(10, paramNodeSpacing);
            const nodeSize = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getFuncByUnknownType)(30, paramNodeSize, false);
            layoutNodes.forEach((node) => {
                if (!node.x || !node.y) {
                    // for bb
                    node.x = 0;
                    node.y = 0;
                }
                const res = nodeSize(node) || 30;
                let nodeW;
                let nodeH;
                if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(res)) {
                    nodeW = res[0];
                    nodeH = res[1];
                }
                else {
                    nodeW = res;
                    nodeH = res;
                }
                const p = nodeSpacing !== undefined ? nodeSpacing(node) : preventOverlapPadding;
                const w = nodeW + p;
                const h = nodeH + p;
                self.cellWidth = Math.max(self.cellWidth, w);
                self.cellHeight = Math.max(self.cellHeight, h);
            });
        }
        self.cellUsed = {}; // e.g. 'c-0-2' => true
        // to keep track of current cell position
        self.row = 0;
        self.col = 0;
        // get a cache of all the manual positions
        self.id2manPos = {};
        for (let i = 0; i < layoutNodes.length; i++) {
            const node = layoutNodes[i];
            let rcPos;
            if (self.position) {
                rcPos = self.position(node);
            }
            if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {
                // must have at least row or col def'd
                const pos = {
                    row: rcPos.row,
                    col: rcPos.col
                };
                if (pos.col === undefined) {
                    // find unused col
                    pos.col = 0;
                    while (self.used(pos.row, pos.col)) {
                        pos.col++;
                    }
                }
                else if (pos.row === undefined) {
                    // find unused row
                    pos.row = 0;
                    while (self.used(pos.row, pos.col)) {
                        pos.row++;
                    }
                }
                self.id2manPos[node.id] = pos;
                self.use(pos.row, pos.col);
            }
            self.getPos(node);
        }
        if (self.onLayoutEnd)
            self.onLayoutEnd();
        return {
            edges,
            nodes: layoutNodes
        };
    }
    small(val) {
        const self = this;
        let res;
        const rows = self.rows || 5;
        const cols = self.cols || 5;
        if (val == null) {
            res = Math.min(rows, cols);
        }
        else {
            const min = Math.min(rows, cols);
            if (min === self.rows) {
                self.rows = val;
            }
            else {
                self.cols = val;
            }
        }
        return res;
    }
    large(val) {
        const self = this;
        let res;
        const rows = self.rows || 5;
        const cols = self.cols || 5;
        if (val == null) {
            res = Math.max(rows, cols);
        }
        else {
            const max = Math.max(rows, cols);
            if (max === self.rows) {
                self.rows = val;
            }
            else {
                self.cols = val;
            }
        }
        return res;
    }
    used(row, col) {
        const self = this;
        return self.cellUsed[`c-${row}-${col}`] || false;
    }
    use(row, col) {
        const self = this;
        self.cellUsed[`c-${row}-${col}`] = true;
    }
    moveToNextCell() {
        const self = this;
        const cols = self.cols || 5;
        self.col++;
        if (self.col >= cols) {
            self.col = 0;
            self.row++;
        }
    }
    getPos(node) {
        const self = this;
        const { begin, cellWidth, cellHeight } = self;
        let x;
        let y;
        // see if we have a manual position set
        const rcPos = self.id2manPos[node.id];
        if (rcPos) {
            x = rcPos.col * cellWidth + cellWidth / 2 + begin[0];
            y = rcPos.row * cellHeight + cellHeight / 2 + begin[1];
        }
        else {
            // otherwise set automatically
            while (self.used(self.row, self.col)) {
                self.moveToNextCell();
            }
            x = self.col * cellWidth + cellWidth / 2 + begin[0];
            y = self.row * cellHeight + cellHeight / 2 + begin[1];
            self.use(self.row, self.col);
            self.moveToNextCell();
        }
        node.x = x;
        node.y = y;
    }
    getType() {
        return "grid";
    }
}
//# sourceMappingURL=grid.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CircularLayout: () => (/* reexport safe */ _circular__WEBPACK_IMPORTED_MODULE_5__.CircularLayout),
/* harmony export */   ComboCombinedLayout: () => (/* reexport safe */ _comboCombined__WEBPACK_IMPORTED_MODULE_15__.ComboCombinedLayout),
/* harmony export */   ComboForceLayout: () => (/* reexport safe */ _comboForce__WEBPACK_IMPORTED_MODULE_14__.ComboForceLayout),
/* harmony export */   ConcentricLayout: () => (/* reexport safe */ _concentric__WEBPACK_IMPORTED_MODULE_9__.ConcentricLayout),
/* harmony export */   DagreCompoundLayout: () => (/* reexport safe */ _dagreCompound__WEBPACK_IMPORTED_MODULE_7__.DagreCompoundLayout),
/* harmony export */   DagreLayout: () => (/* reexport safe */ _dagre__WEBPACK_IMPORTED_MODULE_6__.DagreLayout),
/* harmony export */   ERLayout: () => (/* reexport safe */ _er__WEBPACK_IMPORTED_MODULE_17__.ERLayout),
/* harmony export */   Force2Layout: () => (/* reexport safe */ _force2__WEBPACK_IMPORTED_MODULE_3__.Force2Layout),
/* harmony export */   ForceAtlas2Layout: () => (/* reexport safe */ _forceAtlas2__WEBPACK_IMPORTED_MODULE_16__.ForceAtlas2Layout),
/* harmony export */   ForceLayout: () => (/* reexport safe */ _force__WEBPACK_IMPORTED_MODULE_4__.ForceLayout),
/* harmony export */   FruchtermanGPULayout: () => (/* reexport safe */ _gpu_fruchterman__WEBPACK_IMPORTED_MODULE_12__.FruchtermanGPULayout),
/* harmony export */   FruchtermanLayout: () => (/* reexport safe */ _fruchterman__WEBPACK_IMPORTED_MODULE_11__.FruchtermanLayout),
/* harmony export */   GForceGPULayout: () => (/* reexport safe */ _gpu_gForce__WEBPACK_IMPORTED_MODULE_13__.GForceGPULayout),
/* harmony export */   GForceLayout: () => (/* reexport safe */ _gForce__WEBPACK_IMPORTED_MODULE_2__.GForceLayout),
/* harmony export */   GridLayout: () => (/* reexport safe */ _grid__WEBPACK_IMPORTED_MODULE_0__.GridLayout),
/* harmony export */   Layout: () => (/* reexport safe */ _layout__WEBPACK_IMPORTED_MODULE_18__.Layout),
/* harmony export */   Layouts: () => (/* reexport safe */ _layout__WEBPACK_IMPORTED_MODULE_18__.Layouts),
/* harmony export */   MDSLayout: () => (/* reexport safe */ _mds__WEBPACK_IMPORTED_MODULE_10__.MDSLayout),
/* harmony export */   RadialLayout: () => (/* reexport safe */ _radial__WEBPACK_IMPORTED_MODULE_8__.RadialLayout),
/* harmony export */   RandomLayout: () => (/* reexport safe */ _random__WEBPACK_IMPORTED_MODULE_1__.RandomLayout)
/* harmony export */ });
/* harmony import */ var _grid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./grid */ "./node_modules/@antv/layout/es/layout/grid.js");
/* harmony import */ var _random__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./random */ "./node_modules/@antv/layout/es/layout/random.js");
/* harmony import */ var _gForce__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./gForce */ "./node_modules/@antv/layout/es/layout/gForce.js");
/* harmony import */ var _force2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./force2 */ "./node_modules/@antv/layout/es/layout/force2/index.js");
/* harmony import */ var _force__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./force */ "./node_modules/@antv/layout/es/layout/force/index.js");
/* harmony import */ var _circular__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./circular */ "./node_modules/@antv/layout/es/layout/circular.js");
/* harmony import */ var _dagre__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dagre */ "./node_modules/@antv/layout/es/layout/dagre.js");
/* harmony import */ var _dagreCompound__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dagreCompound */ "./node_modules/@antv/layout/es/layout/dagreCompound.js");
/* harmony import */ var _radial__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./radial */ "./node_modules/@antv/layout/es/layout/radial/index.js");
/* harmony import */ var _concentric__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./concentric */ "./node_modules/@antv/layout/es/layout/concentric.js");
/* harmony import */ var _mds__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./mds */ "./node_modules/@antv/layout/es/layout/mds.js");
/* harmony import */ var _fruchterman__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./fruchterman */ "./node_modules/@antv/layout/es/layout/fruchterman.js");
/* harmony import */ var _gpu_fruchterman__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./gpu/fruchterman */ "./node_modules/@antv/layout/es/layout/gpu/fruchterman.js");
/* harmony import */ var _gpu_gForce__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./gpu/gForce */ "./node_modules/@antv/layout/es/layout/gpu/gForce.js");
/* harmony import */ var _comboForce__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./comboForce */ "./node_modules/@antv/layout/es/layout/comboForce.js");
/* harmony import */ var _comboCombined__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./comboCombined */ "./node_modules/@antv/layout/es/layout/comboCombined.js");
/* harmony import */ var _forceAtlas2__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./forceAtlas2 */ "./node_modules/@antv/layout/es/layout/forceAtlas2/index.js");
/* harmony import */ var _er__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./er */ "./node_modules/@antv/layout/es/layout/er/index.js");
/* harmony import */ var _layout__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./layout */ "./node_modules/@antv/layout/es/layout/layout.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./types */ "./node_modules/@antv/layout/es/layout/types.js");




















// layout

// types file

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/layout.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/layout.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Layout: () => (/* binding */ Layout),
/* harmony export */   Layouts: () => (/* binding */ Layouts)
/* harmony export */ });
/* harmony import */ var _registy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registy */ "./node_modules/@antv/layout/es/registy/index.js");
/* harmony import */ var _grid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./grid */ "./node_modules/@antv/layout/es/layout/grid.js");
/* harmony import */ var _random__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./random */ "./node_modules/@antv/layout/es/layout/random.js");
/* harmony import */ var _force2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./force2 */ "./node_modules/@antv/layout/es/layout/force2/index.js");
/* harmony import */ var _gForce__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./gForce */ "./node_modules/@antv/layout/es/layout/gForce.js");
/* harmony import */ var _force__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./force */ "./node_modules/@antv/layout/es/layout/force/index.js");
/* harmony import */ var _circular__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./circular */ "./node_modules/@antv/layout/es/layout/circular.js");
/* harmony import */ var _dagre__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dagre */ "./node_modules/@antv/layout/es/layout/dagre.js");
/* harmony import */ var _radial__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./radial */ "./node_modules/@antv/layout/es/layout/radial/index.js");
/* harmony import */ var _concentric__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./concentric */ "./node_modules/@antv/layout/es/layout/concentric.js");
/* harmony import */ var _mds__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./mds */ "./node_modules/@antv/layout/es/layout/mds.js");
/* harmony import */ var _fruchterman__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./fruchterman */ "./node_modules/@antv/layout/es/layout/fruchterman.js");
/* harmony import */ var _gpu_fruchterman__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./gpu/fruchterman */ "./node_modules/@antv/layout/es/layout/gpu/fruchterman.js");
/* harmony import */ var _gpu_gForce__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./gpu/gForce */ "./node_modules/@antv/layout/es/layout/gpu/gForce.js");
/* harmony import */ var _comboForce__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./comboForce */ "./node_modules/@antv/layout/es/layout/comboForce.js");
/* harmony import */ var _comboCombined__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./comboCombined */ "./node_modules/@antv/layout/es/layout/comboCombined.js");
/* harmony import */ var _forceAtlas2__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./forceAtlas2 */ "./node_modules/@antv/layout/es/layout/forceAtlas2/index.js");
/* harmony import */ var _er__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./er */ "./node_modules/@antv/layout/es/layout/er/index.js");
/* harmony import */ var _dagreCompound__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./dagreCompound */ "./node_modules/@antv/layout/es/layout/dagreCompound.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/layout/es/util/index.js");




















class Layout {
    constructor(options) {
        const layoutClass = (0,_registy__WEBPACK_IMPORTED_MODULE_0__.getLayoutByName)(options.type);
        this.layoutInstance = new layoutClass(options);
    }
    layout(data) {
        return this.layoutInstance.layout(data);
    }
    updateCfg(cfg) {
        this.layoutInstance.updateCfg(cfg);
    }
    init(data) {
        this.correctLayers(data.nodes);
        this.layoutInstance.init(data);
    }
    /**
     * correcting the layers on the node data
     * if min(layer) <= 0, layers should begin from abs(min(layer)) + 1
     * @param nodes
     * @returns
     */
    correctLayers(nodes) {
        if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length))
            return;
        let minLayer = Infinity;
        const hasLayerNodes = [];
        nodes.forEach((node) => {
            if ((0,_util__WEBPACK_IMPORTED_MODULE_19__.isString)(node.layer)) {
                node.layer = parseInt(node.layer, 10);
            }
            // keep node.layer === undefined for TS problem
            if (node.layer === undefined || isNaN(node.layer))
                return;
            hasLayerNodes.push(node);
            if (node.layer < minLayer)
                minLayer = node.layer;
        });
        if (minLayer <= 0) {
            const layerOffset = Math.abs(minLayer) + 1;
            // @ts-ignore
            hasLayerNodes.forEach((node) => node.layer += layerOffset);
        }
    }
    execute() {
        this.layoutInstance.execute();
    }
    getDefaultCfg() {
        return this.layoutInstance.getDefaultCfg();
    }
    destroy() {
        return this.layoutInstance.destroy();
    }
}
// FIXME
// FOR G6
// tslint:disable-next-line
const Layouts = {
    force: _force__WEBPACK_IMPORTED_MODULE_5__.ForceLayout,
    fruchterman: _fruchterman__WEBPACK_IMPORTED_MODULE_11__.FruchtermanLayout,
    forceAtlas2: _forceAtlas2__WEBPACK_IMPORTED_MODULE_16__.ForceAtlas2Layout,
    gForce: _gForce__WEBPACK_IMPORTED_MODULE_4__.GForceLayout,
    force2: _force2__WEBPACK_IMPORTED_MODULE_3__.Force2Layout,
    dagre: _dagre__WEBPACK_IMPORTED_MODULE_7__.DagreLayout,
    dagreCompound: _dagreCompound__WEBPACK_IMPORTED_MODULE_18__.DagreCompoundLayout,
    circular: _circular__WEBPACK_IMPORTED_MODULE_6__.CircularLayout,
    radial: _radial__WEBPACK_IMPORTED_MODULE_8__.RadialLayout,
    concentric: _concentric__WEBPACK_IMPORTED_MODULE_9__.ConcentricLayout,
    grid: _grid__WEBPACK_IMPORTED_MODULE_1__.GridLayout,
    mds: _mds__WEBPACK_IMPORTED_MODULE_10__.MDSLayout,
    comboForce: _comboForce__WEBPACK_IMPORTED_MODULE_14__.ComboForceLayout,
    comboCombined: _comboCombined__WEBPACK_IMPORTED_MODULE_15__.ComboCombinedLayout,
    random: _random__WEBPACK_IMPORTED_MODULE_2__.RandomLayout,
    'gForce-gpu': _gpu_gForce__WEBPACK_IMPORTED_MODULE_13__.GForceGPULayout,
    'fruchterman-gpu': _gpu_fruchterman__WEBPACK_IMPORTED_MODULE_12__.FruchtermanGPULayout,
    er: _er__WEBPACK_IMPORTED_MODULE_17__.ERLayout,
};
//# sourceMappingURL=layout.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/mds.js":
/*!****************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/mds.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MDSLayout: () => (/* binding */ MDSLayout)
/* harmony export */ });
/* harmony import */ var ml_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ml-matrix */ "./node_modules/ml-matrix/src/matrix.js");
/* harmony import */ var ml_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ml-matrix */ "./node_modules/ml-matrix/src/dc/svd.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/layout/es/util/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./node_modules/@antv/layout/es/layout/base.js");
/**
 * @fileOverview MDS layout
 * @author shiwu.wyy@antfin.com
 */



/**
 * mds 布局
 */
class MDSLayout extends _base__WEBPACK_IMPORTED_MODULE_1__.Base {
    constructor(options) {
        super();
        /** 布局中心 */
        this.center = [0, 0];
        /** 边长度 */
        this.linkDistance = 50;
        this.nodes = [];
        this.edges = [];
        /** 迭代结束的回调函数 */
        this.onLayoutEnd = () => { };
        this.updateCfg(options);
    }
    getDefaultCfg() {
        return {
            center: [0, 0],
            linkDistance: 50
        };
    }
    /**
     * 执行布局
     */
    execute() {
        const self = this;
        const { nodes, edges = [] } = self;
        const center = self.center;
        if (!nodes || nodes.length === 0) {
            if (self.onLayoutEnd)
                self.onLayoutEnd();
            return;
        }
        if (nodes.length === 1) {
            nodes[0].x = center[0];
            nodes[0].y = center[1];
            if (self.onLayoutEnd)
                self.onLayoutEnd();
            return;
        }
        const linkDistance = self.linkDistance;
        // the graph-theoretic distance (shortest path distance) matrix
        const adjMatrix = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getAdjMatrix)({ nodes, edges }, false);
        const distances = (0,_util__WEBPACK_IMPORTED_MODULE_0__.floydWarshall)(adjMatrix);
        self.handleInfinity(distances);
        // scale the ideal edge length acoording to linkDistance
        const scaledD = (0,_util__WEBPACK_IMPORTED_MODULE_0__.scaleMatrix)(distances, linkDistance);
        self.scaledDistances = scaledD;
        // get positions by MDS
        const positions = self.runMDS();
        self.positions = positions;
        positions.forEach((p, i) => {
            nodes[i].x = p[0] + center[0];
            nodes[i].y = p[1] + center[1];
        });
        if (self.onLayoutEnd)
            self.onLayoutEnd();
        return {
            nodes,
            edges
        };
    }
    /**
     * mds 算法
     * @return {array} positions 计算后的节点位置数组
     */
    runMDS() {
        const self = this;
        const dimension = 2;
        const distances = self.scaledDistances;
        // square distances
        const M = ml_matrix__WEBPACK_IMPORTED_MODULE_2__["default"].mul(ml_matrix__WEBPACK_IMPORTED_MODULE_2__["default"].pow(distances, 2), -0.5);
        // double centre the rows/columns
        const rowMeans = M.mean("row");
        const colMeans = M.mean("column");
        const totalMean = M.mean();
        M.add(totalMean)
            .subRowVector(rowMeans)
            .subColumnVector(colMeans);
        // take the SVD of the double centred matrix, and return the
        // points from it
        const ret = new ml_matrix__WEBPACK_IMPORTED_MODULE_3__["default"](M);
        const eigenValues = ml_matrix__WEBPACK_IMPORTED_MODULE_2__["default"].sqrt(ret.diagonalMatrix).diagonal();
        return ret.leftSingularVectors.toJSON().map((row) => {
            return ml_matrix__WEBPACK_IMPORTED_MODULE_2__["default"].mul([row], [eigenValues])
                .toJSON()[0]
                .splice(0, dimension);
        });
    }
    handleInfinity(distances) {
        let maxDistance = -999999;
        distances.forEach((row) => {
            row.forEach((value) => {
                if (value === Infinity) {
                    return;
                }
                if (maxDistance < value) {
                    maxDistance = value;
                }
            });
        });
        distances.forEach((row, i) => {
            row.forEach((value, j) => {
                if (value === Infinity) {
                    distances[i][j] = maxDistance;
                }
            });
        });
    }
    getType() {
        return "mds";
    }
}
//# sourceMappingURL=mds.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/radial/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/radial/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RadialLayout: () => (/* reexport safe */ _radial__WEBPACK_IMPORTED_MODULE_0__.RadialLayout)
/* harmony export */ });
/* harmony import */ var _radial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./radial */ "./node_modules/@antv/layout/es/layout/radial/radial.js");

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/radial/mds.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/radial/mds.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MDS)
/* harmony export */ });
/* harmony import */ var ml_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ml-matrix */ "./node_modules/ml-matrix/src/matrix.js");
/* harmony import */ var ml_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ml-matrix */ "./node_modules/ml-matrix/src/dc/svd.js");

class MDS {
    constructor(params) {
        this.distances = params.distances;
        this.dimension = params.dimension || 2;
        this.linkDistance = params.linkDistance;
    }
    layout() {
        const self = this;
        const { dimension, distances, linkDistance } = self;
        try {
            // square distances
            const M = ml_matrix__WEBPACK_IMPORTED_MODULE_0__["default"].mul(ml_matrix__WEBPACK_IMPORTED_MODULE_0__["default"].pow(distances, 2), -0.5);
            // double centre the rows/columns
            const rowMeans = M.mean('row');
            const colMeans = M.mean('column');
            const totalMean = M.mean();
            M.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans);
            // take the SVD of the double centred matrix, and return the
            // points from it
            const ret = new ml_matrix__WEBPACK_IMPORTED_MODULE_1__["default"](M);
            const eigenValues = ml_matrix__WEBPACK_IMPORTED_MODULE_0__["default"].sqrt(ret.diagonalMatrix).diagonal();
            return ret.leftSingularVectors.toJSON().map((row) => {
                return ml_matrix__WEBPACK_IMPORTED_MODULE_0__["default"].mul([row], [eigenValues]).toJSON()[0].splice(0, dimension);
            });
        }
        catch (_a) {
            const res = [];
            for (let i = 0; i < distances.length; i++) {
                const x = Math.random() * linkDistance;
                const y = Math.random() * linkDistance;
                res.push([x, y]);
            }
            return res;
        }
    }
}
//# sourceMappingURL=mds.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/radial/radial.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/radial/radial.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RadialLayout: () => (/* binding */ RadialLayout)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util */ "./node_modules/@antv/layout/es/util/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base */ "./node_modules/@antv/layout/es/layout/base.js");
/* harmony import */ var _mds__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mds */ "./node_modules/@antv/layout/es/layout/radial/mds.js");
/* harmony import */ var _radialNonoverlapForce__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./radialNonoverlapForce */ "./node_modules/@antv/layout/es/layout/radial/radialNonoverlapForce.js");
/**
 * @fileOverview random layout
 * @author shiwu.wyy@antfin.com
 */




function getWeightMatrix(M) {
    const rows = M.length;
    const cols = M[0].length;
    const result = [];
    for (let i = 0; i < rows; i++) {
        const row = [];
        for (let j = 0; j < cols; j++) {
            if (M[i][j] !== 0) {
                row.push(1 / (M[i][j] * M[i][j]));
            }
            else {
                row.push(0);
            }
        }
        result.push(row);
    }
    return result;
}
function getIndexById(array, id) {
    let index = -1;
    array.forEach((a, i) => {
        if (a.id === id) {
            index = i;
        }
    });
    return index;
}
function getEDistance(p1, p2) {
    return Math.sqrt((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]));
}
/**
 * 辐射状布局
 */
class RadialLayout extends _base__WEBPACK_IMPORTED_MODULE_1__.Base {
    constructor(options) {
        super();
        /** 停止迭代的最大迭代数 */
        this.maxIteration = 1000;
        /** 中心点，默认为数据中第一个点 */
        this.focusNode = null;
        /** 每一圈半径 */
        this.unitRadius = null;
        /** 默认边长度 */
        this.linkDistance = 50;
        /** 是否防止重叠 */
        this.preventOverlap = false;
        /** 是否必须是严格的 radial 布局，即每一层的节点严格布局在一个环上。preventOverlap 为 true 时生效 */
        this.strictRadial = true;
        /** 防止重叠步骤的最大迭代次数 */
        this.maxPreventOverlapIteration = 200;
        this.sortStrength = 10;
        this.nodes = [];
        this.edges = [];
        this.updateCfg(options);
    }
    getDefaultCfg() {
        return {
            maxIteration: 1000,
            focusNode: null,
            unitRadius: null,
            linkDistance: 50,
            preventOverlap: false,
            nodeSize: undefined,
            nodeSpacing: undefined,
            strictRadial: true,
            maxPreventOverlapIteration: 200,
            sortBy: undefined,
            sortStrength: 10
        };
    }
    /**
     * 执行布局
     */
    execute() {
        const self = this;
        const nodes = self.nodes;
        const edges = self.edges || [];
        if (!nodes || nodes.length === 0) {
            if (self.onLayoutEnd)
                self.onLayoutEnd();
            return;
        }
        if (!self.width && typeof window !== "undefined") {
            self.width = window.innerWidth;
        }
        if (!self.height && typeof window !== "undefined") {
            self.height = window.innerHeight;
        }
        if (!self.center) {
            self.center = [self.width / 2, self.height / 2];
        }
        const center = self.center;
        if (nodes.length === 1) {
            nodes[0].x = center[0];
            nodes[0].y = center[1];
            if (self.onLayoutEnd)
                self.onLayoutEnd();
            return;
        }
        const linkDistance = self.linkDistance;
        // layout
        let focusNode = null;
        if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isString)(self.focusNode)) {
            let found = false;
            for (let i = 0; i < nodes.length; i++) {
                if (nodes[i].id === self.focusNode) {
                    focusNode = nodes[i];
                    self.focusNode = focusNode;
                    found = true;
                    i = nodes.length;
                }
            }
            if (!found) {
                focusNode = null;
            }
        }
        else {
            focusNode = self.focusNode;
        }
        // default focus node
        if (!focusNode) {
            focusNode = nodes[0];
            self.focusNode = focusNode;
        }
        // the index of the focusNode in data
        let focusIndex = getIndexById(nodes, focusNode.id);
        if (focusIndex < 0)
            focusIndex = 0;
        self.focusIndex = focusIndex;
        // the graph-theoretic distance (shortest path distance) matrix
        const adjMatrix = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getAdjMatrix)({ nodes, edges }, false);
        const D = (0,_util__WEBPACK_IMPORTED_MODULE_0__.floydWarshall)(adjMatrix);
        const maxDistance = self.maxToFocus(D, focusIndex);
        // replace first node in unconnected component to the circle at (maxDistance + 1)
        self.handleInfinity(D, focusIndex, maxDistance + 1);
        self.distances = D;
        // the shortest path distance from each node to focusNode
        const focusNodeD = D[focusIndex];
        const width = self.width || 500;
        const height = self.height || 500;
        let semiWidth = width - center[0] > center[0] ? center[0] : width - center[0];
        let semiHeight = height - center[1] > center[1] ? center[1] : height - center[1];
        if (semiWidth === 0) {
            semiWidth = width / 2;
        }
        if (semiHeight === 0) {
            semiHeight = height / 2;
        }
        // the maxRadius of the graph
        const maxRadius = semiHeight > semiWidth ? semiWidth : semiHeight;
        const maxD = Math.max(...focusNodeD);
        // the radius for each nodes away from focusNode
        const radii = [];
        focusNodeD.forEach((value, i) => {
            if (!self.unitRadius) {
                self.unitRadius = maxRadius / maxD;
            }
            radii[i] = value * self.unitRadius;
        });
        self.radii = radii;
        const eIdealD = self.eIdealDisMatrix();
        // const eIdealD = scaleMatrix(D, linkDistance);
        self.eIdealDistances = eIdealD;
        // the weight matrix, Wij = 1 / dij^(-2)
        const W = getWeightMatrix(eIdealD);
        self.weights = W;
        // the initial positions from mds
        const mds = new _mds__WEBPACK_IMPORTED_MODULE_2__["default"]({ linkDistance, distances: eIdealD });
        let positions = mds.layout();
        positions.forEach((p) => {
            if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isNaN)(p[0])) {
                p[0] = Math.random() * linkDistance;
            }
            if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isNaN)(p[1])) {
                p[1] = Math.random() * linkDistance;
            }
        });
        self.positions = positions;
        positions.forEach((p, i) => {
            nodes[i].x = p[0] + center[0];
            nodes[i].y = p[1] + center[1];
        });
        // move the graph to origin, centered at focusNode
        positions.forEach((p) => {
            p[0] -= positions[focusIndex][0];
            p[1] -= positions[focusIndex][1];
        });
        self.run();
        const preventOverlap = self.preventOverlap;
        const nodeSize = self.nodeSize;
        let nodeSizeFunc;
        const strictRadial = self.strictRadial;
        // stagger the overlapped nodes
        if (preventOverlap) {
            const nodeSpacing = self.nodeSpacing;
            let nodeSpacingFunc;
            if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isNumber)(nodeSpacing)) {
                nodeSpacingFunc = () => nodeSpacing;
            }
            else if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(nodeSpacing)) {
                nodeSpacingFunc = nodeSpacing;
            }
            else {
                nodeSpacingFunc = () => 0;
            }
            if (!nodeSize) {
                nodeSizeFunc = (d) => {
                    if (d.size) {
                        if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(d.size)) {
                            const res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];
                            return res + nodeSpacingFunc(d);
                        }
                        if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(d.size)) {
                            const res = d.size.width > d.size.height ? d.size.width : d.size.height;
                            return res + nodeSpacingFunc(d);
                        }
                        return d.size + nodeSpacingFunc(d);
                    }
                    return 10 + nodeSpacingFunc(d);
                };
            }
            else if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(nodeSize)) {
                nodeSizeFunc = (d) => {
                    const res = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];
                    return res + nodeSpacingFunc(d);
                };
            }
            else {
                nodeSizeFunc = (d) => nodeSize + nodeSpacingFunc(d);
            }
            const nonoverlapForceParams = {
                nodes,
                nodeSizeFunc,
                adjMatrix,
                positions,
                radii,
                height,
                width,
                strictRadial,
                focusID: focusIndex,
                iterations: self.maxPreventOverlapIteration || 200,
                k: positions.length / 4.5
            };
            const nonoverlapForce = new _radialNonoverlapForce__WEBPACK_IMPORTED_MODULE_3__["default"](nonoverlapForceParams);
            positions = nonoverlapForce.layout();
        }
        // move the graph to center
        positions.forEach((p, i) => {
            nodes[i].x = p[0] + center[0];
            nodes[i].y = p[1] + center[1];
        });
        if (self.onLayoutEnd)
            self.onLayoutEnd();
        return {
            nodes,
            edges
        };
    }
    run() {
        const self = this;
        const maxIteration = self.maxIteration;
        const positions = self.positions || [];
        const W = self.weights || [];
        const eIdealDis = self.eIdealDistances || [];
        const radii = self.radii || [];
        for (let i = 0; i <= maxIteration; i++) {
            const param = i / maxIteration;
            self.oneIteration(param, positions, radii, eIdealDis, W);
        }
    }
    oneIteration(param, positions, radii, D, W) {
        const self = this;
        const vparam = 1 - param;
        const focusIndex = self.focusIndex;
        positions.forEach((v, i) => {
            // v
            const originDis = getEDistance(v, [0, 0]);
            const reciODis = originDis === 0 ? 0 : 1 / originDis;
            if (i === focusIndex) {
                return;
            }
            let xMolecule = 0;
            let yMolecule = 0;
            let denominator = 0;
            positions.forEach((u, j) => {
                // u
                if (i === j) {
                    return;
                }
                // the euclidean distance between v and u
                const edis = getEDistance(v, u);
                const reciEdis = edis === 0 ? 0 : 1 / edis;
                const idealDis = D[j][i];
                // same for x and y
                denominator += W[i][j];
                // x
                xMolecule += W[i][j] * (u[0] + idealDis * (v[0] - u[0]) * reciEdis);
                // y
                yMolecule += W[i][j] * (u[1] + idealDis * (v[1] - u[1]) * reciEdis);
            });
            const reciR = radii[i] === 0 ? 0 : 1 / radii[i];
            denominator *= vparam;
            denominator += param * reciR * reciR;
            // x
            xMolecule *= vparam;
            xMolecule += param * reciR * v[0] * reciODis;
            v[0] = xMolecule / denominator;
            // y
            yMolecule *= vparam;
            yMolecule += param * reciR * v[1] * reciODis;
            v[1] = yMolecule / denominator;
        });
    }
    eIdealDisMatrix() {
        const self = this;
        const nodes = self.nodes;
        if (!nodes)
            return [];
        const D = self.distances;
        const linkDis = self.linkDistance;
        const radii = self.radii || [];
        const unitRadius = self.unitRadius || 50;
        const result = [];
        if (D) {
            D.forEach((row, i) => {
                const newRow = [];
                row.forEach((v, j) => {
                    if (i === j) {
                        newRow.push(0);
                    }
                    else if (radii[i] === radii[j]) {
                        // i and j are on the same circle
                        if (self.sortBy === "data") {
                            // sort the nodes on the same circle according to the ordering of the data
                            newRow.push((v * (Math.abs(i - j) * self.sortStrength)) /
                                (radii[i] / unitRadius));
                        }
                        else if (self.sortBy) {
                            // sort the nodes on the same circle according to the attributes
                            let iValue = nodes[i][self.sortBy] || 0;
                            let jValue = nodes[j][self.sortBy] || 0;
                            if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isString)(iValue)) {
                                iValue = iValue.charCodeAt(0);
                            }
                            if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isString)(jValue)) {
                                jValue = jValue.charCodeAt(0);
                            }
                            newRow.push((v * (Math.abs(iValue - jValue) * self.sortStrength)) /
                                (radii[i] / unitRadius));
                        }
                        else {
                            newRow.push((v * linkDis) / (radii[i] / unitRadius));
                        }
                    }
                    else {
                        // i and j are on different circle
                        // i and j are on different circle
                        const link = (linkDis + unitRadius) / 2;
                        newRow.push(v * link);
                    }
                });
                result.push(newRow);
            });
        }
        return result;
    }
    handleInfinity(matrix, focusIndex, step) {
        const length = matrix.length;
        // 遍历 matrix 中遍历 focus 对应行
        for (let i = 0; i < length; i++) {
            // matrix 关注点对应行的 Inf 项
            if (matrix[focusIndex][i] === Infinity) {
                matrix[focusIndex][i] = step;
                matrix[i][focusIndex] = step;
                // 遍历 matrix 中的 i 行，i 行中非 Inf 项若在 focus 行为 Inf，则替换 focus 行的那个 Inf
                for (let j = 0; j < length; j++) {
                    if (matrix[i][j] !== Infinity && matrix[focusIndex][j] === Infinity) {
                        matrix[focusIndex][j] = step + matrix[i][j];
                        matrix[j][focusIndex] = step + matrix[i][j];
                    }
                }
            }
        }
        // 处理其他行的 Inf。根据该行对应点与 focus 距离以及 Inf 项点 与 focus 距离，决定替换值
        for (let i = 0; i < length; i++) {
            if (i === focusIndex) {
                continue;
            }
            for (let j = 0; j < length; j++) {
                if (matrix[i][j] === Infinity) {
                    let minus = Math.abs(matrix[focusIndex][i] - matrix[focusIndex][j]);
                    minus = minus === 0 ? 1 : minus;
                    matrix[i][j] = minus;
                }
            }
        }
    }
    maxToFocus(matrix, focusIndex) {
        let max = 0;
        for (let i = 0; i < matrix[focusIndex].length; i++) {
            if (matrix[focusIndex][i] === Infinity) {
                continue;
            }
            max = matrix[focusIndex][i] > max ? matrix[focusIndex][i] : max;
        }
        return max;
    }
    getType() {
        return "radial";
    }
}
//# sourceMappingURL=radial.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/radial/radialNonoverlapForce.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/radial/radialNonoverlapForce.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RadialNonoverlapForce)
/* harmony export */ });
const SPEED_DIVISOR = 800;
class RadialNonoverlapForce {
    constructor(params) {
        this.disp = [];
        this.positions = params.positions;
        this.adjMatrix = params.adjMatrix;
        this.focusID = params.focusID;
        this.radii = params.radii;
        this.iterations = params.iterations || 10;
        this.height = params.height || 10;
        this.width = params.width || 10;
        this.speed = params.speed || 100;
        this.gravity = params.gravity || 10;
        this.nodeSizeFunc = params.nodeSizeFunc;
        this.k = params.k || 5;
        this.strictRadial = params.strictRadial;
        this.nodes = params.nodes;
    }
    layout() {
        const self = this;
        const positions = self.positions;
        const disp = [];
        const iterations = self.iterations;
        const maxDisplace = self.width / 10;
        self.maxDisplace = maxDisplace;
        self.disp = disp;
        for (let i = 0; i < iterations; i++) {
            positions.forEach((_, k) => {
                disp[k] = { x: 0, y: 0 };
            });
            // 给重叠的节点增加斥力
            self.getRepulsion();
            self.updatePositions();
        }
        return positions;
    }
    getRepulsion() {
        const self = this;
        const positions = self.positions;
        const nodes = self.nodes;
        const disp = self.disp;
        const k = self.k;
        const radii = self.radii || [];
        positions.forEach((v, i) => {
            disp[i] = { x: 0, y: 0 };
            positions.forEach((u, j) => {
                if (i === j) {
                    return;
                }
                // v and u are not on the same circle, return
                if (radii[i] !== radii[j]) {
                    return;
                }
                let vecx = v[0] - u[0];
                let vecy = v[1] - u[1];
                let vecLength = Math.sqrt(vecx * vecx + vecy * vecy);
                if (vecLength === 0) {
                    vecLength = 1;
                    const sign = i > j ? 1 : -1;
                    vecx = 0.01 * sign;
                    vecy = 0.01 * sign;
                }
                // these two nodes overlap
                if (vecLength < self.nodeSizeFunc(nodes[i]) / 2 + self.nodeSizeFunc(nodes[j]) / 2) {
                    const common = (k * k) / vecLength;
                    disp[i].x += (vecx / vecLength) * common;
                    disp[i].y += (vecy / vecLength) * common;
                }
            });
        });
    }
    updatePositions() {
        const self = this;
        const positions = self.positions;
        const disp = self.disp;
        const speed = self.speed;
        const strictRadial = self.strictRadial;
        const f = self.focusID;
        const maxDisplace = self.maxDisplace || self.width / 10;
        if (strictRadial) {
            disp.forEach((di, i) => {
                const vx = positions[i][0] - positions[f][0];
                const vy = positions[i][1] - positions[f][1];
                const vLength = Math.sqrt(vx * vx + vy * vy);
                let vpx = vy / vLength;
                let vpy = -vx / vLength;
                const diLength = Math.sqrt(di.x * di.x + di.y * di.y);
                let alpha = Math.acos((vpx * di.x + vpy * di.y) / diLength);
                if (alpha > Math.PI / 2) {
                    alpha -= Math.PI / 2;
                    vpx *= -1;
                    vpy *= -1;
                }
                const tdispLength = Math.cos(alpha) * diLength;
                di.x = vpx * tdispLength;
                di.y = vpy * tdispLength;
            });
        }
        // move
        const radii = self.radii;
        positions.forEach((n, i) => {
            if (i === f) {
                return;
            }
            const distLength = Math.sqrt(disp[i].x * disp[i].x + disp[i].y * disp[i].y);
            if (distLength > 0 && i !== f) {
                const limitedDist = Math.min(maxDisplace * (speed / SPEED_DIVISOR), distLength);
                n[0] += (disp[i].x / distLength) * limitedDist;
                n[1] += (disp[i].y / distLength) * limitedDist;
                if (strictRadial) {
                    let vx = n[0] - positions[f][0];
                    let vy = n[1] - positions[f][1];
                    const nfDis = Math.sqrt(vx * vx + vy * vy);
                    vx = (vx / nfDis) * radii[i];
                    vy = (vy / nfDis) * radii[i];
                    n[0] = positions[f][0] + vx;
                    n[1] = positions[f][1] + vy;
                }
            }
        });
    }
}
//# sourceMappingURL=radialNonoverlapForce.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/random.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/random.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RandomLayout: () => (/* binding */ RandomLayout)
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./node_modules/@antv/layout/es/layout/base.js");
/**
 * @fileOverview random layout
 * @author shiwu.wyy@antfin.com
 */

/**
 * 随机布局
 */
class RandomLayout extends _base__WEBPACK_IMPORTED_MODULE_0__.Base {
    constructor(options) {
        super();
        /** 布局中心 */
        this.center = [0, 0];
        /** 宽度 */
        this.width = 300;
        /** 高度 */
        this.height = 300;
        this.nodes = [];
        this.edges = [];
        /** 迭代结束的回调函数 */
        this.onLayoutEnd = () => { };
        this.updateCfg(options);
    }
    getDefaultCfg() {
        return {
            center: [0, 0],
            width: 300,
            height: 300
        };
    }
    /**
     * 执行布局
     */
    execute() {
        const self = this;
        const nodes = self.nodes;
        const layoutScale = 0.9;
        const center = self.center;
        if (!self.width && typeof window !== "undefined") {
            self.width = window.innerWidth;
        }
        if (!self.height && typeof window !== "undefined") {
            self.height = window.innerHeight;
        }
        if (nodes) {
            nodes.forEach((node) => {
                node.x = (Math.random() - 0.5) * layoutScale * self.width + center[0];
                node.y = (Math.random() - 0.5) * layoutScale * self.height + center[1];
            });
        }
        if (self.onLayoutEnd)
            self.onLayoutEnd();
        return {
            nodes,
            edges: this.edges
        };
    }
    getType() {
        return "random";
    }
}
//# sourceMappingURL=random.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/layout/types.js":
/*!******************************************************!*\
  !*** ./node_modules/@antv/layout/es/layout/types.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/registy/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/layout/es/registy/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getLayoutByName: () => (/* binding */ getLayoutByName),
/* harmony export */   registerLayout: () => (/* binding */ registerLayout),
/* harmony export */   unRegisterLayout: () => (/* binding */ unRegisterLayout)
/* harmony export */ });
/* harmony import */ var _layout_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../layout/base */ "./node_modules/@antv/layout/es/layout/base.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/layout/es/util/index.js");


const map = new Map();
const registerLayout = (name, layoutOverride) => {
    if (map.get(name)) {
        console.warn(`The layout with the name ${name} exists already, it will be overridden`);
    }
    if ((0,_util__WEBPACK_IMPORTED_MODULE_1__.isObject)(layoutOverride)) {
        // tslint:disable-next-line: max-classes-per-file
        class GLayout extends _layout_base__WEBPACK_IMPORTED_MODULE_0__.Base {
            constructor(cfg) {
                var _a;
                super();
                const self = this;
                const props = {};
                const defaultCfg = Object.assign({}, self.getDefaultCfg(), ((_a = layoutOverride.getDefaultCfg) === null || _a === void 0 ? void 0 : _a.call(layoutOverride)) || {});
                Object.assign(props, defaultCfg, layoutOverride, cfg);
                Object.keys(props).forEach((key) => {
                    const value = props[key];
                    self[key] = value;
                });
            }
        }
        map.set(name, GLayout);
    }
    else {
        map.set(name, layoutOverride);
    }
    return map.get(name);
};
const unRegisterLayout = (name) => {
    if (map.has(name)) {
        map.delete(name);
    }
};
const getLayoutByName = (name) => {
    if (map.has(name)) {
        return map.get(name);
    }
    return null;
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/util/array.js":
/*!****************************************************!*\
  !*** ./node_modules/@antv/layout/es/util/array.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isArray: () => (/* binding */ isArray)
/* harmony export */ });
const isArray = Array.isArray;
//# sourceMappingURL=array.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/util/function.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/layout/es/util/function.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getFunc: () => (/* binding */ getFunc),
/* harmony export */   getFuncByUnknownType: () => (/* binding */ getFuncByUnknownType),
/* harmony export */   isFunction: () => (/* binding */ isFunction)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! . */ "./node_modules/@antv/layout/es/util/index.js");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./number */ "./node_modules/@antv/layout/es/util/number.js");


const isFunction = (val) => typeof val === 'function';
const getFunc = (value, defaultValue, func) => {
    let resultFunc;
    if (func) {
        resultFunc = func;
    }
    else if ((0,_number__WEBPACK_IMPORTED_MODULE_1__.isNumber)(value)) {
        resultFunc = () => value;
    }
    else {
        resultFunc = () => defaultValue;
    }
    return resultFunc;
};
const getFuncByUnknownType = (defaultValue, value, resultIsNumber = true) => {
    if (!value && value !== 0) {
        return (d) => {
            if (d.size) {
                if ((0,___WEBPACK_IMPORTED_MODULE_0__.isArray)(d.size))
                    return d.size[0] > d.size[1] ? d.size[0] : d.size[1];
                if ((0,___WEBPACK_IMPORTED_MODULE_0__.isObject)(d.size))
                    return d.size.width > d.size.height ? d.size.width : d.size.height;
                return d.size;
            }
            return defaultValue;
        };
    }
    if (isFunction(value)) {
        return value;
    }
    if ((0,_number__WEBPACK_IMPORTED_MODULE_1__.isNumber)(value)) {
        return () => value;
    }
    if ((0,___WEBPACK_IMPORTED_MODULE_0__.isArray)(value)) {
        return () => {
            if (resultIsNumber) {
                const max = Math.max(...value);
                return isNaN(max) ? defaultValue : max;
            }
            return value;
        };
    }
    if ((0,___WEBPACK_IMPORTED_MODULE_0__.isObject)(value)) {
        return () => {
            if (resultIsNumber) {
                const max = Math.max(value.width, value.height);
                return isNaN(max) ? defaultValue : max;
            }
            return [value.width, value.height];
        };
    }
    return () => defaultValue;
};
//# sourceMappingURL=function.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/util/gpu.js":
/*!**************************************************!*\
  !*** ./node_modules/@antv/layout/es/util/gpu.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arrayToTextureData: () => (/* binding */ arrayToTextureData),
/* harmony export */   attributesToTextureData: () => (/* binding */ attributesToTextureData),
/* harmony export */   buildTextureData: () => (/* binding */ buildTextureData),
/* harmony export */   buildTextureDataWithTwoEdgeAttr: () => (/* binding */ buildTextureDataWithTwoEdgeAttr),
/* harmony export */   proccessToFunc: () => (/* binding */ proccessToFunc)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ */ "./node_modules/@antv/layout/es/util/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/@antv/layout/es/util/math.js");


/**
 * 将 number | Function 类型的参数转换为 return number 的 Function
 * @param  {number | Function}  value 需要被转换的值
 * @param  {number}  defaultV 返回函数的默认返回值
 * @return {Function} 转换后的函数
 */
const proccessToFunc = (value, defaultV) => {
    let func;
    if (!value) {
        func = () => {
            return defaultV || 1;
        };
    }
    else if ((0,___WEBPACK_IMPORTED_MODULE_0__.isNumber)(value)) {
        func = () => {
            return value;
        };
    }
    else {
        func = value;
    }
    return func;
};
/**
 * 将节点和边数据转换为 GPU 可读的数组。并返回 maxEdgePerVetex，每个节点上最多的边数
 * @param  {NodeConfig[]}  nodes 需要被转换的值
 * @param  {EdgeConfig[]}  edges 返回函数的默认返回值
 * @return {Object} 转换后的数组及 maxEdgePerVetex 组成的对象
 */
const buildTextureData = (nodes, edges) => {
    const dataArray = [];
    const nodeDict = [];
    const mapIdPos = {};
    let i = 0;
    for (i = 0; i < nodes.length; i++) {
        const n = nodes[i];
        mapIdPos[n.id] = i;
        dataArray.push(n.x);
        dataArray.push(n.y);
        dataArray.push(0);
        dataArray.push(0);
        nodeDict.push([]);
    }
    for (i = 0; i < edges.length; i++) {
        const e = edges[i];
        const source = (0,_math__WEBPACK_IMPORTED_MODULE_1__.getEdgeTerminal)(e, 'source');
        const target = (0,_math__WEBPACK_IMPORTED_MODULE_1__.getEdgeTerminal)(e, 'target');
        if (!isNaN(mapIdPos[source]) && !isNaN(mapIdPos[target])) {
            nodeDict[mapIdPos[source]].push(mapIdPos[target]);
            nodeDict[mapIdPos[target]].push(mapIdPos[source]);
        }
    }
    let maxEdgePerVetex = 0;
    for (i = 0; i < nodes.length; i++) {
        const offset = dataArray.length;
        const dests = nodeDict[i];
        const len = dests.length;
        dataArray[i * 4 + 2] = offset;
        dataArray[i * 4 + 3] = len;
        maxEdgePerVetex = Math.max(maxEdgePerVetex, len);
        for (let j = 0; j < len; ++j) {
            const dest = dests[j];
            dataArray.push(+dest);
        }
    }
    while (dataArray.length % 4 !== 0) {
        dataArray.push(0);
    }
    return {
        maxEdgePerVetex,
        array: new Float32Array(dataArray),
    };
};
/**
* 将节点和边数据转换为 GPU 可读的数组，每条边带有一个属性。并返回 maxEdgePerVetex，每个节点上最多的边数
* @param  {NodeConfig[]}  nodes 节点数组
* @param  {EdgeConfig[]}  edges 边数组
* @param  {Function}  attrs 读取边属性的函数
* @return {Object} 转换后的数组及 maxEdgePerVetex 组成的对象
*/
// export const buildTextureDataWithOneEdgeAttr = (nodes: OutNode[], edges: Edge[], attrs: Function): {
//   array: Float32Array,
//   maxEdgePerVetex: number
// } => {
//   const dataArray = [];
//   const nodeDict: any = [];
//   const mapIdPos: IndexMap = {};
//   let i = 0;
//   for (i = 0; i < nodes.length; i++) {
//       const n = nodes[i];
//       mapIdPos[n.id] = i;
//       dataArray.push(n.x);
//       dataArray.push(n.y);
//       dataArray.push(0);
//       dataArray.push(0);
//       nodeDict.push([]);
//   }
//   for (i = 0; i < edges.length; i++) {
//       const e = edges[i];
//       nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);
//       nodeDict[mapIdPos[e.source]].push(attrs(e)); // 理想边长，后续可以改成每条边不同
//       nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);
//       nodeDict[mapIdPos[e.target]].push(attrs(e)); // 理想边长，后续可以改成每条边不同
//   }
//   let maxEdgePerVetex = 0;
//   for (i = 0; i < nodes.length; i++) {
//       const offset: number = dataArray.length;
//       const dests = nodeDict[i]; // dest 中节点 id 与边长间隔存储，即一位节点 id，一位边长……
//       const len = dests.length;
//       dataArray[i * 4 + 2] = offset;
//       dataArray[i * 4 + 3] = len / 2; // 第四位存储与该节点相关的所有节点个数
//       maxEdgePerVetex = Math.max(maxEdgePerVetex, len / 2);
//       for (let j = 0; j < len; ++j) {
//           const dest = dests[j];
//           dataArray.push(+dest);
//       }
//   }
//   // 不是 4 的倍数，填充 0
//   while (dataArray.length % 4 !== 0) {
//       dataArray.push(0);
//   }
//   return {
//       array: new Float32Array(dataArray),
//       maxEdgePerVetex
//   }
// }
/**
* 将节点和边数据转换为 GPU 可读的数组，每条边带有一个以上属性。并返回 maxEdgePerVetex，每个节点上最多的边数
* @param  {NodeConfig[]}  nodes 节点数组
* @param  {EdgeConfig[]}  edges 边数组
* @param  {Function}  attrs 读取边属性的函数
* @return {Object} 转换后的数组及 maxEdgePerVetex 组成的对象
*/
const buildTextureDataWithTwoEdgeAttr = (nodes, edges, attrs1, attrs2) => {
    const dataArray = [];
    const nodeDict = [];
    const mapIdPos = {};
    let i = 0;
    for (i = 0; i < nodes.length; i++) {
        const n = nodes[i];
        mapIdPos[n.id] = i;
        dataArray.push(n.x);
        dataArray.push(n.y);
        dataArray.push(0);
        dataArray.push(0);
        nodeDict.push([]);
    }
    for (i = 0; i < edges.length; i++) {
        const e = edges[i];
        const source = (0,_math__WEBPACK_IMPORTED_MODULE_1__.getEdgeTerminal)(e, 'source');
        const target = (0,_math__WEBPACK_IMPORTED_MODULE_1__.getEdgeTerminal)(e, 'target');
        nodeDict[mapIdPos[source]].push(mapIdPos[target]);
        nodeDict[mapIdPos[source]].push(attrs1(e));
        nodeDict[mapIdPos[source]].push(attrs2(e));
        nodeDict[mapIdPos[source]].push(0);
        nodeDict[mapIdPos[target]].push(mapIdPos[source]);
        nodeDict[mapIdPos[target]].push(attrs1(e));
        nodeDict[mapIdPos[target]].push(attrs2(e));
        nodeDict[mapIdPos[target]].push(0);
    }
    let maxEdgePerVetex = 0;
    for (i = 0; i < nodes.length; i++) {
        const offset = dataArray.length;
        const dests = nodeDict[i]; // dest 中节点 id 与边长间隔存储，即一位节点 id，一位边长……
        const len = dests.length;
        // dataArray[i * 4 + 2] = offset;
        // dataArray[i * 4 + 3] = len / 4; // 第四位存储与该节点相关的所有节点个数
        // pack offset & length into float32: offset 20bit, length 12bit
        dataArray[i * 4 + 2] = offset + 1048576 * len / 4;
        dataArray[i * 4 + 3] = 0; // 第四位存储与上一次的距离差值
        maxEdgePerVetex = Math.max(maxEdgePerVetex, len / 4);
        for (let j = 0; j < len; ++j) {
            const dest = dests[j];
            dataArray.push(+dest);
        }
    }
    // 不是 4 的倍数，填充 0
    while (dataArray.length % 4 !== 0) {
        dataArray.push(0);
    }
    return {
        maxEdgePerVetex,
        array: new Float32Array(dataArray),
    };
};
/**
* transform the extended attributes of nodes or edges to a texture array
* @param  {string[]}  attributeNames attributes' name to be read from items and put into output array
* @param  {ModelConfig[]}  items the items to be read
* @return {Float32Array} the attributes' value array to be read by GPU
*/
const attributesToTextureData = (attributeNames, items) => {
    const dataArray = [];
    const attributeNum = attributeNames.length;
    const attributteStringMap = {};
    items.forEach((item) => {
        attributeNames.forEach((name, i) => {
            if (attributteStringMap[item[name]] === undefined) {
                attributteStringMap[item[name]] = Object.keys(attributteStringMap).length;
            }
            dataArray.push(attributteStringMap[item[name]]);
            // insure each node's attributes take inter number of grids
            if (i === attributeNum - 1) {
                while (dataArray.length % 4 !== 0) {
                    dataArray.push(0);
                }
            }
        });
    });
    return {
        array: new Float32Array(dataArray),
        count: Object.keys(attributteStringMap).length
    };
};
/**
* transform the number array format of extended attributes of nodes or edges to a texture array
* @param  {string[]}  attributeNames attributes' name to be read from items and put into output array
* @return {Float32Array} the attributes' value array to be read by GPU
*/
const arrayToTextureData = (valueArrays) => {
    const dataArray = [];
    const attributeNum = valueArrays.length;
    const itemNum = valueArrays[0].length;
    for (let j = 0; j < itemNum; j++) {
        valueArrays.forEach((valueArray, i) => {
            dataArray.push(valueArray[j]);
            // insure each node's attributes take inter number of grids
            if (i === attributeNum - 1) {
                while (dataArray.length % 4 !== 0) {
                    dataArray.push(0);
                }
            }
        });
    }
    return new Float32Array(dataArray);
};
//# sourceMappingURL=gpu.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/util/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@antv/layout/es/util/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   camelize: () => (/* reexport safe */ _string__WEBPACK_IMPORTED_MODULE_0__.camelize),
/* harmony export */   clone: () => (/* reexport safe */ _object__WEBPACK_IMPORTED_MODULE_4__.clone),
/* harmony export */   floydWarshall: () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_3__.floydWarshall),
/* harmony export */   getAdjMatrix: () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_3__.getAdjMatrix),
/* harmony export */   getAvgNodePosition: () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_3__.getAvgNodePosition),
/* harmony export */   getCoreNodeAndRelativeLeafNodes: () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_3__.getCoreNodeAndRelativeLeafNodes),
/* harmony export */   getDegree: () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_3__.getDegree),
/* harmony export */   getDegreeMap: () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_3__.getDegreeMap),
/* harmony export */   getEdgeTerminal: () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_3__.getEdgeTerminal),
/* harmony export */   getFunc: () => (/* reexport safe */ _function__WEBPACK_IMPORTED_MODULE_5__.getFunc),
/* harmony export */   getFuncByUnknownType: () => (/* reexport safe */ _function__WEBPACK_IMPORTED_MODULE_5__.getFuncByUnknownType),
/* harmony export */   getLayoutBBox: () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_3__.getLayoutBBox),
/* harmony export */   isArray: () => (/* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_1__.isArray),
/* harmony export */   isFunction: () => (/* reexport safe */ _function__WEBPACK_IMPORTED_MODULE_5__.isFunction),
/* harmony export */   isNaN: () => (/* reexport safe */ _number__WEBPACK_IMPORTED_MODULE_2__.isNaN),
/* harmony export */   isNumber: () => (/* reexport safe */ _number__WEBPACK_IMPORTED_MODULE_2__.isNumber),
/* harmony export */   isObject: () => (/* reexport safe */ _object__WEBPACK_IMPORTED_MODULE_4__.isObject),
/* harmony export */   isString: () => (/* reexport safe */ _string__WEBPACK_IMPORTED_MODULE_0__.isString),
/* harmony export */   scaleMatrix: () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_3__.scaleMatrix),
/* harmony export */   toNumber: () => (/* reexport safe */ _number__WEBPACK_IMPORTED_MODULE_2__.toNumber),
/* harmony export */   traverseTreeUp: () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_3__.traverseTreeUp)
/* harmony export */ });
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./string */ "./node_modules/@antv/layout/es/util/string.js");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array */ "./node_modules/@antv/layout/es/util/array.js");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./number */ "./node_modules/@antv/layout/es/util/number.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./math */ "./node_modules/@antv/layout/es/util/math.js");
/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./object */ "./node_modules/@antv/layout/es/util/object.js");
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./function */ "./node_modules/@antv/layout/es/util/function.js");






//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/util/math.js":
/*!***************************************************!*\
  !*** ./node_modules/@antv/layout/es/util/math.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   floydWarshall: () => (/* binding */ floydWarshall),
/* harmony export */   getAdjMatrix: () => (/* binding */ getAdjMatrix),
/* harmony export */   getAvgNodePosition: () => (/* binding */ getAvgNodePosition),
/* harmony export */   getCoreNodeAndRelativeLeafNodes: () => (/* binding */ getCoreNodeAndRelativeLeafNodes),
/* harmony export */   getDegree: () => (/* binding */ getDegree),
/* harmony export */   getDegreeMap: () => (/* binding */ getDegreeMap),
/* harmony export */   getEdgeTerminal: () => (/* binding */ getEdgeTerminal),
/* harmony export */   getLayoutBBox: () => (/* binding */ getLayoutBBox),
/* harmony export */   scaleMatrix: () => (/* binding */ scaleMatrix),
/* harmony export */   traverseTreeUp: () => (/* binding */ traverseTreeUp)
/* harmony export */ });
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "./node_modules/@antv/layout/es/util/array.js");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./number */ "./node_modules/@antv/layout/es/util/number.js");
/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./object */ "./node_modules/@antv/layout/es/util/object.js");



const getEdgeTerminal = (edge, type) => {
    const terminal = edge[type];
    if ((0,_object__WEBPACK_IMPORTED_MODULE_2__.isObject)(terminal)) {
        return terminal.cell;
    }
    return terminal;
};
const getDegree = (n, nodeIdxMap, edges) => {
    const degrees = [];
    for (let i = 0; i < n; i++) {
        degrees[i] = {
            in: 0,
            out: 0,
            all: 0
        };
    }
    if (!edges)
        return degrees;
    edges.forEach((e) => {
        const source = getEdgeTerminal(e, 'source');
        const target = getEdgeTerminal(e, 'target');
        if (source && degrees[nodeIdxMap[source]]) {
            degrees[nodeIdxMap[source]].out += 1;
            degrees[nodeIdxMap[source]].all += 1;
        }
        if (target && degrees[nodeIdxMap[target]]) {
            degrees[nodeIdxMap[target]].in += 1;
            degrees[nodeIdxMap[target]].all += 1;
        }
    });
    return degrees;
};
const getDegreeMap = (nodes, edges) => {
    const degreesMap = {};
    nodes.forEach((node) => {
        degreesMap[node.id] = {
            in: 0,
            out: 0,
            all: 0
        };
    });
    if (!edges)
        return degreesMap;
    edges.forEach((e) => {
        const source = getEdgeTerminal(e, 'source');
        const target = getEdgeTerminal(e, 'target');
        if (source) {
            degreesMap[source].out += 1;
            degreesMap[source].all += 1;
        }
        if (target) {
            degreesMap[target].in += 1;
            degreesMap[target].all += 1;
        }
    });
    return degreesMap;
};
const floydWarshall = (adjMatrix) => {
    // initialize
    const dist = [];
    const size = adjMatrix.length;
    for (let i = 0; i < size; i += 1) {
        dist[i] = [];
        for (let j = 0; j < size; j += 1) {
            if (i === j) {
                dist[i][j] = 0;
            }
            else if (adjMatrix[i][j] === 0 || !adjMatrix[i][j]) {
                dist[i][j] = Infinity;
            }
            else {
                dist[i][j] = adjMatrix[i][j];
            }
        }
    }
    // floyd
    for (let k = 0; k < size; k += 1) {
        for (let i = 0; i < size; i += 1) {
            for (let j = 0; j < size; j += 1) {
                if (dist[i][j] > dist[i][k] + dist[k][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                }
            }
        }
    }
    return dist;
};
const getAdjMatrix = (data, directed) => {
    const { nodes, edges } = data;
    const matrix = [];
    // map node with index in data.nodes
    const nodeMap = {};
    if (!nodes) {
        throw new Error('invalid nodes data!');
    }
    if (nodes) {
        nodes.forEach((node, i) => {
            nodeMap[node.id] = i;
            const row = [];
            matrix.push(row);
        });
    }
    edges === null || edges === void 0 ? void 0 : edges.forEach((e) => {
        const source = getEdgeTerminal(e, 'source');
        const target = getEdgeTerminal(e, 'target');
        const sIndex = nodeMap[source];
        const tIndex = nodeMap[target];
        if (sIndex === undefined || tIndex === undefined)
            return;
        matrix[sIndex][tIndex] = 1;
        if (!directed) {
            matrix[tIndex][sIndex] = 1;
        }
    });
    return matrix;
};
/**
 * scale matrix
 * @param matrix [ [], [], [] ]
 * @param ratio
 */
const scaleMatrix = (matrix, ratio) => {
    const result = [];
    matrix.forEach((row) => {
        const newRow = [];
        row.forEach((v) => {
            newRow.push(v * ratio);
        });
        result.push(newRow);
    });
    return result;
};
/**
 * depth first traverse, from leaves to root, children in inverse order
 *  if the fn returns false, terminate the traverse
 */
const traverseUp = (data, fn) => {
    if (data && data.children) {
        for (let i = data.children.length - 1; i >= 0; i--) {
            if (!traverseUp(data.children[i], fn))
                return;
        }
    }
    if (!fn(data)) {
        return false;
    }
    return true;
};
/**
 * depth first traverse, from leaves to root, children in inverse order
 * if the fn returns false, terminate the traverse
 */
const traverseTreeUp = (data, fn) => {
    if (typeof fn !== 'function') {
        return;
    }
    traverseUp(data, fn);
};
/**
 * calculate the bounding box for the nodes according to their x, y, and size
 * @param nodes nodes in the layout
 * @returns
 */
const getLayoutBBox = (nodes) => {
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    nodes.forEach((node) => {
        let size = node.size;
        if ((0,_array__WEBPACK_IMPORTED_MODULE_0__.isArray)(size)) {
            if (size.length === 1)
                size = [size[0], size[0]];
        }
        else if ((0,_number__WEBPACK_IMPORTED_MODULE_1__.isNumber)(size)) {
            size = [size, size];
        }
        else if (size === undefined || isNaN(size)) {
            size = [30, 30];
        }
        const halfSize = [size[0] / 2, size[1] / 2];
        const left = node.x - halfSize[0];
        const right = node.x + halfSize[0];
        const top = node.y - halfSize[1];
        const bottom = node.y + halfSize[1];
        if (minX > left)
            minX = left;
        if (minY > top)
            minY = top;
        if (maxX < right)
            maxX = right;
        if (maxY < bottom)
            maxY = bottom;
    });
    return { minX, minY, maxX, maxY };
};
/**
 * 获取节点集合的平均位置信息
 * @param nodes 节点集合
 * @returns 平局内置
 */
const getAvgNodePosition = (nodes) => {
    const totalNodes = { x: 0, y: 0 };
    nodes.forEach((node) => {
        totalNodes.x += node.x || 0;
        totalNodes.y += node.y || 0;
    });
    // 获取均值向量
    const length = nodes.length || 1;
    return {
        x: totalNodes.x / length,
        y: totalNodes.y / length,
    };
};
// 找出指定节点关联的边的起点或终点
const getCoreNode = (type, node, edges) => {
    var _a, _b;
    if (type === 'source') {
        return (((_a = edges === null || edges === void 0 ? void 0 : edges.find((edge) => edge.target === node.id)) === null || _a === void 0 ? void 0 : _a.source) || {});
    }
    return (((_b = edges === null || edges === void 0 ? void 0 : edges.find((edge) => edge.source === node.id)) === null || _b === void 0 ? void 0 : _b.target) || {});
};
// 找出指定节点为起点或终点的所有一度叶子节点
const getRelativeNodeIds = (type, coreNode, edges) => {
    let relativeNodes = [];
    switch (type) {
        case 'source':
            relativeNodes = edges === null || edges === void 0 ? void 0 : edges.filter((edge) => edge.source === coreNode.id).map((edge) => edge.target);
            break;
        case 'target':
            relativeNodes = edges === null || edges === void 0 ? void 0 : edges.filter((edge) => edge.target === coreNode.id).map((edge) => edge.source);
            break;
        case 'both':
            relativeNodes = edges === null || edges === void 0 ? void 0 : edges.filter((edge) => edge.source === coreNode.id).map((edge) => edge.target).concat(edges === null || edges === void 0 ? void 0 : edges.filter((edge) => edge.target === coreNode.id).map((edge) => edge.source));
            break;
        default:
            break;
    }
    // 去重
    const set = new Set(relativeNodes);
    return Array.from(set);
};
// 找出同类型的节点
const getSameTypeNodes = (type, nodeClusterBy, node, relativeNodes, degreesMap) => {
    // @ts-ignore
    const typeName = node[nodeClusterBy] || '';
    // @ts-ignore
    let sameTypeNodes = (relativeNodes === null || relativeNodes === void 0 ? void 0 : relativeNodes.filter((item) => item[nodeClusterBy] === typeName)) || [];
    if (type === 'leaf') {
        sameTypeNodes = sameTypeNodes.filter((node) => { var _a, _b; return ((_a = degreesMap[node.id]) === null || _a === void 0 ? void 0 : _a.in) === 0 || ((_b = degreesMap[node.id]) === null || _b === void 0 ? void 0 : _b.out) === 0; });
    }
    return sameTypeNodes;
};
// 找出与指定节点关联的边的起点或终点出发的所有一度叶子节点
const getCoreNodeAndRelativeLeafNodes = (type, node, edges, nodeClusterBy, degreesMap, nodeMap) => {
    const { in: inDegree, out: outDegree } = degreesMap[node.id];
    let coreNode = node;
    let relativeLeafNodes = [];
    if (inDegree === 0) {
        // 如果为没有出边的叶子节点，则找出与它关联的边的起点出发的所有一度节点
        coreNode = getCoreNode('source', node, edges);
        relativeLeafNodes = getRelativeNodeIds('both', coreNode, edges).map((nodeId) => nodeMap[nodeId]);
    }
    else if (outDegree === 0) {
        // 如果为没有入边边的叶子节点，则找出与它关联的边的起点出发的所有一度节点
        coreNode = getCoreNode('target', node, edges);
        relativeLeafNodes = getRelativeNodeIds('both', coreNode, edges).map((nodeId) => nodeMap[nodeId]);
    }
    relativeLeafNodes = relativeLeafNodes.filter((node) => degreesMap[node.id] && (degreesMap[node.id].in === 0 || degreesMap[node.id].out === 0));
    const sameTypeLeafNodes = getSameTypeNodes(type, nodeClusterBy, node, relativeLeafNodes, degreesMap);
    return { coreNode, relativeLeafNodes, sameTypeLeafNodes };
};
//# sourceMappingURL=math.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/util/number.js":
/*!*****************************************************!*\
  !*** ./node_modules/@antv/layout/es/util/number.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isNaN: () => (/* binding */ isNaN),
/* harmony export */   isNumber: () => (/* binding */ isNumber),
/* harmony export */   toNumber: () => (/* binding */ toNumber)
/* harmony export */ });
const isNumber = (val) => typeof val === 'number';
const isNaN = (num) => Number.isNaN(Number(num));
const toNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
};
//# sourceMappingURL=number.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/util/object.js":
/*!*****************************************************!*\
  !*** ./node_modules/@antv/layout/es/util/object.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   isObject: () => (/* binding */ isObject)
/* harmony export */ });
const isObject = (val) => val !== null && typeof val === 'object';
const clone = (target) => {
    if (target === null) {
        return target;
    }
    if (target instanceof Date) {
        return new Date(target.getTime());
    }
    if (target instanceof Array) {
        const cp = [];
        target.forEach((v) => {
            cp.push(v);
        });
        return cp.map((n) => clone(n));
    }
    if (typeof target === 'object' && Object.keys(target).length) {
        const cp = Object.assign({}, target);
        Object.keys(cp).forEach((k) => {
            cp[k] = clone(cp[k]);
        });
        return cp;
    }
    return target;
};
//# sourceMappingURL=object.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/es/util/string.js":
/*!*****************************************************!*\
  !*** ./node_modules/@antv/layout/es/util/string.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   camelize: () => (/* binding */ camelize),
/* harmony export */   isString: () => (/* binding */ isString)
/* harmony export */ });
const isString = (val) => typeof val === 'string';
const cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return ((str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    });
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
});
// export const capitalize = cacheStringFunction(
//   (str: string) => str.charAt(0).toUpperCase() + str.slice(1),
// )
//# sourceMappingURL=string.js.map

/***/ }),

/***/ "./node_modules/@antv/util/esm/lodash/is-array.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/util/esm/lodash/is-array.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _is_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-type */ "./node_modules/@antv/util/esm/lodash/is-type.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function (value) {
    return Array.isArray ? Array.isArray(value) : (0,_is_type__WEBPACK_IMPORTED_MODULE_0__["default"])(value, 'Array');
});
//# sourceMappingURL=is-array.js.map

/***/ }),

/***/ "./node_modules/@antv/util/esm/lodash/is-type.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/util/esm/lodash/is-type.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var toString = {}.toString;
var isType = function (value, type) { return toString.call(value) === '[object ' + type + ']'; };
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isType);
//# sourceMappingURL=is-type.js.map

/***/ }),

/***/ "./node_modules/@antv/util/esm/lodash/max.js":
/*!***************************************************!*\
  !*** ./node_modules/@antv/util/esm/lodash/max.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _is_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-array */ "./node_modules/@antv/util/esm/lodash/is-array.js");

/**
 * @param {Array} arr The array to iterate over.
 * @return {*} Returns the maximum value.
 * @example
 *
 * max([1, 2]);
 * // => 2
 *
 * max([]);
 * // => undefined
 *
 * const data = new Array(1250010).fill(1).map((d,idx) => idx);
 *
 * max(data);
 * // => 1250010
 * // Math.max(...data) will encounter "Maximum call stack size exceeded" error
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function (arr) {
    if (!(0,_is_array__WEBPACK_IMPORTED_MODULE_0__["default"])(arr)) {
        return undefined;
    }
    return arr.reduce(function (prev, curr) {
        return Math.max(prev, curr);
    }, arr[0]);
});
//# sourceMappingURL=max.js.map

/***/ }),

/***/ "./node_modules/@antv/util/esm/lodash/min.js":
/*!***************************************************!*\
  !*** ./node_modules/@antv/util/esm/lodash/min.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _is_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-array */ "./node_modules/@antv/util/esm/lodash/is-array.js");

/**
 * @param {Array} arr The array to iterate over.
 * @return {*} Returns the minimum value.
 * @example
 *
 * min([1, 2]);
 * // => 1
 *
 * min([]);
 * // => undefined
 *
 * const data = new Array(1250010).fill(1).map((d,idx) => idx);
 *
 * min(data);
 * // => 1250010
 * // Math.min(...data) will encounter "Maximum call stack size exceeded" error
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function (arr) {
    if (!(0,_is_array__WEBPACK_IMPORTED_MODULE_0__["default"])(arr)) {
        return undefined;
    }
    return arr.reduce(function (prev, curr) {
        return Math.min(prev, curr);
    }, arr[0]);
});
//# sourceMappingURL=min.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/algorithm/dijkstra.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/algorithm/dijkstra.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Dijkstra: () => (/* binding */ Dijkstra)
/* harmony export */ });
/* harmony import */ var _priorityqueue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./priorityqueue */ "./node_modules/@antv/x6-common/es/algorithm/priorityqueue.js");

var Dijkstra;
(function (Dijkstra) {
    function run(adjacencyList, source, weight = (u, v) => 1) {
        const dist = {};
        const previous = {};
        const scanned = {};
        const queue = new _priorityqueue__WEBPACK_IMPORTED_MODULE_0__.PriorityQueue();
        dist[source] = 0;
        Object.keys(adjacencyList).forEach((v) => {
            if (v !== source) {
                dist[v] = Infinity;
            }
            queue.insert(dist[v], v, v);
        });
        while (!queue.isEmpty()) {
            const u = queue.remove();
            scanned[u] = true;
            const neighbours = adjacencyList[u] || [];
            for (let i = 0; i < neighbours.length; i += 1) {
                const v = neighbours[i];
                if (!scanned[v]) {
                    const alt = dist[u] + weight(u, v);
                    if (alt < dist[v]) {
                        dist[v] = alt;
                        previous[v] = u;
                        queue.updatePriority(v, alt);
                    }
                }
            }
        }
        return previous;
    }
    Dijkstra.run = run;
})(Dijkstra || (Dijkstra = {}));
//# sourceMappingURL=dijkstra.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/algorithm/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/algorithm/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Dijkstra: () => (/* reexport safe */ _dijkstra__WEBPACK_IMPORTED_MODULE_1__.Dijkstra),
/* harmony export */   PriorityQueue: () => (/* reexport safe */ _priorityqueue__WEBPACK_IMPORTED_MODULE_0__.PriorityQueue)
/* harmony export */ });
/* harmony import */ var _priorityqueue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./priorityqueue */ "./node_modules/@antv/x6-common/es/algorithm/priorityqueue.js");
/* harmony import */ var _dijkstra__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dijkstra */ "./node_modules/@antv/x6-common/es/algorithm/dijkstra.js");


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/algorithm/priorityqueue.js":
/*!********************************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/algorithm/priorityqueue.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PriorityQueue: () => (/* binding */ PriorityQueue)
/* harmony export */ });
/**
 * An implementation of the Priority Queue abstract data type.
 *
 * @see: http://en.wikipedia.org/wiki/Priority_queue
 *
 * It is like a normal stack or queue, but where each item has assigned a
 * priority (a number). Items with higher priority are served before items
 * with lower priority. This implementation uses binary heap as an internal
 * representation of the queue. The time complexity of all the methods is as
 * follows:
 *
 * - create: `O(n)`
 * - insert: `O(log n)`
 * - remove: `O(log n)`
 * - peek: `O(1)`
 * - isEmpty: `O(1)`
 * - peekPriority: `O(1)`
 */
class PriorityQueue {
    constructor(options = {}) {
        this.comparator = options.comparator || PriorityQueue.defaultComparator;
        this.index = {};
        this.data = options.data || [];
        this.heapify();
    }
    /**
     * Returns `true` if the priority queue is empty, `false` otherwise.
     */
    isEmpty() {
        return this.data.length === 0;
    }
    /**
     * Inserts a value with priority to the queue. Optionally pass a unique
     * id of this item. Passing unique IDs for each item you insert allows
     * you to use the `updatePriority()` operation.
     * @param priority
     * @param value
     * @param id
     */
    insert(priority, value, id) {
        const item = { priority, value };
        const index = this.data.length;
        if (id) {
            item.id = id;
            this.index[id] = index;
        }
        this.data.push(item);
        this.bubbleUp(index);
        return this;
    }
    /**
     * Returns the value of an item with the highest priority.
     */
    peek() {
        return this.data[0] ? this.data[0].value : null;
    }
    /**
     * Returns the highest priority in the queue.
     */
    peekPriority() {
        return this.data[0] ? this.data[0].priority : null;
    }
    updatePriority(id, priority) {
        const index = this.index[id];
        if (typeof index === 'undefined') {
            throw new Error(`Node with id '${id}' was not found in the heap.`);
        }
        const data = this.data;
        const oldPriority = data[index].priority;
        const comp = this.comparator(priority, oldPriority);
        if (comp < 0) {
            data[index].priority = priority;
            this.bubbleUp(index);
        }
        else if (comp > 0) {
            data[index].priority = priority;
            this.bubbleDown(index);
        }
    }
    /**
     * Removes the item with the highest priority from the queue
     *
     * @returns The value of the removed item.
     */
    remove() {
        const data = this.data;
        const peek = data[0];
        const last = data.pop();
        if (peek.id) {
            delete this.index[peek.id];
        }
        if (data.length > 0) {
            data[0] = last;
            if (last.id) {
                this.index[last.id] = 0;
            }
            this.bubbleDown(0);
        }
        return peek ? peek.value : null;
    }
    heapify() {
        for (let i = 0; i < this.data.length; i += 1) {
            this.bubbleUp(i);
        }
    }
    bubbleUp(index) {
        const data = this.data;
        let tmp;
        let parent;
        let current = index;
        while (current > 0) {
            parent = (current - 1) >>> 1;
            if (this.comparator(data[current].priority, data[parent].priority) < 0) {
                tmp = data[parent];
                data[parent] = data[current];
                let id = data[current].id;
                if (id != null) {
                    this.index[id] = parent;
                }
                data[current] = tmp;
                id = data[current].id;
                if (id != null) {
                    this.index[id] = current;
                }
                current = parent;
            }
            else {
                break;
            }
        }
    }
    bubbleDown(index) {
        const data = this.data;
        const last = data.length - 1;
        let current = index;
        // eslint-disable-next-line
        while (true) {
            const left = (current << 1) + 1;
            const right = left + 1;
            let minIndex = current;
            if (left <= last &&
                this.comparator(data[left].priority, data[minIndex].priority) < 0) {
                minIndex = left;
            }
            if (right <= last &&
                this.comparator(data[right].priority, data[minIndex].priority) < 0) {
                minIndex = right;
            }
            if (minIndex !== current) {
                const tmp = data[minIndex];
                data[minIndex] = data[current];
                let id = data[current].id;
                if (id != null) {
                    this.index[id] = minIndex;
                }
                data[current] = tmp;
                id = data[current].id;
                if (id != null) {
                    this.index[id] = current;
                }
                current = minIndex;
            }
            else {
                break;
            }
        }
    }
}
(function (PriorityQueue) {
    PriorityQueue.defaultComparator = (a, b) => a - b;
})(PriorityQueue || (PriorityQueue = {}));
//# sourceMappingURL=priorityqueue.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/animation/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/animation/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Interp: () => (/* reexport safe */ _interp__WEBPACK_IMPORTED_MODULE_1__.Interp),
/* harmony export */   Timing: () => (/* reexport safe */ _timing__WEBPACK_IMPORTED_MODULE_0__.Timing)
/* harmony export */ });
/* harmony import */ var _timing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timing */ "./node_modules/@antv/x6-common/es/animation/timing.js");
/* harmony import */ var _interp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interp */ "./node_modules/@antv/x6-common/es/animation/interp.js");


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/animation/interp.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/animation/interp.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Interp: () => (/* binding */ Interp)
/* harmony export */ });
var Interp;
(function (Interp) {
    Interp.number = (a, b) => {
        const d = b - a;
        return (t) => {
            return a + d * t;
        };
    };
    Interp.object = (a, b) => {
        const keys = Object.keys(a);
        return (t) => {
            const ret = {};
            for (let i = keys.length - 1; i !== -1; i -= 1) {
                const key = keys[i];
                ret[key] = a[key] + (b[key] - a[key]) * t;
            }
            return ret;
        };
    };
    Interp.unit = (a, b) => {
        const reg = /(-?[0-9]*.[0-9]*)(px|em|cm|mm|in|pt|pc|%)/;
        const ma = reg.exec(a);
        const mb = reg.exec(b);
        const pb = mb ? mb[1] : '';
        const aa = ma ? +ma[1] : 0;
        const bb = mb ? +mb[1] : 0;
        const index = pb.indexOf('.');
        const precision = index > 0 ? pb[1].length - index - 1 : 0;
        const d = bb - aa;
        const u = ma ? ma[2] : '';
        return (t) => {
            return (aa + d * t).toFixed(precision) + u;
        };
    };
    Interp.color = (a, b) => {
        const ca = parseInt(a.slice(1), 16);
        const cb = parseInt(b.slice(1), 16);
        const ra = ca & 0x0000ff;
        const rd = (cb & 0x0000ff) - ra;
        const ga = ca & 0x00ff00;
        const gd = (cb & 0x00ff00) - ga;
        const ba = ca & 0xff0000;
        const bd = (cb & 0xff0000) - ba;
        return (t) => {
            const r = (ra + rd * t) & 0x000000ff;
            const g = (ga + gd * t) & 0x0000ff00;
            const b = (ba + bd * t) & 0x00ff0000;
            return `#${((1 << 24) | r | g | b).toString(16).slice(1)}`;
        };
    };
})(Interp || (Interp = {}));
//# sourceMappingURL=interp.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/animation/timing.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/animation/timing.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Timing: () => (/* binding */ Timing)
/* harmony export */ });
var Timing;
(function (Timing) {
    Timing.linear = (t) => t;
    Timing.quad = (t) => t * t;
    Timing.cubic = (t) => t * t * t;
    Timing.inout = (t) => {
        if (t <= 0) {
            return 0;
        }
        if (t >= 1) {
            return 1;
        }
        const t2 = t * t;
        const t3 = t2 * t;
        return 4 * (t < 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75);
    };
    Timing.exponential = (t) => {
        return Math.pow(2, 10 * (t - 1)); // eslint-disable-line
    };
    Timing.bounce = ((t) => {
        // eslint-disable-next-line
        for (let a = 0, b = 1; 1; a += b, b /= 2) {
            if (t >= (7 - 4 * a) / 11) {
                const q = (11 - 6 * a - 11 * t) / 4;
                return -q * q + b * b;
            }
        }
    });
})(Timing || (Timing = {}));
(function (Timing) {
    Timing.decorators = {
        reverse(f) {
            return (t) => 1 - f(1 - t);
        },
        reflect(f) {
            return (t) => 0.5 * (t < 0.5 ? f(2 * t) : 2 - f(2 - 2 * t));
        },
        clamp(f, n = 0, x = 1) {
            return (t) => {
                const r = f(t);
                return r < n ? n : r > x ? x : r;
            };
        },
        back(s = 1.70158) {
            return (t) => t * t * ((s + 1) * t - s);
        },
        elastic(x = 1.5) {
            return (t) => Math.pow(2, 10 * (t - 1)) * Math.cos(((20 * Math.PI * x) / 3) * t); // eslint-disable-line
        },
    };
})(Timing || (Timing = {}));
(function (Timing) {
    // Slight acceleration from zero to full speed
    function easeInSine(t) {
        return -1 * Math.cos(t * (Math.PI / 2)) + 1;
    }
    Timing.easeInSine = easeInSine;
    // Slight deceleration at the end
    function easeOutSine(t) {
        return Math.sin(t * (Math.PI / 2));
    }
    Timing.easeOutSine = easeOutSine;
    // Slight acceleration at beginning and slight deceleration at end
    function easeInOutSine(t) {
        return -0.5 * (Math.cos(Math.PI * t) - 1);
    }
    Timing.easeInOutSine = easeInOutSine;
    // Accelerating from zero velocity
    function easeInQuad(t) {
        return t * t;
    }
    Timing.easeInQuad = easeInQuad;
    // Decelerating to zero velocity
    function easeOutQuad(t) {
        return t * (2 - t);
    }
    Timing.easeOutQuad = easeOutQuad;
    // Acceleration until halfway, then deceleration
    function easeInOutQuad(t) {
        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    }
    Timing.easeInOutQuad = easeInOutQuad;
    // Accelerating from zero velocity
    function easeInCubic(t) {
        return t * t * t;
    }
    Timing.easeInCubic = easeInCubic;
    // Decelerating to zero velocity
    function easeOutCubic(t) {
        const t1 = t - 1;
        return t1 * t1 * t1 + 1;
    }
    Timing.easeOutCubic = easeOutCubic;
    // Acceleration until halfway, then deceleration
    function easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
    }
    Timing.easeInOutCubic = easeInOutCubic;
    // Accelerating from zero velocity
    function easeInQuart(t) {
        return t * t * t * t;
    }
    Timing.easeInQuart = easeInQuart;
    // Decelerating to zero velocity
    function easeOutQuart(t) {
        const t1 = t - 1;
        return 1 - t1 * t1 * t1 * t1;
    }
    Timing.easeOutQuart = easeOutQuart;
    // Acceleration until halfway, then deceleration
    function easeInOutQuart(t) {
        const t1 = t - 1;
        return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * t1 * t1 * t1 * t1;
    }
    Timing.easeInOutQuart = easeInOutQuart;
    // Accelerating from zero velocity
    function easeInQuint(t) {
        return t * t * t * t * t;
    }
    Timing.easeInQuint = easeInQuint;
    // Decelerating to zero velocity
    function easeOutQuint(t) {
        const t1 = t - 1;
        return 1 + t1 * t1 * t1 * t1 * t1;
    }
    Timing.easeOutQuint = easeOutQuint;
    // Acceleration until halfway, then deceleration
    function easeInOutQuint(t) {
        const t1 = t - 1;
        return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * t1 * t1 * t1 * t1 * t1;
    }
    Timing.easeInOutQuint = easeInOutQuint;
    // Accelerate exponentially until finish
    function easeInExpo(t) {
        if (t === 0) {
            return 0;
        }
        return Math.pow(2, 10 * (t - 1)); // eslint-disable-line
    }
    Timing.easeInExpo = easeInExpo;
    // Initial exponential acceleration slowing to stop
    function easeOutExpo(t) {
        if (t === 1) {
            return 1;
        }
        return -Math.pow(2, -10 * t) + 1; // eslint-disable-line
    }
    Timing.easeOutExpo = easeOutExpo;
    // Exponential acceleration and deceleration
    function easeInOutExpo(t) {
        if (t === 0 || t === 1) {
            return t;
        }
        const scaledTime = t * 2;
        const scaledTime1 = scaledTime - 1;
        if (scaledTime < 1) {
            return 0.5 * Math.pow(2, 10 * scaledTime1); // eslint-disable-line
        }
        return 0.5 * (-Math.pow(2, -10 * scaledTime1) + 2); // eslint-disable-line
    }
    Timing.easeInOutExpo = easeInOutExpo;
    // Increasing velocity until stop
    function easeInCirc(t) {
        const scaledTime = t / 1;
        return -1 * (Math.sqrt(1 - scaledTime * t) - 1);
    }
    Timing.easeInCirc = easeInCirc;
    // Start fast, decreasing velocity until stop
    function easeOutCirc(t) {
        const t1 = t - 1;
        return Math.sqrt(1 - t1 * t1);
    }
    Timing.easeOutCirc = easeOutCirc;
    // Fast increase in velocity, fast decrease in velocity
    function easeInOutCirc(t) {
        const scaledTime = t * 2;
        const scaledTime1 = scaledTime - 2;
        if (scaledTime < 1) {
            return -0.5 * (Math.sqrt(1 - scaledTime * scaledTime) - 1);
        }
        return 0.5 * (Math.sqrt(1 - scaledTime1 * scaledTime1) + 1);
    }
    Timing.easeInOutCirc = easeInOutCirc;
    // Slow movement backwards then fast snap to finish
    function easeInBack(t, magnitude = 1.70158) {
        return t * t * ((magnitude + 1) * t - magnitude);
    }
    Timing.easeInBack = easeInBack;
    // Fast snap to backwards point then slow resolve to finish
    function easeOutBack(t, magnitude = 1.70158) {
        const scaledTime = t / 1 - 1;
        return (scaledTime * scaledTime * ((magnitude + 1) * scaledTime + magnitude) + 1);
    }
    Timing.easeOutBack = easeOutBack;
    // Slow movement backwards, fast snap to past finish, slow resolve to finish
    function easeInOutBack(t, magnitude = 1.70158) {
        const scaledTime = t * 2;
        const scaledTime2 = scaledTime - 2;
        const s = magnitude * 1.525;
        if (scaledTime < 1) {
            return 0.5 * scaledTime * scaledTime * ((s + 1) * scaledTime - s);
        }
        return 0.5 * (scaledTime2 * scaledTime2 * ((s + 1) * scaledTime2 + s) + 2);
    }
    Timing.easeInOutBack = easeInOutBack;
    // Bounces slowly then quickly to finish
    function easeInElastic(t, magnitude = 0.7) {
        if (t === 0 || t === 1) {
            return t;
        }
        const scaledTime = t / 1;
        const scaledTime1 = scaledTime - 1;
        const p = 1 - magnitude;
        const s = (p / (2 * Math.PI)) * Math.asin(1);
        return -(Math.pow(2, 10 * scaledTime1) * // eslint-disable-line
            Math.sin(((scaledTime1 - s) * (2 * Math.PI)) / p));
    }
    Timing.easeInElastic = easeInElastic;
    // Fast acceleration, bounces to zero
    function easeOutElastic(t, magnitude = 0.7) {
        const p = 1 - magnitude;
        const scaledTime = t * 2;
        if (t === 0 || t === 1) {
            return t;
        }
        const s = (p / (2 * Math.PI)) * Math.asin(1);
        return (Math.pow(2, -10 * scaledTime) * // eslint-disable-line
            Math.sin(((scaledTime - s) * (2 * Math.PI)) / p) +
            1);
    }
    Timing.easeOutElastic = easeOutElastic;
    // Slow start and end, two bounces sandwich a fast motion
    function easeInOutElastic(t, magnitude = 0.65) {
        const p = 1 - magnitude;
        if (t === 0 || t === 1) {
            return t;
        }
        const scaledTime = t * 2;
        const scaledTime1 = scaledTime - 1;
        const s = (p / (2 * Math.PI)) * Math.asin(1);
        if (scaledTime < 1) {
            return (-0.5 *
                (Math.pow(2, 10 * scaledTime1) * // eslint-disable-line
                    Math.sin(((scaledTime1 - s) * (2 * Math.PI)) / p)));
        }
        return (Math.pow(2, -10 * scaledTime1) * // eslint-disable-line
            Math.sin(((scaledTime1 - s) * (2 * Math.PI)) / p) *
            0.5 +
            1);
    }
    Timing.easeInOutElastic = easeInOutElastic;
    // Bounce to completion
    function easeOutBounce(t) {
        const scaledTime = t / 1;
        if (scaledTime < 1 / 2.75) {
            return 7.5625 * scaledTime * scaledTime;
        }
        if (scaledTime < 2 / 2.75) {
            const scaledTime2 = scaledTime - 1.5 / 2.75;
            return 7.5625 * scaledTime2 * scaledTime2 + 0.75;
        }
        if (scaledTime < 2.5 / 2.75) {
            const scaledTime2 = scaledTime - 2.25 / 2.75;
            return 7.5625 * scaledTime2 * scaledTime2 + 0.9375;
        }
        {
            const scaledTime2 = scaledTime - 2.625 / 2.75;
            return 7.5625 * scaledTime2 * scaledTime2 + 0.984375;
        }
    }
    Timing.easeOutBounce = easeOutBounce;
    // Bounce increasing in velocity until completion
    function easeInBounce(t) {
        return 1 - easeOutBounce(1 - t);
    }
    Timing.easeInBounce = easeInBounce;
    // Bounce in and bounce out
    function easeInOutBounce(t) {
        if (t < 0.5) {
            return easeInBounce(t * 2) * 0.5;
        }
        return easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
    }
    Timing.easeInOutBounce = easeInOutBounce;
})(Timing || (Timing = {}));
//# sourceMappingURL=timing.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/array/array.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/array/array.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   difference: () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   groupBy: () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   max: () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   sortBy: () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   sortedIndex: () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   sortedIndexBy: () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   union: () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   uniq: () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/uniq.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/union.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/sortedIndex.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/sortedIndexBy.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/sortBy.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/groupBy.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/difference.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/max.js");

//# sourceMappingURL=array.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/array/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/array/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ArrayExt: () => (/* reexport module object */ _array__WEBPACK_IMPORTED_MODULE_0__)
/* harmony export */ });
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "./node_modules/@antv/x6-common/es/array/array.js");


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/color/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/color/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Color: () => (/* binding */ Color)
/* harmony export */ });
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../number */ "./node_modules/@antv/x6-common/es/number/index.js");
/* eslint-disable no-constructor-return */

class Color {
    constructor(color, g, b, a) {
        if (color == null) {
            return this.set(255, 255, 255, 1);
        }
        if (typeof color === 'number') {
            return this.set(color, g, b, a);
        }
        if (typeof color === 'string') {
            return Color.fromString(color) || this;
        }
        if (Array.isArray(color)) {
            return this.set(color);
        }
        this.set(color.r, color.g, color.b, color.a == null ? 1 : color.a);
    }
    blend(start, end, weight) {
        this.set(start.r + (end.r - start.r) * weight, start.g + (end.g - start.g) * weight, start.b + (end.b - start.b) * weight, start.a + (end.a - start.a) * weight);
    }
    lighten(amount) {
        const rgba = Color.lighten(this.toArray(), amount);
        this.r = rgba[0];
        this.g = rgba[1];
        this.b = rgba[2];
        this.a = rgba[3];
    }
    darken(amount) {
        this.lighten(-amount);
    }
    set(arg0, arg1, arg2, arg3) {
        const r = Array.isArray(arg0) ? arg0[0] : arg0;
        const g = Array.isArray(arg0) ? arg0[1] : arg1;
        const b = Array.isArray(arg0) ? arg0[2] : arg2;
        const a = Array.isArray(arg0) ? arg0[3] : arg3;
        this.r = Math.round(_number__WEBPACK_IMPORTED_MODULE_0__.NumberExt.clamp(r, 0, 255));
        this.g = Math.round(_number__WEBPACK_IMPORTED_MODULE_0__.NumberExt.clamp(g, 0, 255));
        this.b = Math.round(_number__WEBPACK_IMPORTED_MODULE_0__.NumberExt.clamp(b, 0, 255));
        this.a = a == null ? 1 : _number__WEBPACK_IMPORTED_MODULE_0__.NumberExt.clamp(a, 0, 1);
        return this;
    }
    toHex() {
        const hex = ['r', 'g', 'b'].map((key) => {
            const str = this[key].toString(16);
            return str.length < 2 ? `0${str}` : str;
        });
        return `#${hex.join('')}`;
    }
    toRGBA() {
        return this.toArray();
    }
    toHSLA() {
        return Color.rgba2hsla(this.r, this.g, this.b, this.a);
    }
    toCSS(ignoreAlpha) {
        const rgb = `${this.r},${this.g},${this.b},`;
        return ignoreAlpha ? `rgb(${rgb})` : `rgba(${rgb},${this.a})`;
    }
    toGrey() {
        return Color.makeGrey(Math.round((this.r + this.g + this.b) / 3), this.a);
    }
    toArray() {
        return [this.r, this.g, this.b, this.a];
    }
    toString() {
        return this.toCSS();
    }
}
(function (Color) {
    function fromArray(arr) {
        return new Color(arr);
    }
    Color.fromArray = fromArray;
    function fromHex(color) {
        return new Color([...hex2rgb(color), 1]);
    }
    Color.fromHex = fromHex;
    function fromRGBA(color) {
        const matches = color.toLowerCase().match(/^rgba?\(([\s.,0-9]+)\)/);
        if (matches) {
            const arr = matches[1].split(/\s*,\s*/).map((v) => parseInt(v, 10));
            return new Color(arr);
        }
        return null;
    }
    Color.fromRGBA = fromRGBA;
    function hue2rgb(m1, m2, h) {
        if (h < 0) {
            ++h; // eslint-disable-line
        }
        if (h > 1) {
            --h; // eslint-disable-line
        }
        const h6 = 6 * h;
        if (h6 < 1) {
            return m1 + (m2 - m1) * h6;
        }
        if (2 * h < 1) {
            return m2;
        }
        if (3 * h < 2) {
            return m1 + (m2 - m1) * (2 / 3 - h) * 6;
        }
        return m1;
    }
    function fromHSLA(color) {
        const matches = color.toLowerCase().match(/^hsla?\(([\s.,0-9]+)\)/);
        if (matches) {
            const arr = matches[2].split(/\s*,\s*/);
            const h = (((parseFloat(arr[0]) % 360) + 360) % 360) / 360;
            const s = parseFloat(arr[1]) / 100;
            const l = parseFloat(arr[2]) / 100;
            const a = arr[3] == null ? 1 : parseInt(arr[3], 10);
            return new Color(hsla2rgba(h, s, l, a));
        }
        return null;
    }
    Color.fromHSLA = fromHSLA;
    function fromString(color) {
        if (color.startsWith('#')) {
            return fromHex(color);
        }
        if (color.startsWith('rgb')) {
            return fromRGBA(color);
        }
        const preset = Color.named[color];
        if (preset) {
            return fromHex(preset);
        }
        return fromHSLA(color);
    }
    Color.fromString = fromString;
    function makeGrey(g, a) {
        return Color.fromArray([g, g, g, a]);
    }
    Color.makeGrey = makeGrey;
    function rgba2hsla(arg0, arg1, arg2, arg3) {
        const r = Array.isArray(arg0) ? arg0[0] : arg0;
        const g = Array.isArray(arg0) ? arg0[1] : arg1;
        const b = Array.isArray(arg0) ? arg0[2] : arg2;
        const a = Array.isArray(arg0) ? arg0[3] : arg3;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const l = (max + min) / 2;
        let h = 0;
        let s = 0;
        if (min !== max) {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / d + 2;
                    break;
                case b:
                    h = (r - g) / d + 4;
                    break;
                default:
                    break;
            }
            h /= 6;
        }
        return [h, s, l, a == null ? 1 : a];
    }
    Color.rgba2hsla = rgba2hsla;
    function hsla2rgba(arg0, arg1, arg2, arg3) {
        const h = Array.isArray(arg0) ? arg0[0] : arg0;
        const s = Array.isArray(arg0) ? arg0[1] : arg1;
        const l = Array.isArray(arg0) ? arg0[2] : arg2;
        const a = Array.isArray(arg0) ? arg0[3] : arg3;
        const m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
        const m1 = 2 * l - m2;
        return [
            hue2rgb(m1, m2, h + 1 / 3) * 256,
            hue2rgb(m1, m2, h) * 256,
            hue2rgb(m1, m2, h - 1 / 3) * 256,
            a == null ? 1 : a,
        ];
    }
    Color.hsla2rgba = hsla2rgba;
    function random(ignoreAlpha) {
        return new Color(Math.round(Math.random() * 256), Math.round(Math.random() * 256), Math.round(Math.random() * 256), ignoreAlpha ? undefined : parseFloat(Math.random().toFixed(2)));
    }
    Color.random = random;
    function randomHex() {
        const letters = '0123456789ABCDEF';
        let color = '#';
        for (let i = 0; i < 6; i += 1) {
            color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
    }
    Color.randomHex = randomHex;
    function randomRGBA(ignoreAlpha) {
        return random(ignoreAlpha).toString();
    }
    Color.randomRGBA = randomRGBA;
    function invert(color, bw) {
        if (typeof color === 'string') {
            const pound = color[0] === '#';
            const [r, g, b] = hex2rgb(color);
            if (bw) {
                // http://stackoverflow.com/a/3943023/112731
                return r * 0.299 + g * 0.587 + b * 0.114 > 186 ? '#000000' : '#ffffff';
            }
            return `${pound ? '#' : ''}${rgb2hex(255 - r, 255 - g, 255 - b)}`;
        }
        const r = color[0];
        const g = color[1];
        const b = color[2];
        const a = color[3];
        if (bw) {
            return r * 0.299 + g * 0.587 + b * 0.114 > 186
                ? [0, 0, 0, a]
                : [255, 255, 255, a];
        }
        return [255 - r, 255 - g, 255 - b, a];
    }
    Color.invert = invert;
    function hex2rgb(hex) {
        const color = hex.indexOf('#') === 0 ? hex : `#${hex}`;
        let val = Number(`0x${color.substr(1)}`);
        if (!(color.length === 4 || color.length === 7) || Number.isNaN(val)) {
            throw new Error('Invalid hex color.');
        }
        const bits = color.length === 4 ? 4 : 8;
        const mask = (1 << bits) - 1;
        const bgr = ['b', 'g', 'r'].map(() => {
            const c = val & mask;
            val >>= bits;
            return bits === 4 ? 17 * c : c;
        });
        return [bgr[2], bgr[1], bgr[0]];
    }
    function rgb2hex(r, g, b) {
        const pad = (hex) => (hex.length < 2 ? `0${hex}` : hex);
        return `${pad(r.toString(16))}${pad(g.toString(16))}${pad(b.toString(16))}`;
    }
    function lighten(color, amt) {
        return lum(color, amt);
    }
    Color.lighten = lighten;
    function darken(color, amt) {
        return lum(color, -amt);
    }
    Color.darken = darken;
    function lum(color, amt) {
        if (typeof color === 'string') {
            const pound = color[0] === '#';
            const num = parseInt(pound ? color.substr(1) : color, 16);
            const r = _number__WEBPACK_IMPORTED_MODULE_0__.NumberExt.clamp((num >> 16) + amt, 0, 255);
            const g = _number__WEBPACK_IMPORTED_MODULE_0__.NumberExt.clamp(((num >> 8) & 0x00ff) + amt, 0, 255);
            const b = _number__WEBPACK_IMPORTED_MODULE_0__.NumberExt.clamp((num & 0x0000ff) + amt, 0, 255);
            return `${pound ? '#' : ''}${(b | (g << 8) | (r << 16)).toString(16)}`;
        }
        const hex = rgb2hex(color[0], color[1], color[2]);
        const arr = hex2rgb(lum(hex, amt));
        return [arr[0], arr[1], arr[2], color[3]];
    }
})(Color || (Color = {}));
(function (Color) {
    Color.named = {
        aliceblue: '#f0f8ff',
        antiquewhite: '#faebd7',
        aqua: '#00ffff',
        aquamarine: '#7fffd4',
        azure: '#f0ffff',
        beige: '#f5f5dc',
        bisque: '#ffe4c4',
        black: '#000000',
        blanchedalmond: '#ffebcd',
        blue: '#0000ff',
        blueviolet: '#8a2be2',
        brown: '#a52a2a',
        burlywood: '#deb887',
        burntsienna: '#ea7e5d',
        cadetblue: '#5f9ea0',
        chartreuse: '#7fff00',
        chocolate: '#d2691e',
        coral: '#ff7f50',
        cornflowerblue: '#6495ed',
        cornsilk: '#fff8dc',
        crimson: '#dc143c',
        cyan: '#00ffff',
        darkblue: '#00008b',
        darkcyan: '#008b8b',
        darkgoldenrod: '#b8860b',
        darkgray: '#a9a9a9',
        darkgreen: '#006400',
        darkgrey: '#a9a9a9',
        darkkhaki: '#bdb76b',
        darkmagenta: '#8b008b',
        darkolivegreen: '#556b2f',
        darkorange: '#ff8c00',
        darkorchid: '#9932cc',
        darkred: '#8b0000',
        darksalmon: '#e9967a',
        darkseagreen: '#8fbc8f',
        darkslateblue: '#483d8b',
        darkslategray: '#2f4f4f',
        darkslategrey: '#2f4f4f',
        darkturquoise: '#00ced1',
        darkviolet: '#9400d3',
        deeppink: '#ff1493',
        deepskyblue: '#00bfff',
        dimgray: '#696969',
        dimgrey: '#696969',
        dodgerblue: '#1e90ff',
        firebrick: '#b22222',
        floralwhite: '#fffaf0',
        forestgreen: '#228b22',
        fuchsia: '#ff00ff',
        gainsboro: '#dcdcdc',
        ghostwhite: '#f8f8ff',
        gold: '#ffd700',
        goldenrod: '#daa520',
        gray: '#808080',
        green: '#008000',
        greenyellow: '#adff2f',
        grey: '#808080',
        honeydew: '#f0fff0',
        hotpink: '#ff69b4',
        indianred: '#cd5c5c',
        indigo: '#4b0082',
        ivory: '#fffff0',
        khaki: '#f0e68c',
        lavender: '#e6e6fa',
        lavenderblush: '#fff0f5',
        lawngreen: '#7cfc00',
        lemonchiffon: '#fffacd',
        lightblue: '#add8e6',
        lightcoral: '#f08080',
        lightcyan: '#e0ffff',
        lightgoldenrodyellow: '#fafad2',
        lightgray: '#d3d3d3',
        lightgreen: '#90ee90',
        lightgrey: '#d3d3d3',
        lightpink: '#ffb6c1',
        lightsalmon: '#ffa07a',
        lightseagreen: '#20b2aa',
        lightskyblue: '#87cefa',
        lightslategray: '#778899',
        lightslategrey: '#778899',
        lightsteelblue: '#b0c4de',
        lightyellow: '#ffffe0',
        lime: '#00ff00',
        limegreen: '#32cd32',
        linen: '#faf0e6',
        magenta: '#ff00ff',
        maroon: '#800000',
        mediumaquamarine: '#66cdaa',
        mediumblue: '#0000cd',
        mediumorchid: '#ba55d3',
        mediumpurple: '#9370db',
        mediumseagreen: '#3cb371',
        mediumslateblue: '#7b68ee',
        mediumspringgreen: '#00fa9a',
        mediumturquoise: '#48d1cc',
        mediumvioletred: '#c71585',
        midnightblue: '#191970',
        mintcream: '#f5fffa',
        mistyrose: '#ffe4e1',
        moccasin: '#ffe4b5',
        navajowhite: '#ffdead',
        navy: '#000080',
        oldlace: '#fdf5e6',
        olive: '#808000',
        olivedrab: '#6b8e23',
        orange: '#ffa500',
        orangered: '#ff4500',
        orchid: '#da70d6',
        palegoldenrod: '#eee8aa',
        palegreen: '#98fb98',
        paleturquoise: '#afeeee',
        palevioletred: '#db7093',
        papayawhip: '#ffefd5',
        peachpuff: '#ffdab9',
        peru: '#cd853f',
        pink: '#ffc0cb',
        plum: '#dda0dd',
        powderblue: '#b0e0e6',
        purple: '#800080',
        rebeccapurple: '#663399',
        red: '#ff0000',
        rosybrown: '#bc8f8f',
        royalblue: '#4169e1',
        saddlebrown: '#8b4513',
        salmon: '#fa8072',
        sandybrown: '#f4a460',
        seagreen: '#2e8b57',
        seashell: '#fff5ee',
        sienna: '#a0522d',
        silver: '#c0c0c0',
        skyblue: '#87ceeb',
        slateblue: '#6a5acd',
        slategray: '#708090',
        slategrey: '#708090',
        snow: '#fffafa',
        springgreen: '#00ff7f',
        steelblue: '#4682b4',
        tan: '#d2b48c',
        teal: '#008080',
        thistle: '#d8bfd8',
        tomato: '#ff6347',
        turquoise: '#40e0d0',
        violet: '#ee82ee',
        wheat: '#f5deb3',
        white: '#ffffff',
        whitesmoke: '#f5f5f5',
        yellow: '#ffff00',
        yellowgreen: '#9acd32',
    };
})(Color || (Color = {}));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/common/basecoat.js":
/*!************************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/common/basecoat.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Basecoat: () => (/* binding */ Basecoat)
/* harmony export */ });
/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../event */ "./node_modules/@antv/x6-common/es/event/index.js");
/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../object */ "./node_modules/@antv/x6-common/es/object/index.js");
/* harmony import */ var _disposable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./disposable */ "./node_modules/@antv/x6-common/es/common/disposable.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};



class Basecoat extends _event__WEBPACK_IMPORTED_MODULE_0__.Events {
    dispose() {
        this.off();
    }
}
__decorate([
    _disposable__WEBPACK_IMPORTED_MODULE_2__.Disposable.dispose()
], Basecoat.prototype, "dispose", null);
(function (Basecoat) {
    Basecoat.dispose = _disposable__WEBPACK_IMPORTED_MODULE_2__.Disposable.dispose;
})(Basecoat || (Basecoat = {}));
_object__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.applyMixins(Basecoat, _disposable__WEBPACK_IMPORTED_MODULE_2__.Disposable);
//# sourceMappingURL=basecoat.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/common/disablable.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/common/disablable.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Disablable: () => (/* binding */ Disablable)
/* harmony export */ });
/* harmony import */ var _basecoat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basecoat */ "./node_modules/@antv/x6-common/es/common/basecoat.js");
/* eslint-disable no-underscore-dangle */

class Disablable extends _basecoat__WEBPACK_IMPORTED_MODULE_0__.Basecoat {
    get disabled() {
        return this._disabled === true;
    }
    enable() {
        delete this._disabled;
    }
    disable() {
        this._disabled = true;
    }
}
//# sourceMappingURL=disablable.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/common/disposable.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/common/disposable.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Disposable: () => (/* binding */ Disposable),
/* harmony export */   DisposableDelegate: () => (/* binding */ DisposableDelegate),
/* harmony export */   DisposableSet: () => (/* binding */ DisposableSet)
/* harmony export */ });
/* eslint-disable no-underscore-dangle */
class Disposable {
    get disposed() {
        return this._disposed === true;
    }
    dispose() {
        this._disposed = true;
    }
}
(function (Disposable) {
    function dispose() {
        return (target, methodName, descriptor) => {
            const raw = descriptor.value;
            const proto = target.__proto__; // eslint-disable-line
            descriptor.value = function (...args) {
                if (this.disposed) {
                    return;
                }
                raw.call(this, ...args);
                proto.dispose.call(this);
            };
        };
    }
    Disposable.dispose = dispose;
})(Disposable || (Disposable = {}));
/**
 * A disposable object which delegates to a callback function.
 */
class DisposableDelegate {
    /**
     * Construct a new disposable delegate.
     *
     * @param callback - The callback function to invoke on dispose.
     */
    constructor(callback) {
        this.callback = callback;
    }
    /**
     * Test whether the delegate has been disposed.
     */
    get disposed() {
        return !this.callback;
    }
    /**
     * Dispose of the delegate and invoke the callback function.
     */
    dispose() {
        if (!this.callback) {
            return;
        }
        const callback = this.callback;
        this.callback = null;
        callback();
    }
}
/**
 * An object which manages a collection of disposable items.
 */
class DisposableSet {
    constructor() {
        this.isDisposed = false; // eslint-disable-line:variable-name
        this.items = new Set();
    }
    /**
     * Test whether the set has been disposed.
     */
    get disposed() {
        return this.isDisposed;
    }
    /**
     * Dispose of the set and the items it contains.
     *
     * #### Notes
     * Items are disposed in the order they are added to the set.
     */
    dispose() {
        if (this.isDisposed) {
            return;
        }
        this.isDisposed = true;
        this.items.forEach((item) => {
            item.dispose();
        });
        this.items.clear();
    }
    /**
     * Test whether the set contains a specific item.
     *
     * @param item - The item of interest.
     *
     * @returns `true` if the set contains the item, `false` otherwise.
     */
    contains(item) {
        return this.items.has(item);
    }
    /**
     * Add a disposable item to the set.
     *
     * @param item - The item to add to the set.
     *
     * #### Notes
     * If the item is already contained in the set, this is a no-op.
     */
    add(item) {
        this.items.add(item);
    }
    /**
     * Remove a disposable item from the set.
     *
     * @param item - The item to remove from the set.
     *
     * #### Notes
     * If the item is not contained in the set, this is a no-op.
     */
    remove(item) {
        this.items.delete(item);
    }
    /**
     * Remove all items from the set.
     */
    clear() {
        this.items.clear();
    }
}
(function (DisposableSet) {
    /**
     * Create a disposable set from an iterable of items.
     *
     * @param items - The iterable or array-like object of interest.
     *
     * @returns A new disposable initialized with the given items.
     */
    function from(items) {
        const set = new DisposableSet();
        items.forEach((item) => {
            set.add(item);
        });
        return set;
    }
    DisposableSet.from = from;
})(DisposableSet || (DisposableSet = {}));
//# sourceMappingURL=disposable.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/common/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/common/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Basecoat: () => (/* reexport safe */ _basecoat__WEBPACK_IMPORTED_MODULE_2__.Basecoat),
/* harmony export */   Disablable: () => (/* reexport safe */ _disablable__WEBPACK_IMPORTED_MODULE_1__.Disablable),
/* harmony export */   Disposable: () => (/* reexport safe */ _disposable__WEBPACK_IMPORTED_MODULE_0__.Disposable),
/* harmony export */   DisposableDelegate: () => (/* reexport safe */ _disposable__WEBPACK_IMPORTED_MODULE_0__.DisposableDelegate),
/* harmony export */   DisposableSet: () => (/* reexport safe */ _disposable__WEBPACK_IMPORTED_MODULE_0__.DisposableSet)
/* harmony export */ });
/* harmony import */ var _disposable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./disposable */ "./node_modules/@antv/x6-common/es/common/disposable.js");
/* harmony import */ var _disablable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./disablable */ "./node_modules/@antv/x6-common/es/common/disablable.js");
/* harmony import */ var _basecoat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basecoat */ "./node_modules/@antv/x6-common/es/common/basecoat.js");



//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/css-loader/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/css-loader/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CssLoader: () => (/* reexport module object */ _loader__WEBPACK_IMPORTED_MODULE_0__)
/* harmony export */ });
/* harmony import */ var _loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loader */ "./node_modules/@antv/x6-common/es/css-loader/loader.js");


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/css-loader/loader.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/css-loader/loader.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clean: () => (/* binding */ clean),
/* harmony export */   ensure: () => (/* binding */ ensure)
/* harmony export */ });
/* harmony import */ var _platform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform */ "./node_modules/@antv/x6-common/es/platform/index.js");

const cssModules = [];
function ensure(name, content) {
    const cssModule = cssModules.find((m) => m.name === name);
    if (cssModule) {
        cssModule.loadTimes += 1;
        if (cssModule.loadTimes > 1) {
            return;
        }
    }
    if (!_platform__WEBPACK_IMPORTED_MODULE_0__.Platform.isApplyingHMR()) {
        const styleElement = document.createElement('style');
        styleElement.setAttribute('type', 'text/css');
        styleElement.textContent = content;
        const head = document.querySelector('head');
        if (head) {
            head.insertBefore(styleElement, head.firstChild);
        }
        cssModules.push({
            name,
            loadTimes: 1,
            styleElement,
        });
    }
}
function clean(name) {
    const index = cssModules.findIndex((m) => m.name === name);
    if (index > -1) {
        const cssModule = cssModules[index];
        cssModule.loadTimes -= 1;
        if (cssModule.loadTimes > 0) {
            return;
        }
        let styleElement = cssModule.styleElement;
        if (styleElement && styleElement.parentNode) {
            styleElement.parentNode.removeChild(styleElement);
        }
        styleElement = null;
        cssModules.splice(index, 1);
    }
}
//# sourceMappingURL=loader.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/datauri/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/datauri/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DataUri: () => (/* binding */ DataUri)
/* harmony export */ });
var DataUri;
(function (DataUri) {
    function isDataUrl(url) {
        const prefix = 'data:';
        return url.substr(0, prefix.length) === prefix;
    }
    DataUri.isDataUrl = isDataUrl;
    /**
     * Converts an image at `url` to base64-encoded data uri.
     * The mime type of the image is inferred from the `url` file extension.
     */
    function imageToDataUri(url, callback) {
        // No need to convert to data uri if it is already in data uri.
        if (!url || isDataUrl(url)) {
            // Keep the async nature of the function.
            setTimeout(() => callback(null, url));
            return;
        }
        const onError = () => {
            callback(new Error(`Failed to load image: ${url}`));
        };
        const onLoad = window.FileReader
            ? // chrome, IE10+
                (xhr) => {
                    if (xhr.status === 200) {
                        const reader = new FileReader();
                        reader.onload = (evt) => {
                            const dataUri = evt.target.result;
                            callback(null, dataUri);
                        };
                        reader.onerror = onError;
                        reader.readAsDataURL(xhr.response);
                    }
                    else {
                        onError();
                    }
                }
            : (xhr) => {
                const toString = (u8a) => {
                    const CHUNK_SZ = 0x8000;
                    const c = [];
                    for (let i = 0; i < u8a.length; i += CHUNK_SZ) {
                        c.push(String.fromCharCode.apply(null, u8a.subarray(i, i + CHUNK_SZ)));
                    }
                    return c.join('');
                };
                if (xhr.status === 200) {
                    let suffix = url.split('.').pop() || 'png';
                    if (suffix === 'svg') {
                        suffix = 'svg+xml';
                    }
                    const meta = `data:image/${suffix};base64,`;
                    const bytes = new Uint8Array(xhr.response);
                    const base64 = meta + btoa(toString(bytes));
                    callback(null, base64);
                }
                else {
                    onError();
                }
            };
        const xhr = new XMLHttpRequest();
        xhr.responseType = window.FileReader ? 'blob' : 'arraybuffer';
        xhr.open('GET', url, true);
        xhr.addEventListener('error', onError);
        xhr.addEventListener('load', () => onLoad(xhr));
        xhr.send();
    }
    DataUri.imageToDataUri = imageToDataUri;
    function dataUriToBlob(dataUrl) {
        let uri = dataUrl.replace(/\s/g, '');
        uri = decodeURIComponent(uri);
        const index = uri.indexOf(',');
        const dataType = uri.slice(0, index); // e.g. 'data:image/jpeg;base64'
        const mime = dataType.split(':')[1].split(';')[0]; // e.g. 'image/jpeg'
        const data = uri.slice(index + 1);
        let decodedString;
        if (dataType.indexOf('base64') >= 0) {
            // data may be encoded in base64
            decodedString = atob(data);
        }
        else {
            // convert the decoded string to UTF-8
            decodedString = unescape(encodeURIComponent(data));
        }
        // write the bytes of the string to a typed array
        const ia = new Uint8Array(decodedString.length);
        for (let i = 0; i < decodedString.length; i += 1) {
            ia[i] = decodedString.charCodeAt(i);
        }
        return new Blob([ia], { type: mime });
    }
    DataUri.dataUriToBlob = dataUriToBlob;
    function downloadBlob(blob, fileName) {
        const msSaveBlob = window.navigator.msSaveBlob;
        if (msSaveBlob) {
            // requires IE 10+
            // pulls up a save dialog
            msSaveBlob(blob, fileName);
        }
        else {
            // other browsers
            // downloads directly in Chrome and Safari
            // presents a save/open dialog in Firefox
            // Firefox bug: `from` field in save dialog always shows `from:blob:`
            // https://bugzilla.mozilla.org/show_bug.cgi?id=1053327
            const url = window.URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = fileName;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            // mark the url for garbage collection
            window.URL.revokeObjectURL(url);
        }
    }
    DataUri.downloadBlob = downloadBlob;
    function downloadDataUri(dataUrl, fileName) {
        const blob = dataUriToBlob(dataUrl);
        downloadBlob(blob, fileName);
    }
    DataUri.downloadDataUri = downloadDataUri;
    function parseViewBox(svg) {
        const matches = svg.match(/<svg[^>]*viewBox\s*=\s*(["']?)(.+?)\1[^>]*>/i);
        if (matches && matches[2]) {
            return matches[2].replace(/\s+/, ' ').split(' ');
        }
        return null;
    }
    function getNumber(str) {
        const ret = parseFloat(str);
        return Number.isNaN(ret) ? null : ret;
    }
    function svgToDataUrl(svg, options = {}) {
        let viewBox = null;
        const getNumberFromViewBox = (index) => {
            if (viewBox == null) {
                viewBox = parseViewBox(svg);
            }
            if (viewBox != null) {
                return getNumber(viewBox[index]);
            }
            return null;
        };
        const getNumberFromMatches = (reg) => {
            const matches = svg.match(reg);
            if (matches && matches[2]) {
                return getNumber(matches[2]);
            }
            return null;
        };
        let w = options.width;
        if (w == null) {
            w = getNumberFromMatches(/<svg[^>]*width\s*=\s*(["']?)(.+?)\1[^>]*>/i);
        }
        if (w == null) {
            w = getNumberFromViewBox(2);
        }
        if (w == null) {
            throw new Error('Can not parse width from svg string');
        }
        let h = options.height;
        if (h == null) {
            h = getNumberFromMatches(/<svg[^>]*height\s*=\s*(["']?)(.+?)\1[^>]*>/i);
        }
        if (h == null) {
            h = getNumberFromViewBox(3);
        }
        if (h == null) {
            throw new Error('Can not parse height from svg string');
        }
        const decoded = encodeURIComponent(svg)
            .replace(/'/g, '%27')
            .replace(/"/g, '%22');
        const header = 'data:image/svg+xml';
        const dataUrl = `${header},${decoded}`;
        return dataUrl;
    }
    DataUri.svgToDataUrl = svgToDataUrl;
})(DataUri || (DataUri = {}));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/dictionary/dictionary.js":
/*!******************************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/dictionary/dictionary.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Dictionary: () => (/* binding */ Dictionary)
/* harmony export */ });
class Dictionary {
    constructor() {
        this.clear();
    }
    clear() {
        this.map = new WeakMap();
        this.arr = [];
    }
    has(key) {
        return this.map.has(key);
    }
    get(key) {
        return this.map.get(key);
    }
    set(key, value) {
        this.map.set(key, value);
        this.arr.push(key);
    }
    delete(key) {
        const index = this.arr.indexOf(key);
        if (index >= 0) {
            this.arr.splice(index, 1);
        }
        const ret = this.map.get(key);
        this.map.delete(key);
        return ret;
    }
    each(iterator) {
        this.arr.forEach((key) => {
            const value = this.map.get(key);
            iterator(value, key);
        });
    }
    dispose() {
        this.clear();
    }
}
//# sourceMappingURL=dictionary.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/dictionary/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/dictionary/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Dictionary: () => (/* reexport safe */ _dictionary__WEBPACK_IMPORTED_MODULE_0__.Dictionary)
/* harmony export */ });
/* harmony import */ var _dictionary__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dictionary */ "./node_modules/@antv/x6-common/es/dictionary/dictionary.js");

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/dom/attr.js":
/*!*****************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/dom/attr.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CASE_SENSITIVE_ATTR: () => (/* binding */ CASE_SENSITIVE_ATTR),
/* harmony export */   attr: () => (/* binding */ attr),
/* harmony export */   getAttribute: () => (/* binding */ getAttribute),
/* harmony export */   kebablizeAttrs: () => (/* binding */ kebablizeAttrs),
/* harmony export */   mergeAttrs: () => (/* binding */ mergeAttrs),
/* harmony export */   qualifyAttr: () => (/* binding */ qualifyAttr),
/* harmony export */   removeAttribute: () => (/* binding */ removeAttribute),
/* harmony export */   setAttribute: () => (/* binding */ setAttribute),
/* harmony export */   setAttributes: () => (/* binding */ setAttributes),
/* harmony export */   styleToObject: () => (/* binding */ styleToObject)
/* harmony export */ });
/* harmony import */ var _elem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./elem */ "./node_modules/@antv/x6-common/es/dom/elem.js");
/* harmony import */ var _string_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../string/format */ "./node_modules/@antv/x6-common/es/string/format.js");


const CASE_SENSITIVE_ATTR = [
    'viewBox',
    'attributeName',
    'attributeType',
    'repeatCount',
    'textLength',
    'lengthAdjust',
    'gradientUnits',
];
function getAttribute(elem, name) {
    return elem.getAttribute(name);
}
function removeAttribute(elem, name) {
    const qualified = qualifyAttr(name);
    if (qualified.ns) {
        if (elem.hasAttributeNS(qualified.ns, qualified.local)) {
            elem.removeAttributeNS(qualified.ns, qualified.local);
        }
    }
    else if (elem.hasAttribute(name)) {
        elem.removeAttribute(name);
    }
}
function setAttribute(elem, name, value) {
    if (value == null) {
        return removeAttribute(elem, name);
    }
    const qualified = qualifyAttr(name);
    if (qualified.ns && typeof value === 'string') {
        elem.setAttributeNS(qualified.ns, name, value);
    }
    else if (name === 'id') {
        elem.id = `${value}`;
    }
    else {
        elem.setAttribute(name, `${value}`);
    }
}
function setAttributes(elem, attrs) {
    Object.keys(attrs).forEach((name) => {
        setAttribute(elem, name, attrs[name]);
    });
}
function attr(elem, name, value) {
    if (name == null) {
        const attrs = elem.attributes;
        const ret = {};
        for (let i = 0; i < attrs.length; i += 1) {
            ret[attrs[i].name] = attrs[i].value;
        }
        return ret;
    }
    if (typeof name === 'string' && value === undefined) {
        return elem.getAttribute(name);
    }
    if (typeof name === 'object') {
        setAttributes(elem, name);
    }
    else {
        setAttribute(elem, name, value);
    }
}
function qualifyAttr(name) {
    if (name.indexOf(':') !== -1) {
        const combinedKey = name.split(':');
        return {
            ns: _elem__WEBPACK_IMPORTED_MODULE_0__.ns[combinedKey[0]],
            local: combinedKey[1],
        };
    }
    return {
        ns: null,
        local: name,
    };
}
function kebablizeAttrs(attrs) {
    const result = {};
    Object.keys(attrs).forEach((key) => {
        const name = CASE_SENSITIVE_ATTR.includes(key) ? key : (0,_string_format__WEBPACK_IMPORTED_MODULE_1__.kebabCase)(key);
        result[name] = attrs[key];
    });
    return result;
}
function styleToObject(styleString) {
    const ret = {};
    const styles = styleString.split(';');
    styles.forEach((item) => {
        const section = item.trim();
        if (section) {
            const pair = section.split('=');
            if (pair.length) {
                ret[pair[0].trim()] = pair[1] ? pair[1].trim() : '';
            }
        }
    });
    return ret;
}
function mergeAttrs(target, source) {
    Object.keys(source).forEach((attr) => {
        if (attr === 'class') {
            target[attr] = target[attr]
                ? `${target[attr]} ${source[attr]}`
                : source[attr];
        }
        else if (attr === 'style') {
            const to = typeof target[attr] === 'object';
            const so = typeof source[attr] === 'object';
            let tt;
            let ss;
            if (to && so) {
                tt = target[attr];
                ss = source[attr];
            }
            else if (to) {
                tt = target[attr];
                ss = styleToObject(source[attr]);
            }
            else if (so) {
                tt = styleToObject(target[attr]);
                ss = source[attr];
            }
            else {
                tt = styleToObject(target[attr]);
                ss = styleToObject(source[attr]);
            }
            target[attr] = mergeAttrs(tt, ss);
        }
        else {
            target[attr] = source[attr];
        }
    });
    return target;
}
//# sourceMappingURL=attr.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/dom/class.js":
/*!******************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/dom/class.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addClass: () => (/* binding */ addClass),
/* harmony export */   getClass: () => (/* binding */ getClass),
/* harmony export */   hasClass: () => (/* binding */ hasClass),
/* harmony export */   removeClass: () => (/* binding */ removeClass),
/* harmony export */   toggleClass: () => (/* binding */ toggleClass)
/* harmony export */ });
const rclass = /[\t\r\n\f]/g;
const rnotwhite = /\S+/g;
const fillSpaces = (str) => ` ${str} `;
function getClass(elem) {
    return (elem && elem.getAttribute && elem.getAttribute('class')) || '';
}
function hasClass(elem, selector) {
    if (elem == null || selector == null) {
        return false;
    }
    const classNames = fillSpaces(getClass(elem));
    const className = fillSpaces(selector);
    return elem.nodeType === 1
        ? classNames.replace(rclass, ' ').includes(className)
        : false;
}
function addClass(elem, selector) {
    if (elem == null || selector == null) {
        return;
    }
    if (typeof selector === 'function') {
        return addClass(elem, selector(getClass(elem)));
    }
    if (typeof selector === 'string' && elem.nodeType === 1) {
        const classes = selector.match(rnotwhite) || [];
        const oldValue = fillSpaces(getClass(elem)).replace(rclass, ' ');
        let newValue = classes.reduce((memo, cls) => {
            if (memo.indexOf(fillSpaces(cls)) < 0) {
                return `${memo}${cls} `;
            }
            return memo;
        }, oldValue);
        newValue = newValue.trim();
        if (oldValue !== newValue) {
            elem.setAttribute('class', newValue);
        }
    }
}
function removeClass(elem, selector) {
    if (elem == null) {
        return;
    }
    if (typeof selector === 'function') {
        return removeClass(elem, selector(getClass(elem)));
    }
    if ((!selector || typeof selector === 'string') && elem.nodeType === 1) {
        const classes = (selector || '').match(rnotwhite) || [];
        const oldValue = fillSpaces(getClass(elem)).replace(rclass, ' ');
        let newValue = classes.reduce((memo, cls) => {
            const className = fillSpaces(cls);
            if (memo.indexOf(className) > -1) {
                return memo.replace(className, ' ');
            }
            return memo;
        }, oldValue);
        newValue = selector ? newValue.trim() : '';
        if (oldValue !== newValue) {
            elem.setAttribute('class', newValue);
        }
    }
}
function toggleClass(elem, selector, stateVal) {
    if (elem == null || selector == null) {
        return;
    }
    if (stateVal != null && typeof selector === 'string') {
        stateVal ? addClass(elem, selector) : removeClass(elem, selector);
        return;
    }
    if (typeof selector === 'function') {
        return toggleClass(elem, selector(getClass(elem), stateVal), stateVal);
    }
    if (typeof selector === 'string') {
        const metches = selector.match(rnotwhite) || [];
        metches.forEach((cls) => {
            hasClass(elem, cls) ? removeClass(elem, cls) : addClass(elem, cls);
        });
    }
}
//# sourceMappingURL=class.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/dom/css.js":
/*!****************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/dom/css.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   computeStyle: () => (/* binding */ computeStyle),
/* harmony export */   computeStyleInt: () => (/* binding */ computeStyleInt),
/* harmony export */   css: () => (/* binding */ css),
/* harmony export */   isCSSVariable: () => (/* binding */ isCSSVariable)
/* harmony export */ });
/* harmony import */ var _prefix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./prefix */ "./node_modules/@antv/x6-common/es/dom/prefix.js");

const numericProps = {
    animationIterationCount: true,
    columnCount: true,
    flexGrow: true,
    flexShrink: true,
    fontWeight: true,
    gridArea: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnStart: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowStart: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    widows: true,
    zIndex: true,
};
function isCSSVariable(prop) {
    return /^--/.test(prop);
}
function computeStyle(elem, prop, isVariable) {
    const style = window.getComputedStyle(elem, null);
    return isVariable
        ? style.getPropertyValue(prop) || undefined
        : style[prop] || elem.style[prop];
}
function computeStyleInt(elem, prop) {
    return parseInt(computeStyle(elem, prop), 10) || 0;
}
function getSuffixedValue(prop, value) {
    return !numericProps[prop] && typeof value === 'number' ? `${value}px` : value;
}
function css(elem, prop, value) {
    if (typeof prop === 'string') {
        const isVariable = isCSSVariable(prop);
        if (!isVariable) {
            prop = (0,_prefix__WEBPACK_IMPORTED_MODULE_0__.getVendorPrefixedName)(prop); // eslint-disable-line
        }
        if (value === undefined) {
            return computeStyle(elem, prop, isVariable);
        }
        if (!isVariable) {
            value = getSuffixedValue(prop, value); // eslint-disable-line
        }
        const style = elem.style;
        if (isVariable) {
            style.setProperty(prop, value);
        }
        else {
            style[prop] = value;
        }
        return;
    }
    // eslint-disable-next-line
    for (const key in prop) {
        css(elem, key, prop[key]);
    }
}
//# sourceMappingURL=css.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/dom/data.js":
/*!*****************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/dom/data.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   data: () => (/* binding */ data),
/* harmony export */   getData: () => (/* binding */ getData),
/* harmony export */   setData: () => (/* binding */ setData)
/* harmony export */ });
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../string */ "./node_modules/@antv/x6-common/es/string/index.js");

const dataset = new WeakMap();
function getData(elem, name) {
    const key = _string__WEBPACK_IMPORTED_MODULE_0__.StringExt.camelCase(name);
    const cache = dataset.get(elem);
    if (cache) {
        return cache[key];
    }
}
function setData(elem, name, value) {
    const key = _string__WEBPACK_IMPORTED_MODULE_0__.StringExt.camelCase(name);
    const cache = dataset.get(elem);
    if (cache) {
        cache[key] = value;
    }
    else {
        dataset.set(elem, {
            [key]: value,
        });
    }
}
function data(elem, name, value) {
    if (!name) {
        const datas = {};
        Object.keys(dataset).forEach((key) => {
            datas[key] = getData(elem, key);
        });
        return datas;
    }
    if (typeof name === 'string') {
        if (value === undefined) {
            return getData(elem, name);
        }
        setData(elem, name, value);
        return;
    }
    // eslint-disable-next-line
    for (const key in name) {
        data(elem, key, name[key]);
    }
}
//# sourceMappingURL=data.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/dom/elem.js":
/*!*****************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/dom/elem.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   after: () => (/* binding */ after),
/* harmony export */   append: () => (/* binding */ append),
/* harmony export */   appendTo: () => (/* binding */ appendTo),
/* harmony export */   before: () => (/* binding */ before),
/* harmony export */   children: () => (/* binding */ children),
/* harmony export */   contains: () => (/* binding */ contains),
/* harmony export */   createElement: () => (/* binding */ createElement),
/* harmony export */   createElementNS: () => (/* binding */ createElementNS),
/* harmony export */   createSvgDocument: () => (/* binding */ createSvgDocument),
/* harmony export */   createSvgElement: () => (/* binding */ createSvgElement),
/* harmony export */   empty: () => (/* binding */ empty),
/* harmony export */   ensureId: () => (/* binding */ ensureId),
/* harmony export */   find: () => (/* binding */ find),
/* harmony export */   findOne: () => (/* binding */ findOne),
/* harmony export */   findParentByClass: () => (/* binding */ findParentByClass),
/* harmony export */   index: () => (/* binding */ index),
/* harmony export */   isElement: () => (/* binding */ isElement),
/* harmony export */   isHTMLElement: () => (/* binding */ isHTMLElement),
/* harmony export */   isSVGGraphicsElement: () => (/* binding */ isSVGGraphicsElement),
/* harmony export */   ns: () => (/* binding */ ns),
/* harmony export */   parseXML: () => (/* binding */ parseXML),
/* harmony export */   prepend: () => (/* binding */ prepend),
/* harmony export */   remove: () => (/* binding */ remove),
/* harmony export */   svgVersion: () => (/* binding */ svgVersion),
/* harmony export */   tagName: () => (/* binding */ tagName),
/* harmony export */   uniqueId: () => (/* binding */ uniqueId)
/* harmony export */ });
/* harmony import */ var _class__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./class */ "./node_modules/@antv/x6-common/es/dom/class.js");

let idCounter = 0;
function uniqueId() {
    idCounter += 1;
    return `v${idCounter}`;
}
function ensureId(elem) {
    if (elem.id == null || elem.id === '') {
        elem.id = uniqueId();
    }
    return elem.id;
}
/**
 * Returns true if object is an instance of SVGGraphicsElement.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement
 */
function isSVGGraphicsElement(elem) {
    if (elem == null) {
        return false;
    }
    return typeof elem.getScreenCTM === 'function' && elem instanceof SVGElement;
}
const ns = {
    svg: 'http://www.w3.org/2000/svg',
    xmlns: 'http://www.w3.org/2000/xmlns/',
    xml: 'http://www.w3.org/XML/1998/namespace',
    xlink: 'http://www.w3.org/1999/xlink',
    xhtml: 'http://www.w3.org/1999/xhtml',
};
const svgVersion = '1.1';
function createElement(tagName, doc = document) {
    return doc.createElement(tagName);
}
function createElementNS(tagName, namespaceURI = ns.xhtml, doc = document) {
    return doc.createElementNS(namespaceURI, tagName);
}
function createSvgElement(tagName, doc = document) {
    return createElementNS(tagName, ns.svg, doc);
}
function createSvgDocument(content) {
    if (content) {
        const xml = `<svg xmlns="${ns.svg}" xmlns:xlink="${ns.xlink}" version="${svgVersion}">${content}</svg>`; // lgtm[js/html-constructed-from-input]
        const { documentElement } = parseXML(xml, { async: false });
        return documentElement;
    }
    const svg = document.createElementNS(ns.svg, 'svg');
    svg.setAttributeNS(ns.xmlns, 'xmlns:xlink', ns.xlink);
    svg.setAttribute('version', svgVersion);
    return svg;
}
function parseXML(data, options = {}) {
    let xml;
    try {
        const parser = new DOMParser();
        if (options.async != null) {
            const instance = parser;
            instance.async = options.async;
        }
        xml = parser.parseFromString(data, options.mimeType || 'text/xml');
    }
    catch (error) {
        xml = undefined;
    }
    if (!xml || xml.getElementsByTagName('parsererror').length) {
        throw new Error(`Invalid XML: ${data}`);
    }
    return xml;
}
function tagName(node, lowercase = true) {
    const nodeName = node.nodeName;
    return lowercase ? nodeName.toLowerCase() : nodeName.toUpperCase();
}
function index(elem) {
    let index = 0;
    let node = elem.previousSibling;
    while (node) {
        if (node.nodeType === 1) {
            index += 1;
        }
        node = node.previousSibling;
    }
    return index;
}
function find(elem, selector) {
    return elem.querySelectorAll(selector);
}
function findOne(elem, selector) {
    return elem.querySelector(selector);
}
function findParentByClass(elem, className, terminator) {
    const ownerSVGElement = elem.ownerSVGElement;
    let node = elem.parentNode;
    while (node && node !== terminator && node !== ownerSVGElement) {
        if ((0,_class__WEBPACK_IMPORTED_MODULE_0__.hasClass)(node, className)) {
            return node;
        }
        node = node.parentNode;
    }
    return null;
}
function contains(parent, child) {
    const bup = child && child.parentNode;
    return (parent === bup ||
        !!(bup && bup.nodeType === 1 && parent.compareDocumentPosition(bup) & 16) // eslint-disable-line no-bitwise
    );
}
function remove(elem) {
    if (elem) {
        const elems = Array.isArray(elem) ? elem : [elem];
        elems.forEach((item) => {
            if (item.parentNode) {
                item.parentNode.removeChild(item);
            }
        });
    }
}
function empty(elem) {
    while (elem.firstChild) {
        elem.removeChild(elem.firstChild);
    }
}
function append(elem, elems) {
    const arr = Array.isArray(elems) ? elems : [elems];
    arr.forEach((child) => {
        if (child != null) {
            elem.appendChild(child);
        }
    });
}
function prepend(elem, elems) {
    const child = elem.firstChild;
    return child ? before(child, elems) : append(elem, elems);
}
function before(elem, elems) {
    const parent = elem.parentNode;
    if (parent) {
        const arr = Array.isArray(elems) ? elems : [elems];
        arr.forEach((child) => {
            if (child != null) {
                parent.insertBefore(child, elem);
            }
        });
    }
}
function after(elem, elems) {
    const parent = elem.parentNode;
    if (parent) {
        const arr = Array.isArray(elems) ? elems : [elems];
        arr.forEach((child) => {
            if (child != null) {
                parent.insertBefore(child, elem.nextSibling);
            }
        });
    }
}
function appendTo(elem, target) {
    if (target != null) {
        target.appendChild(elem);
    }
}
function isElement(x) {
    return !!x && x.nodeType === 1;
}
// Determines whether a node is an HTML node
function isHTMLElement(elem) {
    try {
        // Using W3 DOM2 (works for FF, Opera and Chrome)
        return elem instanceof HTMLElement;
    }
    catch (e) {
        // Browsers not supporting W3 DOM2 don't have HTMLElement and
        // an exception is thrown and we end up here. Testing some
        // properties that all elements have (works on IE7)
        return (typeof elem === 'object' &&
            elem.nodeType === 1 &&
            typeof elem.style === 'object' &&
            typeof elem.ownerDocument === 'object');
    }
}
function children(parent, className) {
    const matched = [];
    let elem = parent.firstChild;
    for (; elem; elem = elem.nextSibling) {
        if (elem.nodeType === 1) {
            if (!className || (0,_class__WEBPACK_IMPORTED_MODULE_0__.hasClass)(elem, className)) {
                matched.push(elem);
            }
        }
    }
    return matched;
}
//# sourceMappingURL=elem.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/dom/event/core.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/dom/event/core.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Core: () => (/* binding */ Core)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6-common/es/dom/event/util.js");
/* harmony import */ var _hook__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hook */ "./node_modules/@antv/x6-common/es/dom/event/hook.js");
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./store */ "./node_modules/@antv/x6-common/es/dom/event/store.js");
/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./object */ "./node_modules/@antv/x6-common/es/dom/event/object.js");
/* harmony import */ var _special__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./special */ "./node_modules/@antv/x6-common/es/dom/event/special.js");
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};





var Core;
(function (Core) {
    let triggered;
    function on(elem, types, handler, data, selector) {
        if (!_util__WEBPACK_IMPORTED_MODULE_0__.Util.isValidTarget(elem)) {
            return;
        }
        // Caller can pass in an object of custom data in lieu of the handler
        let handlerData;
        if (typeof handler !== 'function') {
            const { handler: h, selector: s } = handler, others = __rest(handler, ["handler", "selector"]);
            handler = h; // eslint-disable-line
            selector = s; // eslint-disable-line
            handlerData = others;
        }
        // Ensure that invalid selectors throw exceptions at attach time
        // if (!Util.isValidSelector(elem, selector)) {
        //   throw new Error('Delegate event with invalid selector.')
        // }
        const store = _store__WEBPACK_IMPORTED_MODULE_2__.Store.ensure(elem);
        // Ensure the main handle
        let mainHandler = store.handler;
        if (mainHandler == null) {
            mainHandler = store.handler = function (e, ...args) {
                return triggered !== e.type ? dispatch(elem, e, ...args) : undefined;
            };
        }
        // Make sure that the handler has a unique ID, used to find/remove it later
        const guid = _util__WEBPACK_IMPORTED_MODULE_0__.Util.ensureHandlerId(handler);
        // Handle multiple events separated by a space
        _util__WEBPACK_IMPORTED_MODULE_0__.Util.splitType(types).forEach((item) => {
            const { originType, namespaces } = _util__WEBPACK_IMPORTED_MODULE_0__.Util.normalizeType(item);
            // There *must* be a type, no attaching namespace-only handlers
            if (!originType) {
                return;
            }
            let type = originType;
            let hook = _hook__WEBPACK_IMPORTED_MODULE_1__.EventHook.get(type);
            // If selector defined, determine special event type, otherwise given type
            type = (selector ? hook.delegateType : hook.bindType) || type;
            // Update hook based on newly reset type
            hook = _hook__WEBPACK_IMPORTED_MODULE_1__.EventHook.get(type);
            // handleObj is passed to all event handlers
            const handleObj = Object.assign({ type,
                originType,
                data,
                selector,
                guid, handler: handler, namespace: namespaces.join('.') }, handlerData);
            // Init the event handler queue if we're the first
            const events = store.events;
            let bag = events[type];
            if (!bag) {
                bag = events[type] = { handlers: [], delegateCount: 0 };
                // Only use addEventListener if the `hook.steup` returns false
                if (!hook.setup ||
                    hook.setup(elem, data, namespaces, mainHandler) === false) {
                    _util__WEBPACK_IMPORTED_MODULE_0__.Util.addEventListener(elem, type, mainHandler);
                }
            }
            if (hook.add) {
                _util__WEBPACK_IMPORTED_MODULE_0__.Util.removeHandlerId(handleObj.handler);
                hook.add(elem, handleObj);
                _util__WEBPACK_IMPORTED_MODULE_0__.Util.setHandlerId(handleObj.handler, guid);
            }
            // Add to the element's handler list, delegates in front
            if (selector) {
                bag.handlers.splice(bag.delegateCount, 0, handleObj);
                bag.delegateCount += 1;
            }
            else {
                bag.handlers.push(handleObj);
            }
        });
    }
    Core.on = on;
    function off(elem, types, handler, selector, mappedTypes) {
        const store = _store__WEBPACK_IMPORTED_MODULE_2__.Store.get(elem);
        if (!store) {
            return;
        }
        const events = store.events;
        if (!events) {
            return;
        }
        // Once for each type.namespace in types; type may be omitted
        _util__WEBPACK_IMPORTED_MODULE_0__.Util.splitType(types).forEach((item) => {
            const { originType, namespaces } = _util__WEBPACK_IMPORTED_MODULE_0__.Util.normalizeType(item);
            // Unbind all events (on this namespace, if provided) for the element
            if (!originType) {
                Object.keys(events).forEach((key) => {
                    off(elem, key + item, handler, selector, true);
                });
                return;
            }
            let type = originType;
            const hook = _hook__WEBPACK_IMPORTED_MODULE_1__.EventHook.get(type);
            type = (selector ? hook.delegateType : hook.bindType) || type;
            const bag = events[type];
            if (!bag) {
                return;
            }
            const rns = namespaces.length > 0
                ? new RegExp(`(^|\\.)${namespaces.join('\\.(?:.*\\.|)')}(\\.|$)`)
                : null;
            // Remove matching events
            const originHandlerCount = bag.handlers.length;
            for (let i = bag.handlers.length - 1; i >= 0; i -= 1) {
                const handleObj = bag.handlers[i];
                if ((mappedTypes || originType === handleObj.originType) &&
                    (!handler || _util__WEBPACK_IMPORTED_MODULE_0__.Util.getHandlerId(handler) === handleObj.guid) &&
                    (rns == null ||
                        (handleObj.namespace && rns.test(handleObj.namespace))) &&
                    (selector == null ||
                        selector === handleObj.selector ||
                        (selector === '**' && handleObj.selector))) {
                    bag.handlers.splice(i, 1);
                    if (handleObj.selector) {
                        bag.delegateCount -= 1;
                    }
                    if (hook.remove) {
                        hook.remove(elem, handleObj);
                    }
                }
            }
            if (originHandlerCount && bag.handlers.length === 0) {
                if (!hook.teardown ||
                    hook.teardown(elem, namespaces, store.handler) === false) {
                    _util__WEBPACK_IMPORTED_MODULE_0__.Util.removeEventListener(elem, type, store.handler);
                }
                delete events[type];
            }
        });
        // Remove data and the expando if it's no longer used
        if (Object.keys(events).length === 0) {
            _store__WEBPACK_IMPORTED_MODULE_2__.Store.remove(elem);
        }
    }
    Core.off = off;
    function dispatch(elem, evt, ...args) {
        const event = _object__WEBPACK_IMPORTED_MODULE_3__.EventObject.create(evt);
        event.delegateTarget = elem;
        const hook = _hook__WEBPACK_IMPORTED_MODULE_1__.EventHook.get(event.type);
        if (hook.preDispatch && hook.preDispatch(elem, event) === false) {
            return;
        }
        const handlerQueue = _util__WEBPACK_IMPORTED_MODULE_0__.Util.getHandlerQueue(elem, event);
        // Run delegates first; they may want to stop propagation beneath us
        for (let i = 0, l = handlerQueue.length; i < l && !event.isPropagationStopped(); i += 1) {
            const matched = handlerQueue[i];
            event.currentTarget = matched.elem;
            for (let j = 0, k = matched.handlers.length; j < k && !event.isImmediatePropagationStopped(); j += 1) {
                const handleObj = matched.handlers[j];
                // If event is namespaced, then each handler is only invoked if it is
                // specially universal or its namespaces are a superset of the event's.
                if (event.rnamespace == null ||
                    (handleObj.namespace && event.rnamespace.test(handleObj.namespace))) {
                    event.handleObj = handleObj;
                    event.data = handleObj.data;
                    const hookHandle = _hook__WEBPACK_IMPORTED_MODULE_1__.EventHook.get(handleObj.originType).handle;
                    const result = hookHandle
                        ? hookHandle(matched.elem, event, ...args)
                        : handleObj.handler.call(matched.elem, event, ...args);
                    if (result !== undefined) {
                        event.result = result;
                        if (result === false) {
                            event.preventDefault();
                            event.stopPropagation();
                        }
                    }
                }
            }
        }
        // Call the postDispatch hook for the mapped type
        if (hook.postDispatch) {
            hook.postDispatch(elem, event);
        }
        return event.result;
    }
    Core.dispatch = dispatch;
    function trigger(event, eventArgs, elem, onlyHandlers) {
        let eventObj = event;
        let type = typeof event === 'string' ? event : event.type;
        let namespaces = typeof event === 'string' || eventObj.namespace == null
            ? []
            : eventObj.namespace.split('.');
        const node = elem;
        // Don't do events on text and comment nodes
        if (node.nodeType === 3 || node.nodeType === 8) {
            return;
        }
        if (type.indexOf('.') > -1) {
            // Namespaced trigger; create a regexp to match event type in handle()
            namespaces = type.split('.');
            type = namespaces.shift();
            namespaces.sort();
        }
        const ontype = type.indexOf(':') < 0 && `on${type}`;
        // Caller can pass in a EventObject, Object, or just an event type string
        eventObj =
            event instanceof _object__WEBPACK_IMPORTED_MODULE_3__.EventObject
                ? event
                : new _object__WEBPACK_IMPORTED_MODULE_3__.EventObject(type, typeof event === 'object' ? event : null);
        eventObj.namespace = namespaces.join('.');
        eventObj.rnamespace = eventObj.namespace
            ? new RegExp(`(^|\\.)${namespaces.join('\\.(?:.*\\.|)')}(\\.|$)`)
            : null;
        // Clean up the event in case it is being reused
        eventObj.result = undefined;
        if (!eventObj.target) {
            eventObj.target = node;
        }
        const args = [eventObj];
        if (Array.isArray(eventArgs)) {
            args.push(...eventArgs);
        }
        else {
            args.push(eventArgs);
        }
        const hook = _hook__WEBPACK_IMPORTED_MODULE_1__.EventHook.get(type);
        if (!onlyHandlers &&
            hook.trigger &&
            hook.trigger(node, eventObj, eventArgs) === false) {
            return;
        }
        let bubbleType;
        // Determine event propagation path in advance, per W3C events spec.
        // Bubble up to document, then to window; watch for a global ownerDocument
        const eventPath = [node];
        if (!onlyHandlers && !hook.noBubble && !_util__WEBPACK_IMPORTED_MODULE_0__.Util.isWindow(node)) {
            bubbleType = hook.delegateType || type;
            let last = node;
            let curr = node.parentNode;
            while (curr != null) {
                eventPath.push(curr);
                last = curr;
                curr = curr.parentNode;
            }
            // Only add window if we got to document
            const doc = node.ownerDocument || document;
            if (last === doc) {
                const win = last.defaultView || last.parentWindow || window;
                eventPath.push(win);
            }
        }
        let lastElement = node;
        // Fire handlers on the event path
        for (let i = 0, l = eventPath.length; i < l && !eventObj.isPropagationStopped(); i += 1) {
            const currElement = eventPath[i];
            lastElement = currElement;
            eventObj.type = i > 1 ? bubbleType : hook.bindType || type;
            // Custom handler
            const store = _store__WEBPACK_IMPORTED_MODULE_2__.Store.get(currElement);
            if (store) {
                if (store.events[eventObj.type] && store.handler) {
                    store.handler.call(currElement, ...args);
                }
            }
            // Native handler
            const handle = (ontype && currElement[ontype]) || null;
            if (handle && _util__WEBPACK_IMPORTED_MODULE_0__.Util.isValidTarget(currElement)) {
                eventObj.result = handle.call(currElement, ...args);
                if (eventObj.result === false) {
                    eventObj.preventDefault();
                }
            }
        }
        eventObj.type = type;
        // If nobody prevented the default action, do it now
        if (!onlyHandlers && !eventObj.isDefaultPrevented()) {
            const preventDefault = hook.preventDefault;
            if ((preventDefault == null ||
                preventDefault(eventPath.pop(), eventObj, eventArgs) === false) &&
                _util__WEBPACK_IMPORTED_MODULE_0__.Util.isValidTarget(node)) {
                // Call a native DOM method on the target with the same name as the
                // event. Don't do default actions on window.
                if (ontype &&
                    typeof node[type] === 'function' &&
                    !_util__WEBPACK_IMPORTED_MODULE_0__.Util.isWindow(node)) {
                    // Don't re-trigger an onFOO event when we call its FOO() method
                    const tmp = node[ontype];
                    if (tmp) {
                        node[ontype] = null;
                    }
                    // Prevent re-triggering of the same event, since we already bubbled it above
                    triggered = type;
                    if (eventObj.isPropagationStopped()) {
                        lastElement.addEventListener(type, _util__WEBPACK_IMPORTED_MODULE_0__.Util.stopPropagationCallback);
                    }
                    node[type]();
                    if (eventObj.isPropagationStopped()) {
                        lastElement.removeEventListener(type, _util__WEBPACK_IMPORTED_MODULE_0__.Util.stopPropagationCallback);
                    }
                    triggered = undefined;
                    if (tmp) {
                        node[ontype] = tmp;
                    }
                }
            }
        }
        return eventObj.result;
    }
    Core.trigger = trigger;
})(Core || (Core = {}));
//# sourceMappingURL=core.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/dom/event/hook.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/dom/event/hook.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EventHook: () => (/* binding */ EventHook)
/* harmony export */ });
var EventHook;
(function (EventHook) {
    const cache = {};
    function get(type) {
        return cache[type] || {};
    }
    EventHook.get = get;
    function register(type, hook) {
        cache[type] = hook;
    }
    EventHook.register = register;
    function unregister(type) {
        delete cache[type];
    }
    EventHook.unregister = unregister;
})(EventHook || (EventHook = {}));
//# sourceMappingURL=hook.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/dom/event/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/dom/event/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Event: () => (/* reexport safe */ _main__WEBPACK_IMPORTED_MODULE_1__.Event),
/* harmony export */   EventHook: () => (/* reexport safe */ _hook__WEBPACK_IMPORTED_MODULE_0__.EventHook),
/* harmony export */   EventObject: () => (/* reexport safe */ _object__WEBPACK_IMPORTED_MODULE_2__.EventObject)
/* harmony export */ });
/* harmony import */ var _hook__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hook */ "./node_modules/@antv/x6-common/es/dom/event/hook.js");
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./main */ "./node_modules/@antv/x6-common/es/dom/event/main.js");
/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./object */ "./node_modules/@antv/x6-common/es/dom/event/object.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types */ "./node_modules/@antv/x6-common/es/dom/event/types.js");




//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/dom/event/main.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/dom/event/main.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Event: () => (/* binding */ Event)
/* harmony export */ });
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ "./node_modules/@antv/x6-common/es/dom/event/core.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6-common/es/dom/event/util.js");
/* eslint-disable no-param-reassign */


var Event;
(function (Event) {
    function on(elem, events, selector, data, handler) {
        Private.on(elem, events, selector, data, handler);
        return elem;
    }
    Event.on = on;
    function once(elem, events, selector, data, handler) {
        Private.on(elem, events, selector, data, handler, true);
        return elem;
    }
    Event.once = once;
    function off(elem, events, selector, handler) {
        Private.off(elem, events, selector, handler);
        return elem;
    }
    Event.off = off;
    function trigger(elem, event, args, 
    /**
     * When onlyHandlers is `true`
     * - Will not call `.event()` on the element it is triggered on. This means
     *   `.trigger('submit', [], true)` on a form will not call `.submit()` on
     *   the form.
     * - Events will not bubble up the DOM hierarchy; if they are not handled
     *   by the target element directly, they do nothing.
     */
    onlyHandlers) {
        _core__WEBPACK_IMPORTED_MODULE_0__.Core.trigger(event, args, elem, onlyHandlers);
        return elem;
    }
    Event.trigger = trigger;
})(Event || (Event = {}));
var Private;
(function (Private) {
    function on(elem, types, selector, data, fn, once) {
        // Types can be a map of types/handlers
        if (typeof types === 'object') {
            // ( types-Object, selector, data )
            if (typeof selector !== 'string') {
                // ( types-Object, data )
                data = data || selector;
                selector = undefined;
            }
            Object.keys(types).forEach((type) => on(elem, type, selector, data, types[type], once));
            return;
        }
        if (data == null && fn == null) {
            // ( types, fn )
            fn = selector;
            data = selector = undefined;
        }
        else if (fn == null) {
            if (typeof selector === 'string') {
                // ( types, selector, fn )
                fn = data;
                data = undefined;
            }
            else {
                // ( types, data, fn )
                fn = data;
                data = selector;
                selector = undefined;
            }
        }
        if (fn === false) {
            fn = _util__WEBPACK_IMPORTED_MODULE_1__.Util.returnFalse;
        }
        else if (!fn) {
            return;
        }
        if (once) {
            const originHandler = fn;
            fn = function (event, ...args) {
                // Can use an empty set, since event contains the info
                Private.off(elem, event);
                return originHandler.call(this, event, ...args);
            };
            // Use same guid so caller can remove using origFn
            _util__WEBPACK_IMPORTED_MODULE_1__.Util.setHandlerId(fn, _util__WEBPACK_IMPORTED_MODULE_1__.Util.ensureHandlerId(originHandler));
        }
        _core__WEBPACK_IMPORTED_MODULE_0__.Core.on(elem, types, fn, data, selector);
    }
    Private.on = on;
    function off(elem, events, selector, fn) {
        const evt = events;
        if (evt && evt.preventDefault != null && evt.handleObj != null) {
            const obj = evt.handleObj;
            off(evt.delegateTarget, obj.namespace ? `${obj.originType}.${obj.namespace}` : obj.originType, obj.selector, obj.handler);
            return;
        }
        if (typeof events === 'object') {
            // ( types-object [, selector] )
            const types = events;
            Object.keys(types).forEach((type) => off(elem, type, selector, types[type]));
            return;
        }
        if (selector === false || typeof selector === 'function') {
            // ( types [, fn] )
            fn = selector;
            selector = undefined;
        }
        if (fn === false) {
            fn = _util__WEBPACK_IMPORTED_MODULE_1__.Util.returnFalse;
        }
        _core__WEBPACK_IMPORTED_MODULE_0__.Core.off(elem, events, fn, selector);
    }
    Private.off = off;
})(Private || (Private = {}));
//# sourceMappingURL=main.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/dom/event/object.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/dom/event/object.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EventObject: () => (/* binding */ EventObject)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6-common/es/dom/event/util.js");

class EventObject {
    constructor(e, props) {
        this.isDefaultPrevented = _util__WEBPACK_IMPORTED_MODULE_0__.Util.returnFalse;
        this.isPropagationStopped = _util__WEBPACK_IMPORTED_MODULE_0__.Util.returnFalse;
        this.isImmediatePropagationStopped = _util__WEBPACK_IMPORTED_MODULE_0__.Util.returnFalse;
        this.isSimulated = false;
        this.preventDefault = () => {
            const e = this.originalEvent;
            this.isDefaultPrevented = _util__WEBPACK_IMPORTED_MODULE_0__.Util.returnTrue;
            if (e && !this.isSimulated) {
                e.preventDefault();
            }
        };
        this.stopPropagation = () => {
            const e = this.originalEvent;
            this.isPropagationStopped = _util__WEBPACK_IMPORTED_MODULE_0__.Util.returnTrue;
            if (e && !this.isSimulated) {
                e.stopPropagation();
            }
        };
        this.stopImmediatePropagation = () => {
            const e = this.originalEvent;
            this.isImmediatePropagationStopped = _util__WEBPACK_IMPORTED_MODULE_0__.Util.returnTrue;
            if (e && !this.isSimulated) {
                e.stopImmediatePropagation();
            }
            this.stopPropagation();
        };
        if (typeof e === 'string') {
            this.type = e;
        }
        else if (e.type) {
            this.originalEvent = e;
            this.type = e.type;
            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = e.defaultPrevented
                ? _util__WEBPACK_IMPORTED_MODULE_0__.Util.returnTrue
                : _util__WEBPACK_IMPORTED_MODULE_0__.Util.returnFalse;
            // Create target properties
            this.target = e.target;
            this.currentTarget = e.currentTarget;
            this.relatedTarget = e.relatedTarget;
            this.timeStamp = e.timeStamp;
        }
        // Put explicitly provided properties onto the event object
        if (props) {
            Object.assign(this, props);
        }
        // Create a timestamp if incoming event doesn't have one
        if (!this.timeStamp) {
            this.timeStamp = Date.now();
        }
    }
}
(function (EventObject) {
    function create(originalEvent) {
        return originalEvent instanceof EventObject
            ? originalEvent
            : new EventObject(originalEvent);
    }
    EventObject.create = create;
})(EventObject || (EventObject = {}));
(function (EventObject) {
    function addProperty(name, hook) {
        Object.defineProperty(EventObject.prototype, name, {
            enumerable: true,
            configurable: true,
            get: typeof hook === 'function'
                ? // eslint-disable-next-line
                    function () {
                        if (this.originalEvent) {
                            return hook(this.originalEvent);
                        }
                    }
                : // eslint-disable-next-line
                    function () {
                        if (this.originalEvent) {
                            return this.originalEvent[name];
                        }
                    },
            set(value) {
                Object.defineProperty(this, name, {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value,
                });
            },
        });
    }
    EventObject.addProperty = addProperty;
})(EventObject || (EventObject = {}));
(function (EventObject) {
    // Common event props including KeyEvent and MouseEvent specific props.
    const commonProps = {
        bubbles: true,
        cancelable: true,
        eventPhase: true,
        detail: true,
        view: true,
        button: true,
        buttons: true,
        clientX: true,
        clientY: true,
        offsetX: true,
        offsetY: true,
        pageX: true,
        pageY: true,
        screenX: true,
        screenY: true,
        toElement: true,
        pointerId: true,
        pointerType: true,
        char: true,
        code: true,
        charCode: true,
        key: true,
        keyCode: true,
        touches: true,
        changedTouches: true,
        targetTouches: true,
        which: true,
        altKey: true,
        ctrlKey: true,
        metaKey: true,
        shiftKey: true,
    };
    Object.keys(commonProps).forEach((name) => EventObject.addProperty(name, commonProps[name]));
})(EventObject || (EventObject = {}));
//# sourceMappingURL=object.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/dom/event/special.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/dom/event/special.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Special: () => (/* binding */ Special)
/* harmony export */ });
/* harmony import */ var _hook__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hook */ "./node_modules/@antv/x6-common/es/dom/event/hook.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6-common/es/dom/event/util.js");


// Prevent triggered image.load events from bubbling to window.load
var Special;
(function (Special) {
    _hook__WEBPACK_IMPORTED_MODULE_0__.EventHook.register('load', {
        noBubble: true,
    });
})(Special || (Special = {}));
// Support: Chrome <=73+
// Chrome doesn't alert on `event.preventDefault()`
// as the standard mandates.
(function (Special) {
    _hook__WEBPACK_IMPORTED_MODULE_0__.EventHook.register('beforeunload', {
        postDispatch(elem, event) {
            if (event.result !== undefined && event.originalEvent) {
                event.originalEvent.returnValue = event.result;
            }
        },
    });
})(Special || (Special = {}));
// For mouseenter/leave call the handler if related is outside the target.
// NB: No relatedTarget if the mouse left/entered the browser window
(function (Special) {
    _hook__WEBPACK_IMPORTED_MODULE_0__.EventHook.register('mouseenter', {
        delegateType: 'mouseover',
        bindType: 'mouseover',
        handle(target, event) {
            let ret;
            const related = event.relatedTarget;
            const handleObj = event.handleObj;
            if (!related || (related !== target && !_util__WEBPACK_IMPORTED_MODULE_1__.Util.contains(target, related))) {
                event.type = handleObj.originType;
                ret = handleObj.handler.call(target, event);
                event.type = 'mouseover';
            }
            return ret;
        },
    });
    _hook__WEBPACK_IMPORTED_MODULE_0__.EventHook.register('mouseleave', {
        delegateType: 'mouseout',
        bindType: 'mouseout',
        handle(target, event) {
            let ret;
            const related = event.relatedTarget;
            const handleObj = event.handleObj;
            if (!related || (related !== target && !_util__WEBPACK_IMPORTED_MODULE_1__.Util.contains(target, related))) {
                event.type = handleObj.originType;
                ret = handleObj.handler.call(target, event);
                event.type = 'mouseout';
            }
            return ret;
        },
    });
})(Special || (Special = {}));
//# sourceMappingURL=special.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/dom/event/store.js":
/*!************************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/dom/event/store.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Store: () => (/* binding */ Store)
/* harmony export */ });
var Store;
(function (Store) {
    const cache = new WeakMap();
    function ensure(target) {
        if (!cache.has(target)) {
            cache.set(target, { events: Object.create(null) });
        }
        return cache.get(target);
    }
    Store.ensure = ensure;
    function get(target) {
        return cache.get(target);
    }
    Store.get = get;
    function remove(target) {
        return cache.delete(target);
    }
    Store.remove = remove;
})(Store || (Store = {}));
//# sourceMappingURL=store.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/dom/event/types.js":
/*!************************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/dom/event/types.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/dom/event/util.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/dom/event/util.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Util: () => (/* binding */ Util)
/* harmony export */ });
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./store */ "./node_modules/@antv/x6-common/es/dom/event/store.js");

var Util;
(function (Util) {
    Util.returnTrue = () => true;
    Util.returnFalse = () => false;
    function stopPropagationCallback(e) {
        e.stopPropagation();
    }
    Util.stopPropagationCallback = stopPropagationCallback;
    function addEventListener(elem, type, handler) {
        if (elem.addEventListener != null) {
            elem.addEventListener(type, handler);
        }
    }
    Util.addEventListener = addEventListener;
    function removeEventListener(elem, type, handler) {
        if (elem.removeEventListener != null) {
            elem.removeEventListener(type, handler);
        }
    }
    Util.removeEventListener = removeEventListener;
})(Util || (Util = {}));
(function (Util) {
    const rNotHTMLWhite = /[^\x20\t\r\n\f]+/g;
    const rNamespace = /^([^.]*)(?:\.(.+)|)/;
    function splitType(types) {
        return (types || '').match(rNotHTMLWhite) || [''];
    }
    Util.splitType = splitType;
    function normalizeType(type) {
        const parts = rNamespace.exec(type) || [];
        return {
            originType: parts[1] ? parts[1].trim() : parts[1],
            namespaces: parts[2]
                ? parts[2]
                    .split('.')
                    .map((ns) => ns.trim())
                    .sort()
                : [],
        };
    }
    Util.normalizeType = normalizeType;
    function isValidTarget(target) {
        // Accepts only:
        //  - Node
        //    - Node.ELEMENT_NODE
        //    - Node.DOCUMENT_NODE
        //  - Object
        //    - Any
        return target.nodeType === 1 || target.nodeType === 9 || !+target.nodeType;
    }
    Util.isValidTarget = isValidTarget;
    function isValidSelector(elem, selector) {
        if (selector) {
            const node = elem;
            return node.querySelector != null && node.querySelector(selector) != null;
        }
        return true;
    }
    Util.isValidSelector = isValidSelector;
})(Util || (Util = {}));
(function (Util) {
    let seed = 0;
    const cache = new WeakMap();
    function ensureHandlerId(handler) {
        if (!cache.has(handler)) {
            cache.set(handler, seed);
            seed += 1;
        }
        return cache.get(handler);
    }
    Util.ensureHandlerId = ensureHandlerId;
    function getHandlerId(handler) {
        return cache.get(handler);
    }
    Util.getHandlerId = getHandlerId;
    function removeHandlerId(handler) {
        return cache.delete(handler);
    }
    Util.removeHandlerId = removeHandlerId;
    function setHandlerId(handler, id) {
        return cache.set(handler, id);
    }
    Util.setHandlerId = setHandlerId;
})(Util || (Util = {}));
(function (Util) {
    function getHandlerQueue(elem, event) {
        const queue = [];
        const store = _store__WEBPACK_IMPORTED_MODULE_0__.Store.get(elem);
        const bag = store && store.events && store.events[event.type];
        const handlers = (bag && bag.handlers) || [];
        const delegateCount = bag ? bag.delegateCount : 0;
        if (delegateCount > 0 &&
            // Support: Firefox <=42 - 66+
            // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
            // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
            // Support: IE 11+
            // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
            !(event.type === 'click' &&
                typeof event.button === 'number' &&
                event.button >= 1)) {
            for (let curr = event.target; curr !== elem; curr = curr.parentNode || elem) {
                // Don't check non-elements
                // Don't process clicks on disabled elements
                if (curr.nodeType === 1 &&
                    !(event.type === 'click' && curr.disabled === true)) {
                    const matchedHandlers = [];
                    const matchedSelectors = {};
                    for (let i = 0; i < delegateCount; i += 1) {
                        const handleObj = handlers[i];
                        const selector = handleObj.selector;
                        if (selector != null && matchedSelectors[selector] == null) {
                            const node = elem;
                            const nodes = [];
                            node.querySelectorAll(selector).forEach((child) => {
                                nodes.push(child);
                            });
                            matchedSelectors[selector] = nodes.includes(curr);
                        }
                        if (matchedSelectors[selector]) {
                            matchedHandlers.push(handleObj);
                        }
                    }
                    if (matchedHandlers.length) {
                        queue.push({ elem: curr, handlers: matchedHandlers });
                    }
                }
            }
        }
        // Add the remaining (directly-bound) handlers
        if (delegateCount < handlers.length) {
            queue.push({ elem, handlers: handlers.slice(delegateCount) });
        }
        return queue;
    }
    Util.getHandlerQueue = getHandlerQueue;
})(Util || (Util = {}));
(function (Util) {
    function isWindow(obj) {
        return obj != null && obj === obj.window;
    }
    Util.isWindow = isWindow;
})(Util || (Util = {}));
(function (Util) {
    function contains(a, b) {
        const adown = a.nodeType === 9 ? a.documentElement : a;
        const bup = b && b.parentNode;
        return (a === bup ||
            !!(bup &&
                bup.nodeType === 1 &&
                // Support: IE 9 - 11+
                // IE doesn't have `contains` on SVG.
                (adown.contains
                    ? adown.contains(bup)
                    : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16)));
    }
    Util.contains = contains;
})(Util || (Util = {}));
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/dom/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/dom/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Dom: () => (/* reexport module object */ _main__WEBPACK_IMPORTED_MODULE_0__)
/* harmony export */ });
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main */ "./node_modules/@antv/x6-common/es/dom/main.js");


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/dom/main.js":
/*!*****************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/dom/main.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CASE_SENSITIVE_ATTR: () => (/* reexport safe */ _attr__WEBPACK_IMPORTED_MODULE_0__.CASE_SENSITIVE_ATTR),
/* harmony export */   Event: () => (/* reexport safe */ _event__WEBPACK_IMPORTED_MODULE_13__.Event),
/* harmony export */   EventHook: () => (/* reexport safe */ _event__WEBPACK_IMPORTED_MODULE_13__.EventHook),
/* harmony export */   EventObject: () => (/* reexport safe */ _event__WEBPACK_IMPORTED_MODULE_13__.EventObject),
/* harmony export */   KAPPA: () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_10__.KAPPA),
/* harmony export */   MouseWheelHandle: () => (/* reexport safe */ _mousewheel__WEBPACK_IMPORTED_MODULE_14__.MouseWheelHandle),
/* harmony export */   addClass: () => (/* reexport safe */ _class__WEBPACK_IMPORTED_MODULE_2__.addClass),
/* harmony export */   after: () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_1__.after),
/* harmony export */   append: () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_1__.append),
/* harmony export */   appendTo: () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_1__.appendTo),
/* harmony export */   attr: () => (/* reexport safe */ _attr__WEBPACK_IMPORTED_MODULE_0__.attr),
/* harmony export */   before: () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_1__.before),
/* harmony export */   breakText: () => (/* reexport safe */ _text__WEBPACK_IMPORTED_MODULE_9__.breakText),
/* harmony export */   children: () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_1__.children),
/* harmony export */   circleToPathData: () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_10__.circleToPathData),
/* harmony export */   clearSelection: () => (/* reexport safe */ _selection__WEBPACK_IMPORTED_MODULE_5__.clearSelection),
/* harmony export */   computeStyle: () => (/* reexport safe */ _css__WEBPACK_IMPORTED_MODULE_6__.computeStyle),
/* harmony export */   computeStyleInt: () => (/* reexport safe */ _css__WEBPACK_IMPORTED_MODULE_6__.computeStyleInt),
/* harmony export */   contains: () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_1__.contains),
/* harmony export */   createElement: () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_1__.createElement),
/* harmony export */   createElementNS: () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_1__.createElementNS),
/* harmony export */   createSVGMatrix: () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_11__.createSVGMatrix),
/* harmony export */   createSVGPoint: () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_11__.createSVGPoint),
/* harmony export */   createSVGTransform: () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_11__.createSVGTransform),
/* harmony export */   createSlicePathData: () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_10__.createSlicePathData),
/* harmony export */   createSvgDocument: () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_1__.createSvgDocument),
/* harmony export */   createSvgElement: () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_1__.createSvgElement),
/* harmony export */   css: () => (/* reexport safe */ _css__WEBPACK_IMPORTED_MODULE_6__.css),
/* harmony export */   data: () => (/* reexport safe */ _data__WEBPACK_IMPORTED_MODULE_7__.data),
/* harmony export */   decomposeMatrix: () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_11__.decomposeMatrix),
/* harmony export */   ellipseToPathData: () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_10__.ellipseToPathData),
/* harmony export */   empty: () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_1__.empty),
/* harmony export */   ensureId: () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_1__.ensureId),
/* harmony export */   find: () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_1__.find),
/* harmony export */   findOne: () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_1__.findOne),
/* harmony export */   findParentByClass: () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_1__.findParentByClass),
/* harmony export */   getAttribute: () => (/* reexport safe */ _attr__WEBPACK_IMPORTED_MODULE_0__.getAttribute),
/* harmony export */   getClass: () => (/* reexport safe */ _class__WEBPACK_IMPORTED_MODULE_2__.getClass),
/* harmony export */   getComputedStyle: () => (/* reexport safe */ _style__WEBPACK_IMPORTED_MODULE_3__.getComputedStyle),
/* harmony export */   getData: () => (/* reexport safe */ _data__WEBPACK_IMPORTED_MODULE_7__.getData),
/* harmony export */   getPointsFromSvgElement: () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_10__.getPointsFromSvgElement),
/* harmony export */   getTransformToElement: () => (/* reexport safe */ _transform__WEBPACK_IMPORTED_MODULE_12__.getTransformToElement),
/* harmony export */   getTransformToParentElement: () => (/* reexport safe */ _transform__WEBPACK_IMPORTED_MODULE_12__.getTransformToParentElement),
/* harmony export */   getVendorPrefixedName: () => (/* reexport safe */ _prefix__WEBPACK_IMPORTED_MODULE_4__.getVendorPrefixedName),
/* harmony export */   hasClass: () => (/* reexport safe */ _class__WEBPACK_IMPORTED_MODULE_2__.hasClass),
/* harmony export */   hasScrollbars: () => (/* reexport safe */ _style__WEBPACK_IMPORTED_MODULE_3__.hasScrollbars),
/* harmony export */   height: () => (/* reexport safe */ _position__WEBPACK_IMPORTED_MODULE_15__.height),
/* harmony export */   index: () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_1__.index),
/* harmony export */   isCSSVariable: () => (/* reexport safe */ _css__WEBPACK_IMPORTED_MODULE_6__.isCSSVariable),
/* harmony export */   isElement: () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_1__.isElement),
/* harmony export */   isHTMLElement: () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement),
/* harmony export */   isSVGGraphicsElement: () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_1__.isSVGGraphicsElement),
/* harmony export */   kebablizeAttrs: () => (/* reexport safe */ _attr__WEBPACK_IMPORTED_MODULE_0__.kebablizeAttrs),
/* harmony export */   lineToPathData: () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_10__.lineToPathData),
/* harmony export */   matrixToRotation: () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_11__.matrixToRotation),
/* harmony export */   matrixToScale: () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_11__.matrixToScale),
/* harmony export */   matrixToTransformString: () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_11__.matrixToTransformString),
/* harmony export */   matrixToTranslation: () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_11__.matrixToTranslation),
/* harmony export */   measureText: () => (/* reexport safe */ _text__WEBPACK_IMPORTED_MODULE_9__.measureText),
/* harmony export */   mergeAttrs: () => (/* reexport safe */ _attr__WEBPACK_IMPORTED_MODULE_0__.mergeAttrs),
/* harmony export */   ns: () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_1__.ns),
/* harmony export */   offset: () => (/* reexport safe */ _position__WEBPACK_IMPORTED_MODULE_15__.offset),
/* harmony export */   parseTransformString: () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_11__.parseTransformString),
/* harmony export */   parseXML: () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_1__.parseXML),
/* harmony export */   polygonToPathData: () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_10__.polygonToPathData),
/* harmony export */   polylineToPathData: () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_10__.polylineToPathData),
/* harmony export */   position: () => (/* reexport safe */ _position__WEBPACK_IMPORTED_MODULE_15__.position),
/* harmony export */   prepend: () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_1__.prepend),
/* harmony export */   prop: () => (/* reexport safe */ _prop__WEBPACK_IMPORTED_MODULE_8__.prop),
/* harmony export */   qualifyAttr: () => (/* reexport safe */ _attr__WEBPACK_IMPORTED_MODULE_0__.qualifyAttr),
/* harmony export */   rectToPathData: () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_10__.rectToPathData),
/* harmony export */   rectangleToPathData: () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_10__.rectangleToPathData),
/* harmony export */   remove: () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_1__.remove),
/* harmony export */   removeAttribute: () => (/* reexport safe */ _attr__WEBPACK_IMPORTED_MODULE_0__.removeAttribute),
/* harmony export */   removeClass: () => (/* reexport safe */ _class__WEBPACK_IMPORTED_MODULE_2__.removeClass),
/* harmony export */   rotate: () => (/* reexport safe */ _transform__WEBPACK_IMPORTED_MODULE_12__.rotate),
/* harmony export */   sample: () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_10__.sample),
/* harmony export */   scale: () => (/* reexport safe */ _transform__WEBPACK_IMPORTED_MODULE_12__.scale),
/* harmony export */   setAttribute: () => (/* reexport safe */ _attr__WEBPACK_IMPORTED_MODULE_0__.setAttribute),
/* harmony export */   setAttributes: () => (/* reexport safe */ _attr__WEBPACK_IMPORTED_MODULE_0__.setAttributes),
/* harmony export */   setData: () => (/* reexport safe */ _data__WEBPACK_IMPORTED_MODULE_7__.setData),
/* harmony export */   setPrefixedStyle: () => (/* reexport safe */ _style__WEBPACK_IMPORTED_MODULE_3__.setPrefixedStyle),
/* harmony export */   splitTextByLength: () => (/* reexport safe */ _text__WEBPACK_IMPORTED_MODULE_9__.splitTextByLength),
/* harmony export */   styleToObject: () => (/* reexport safe */ _attr__WEBPACK_IMPORTED_MODULE_0__.styleToObject),
/* harmony export */   svgVersion: () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_1__.svgVersion),
/* harmony export */   tagName: () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_1__.tagName),
/* harmony export */   text: () => (/* reexport safe */ _text__WEBPACK_IMPORTED_MODULE_9__.text),
/* harmony export */   toLocalPoint: () => (/* reexport safe */ _transform__WEBPACK_IMPORTED_MODULE_12__.toLocalPoint),
/* harmony export */   toPath: () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_10__.toPath),
/* harmony export */   toPathData: () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_10__.toPathData),
/* harmony export */   toggleClass: () => (/* reexport safe */ _class__WEBPACK_IMPORTED_MODULE_2__.toggleClass),
/* harmony export */   transform: () => (/* reexport safe */ _transform__WEBPACK_IMPORTED_MODULE_12__.transform),
/* harmony export */   transformStringToMatrix: () => (/* reexport safe */ _matrix__WEBPACK_IMPORTED_MODULE_11__.transformStringToMatrix),
/* harmony export */   translate: () => (/* reexport safe */ _transform__WEBPACK_IMPORTED_MODULE_12__.translate),
/* harmony export */   uniqueId: () => (/* reexport safe */ _elem__WEBPACK_IMPORTED_MODULE_1__.uniqueId),
/* harmony export */   width: () => (/* reexport safe */ _position__WEBPACK_IMPORTED_MODULE_15__.width)
/* harmony export */ });
/* harmony import */ var _attr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./attr */ "./node_modules/@antv/x6-common/es/dom/attr.js");
/* harmony import */ var _elem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./elem */ "./node_modules/@antv/x6-common/es/dom/elem.js");
/* harmony import */ var _class__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./class */ "./node_modules/@antv/x6-common/es/dom/class.js");
/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./style */ "./node_modules/@antv/x6-common/es/dom/style.js");
/* harmony import */ var _prefix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./prefix */ "./node_modules/@antv/x6-common/es/dom/prefix.js");
/* harmony import */ var _selection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./selection */ "./node_modules/@antv/x6-common/es/dom/selection.js");
/* harmony import */ var _css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./css */ "./node_modules/@antv/x6-common/es/dom/css.js");
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./data */ "./node_modules/@antv/x6-common/es/dom/data.js");
/* harmony import */ var _prop__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./prop */ "./node_modules/@antv/x6-common/es/dom/prop.js");
/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./text */ "./node_modules/@antv/x6-common/es/dom/text.js");
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./path */ "./node_modules/@antv/x6-common/es/dom/path.js");
/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./matrix */ "./node_modules/@antv/x6-common/es/dom/matrix.js");
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./transform */ "./node_modules/@antv/x6-common/es/dom/transform.js");
/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./event */ "./node_modules/@antv/x6-common/es/dom/event/index.js");
/* harmony import */ var _mousewheel__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./mousewheel */ "./node_modules/@antv/x6-common/es/dom/mousewheel.js");
/* harmony import */ var _position__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./position */ "./node_modules/@antv/x6-common/es/dom/position.js");









// svg
// ---




// event


// postion

//# sourceMappingURL=main.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/dom/matrix.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/dom/matrix.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createSVGMatrix: () => (/* binding */ createSVGMatrix),
/* harmony export */   createSVGPoint: () => (/* binding */ createSVGPoint),
/* harmony export */   createSVGTransform: () => (/* binding */ createSVGTransform),
/* harmony export */   decomposeMatrix: () => (/* binding */ decomposeMatrix),
/* harmony export */   matrixToRotation: () => (/* binding */ matrixToRotation),
/* harmony export */   matrixToScale: () => (/* binding */ matrixToScale),
/* harmony export */   matrixToTransformString: () => (/* binding */ matrixToTransformString),
/* harmony export */   matrixToTranslation: () => (/* binding */ matrixToTranslation),
/* harmony export */   parseTransformString: () => (/* binding */ parseTransformString),
/* harmony export */   transformStringToMatrix: () => (/* binding */ transformStringToMatrix)
/* harmony export */ });
/* harmony import */ var _elem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./elem */ "./node_modules/@antv/x6-common/es/dom/elem.js");

const transformRegex = /(\w+)\(([^,)]+),?([^)]+)?\)/gi;
const transformSeparatorRegex = /[ ,]+/;
const transformationListRegex = /^(\w+)\((.*)\)/;
/**
 * Returns a SVG point object initialized with the `x` and `y` coordinates.
 * @see https://developer.mozilla.org/en/docs/Web/API/SVGPoint
 */
function createSVGPoint(x, y) {
    const svgDocument = (0,_elem__WEBPACK_IMPORTED_MODULE_0__.createSvgElement)('svg');
    const p = svgDocument.createSVGPoint();
    p.x = x;
    p.y = y;
    return p;
}
/**
 * Returns the SVG transformation matrix initialized with the given matrix.
 *
 * The given matrix is an object of the form:
 * {
 *   a: number
 *   b: number
 *   c: number
 *   d: number
 *   e: number
 *   f: number
 * }
 *
 * @see https://developer.mozilla.org/en/docs/Web/API/SVGMatrix
 */
function createSVGMatrix(matrix) {
    const svgDocument = (0,_elem__WEBPACK_IMPORTED_MODULE_0__.createSvgElement)('svg');
    const mat = svgDocument.createSVGMatrix();
    if (matrix != null) {
        const source = matrix;
        const target = mat;
        // eslint-disable-next-line
        for (const key in source) {
            target[key] = source[key];
        }
    }
    return mat;
}
/**
 * Returns a SVG transform object.
 * @see https://developer.mozilla.org/en/docs/Web/API/SVGTransform
 */
function createSVGTransform(matrix) {
    const svgDocument = (0,_elem__WEBPACK_IMPORTED_MODULE_0__.createSvgElement)('svg');
    if (matrix != null) {
        if (!(matrix instanceof DOMMatrix)) {
            matrix = createSVGMatrix(matrix); // eslint-disable-line
        }
        return svgDocument.createSVGTransformFromMatrix(matrix);
    }
    return svgDocument.createSVGTransform();
}
/**
 * Returns the SVG transformation matrix built from the `transformString`.
 *
 * E.g. 'translate(10,10) scale(2,2)' will result in matrix:
 * `{ a: 2, b: 0, c: 0, d: 2, e: 10, f: 10}`
 */
function transformStringToMatrix(transform) {
    let mat = createSVGMatrix();
    const matches = transform != null && transform.match(transformRegex);
    if (!matches) {
        return mat;
    }
    for (let i = 0, n = matches.length; i < n; i += 1) {
        const transformationString = matches[i];
        const transformationMatch = transformationString.match(transformationListRegex);
        if (transformationMatch) {
            let sx;
            let sy;
            let tx;
            let ty;
            let angle;
            let ctm = createSVGMatrix();
            const args = transformationMatch[2].split(transformSeparatorRegex);
            switch (transformationMatch[1].toLowerCase()) {
                case 'scale':
                    sx = parseFloat(args[0]);
                    sy = args[1] === undefined ? sx : parseFloat(args[1]);
                    ctm = ctm.scaleNonUniform(sx, sy);
                    break;
                case 'translate':
                    tx = parseFloat(args[0]);
                    ty = parseFloat(args[1]);
                    ctm = ctm.translate(tx, ty);
                    break;
                case 'rotate':
                    angle = parseFloat(args[0]);
                    tx = parseFloat(args[1]) || 0;
                    ty = parseFloat(args[2]) || 0;
                    if (tx !== 0 || ty !== 0) {
                        ctm = ctm.translate(tx, ty).rotate(angle).translate(-tx, -ty);
                    }
                    else {
                        ctm = ctm.rotate(angle);
                    }
                    break;
                case 'skewx':
                    angle = parseFloat(args[0]);
                    ctm = ctm.skewX(angle);
                    break;
                case 'skewy':
                    angle = parseFloat(args[0]);
                    ctm = ctm.skewY(angle);
                    break;
                case 'matrix':
                    ctm.a = parseFloat(args[0]);
                    ctm.b = parseFloat(args[1]);
                    ctm.c = parseFloat(args[2]);
                    ctm.d = parseFloat(args[3]);
                    ctm.e = parseFloat(args[4]);
                    ctm.f = parseFloat(args[5]);
                    break;
                default:
                    continue;
            }
            mat = mat.multiply(ctm);
        }
    }
    return mat;
}
function matrixToTransformString(matrix) {
    const m = matrix || {};
    const a = m.a != null ? m.a : 1;
    const b = m.b != null ? m.b : 0;
    const c = m.c != null ? m.c : 0;
    const d = m.d != null ? m.d : 1;
    const e = m.e != null ? m.e : 0;
    const f = m.f != null ? m.f : 0;
    return `matrix(${a},${b},${c},${d},${e},${f})`;
}
function parseTransformString(transform) {
    let translation;
    let rotation;
    let scale;
    if (transform) {
        const separator = transformSeparatorRegex;
        // Allow reading transform string with a single matrix
        if (transform.trim().indexOf('matrix') >= 0) {
            const matrix = transformStringToMatrix(transform);
            const decomposedMatrix = decomposeMatrix(matrix);
            translation = [decomposedMatrix.translateX, decomposedMatrix.translateY];
            rotation = [decomposedMatrix.rotation];
            scale = [decomposedMatrix.scaleX, decomposedMatrix.scaleY];
            const transformations = [];
            if (translation[0] !== 0 || translation[1] !== 0) {
                transformations.push(`translate(${translation.join(',')})`);
            }
            if (scale[0] !== 1 || scale[1] !== 1) {
                transformations.push(`scale(${scale.join(',')})`);
            }
            if (rotation[0] !== 0) {
                transformations.push(`rotate(${rotation[0]})`);
            }
            transform = transformations.join(' '); // eslint-disable-line
        }
        else {
            const translateMatch = transform.match(/translate\((.*?)\)/);
            if (translateMatch) {
                translation = translateMatch[1].split(separator);
            }
            const rotateMatch = transform.match(/rotate\((.*?)\)/);
            if (rotateMatch) {
                rotation = rotateMatch[1].split(separator);
            }
            const scaleMatch = transform.match(/scale\((.*?)\)/);
            if (scaleMatch) {
                scale = scaleMatch[1].split(separator);
            }
        }
    }
    const sx = scale && scale[0] ? parseFloat(scale[0]) : 1;
    return {
        raw: transform || '',
        translation: {
            tx: translation && translation[0]
                ? parseInt(translation[0], 10)
                : 0,
            ty: translation && translation[1]
                ? parseInt(translation[1], 10)
                : 0,
        },
        rotation: {
            angle: rotation && rotation[0] ? parseInt(rotation[0], 10) : 0,
            cx: rotation && rotation[1]
                ? parseInt(rotation[1], 10)
                : undefined,
            cy: rotation && rotation[2]
                ? parseInt(rotation[2], 10)
                : undefined,
        },
        scale: {
            sx,
            sy: scale && scale[1] ? parseFloat(scale[1]) : sx,
        },
    };
}
function deltaTransformPoint(matrix, point) {
    const dx = point.x * matrix.a + point.y * matrix.c + 0;
    const dy = point.x * matrix.b + point.y * matrix.d + 0;
    return { x: dx, y: dy };
}
/**
 * Decomposes the SVG transformation matrix into separate transformations.
 *
 * Returns an object of the form:
 * {
 *   translateX: number
 *   translateY: number
 *   scaleX: number
 *   scaleY: number
 *   skewX: number
 *   skewY: number
 *   rotation: number
 * }
 *
 * @see https://developer.mozilla.org/en/docs/Web/API/SVGMatrix
 */
function decomposeMatrix(matrix) {
    // @see https://gist.github.com/2052247
    const px = deltaTransformPoint(matrix, { x: 0, y: 1 });
    const py = deltaTransformPoint(matrix, { x: 1, y: 0 });
    const skewX = (180 / Math.PI) * Math.atan2(px.y, px.x) - 90;
    const skewY = (180 / Math.PI) * Math.atan2(py.y, py.x);
    return {
        skewX,
        skewY,
        translateX: matrix.e,
        translateY: matrix.f,
        scaleX: Math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b),
        scaleY: Math.sqrt(matrix.c * matrix.c + matrix.d * matrix.d),
        rotation: skewX,
    };
}
function matrixToScale(matrix) {
    let a;
    let b;
    let c;
    let d;
    if (matrix) {
        a = matrix.a == null ? 1 : matrix.a;
        d = matrix.d == null ? 1 : matrix.d;
        b = matrix.b;
        c = matrix.c;
    }
    else {
        a = d = 1;
    }
    return {
        sx: b ? Math.sqrt(a * a + b * b) : a,
        sy: c ? Math.sqrt(c * c + d * d) : d,
    };
}
function matrixToRotation(matrix) {
    let p = { x: 0, y: 1 };
    if (matrix) {
        p = deltaTransformPoint(matrix, p);
    }
    const deg = (((180 * Math.atan2(p.y, p.x)) / Math.PI) % 360) - 90;
    const angle = (deg % 360) + (deg < 0 ? 360 : 0);
    return {
        angle,
    };
}
function matrixToTranslation(matrix) {
    return {
        tx: (matrix && matrix.e) || 0,
        ty: (matrix && matrix.f) || 0,
    };
}
//# sourceMappingURL=matrix.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/dom/mousewheel.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/dom/mousewheel.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MouseWheelHandle: () => (/* binding */ MouseWheelHandle)
/* harmony export */ });
/* harmony import */ var _platform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform */ "./node_modules/@antv/x6-common/es/platform/index.js");

class MouseWheelHandle {
    constructor(target, onWheelCallback, onWheelGuard) {
        this.animationFrameId = 0;
        this.deltaX = 0;
        this.deltaY = 0;
        this.eventName = _platform__WEBPACK_IMPORTED_MODULE_0__.Platform.isEventSupported('wheel')
            ? 'wheel'
            : 'mousewheel';
        this.target = target;
        this.onWheelCallback = onWheelCallback;
        this.onWheelGuard = onWheelGuard;
        this.onWheel = this.onWheel.bind(this);
        this.didWheel = this.didWheel.bind(this);
    }
    enable() {
        this.target.addEventListener(this.eventName, this.onWheel, {
            passive: false,
        });
    }
    disable() {
        this.target.removeEventListener(this.eventName, this.onWheel);
    }
    onWheel(e) {
        if (this.onWheelGuard != null && !this.onWheelGuard(e)) {
            return;
        }
        this.deltaX += e.deltaX;
        this.deltaY += e.deltaY;
        e.preventDefault();
        let changed;
        if (this.deltaX !== 0 || this.deltaY !== 0) {
            e.stopPropagation();
            changed = true;
        }
        if (changed === true && this.animationFrameId === 0) {
            this.animationFrameId = requestAnimationFrame(() => {
                this.didWheel(e);
            });
        }
    }
    didWheel(e) {
        this.animationFrameId = 0;
        this.onWheelCallback(e, this.deltaX, this.deltaY);
        this.deltaX = 0;
        this.deltaY = 0;
    }
}
//# sourceMappingURL=mousewheel.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/dom/path.js":
/*!*****************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/dom/path.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KAPPA: () => (/* binding */ KAPPA),
/* harmony export */   circleToPathData: () => (/* binding */ circleToPathData),
/* harmony export */   createSlicePathData: () => (/* binding */ createSlicePathData),
/* harmony export */   ellipseToPathData: () => (/* binding */ ellipseToPathData),
/* harmony export */   getPointsFromSvgElement: () => (/* binding */ getPointsFromSvgElement),
/* harmony export */   lineToPathData: () => (/* binding */ lineToPathData),
/* harmony export */   polygonToPathData: () => (/* binding */ polygonToPathData),
/* harmony export */   polylineToPathData: () => (/* binding */ polylineToPathData),
/* harmony export */   rectToPathData: () => (/* binding */ rectToPathData),
/* harmony export */   rectangleToPathData: () => (/* binding */ rectangleToPathData),
/* harmony export */   sample: () => (/* binding */ sample),
/* harmony export */   toPath: () => (/* binding */ toPath),
/* harmony export */   toPathData: () => (/* binding */ toPathData)
/* harmony export */ });
/* harmony import */ var _attr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./attr */ "./node_modules/@antv/x6-common/es/dom/attr.js");
/* harmony import */ var _elem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./elem */ "./node_modules/@antv/x6-common/es/dom/elem.js");


const KAPPA = 0.551784;
function getNumbericAttribute(elem, attr, defaultValue = NaN) {
    const v = elem.getAttribute(attr);
    if (v == null) {
        return defaultValue;
    }
    const n = parseFloat(v);
    return Number.isNaN(n) ? defaultValue : n;
}
function sample(elem, interval = 1) {
    const length = elem.getTotalLength();
    const samples = [];
    let distance = 0;
    let sample;
    while (distance < length) {
        sample = elem.getPointAtLength(distance);
        samples.push({ distance, x: sample.x, y: sample.y });
        distance += interval;
    }
    return samples;
}
function lineToPathData(line) {
    return [
        'M',
        getNumbericAttribute(line, 'x1'),
        getNumbericAttribute(line, 'y1'),
        'L',
        getNumbericAttribute(line, 'x2'),
        getNumbericAttribute(line, 'y2'),
    ].join(' ');
}
function polygonToPathData(polygon) {
    const points = getPointsFromSvgElement(polygon);
    if (points.length === 0) {
        return null;
    }
    return `${svgPointsToPath(points)} Z`;
}
function polylineToPathData(polyline) {
    const points = getPointsFromSvgElement(polyline);
    if (points.length === 0) {
        return null;
    }
    return svgPointsToPath(points);
}
function svgPointsToPath(points) {
    const arr = points.map((p) => `${p.x} ${p.y}`);
    return `M ${arr.join(' L')}`;
}
function getPointsFromSvgElement(elem) {
    const points = [];
    const nodePoints = elem.points;
    if (nodePoints) {
        for (let i = 0, ii = nodePoints.numberOfItems; i < ii; i += 1) {
            points.push(nodePoints.getItem(i));
        }
    }
    return points;
}
function circleToPathData(circle) {
    const cx = getNumbericAttribute(circle, 'cx', 0);
    const cy = getNumbericAttribute(circle, 'cy', 0);
    const r = getNumbericAttribute(circle, 'r');
    const cd = r * KAPPA; // Control distance.
    return [
        'M',
        cx,
        cy - r,
        'C',
        cx + cd,
        cy - r,
        cx + r,
        cy - cd,
        cx + r,
        cy,
        'C',
        cx + r,
        cy + cd,
        cx + cd,
        cy + r,
        cx,
        cy + r,
        'C',
        cx - cd,
        cy + r,
        cx - r,
        cy + cd,
        cx - r,
        cy,
        'C',
        cx - r,
        cy - cd,
        cx - cd,
        cy - r,
        cx,
        cy - r,
        'Z',
    ].join(' ');
}
function ellipseToPathData(ellipse) {
    const cx = getNumbericAttribute(ellipse, 'cx', 0);
    const cy = getNumbericAttribute(ellipse, 'cy', 0);
    const rx = getNumbericAttribute(ellipse, 'rx');
    const ry = getNumbericAttribute(ellipse, 'ry') || rx;
    const cdx = rx * KAPPA; // Control distance x.
    const cdy = ry * KAPPA; // Control distance y.
    const d = [
        'M',
        cx,
        cy - ry,
        'C',
        cx + cdx,
        cy - ry,
        cx + rx,
        cy - cdy,
        cx + rx,
        cy,
        'C',
        cx + rx,
        cy + cdy,
        cx + cdx,
        cy + ry,
        cx,
        cy + ry,
        'C',
        cx - cdx,
        cy + ry,
        cx - rx,
        cy + cdy,
        cx - rx,
        cy,
        'C',
        cx - rx,
        cy - cdy,
        cx - cdx,
        cy - ry,
        cx,
        cy - ry,
        'Z',
    ].join(' ');
    return d;
}
function rectangleToPathData(rect) {
    return rectToPathData({
        x: getNumbericAttribute(rect, 'x', 0),
        y: getNumbericAttribute(rect, 'y', 0),
        width: getNumbericAttribute(rect, 'width', 0),
        height: getNumbericAttribute(rect, 'height', 0),
        rx: getNumbericAttribute(rect, 'rx', 0),
        ry: getNumbericAttribute(rect, 'ry', 0),
    });
}
function rectToPathData(r) {
    let d;
    const x = r.x;
    const y = r.y;
    const width = r.width;
    const height = r.height;
    const topRx = Math.min(r.rx || r['top-rx'] || 0, width / 2);
    const bottomRx = Math.min(r.rx || r['bottom-rx'] || 0, width / 2);
    const topRy = Math.min(r.ry || r['top-ry'] || 0, height / 2);
    const bottomRy = Math.min(r.ry || r['bottom-ry'] || 0, height / 2);
    if (topRx || bottomRx || topRy || bottomRy) {
        d = [
            'M',
            x,
            y + topRy,
            'v',
            height - topRy - bottomRy,
            'a',
            bottomRx,
            bottomRy,
            0,
            0,
            0,
            bottomRx,
            bottomRy,
            'h',
            width - 2 * bottomRx,
            'a',
            bottomRx,
            bottomRy,
            0,
            0,
            0,
            bottomRx,
            -bottomRy,
            'v',
            -(height - bottomRy - topRy),
            'a',
            topRx,
            topRy,
            0,
            0,
            0,
            -topRx,
            -topRy,
            'h',
            -(width - 2 * topRx),
            'a',
            topRx,
            topRy,
            0,
            0,
            0,
            -topRx,
            topRy,
            'Z',
        ];
    }
    else {
        d = ['M', x, y, 'H', x + width, 'V', y + height, 'H', x, 'V', y, 'Z'];
    }
    return d.join(' ');
}
function toPath(elem) {
    const path = (0,_elem__WEBPACK_IMPORTED_MODULE_1__.createSvgElement)('path');
    (0,_attr__WEBPACK_IMPORTED_MODULE_0__.attr)(path, (0,_attr__WEBPACK_IMPORTED_MODULE_0__.attr)(elem));
    const d = toPathData(elem);
    if (d) {
        path.setAttribute('d', d);
    }
    return path;
}
function toPathData(elem) {
    const tagName = elem.tagName.toLowerCase();
    switch (tagName) {
        case 'path':
            return elem.getAttribute('d');
        case 'line':
            return lineToPathData(elem);
        case 'polygon':
            return polygonToPathData(elem);
        case 'polyline':
            return polylineToPathData(elem);
        case 'ellipse':
            return ellipseToPathData(elem);
        case 'circle':
            return circleToPathData(elem);
        case 'rect':
            return rectangleToPathData(elem);
        default:
            break;
    }
    throw new Error(`"${tagName}" cannot be converted to svg path element.`);
}
// Inspired by d3.js https://github.com/mbostock/d3/blob/master/src/svg/arc.js
function createSlicePathData(innerRadius, outerRadius, startAngle, endAngle) {
    const svgArcMax = 2 * Math.PI - 1e-6;
    const r0 = innerRadius;
    const r1 = outerRadius;
    let a0 = startAngle;
    let a1 = endAngle;
    if (a1 < a0) {
        const tmp = a0;
        a0 = a1;
        a1 = tmp;
    }
    const da = a1 - a0;
    const df = da < Math.PI ? '0' : '1';
    const c0 = Math.cos(a0);
    const s0 = Math.sin(a0);
    const c1 = Math.cos(a1);
    const s1 = Math.sin(a1);
    return da >= svgArcMax
        ? r0
            ? // eslint-disable-next-line
                `M0,${r1}A${r1},${r1} 0 1,1 0,${-r1}A${r1},${r1} 0 1,1 0,${r1}M0,${r0}A${r0},${r0} 0 1,0 0,${-r0}A${r0},${r0} 0 1,0 0,${r0}Z`
            : // eslint-disable-next-line
                `M0,${r1}A${r1},${r1} 0 1,1 0,${-r1}A${r1},${r1} 0 1,1 0,${r1}Z`
        : r0
            ? // eslint-disable-next-line
                `M${r1 * c0},${r1 * s0}A${r1},${r1} 0 ${df},1 ${r1 * c1},${r1 * s1}L${r0 * c1},${r0 * s1}A${r0},${r0} 0 ${df},0 ${r0 * c0},${r0 * s0}Z`
            : // eslint-disable-next-line
                `M${r1 * c0},${r1 * s0}A${r1},${r1} 0 ${df},1 ${r1 * c1},${r1 * s1}L0,0` +
                    `Z`;
}
//# sourceMappingURL=path.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/dom/position.js":
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/dom/position.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   height: () => (/* binding */ height),
/* harmony export */   offset: () => (/* binding */ offset),
/* harmony export */   position: () => (/* binding */ position),
/* harmony export */   width: () => (/* binding */ width)
/* harmony export */ });
/* harmony import */ var _css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./css */ "./node_modules/@antv/x6-common/es/dom/css.js");
/* harmony import */ var _elem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./elem */ "./node_modules/@antv/x6-common/es/dom/elem.js");


function offset(elem) {
    const rect = elem.getBoundingClientRect();
    const win = elem.ownerDocument.defaultView;
    return {
        top: rect.top + win.pageYOffset,
        left: rect.left + win.pageXOffset,
    };
}
function width(elem) {
    const rect = elem.getBoundingClientRect();
    return rect.width;
}
function height(elem) {
    const rect = elem.getBoundingClientRect();
    return rect.height;
}
function position(elem) {
    const isFixed = (0,_css__WEBPACK_IMPORTED_MODULE_0__.computeStyle)(elem, 'position') === 'fixed';
    let offsetValue;
    if (isFixed) {
        const rect = elem.getBoundingClientRect();
        offsetValue = { left: rect.left, top: rect.top };
    }
    else {
        offsetValue = offset(elem);
    }
    if (!isFixed) {
        const doc = elem.ownerDocument;
        let offsetParent = elem.offsetParent || doc.documentElement;
        while ((offsetParent === doc.body || offsetParent === doc.documentElement) &&
            (0,_css__WEBPACK_IMPORTED_MODULE_0__.computeStyle)(offsetParent, 'position') === 'static') {
            offsetParent = offsetParent.parentNode;
        }
        if (offsetParent !== elem && (0,_elem__WEBPACK_IMPORTED_MODULE_1__.isElement)(offsetParent)) {
            const parentOffset = offset(offsetParent);
            offsetValue.top -=
                parentOffset.top + (0,_css__WEBPACK_IMPORTED_MODULE_0__.computeStyleInt)(offsetParent, 'borderTopWidth');
            offsetValue.left -=
                parentOffset.left + (0,_css__WEBPACK_IMPORTED_MODULE_0__.computeStyleInt)(offsetParent, 'borderLeftWidth');
        }
    }
    return {
        top: offsetValue.top - (0,_css__WEBPACK_IMPORTED_MODULE_0__.computeStyleInt)(elem, 'marginTop'),
        left: offsetValue.left - (0,_css__WEBPACK_IMPORTED_MODULE_0__.computeStyleInt)(elem, 'marginLeft'),
    };
}
//# sourceMappingURL=position.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/dom/prefix.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/dom/prefix.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getVendorPrefixedName: () => (/* binding */ getVendorPrefixedName)
/* harmony export */ });
const hyphenPattern = /-(.)/g;
function camelize(str) {
    return str.replace(hyphenPattern, (_, char) => char.toUpperCase());
}
const memoized = {};
const prefixes = ['webkit', 'ms', 'moz', 'o'];
const testStyle = typeof document !== 'undefined' ? document.createElement('div').style : {};
function getWithPrefix(name) {
    for (let i = 0; i < prefixes.length; i += 1) {
        const prefixedName = prefixes[i] + name;
        if (prefixedName in testStyle) {
            return prefixedName;
        }
    }
    return null;
}
function getVendorPrefixedName(property) {
    const name = camelize(property);
    if (memoized[name] == null) {
        const capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);
        memoized[name] = name in testStyle ? name : getWithPrefix(capitalizedName);
    }
    return memoized[name];
}
//# sourceMappingURL=prefix.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/dom/prop.js":
/*!*****************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/dom/prop.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   prop: () => (/* binding */ prop)
/* harmony export */ });
const propMap = {
    /* GENERAL */
    class: 'className',
    contenteditable: 'contentEditable',
    /* LABEL */
    for: 'htmlFor',
    /* INPUT */
    readonly: 'readOnly',
    maxlength: 'maxLength',
    tabindex: 'tabIndex',
    /* TABLE */
    colspan: 'colSpan',
    rowspan: 'rowSpan',
    /* IMAGE */
    usemap: 'useMap',
};
function prop(elem, props, value) {
    if (!props) {
        return;
    }
    if (typeof props === 'string') {
        props = propMap[props] || props; // eslint-disable-line
        if (arguments.length < 3) {
            return elem[props];
        }
        ;
        elem[props] = value;
        return;
    }
    // eslint-disable-next-line
    for (const key in props) {
        prop(elem, key, props[key]);
    }
}
//# sourceMappingURL=prop.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/dom/selection.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/dom/selection.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clearSelection: () => (/* binding */ clearSelection)
/* harmony export */ });
const clearSelection = (function () {
    if (typeof document == 'undefined')
        return function () { };
    const doc = document;
    if (doc.selection) {
        return function () {
            doc.selection.empty();
        };
    }
    if (window.getSelection) {
        return function () {
            const selection = window.getSelection();
            if (selection) {
                if (selection.empty) {
                    selection.empty();
                }
                else if (selection.removeAllRanges) {
                    selection.removeAllRanges();
                }
            }
        };
    }
    return function () { };
})();
//# sourceMappingURL=selection.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/dom/style.js":
/*!******************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/dom/style.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getComputedStyle: () => (/* binding */ getComputedStyle),
/* harmony export */   hasScrollbars: () => (/* binding */ hasScrollbars),
/* harmony export */   setPrefixedStyle: () => (/* binding */ setPrefixedStyle)
/* harmony export */ });
/* harmony import */ var _prefix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./prefix */ "./node_modules/@antv/x6-common/es/dom/prefix.js");

function setPrefixedStyle(style, name, value) {
    const vendor = (0,_prefix__WEBPACK_IMPORTED_MODULE_0__.getVendorPrefixedName)(name);
    if (vendor != null) {
        style[vendor] = value;
    }
    style[name] = value;
}
function getComputedStyle(elem, name) {
    // IE9+
    const computed = elem.ownerDocument &&
        elem.ownerDocument.defaultView &&
        elem.ownerDocument.defaultView.opener
        ? elem.ownerDocument.defaultView.getComputedStyle(elem, null)
        : window.getComputedStyle(elem, null);
    if (computed && name) {
        return computed.getPropertyValue(name) || computed[name];
    }
    return computed;
}
function hasScrollbars(container) {
    const style = getComputedStyle(container);
    return (style != null && (style.overflow === 'scroll' || style.overflow === 'auto'));
}
//# sourceMappingURL=style.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/dom/text.js":
/*!*****************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/dom/text.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   breakText: () => (/* binding */ breakText),
/* harmony export */   measureText: () => (/* binding */ measureText),
/* harmony export */   splitTextByLength: () => (/* binding */ splitTextByLength),
/* harmony export */   text: () => (/* binding */ text)
/* harmony export */ });
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../string */ "./node_modules/@antv/x6-common/es/string/index.js");
/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../text */ "./node_modules/@antv/x6-common/es/text/index.js");
/* harmony import */ var _attr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attr */ "./node_modules/@antv/x6-common/es/dom/attr.js");
/* harmony import */ var _vector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../vector */ "./node_modules/@antv/x6-common/es/vector/index.js");
/* harmony import */ var _elem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./elem */ "./node_modules/@antv/x6-common/es/dom/elem.js");
/* eslint-disable no-control-regex */





function createTextPathNode(attrs, elem) {
    const vel = _vector__WEBPACK_IMPORTED_MODULE_3__.Vector.create(elem);
    const textPath = _vector__WEBPACK_IMPORTED_MODULE_3__.Vector.create('textPath');
    const d = attrs.d;
    if (d && attrs['xlink:href'] === undefined) {
        const path = _vector__WEBPACK_IMPORTED_MODULE_3__.Vector.create('path').attr('d', d).appendTo(vel.defs());
        textPath.attr('xlink:href', `#${path.id}`);
    }
    if (typeof attrs === 'object') {
        textPath.attr(attrs);
    }
    return textPath.node;
}
function annotateTextLine(lineNode, lineAnnotations, options) {
    const eol = options.eol;
    const baseSize = options.baseSize;
    const lineHeight = options.lineHeight;
    let maxFontSize = 0;
    let tspanNode;
    const fontMetrics = {};
    const lastJ = lineAnnotations.length - 1;
    for (let j = 0; j <= lastJ; j += 1) {
        let annotation = lineAnnotations[j];
        let fontSize = null;
        if (typeof annotation === 'object') {
            const annotationAttrs = annotation.attrs;
            const vTSpan = _vector__WEBPACK_IMPORTED_MODULE_3__.Vector.create('tspan', annotationAttrs);
            tspanNode = vTSpan.node;
            let t = annotation.t;
            if (eol && j === lastJ) {
                t += eol;
            }
            tspanNode.textContent = t;
            // Per annotation className
            const annotationClass = annotationAttrs.class;
            if (annotationClass) {
                vTSpan.addClass(annotationClass);
            }
            // set the list of indices of all the applied annotations
            // in the `annotations` attribute. This list is a comma
            // separated list of indices.
            if (options.includeAnnotationIndices) {
                vTSpan.attr('annotations', annotation.annotations.join(','));
            }
            // Check for max font size
            fontSize = parseFloat(annotationAttrs['font-size']);
            if (fontSize === undefined)
                fontSize = baseSize;
            if (fontSize && fontSize > maxFontSize)
                maxFontSize = fontSize;
        }
        else {
            if (eol && j === lastJ) {
                annotation += eol;
            }
            tspanNode = document.createTextNode(annotation || ' ');
            if (baseSize && baseSize > maxFontSize) {
                maxFontSize = baseSize;
            }
        }
        lineNode.appendChild(tspanNode);
    }
    if (maxFontSize) {
        fontMetrics.maxFontSize = maxFontSize;
    }
    if (lineHeight) {
        fontMetrics.lineHeight = lineHeight;
    }
    else if (maxFontSize) {
        fontMetrics.lineHeight = maxFontSize * 1.2;
    }
    return fontMetrics;
}
const emRegex = /em$/;
function emToPx(em, fontSize) {
    const numerical = parseFloat(em);
    if (emRegex.test(em)) {
        return numerical * fontSize;
    }
    return numerical;
}
function calculateDY(alignment, linesMetrics, baseSizePx, lineHeight) {
    if (!Array.isArray(linesMetrics)) {
        return 0;
    }
    const n = linesMetrics.length;
    if (!n)
        return 0;
    let lineMetrics = linesMetrics[0];
    const flMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;
    let rLineHeights = 0;
    const lineHeightPx = emToPx(lineHeight, baseSizePx);
    for (let i = 1; i < n; i += 1) {
        lineMetrics = linesMetrics[i];
        const iLineHeight = emToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx;
        rLineHeights += iLineHeight;
    }
    const llMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;
    let dy;
    switch (alignment) {
        case 'middle':
            dy = flMaxFont / 2 - 0.15 * llMaxFont - rLineHeights / 2;
            break;
        case 'bottom':
            dy = -(0.25 * llMaxFont) - rLineHeights;
            break;
        case 'top':
        default:
            dy = 0.8 * flMaxFont;
            break;
    }
    return dy;
}
function text(elem, content, options = {}) {
    content = _text__WEBPACK_IMPORTED_MODULE_1__.Text.sanitize(content); // eslint-disable-line
    const eol = options.eol;
    let textPath = options.textPath;
    const verticalAnchor = options.textVerticalAnchor;
    const namedVerticalAnchor = verticalAnchor === 'middle' ||
        verticalAnchor === 'bottom' ||
        verticalAnchor === 'top';
    // Horizontal shift applied to all the lines but the first.
    let x = options.x;
    if (x === undefined) {
        x = elem.getAttribute('x') || 0;
    }
    // Annotations
    const iai = options.includeAnnotationIndices;
    let annotations = options.annotations;
    if (annotations && !Array.isArray(annotations)) {
        annotations = [annotations];
    }
    // Shift all the <tspan> but first by one line (`1em`)
    const defaultLineHeight = options.lineHeight;
    const autoLineHeight = defaultLineHeight === 'auto';
    const lineHeight = autoLineHeight ? '1.5em' : defaultLineHeight || '1em';
    let needEmpty = true;
    const childNodes = elem.childNodes;
    if (childNodes.length === 1) {
        const node = childNodes[0];
        if (node && node.tagName.toUpperCase() === 'TITLE') {
            needEmpty = false;
        }
    }
    if (needEmpty) {
        (0,_elem__WEBPACK_IMPORTED_MODULE_4__.empty)(elem);
    }
    (0,_attr__WEBPACK_IMPORTED_MODULE_2__.attr)(elem, {
        // Preserve spaces, do not consecutive spaces to get collapsed to one.
        'xml:space': 'preserve',
        // An empty text gets rendered into the DOM in webkit-based browsers.
        // In order to unify this behaviour across all browsers
        // we rather hide the text element when it's empty.
        display: content || options.displayEmpty ? null : 'none',
    });
    // Set default font-size if none
    const strFontSize = (0,_attr__WEBPACK_IMPORTED_MODULE_2__.attr)(elem, 'font-size');
    let fontSize = parseFloat(strFontSize);
    if (!fontSize) {
        fontSize = 16;
        if ((namedVerticalAnchor || annotations) && !strFontSize) {
            (0,_attr__WEBPACK_IMPORTED_MODULE_2__.attr)(elem, 'font-size', `${fontSize}`);
        }
    }
    let containerNode;
    if (textPath) {
        // Now all the `<tspan>`s will be inside the `<textPath>`.
        if (typeof textPath === 'string') {
            textPath = { d: textPath };
        }
        containerNode = createTextPathNode(textPath, elem);
    }
    else {
        containerNode = document.createDocumentFragment();
    }
    let dy;
    let offset = 0;
    let annotatedY;
    const lines = content.split('\n');
    const linesMetrics = [];
    const lastI = lines.length - 1;
    for (let i = 0; i <= lastI; i += 1) {
        dy = lineHeight;
        let lineClassName = 'v-line';
        const lineNode = (0,_elem__WEBPACK_IMPORTED_MODULE_4__.createSvgElement)('tspan');
        let lineMetrics;
        let line = lines[i];
        if (line) {
            if (annotations) {
                // Find the *compacted* annotations for this line.
                const lineAnnotations = _text__WEBPACK_IMPORTED_MODULE_1__.Text.annotate(line, annotations, {
                    offset: -offset,
                    includeAnnotationIndices: iai,
                });
                lineMetrics = annotateTextLine(lineNode, lineAnnotations, {
                    eol: i !== lastI && eol,
                    baseSize: fontSize,
                    lineHeight: autoLineHeight ? null : lineHeight,
                    includeAnnotationIndices: iai,
                });
                // Get the line height based on the biggest font size
                // in the annotations for this line.
                const iLineHeight = lineMetrics.lineHeight;
                if (iLineHeight && autoLineHeight && i !== 0) {
                    dy = iLineHeight;
                }
                if (i === 0) {
                    annotatedY = lineMetrics.maxFontSize * 0.8;
                }
            }
            else {
                if (eol && i !== lastI) {
                    line += eol;
                }
                lineNode.textContent = line;
            }
        }
        else {
            // Make sure the textContent is never empty. If it is, add a dummy
            // character and make it invisible, making the following lines correctly
            // relatively positioned. `dy=1em` won't work with empty lines otherwise.
            lineNode.textContent = '-';
            lineClassName += ' v-empty-line';
            const lineNodeStyle = lineNode.style;
            lineNodeStyle.fillOpacity = 0;
            lineNodeStyle.strokeOpacity = 0;
            if (annotations) {
                lineMetrics = {};
            }
        }
        if (lineMetrics) {
            linesMetrics.push(lineMetrics);
        }
        if (i > 0) {
            lineNode.setAttribute('dy', dy);
        }
        // Firefox requires 'x' to be set on the first line
        if (i > 0 || textPath) {
            lineNode.setAttribute('x', x);
        }
        lineNode.className.baseVal = lineClassName;
        containerNode.appendChild(lineNode);
        offset += line.length + 1; // + 1 = newline character.
    }
    // Y Alignment calculation
    if (namedVerticalAnchor) {
        if (annotations) {
            dy = calculateDY(verticalAnchor, linesMetrics, fontSize, lineHeight);
        }
        else if (verticalAnchor === 'top') {
            // A shortcut for top alignment. It does not depend on font-size nor line-height
            dy = '0.8em';
        }
        else {
            let rh; // remaining height
            if (lastI > 0) {
                rh = parseFloat(lineHeight) || 1;
                rh *= lastI;
                if (!emRegex.test(lineHeight))
                    rh /= fontSize;
            }
            else {
                // Single-line text
                rh = 0;
            }
            switch (verticalAnchor) {
                case 'middle':
                    dy = `${0.3 - rh / 2}em`;
                    break;
                case 'bottom':
                    dy = `${-rh - 0.3}em`;
                    break;
                default:
                    break;
            }
        }
    }
    else if (verticalAnchor === 0) {
        dy = '0em';
    }
    else if (verticalAnchor) {
        dy = verticalAnchor;
    }
    else {
        // No vertical anchor is defined
        dy = 0;
        // Backwards compatibility - we change the `y` attribute instead of `dy`.
        if (elem.getAttribute('y') == null) {
            elem.setAttribute('y', `${annotatedY || '0.8em'}`);
        }
    }
    const firstLine = containerNode.firstChild;
    firstLine.setAttribute('dy', dy);
    elem.appendChild(containerNode);
}
function measureText(text, styles = {}) {
    const canvasContext = document.createElement('canvas').getContext('2d');
    if (!text) {
        return { width: 0 };
    }
    const font = [];
    const fontSize = styles['font-size']
        ? `${parseFloat(styles['font-size'])}px`
        : '14px';
    font.push(styles['font-style'] || 'normal');
    font.push(styles['font-variant'] || 'normal');
    font.push(styles['font-weight'] || 400);
    font.push(fontSize);
    font.push(styles['font-family'] || 'sans-serif');
    canvasContext.font = font.join(' ');
    return canvasContext.measureText(text);
}
function splitTextByLength(text, splitWidth, totalWidth, style = {}) {
    if (splitWidth >= totalWidth) {
        return [text, ''];
    }
    const length = text.length;
    const caches = {};
    let index = Math.round((splitWidth / totalWidth) * length - 1);
    if (index < 0) {
        index = 0;
    }
    // eslint-disable-next-line
    while (index >= 0 && index < length) {
        const frontText = text.slice(0, index);
        const frontWidth = caches[frontText] || measureText(frontText, style).width;
        const behindText = text.slice(0, index + 1);
        const behindWidth = caches[behindText] || measureText(behindText, style).width;
        caches[frontText] = frontWidth;
        caches[behindText] = behindWidth;
        if (frontWidth > splitWidth) {
            index -= 1;
        }
        else if (behindWidth <= splitWidth) {
            index += 1;
        }
        else {
            break;
        }
    }
    return [text.slice(0, index), text.slice(index)];
}
function breakText(text, size, styles = {}, options = {}) {
    const width = size.width;
    const height = size.height;
    const eol = options.eol || '\n';
    const fontSize = styles.fontSize || 14;
    const lineHeight = styles.lineHeight
        ? parseFloat(styles.lineHeight)
        : Math.ceil(fontSize * 1.4);
    const maxLines = Math.floor(height / lineHeight);
    if (text.indexOf(eol) > -1) {
        const delimiter = _string__WEBPACK_IMPORTED_MODULE_0__.StringExt.uuid();
        const splitText = [];
        text.split(eol).map((line) => {
            const part = breakText(line, Object.assign(Object.assign({}, size), { height: Number.MAX_SAFE_INTEGER }), styles, Object.assign(Object.assign({}, options), { eol: delimiter }));
            if (part) {
                splitText.push(...part.split(delimiter));
            }
        });
        return splitText.slice(0, maxLines).join(eol);
    }
    const { width: textWidth } = measureText(text, styles);
    if (textWidth < width) {
        return text;
    }
    const lines = [];
    let remainText = text;
    let remainWidth = textWidth;
    let ellipsis = options.ellipsis;
    let ellipsisWidth = 0;
    if (ellipsis) {
        if (typeof ellipsis !== 'string') {
            ellipsis = '\u2026';
        }
        ellipsisWidth = measureText(ellipsis, styles).width;
    }
    for (let i = 0; i < maxLines; i += 1) {
        if (remainWidth > width) {
            const isLast = i === maxLines - 1;
            if (isLast) {
                const [front] = splitTextByLength(remainText, width - ellipsisWidth, remainWidth, styles);
                lines.push(ellipsis ? `${front}${ellipsis}` : front);
            }
            else {
                const [front, behind] = splitTextByLength(remainText, width, remainWidth, styles);
                lines.push(front);
                remainText = behind;
                remainWidth = measureText(remainText, styles).width;
            }
        }
        else {
            lines.push(remainText);
            break;
        }
    }
    return lines.join(eol);
}
//# sourceMappingURL=text.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/dom/transform.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/dom/transform.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getTransformToElement: () => (/* binding */ getTransformToElement),
/* harmony export */   getTransformToParentElement: () => (/* binding */ getTransformToParentElement),
/* harmony export */   rotate: () => (/* binding */ rotate),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   toLocalPoint: () => (/* binding */ toLocalPoint),
/* harmony export */   transform: () => (/* binding */ transform),
/* harmony export */   translate: () => (/* binding */ translate)
/* harmony export */ });
/* harmony import */ var _attr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./attr */ "./node_modules/@antv/x6-common/es/dom/attr.js");
/* harmony import */ var _elem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./elem */ "./node_modules/@antv/x6-common/es/dom/elem.js");
/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./matrix */ "./node_modules/@antv/x6-common/es/dom/matrix.js");



function transform(elem, matrix, options = {}) {
    if (matrix == null) {
        return (0,_matrix__WEBPACK_IMPORTED_MODULE_2__.transformStringToMatrix)((0,_attr__WEBPACK_IMPORTED_MODULE_0__.attr)(elem, 'transform'));
    }
    if (options.absolute) {
        elem.setAttribute('transform', (0,_matrix__WEBPACK_IMPORTED_MODULE_2__.matrixToTransformString)(matrix));
        return;
    }
    const transformList = elem.transform;
    const svgTransform = (0,_matrix__WEBPACK_IMPORTED_MODULE_2__.createSVGTransform)(matrix);
    transformList.baseVal.appendItem(svgTransform);
}
function translate(elem, tx, ty = 0, options = {}) {
    let transformAttr = (0,_attr__WEBPACK_IMPORTED_MODULE_0__.attr)(elem, 'transform');
    const transform = (0,_matrix__WEBPACK_IMPORTED_MODULE_2__.parseTransformString)(transformAttr);
    if (tx == null) {
        return transform.translation;
    }
    transformAttr = transform.raw;
    transformAttr = transformAttr.replace(/translate\([^)]*\)/g, '').trim();
    const newTx = options.absolute ? tx : transform.translation.tx + tx;
    const newTy = options.absolute ? ty : transform.translation.ty + ty;
    const newTranslate = `translate(${newTx},${newTy})`;
    // Note that `translate()` is always the first transformation. This is
    // usually the desired case.
    elem.setAttribute('transform', `${newTranslate} ${transformAttr}`.trim());
}
function rotate(elem, angle, cx, cy, options = {}) {
    let transformAttr = (0,_attr__WEBPACK_IMPORTED_MODULE_0__.attr)(elem, 'transform');
    const transform = (0,_matrix__WEBPACK_IMPORTED_MODULE_2__.parseTransformString)(transformAttr);
    if (angle == null) {
        return transform.rotation;
    }
    transformAttr = transform.raw;
    transformAttr = transformAttr.replace(/rotate\([^)]*\)/g, '').trim();
    angle %= 360; // eslint-disable-line
    const newAngle = options.absolute ? angle : transform.rotation.angle + angle;
    const newOrigin = cx != null && cy != null ? `,${cx},${cy}` : '';
    const newRotate = `rotate(${newAngle}${newOrigin})`;
    elem.setAttribute('transform', `${transformAttr} ${newRotate}`.trim());
}
function scale(elem, sx, sy) {
    let transformAttr = (0,_attr__WEBPACK_IMPORTED_MODULE_0__.attr)(elem, 'transform');
    const transform = (0,_matrix__WEBPACK_IMPORTED_MODULE_2__.parseTransformString)(transformAttr);
    if (sx == null) {
        return transform.scale;
    }
    sy = sy == null ? sx : sy; // eslint-disable-line
    transformAttr = transform.raw;
    transformAttr = transformAttr.replace(/scale\([^)]*\)/g, '').trim();
    const newScale = `scale(${sx},${sy})`;
    elem.setAttribute('transform', `${transformAttr} ${newScale}`.trim());
}
/**
 * Returns an DOMMatrix that specifies the transformation necessary
 * to convert `elem` coordinate system into `target` coordinate system.
 */
function getTransformToElement(elem, target) {
    if ((0,_elem__WEBPACK_IMPORTED_MODULE_1__.isSVGGraphicsElement)(target) && (0,_elem__WEBPACK_IMPORTED_MODULE_1__.isSVGGraphicsElement)(elem)) {
        const targetCTM = target.getScreenCTM();
        const nodeCTM = elem.getScreenCTM();
        if (targetCTM && nodeCTM) {
            return targetCTM.inverse().multiply(nodeCTM);
        }
    }
    // Could not get actual transformation matrix
    return (0,_matrix__WEBPACK_IMPORTED_MODULE_2__.createSVGMatrix)();
}
/**
 * Returns an DOMMatrix that specifies the transformation necessary
 * to convert `elem` coordinate system into `target` coordinate system.
 * Unlike getTransformToElement, elem is child of target,Because of the reduction in DOM API calls,
 * there is a significant performance improvement.
 */
function getTransformToParentElement(elem, target) {
    let matrix = (0,_matrix__WEBPACK_IMPORTED_MODULE_2__.createSVGMatrix)();
    if ((0,_elem__WEBPACK_IMPORTED_MODULE_1__.isSVGGraphicsElement)(target) && (0,_elem__WEBPACK_IMPORTED_MODULE_1__.isSVGGraphicsElement)(elem)) {
        let node = elem;
        const matrixList = [];
        while (node && node !== target) {
            const transform = node.getAttribute('transform') || null;
            const nodeMatrix = (0,_matrix__WEBPACK_IMPORTED_MODULE_2__.transformStringToMatrix)(transform);
            matrixList.push(nodeMatrix);
            node = node.parentNode;
        }
        matrixList.reverse().forEach((m) => {
            matrix = matrix.multiply(m);
        });
    }
    return matrix;
}
/**
 * Converts a global point with coordinates `x` and `y` into the
 * coordinate space of the element.
 */
function toLocalPoint(elem, x, y) {
    const svg = elem instanceof SVGSVGElement
        ? elem
        : elem.ownerSVGElement;
    const p = svg.createSVGPoint();
    p.x = x;
    p.y = y;
    try {
        const ctm = svg.getScreenCTM();
        const globalPoint = p.matrixTransform(ctm.inverse());
        const globalToLocalMatrix = getTransformToElement(elem, svg).inverse();
        return globalPoint.matrixTransform(globalToLocalMatrix);
    }
    catch (e) {
        return p;
    }
}
//# sourceMappingURL=transform.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/event/events.js":
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/event/events.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Events: () => (/* binding */ Events)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6-common/es/event/util.js");
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../function */ "./node_modules/@antv/x6-common/es/function/index.js");


class Events {
    constructor() {
        this.listeners = {};
    }
    on(name, handler, context) {
        if (handler == null) {
            return this;
        }
        if (!this.listeners[name]) {
            this.listeners[name] = [];
        }
        const cache = this.listeners[name];
        cache.push(handler, context);
        return this;
    }
    once(name, handler, context) {
        const cb = (...args) => {
            this.off(name, cb);
            return (0,_util__WEBPACK_IMPORTED_MODULE_0__.call)([handler, context], args);
        };
        return this.on(name, cb, this);
    }
    off(name, handler, context) {
        // remove all events.
        if (!(name || handler || context)) {
            this.listeners = {};
            return this;
        }
        const listeners = this.listeners;
        const names = name ? [name] : Object.keys(listeners);
        names.forEach((n) => {
            const cache = listeners[n];
            if (!cache) {
                return;
            }
            // remove all events with specified name.
            if (!(handler || context)) {
                delete listeners[n];
                return;
            }
            for (let i = cache.length - 2; i >= 0; i -= 2) {
                if (!((handler && cache[i] !== handler) ||
                    (context && cache[i + 1] !== context))) {
                    cache.splice(i, 2);
                }
            }
        });
        return this;
    }
    trigger(name, ...args) {
        let returned = true;
        if (name !== '*') {
            const list = this.listeners[name];
            if (list != null) {
                returned = (0,_util__WEBPACK_IMPORTED_MODULE_0__.call)([...list], args);
            }
        }
        const list = this.listeners['*'];
        if (list != null) {
            return _function__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.toAsyncBoolean([
                returned,
                (0,_util__WEBPACK_IMPORTED_MODULE_0__.call)([...list], [name, ...args]),
            ]);
        }
        return returned;
    }
    emit(name, ...args) {
        return this.trigger(name, ...args);
    }
}
//# sourceMappingURL=events.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/event/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/event/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Events: () => (/* reexport safe */ _events__WEBPACK_IMPORTED_MODULE_0__.Events)
/* harmony export */ });
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events */ "./node_modules/@antv/x6-common/es/event/events.js");

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/event/util.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/event/util.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   call: () => (/* binding */ call)
/* harmony export */ });
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../function */ "./node_modules/@antv/x6-common/es/function/index.js");

function call(list, args) {
    const results = [];
    for (let i = 0; i < list.length; i += 2) {
        const handler = list[i];
        const context = list[i + 1];
        const params = Array.isArray(args) ? args : [args];
        const ret = _function__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.apply(handler, context, params);
        results.push(ret);
    }
    return _function__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.toAsyncBoolean(results);
}
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/function/async.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/function/async.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isAsync: () => (/* binding */ isAsync),
/* harmony export */   isAsyncLike: () => (/* binding */ isAsyncLike),
/* harmony export */   toAsyncBoolean: () => (/* binding */ toAsyncBoolean),
/* harmony export */   toDeferredBoolean: () => (/* binding */ toDeferredBoolean)
/* harmony export */ });
function isAsyncLike(obj) {
    return typeof obj === 'object' && obj.then && typeof obj.then === 'function';
}
function isAsync(obj) {
    return obj != null && (obj instanceof Promise || isAsyncLike(obj));
}
function toAsyncBoolean(...inputs) {
    const results = [];
    inputs.forEach((arg) => {
        if (Array.isArray(arg)) {
            results.push(...arg);
        }
        else {
            results.push(arg);
        }
    });
    const hasAsync = results.some((res) => isAsync(res));
    if (hasAsync) {
        const deferres = results.map((res) => isAsync(res) ? res : Promise.resolve(res !== false));
        return Promise.all(deferres).then((arr) => arr.reduce((memo, item) => item !== false && memo, true));
    }
    return results.every((res) => res !== false);
}
function toDeferredBoolean(...inputs) {
    const ret = toAsyncBoolean(inputs);
    return typeof ret === 'boolean' ? Promise.resolve(ret) : ret;
}
//# sourceMappingURL=async.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/function/function.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/function/function.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   apply: () => (/* binding */ apply),
/* harmony export */   call: () => (/* binding */ call),
/* harmony export */   debounce: () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   throttle: () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/debounce.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/throttle.js");

function apply(fn, ctx, args) {
    if (args) {
        switch (args.length) {
            case 0:
                return fn.call(ctx);
            case 1:
                return fn.call(ctx, args[0]);
            case 2:
                return fn.call(ctx, args[0], args[1]);
            case 3:
                return fn.call(ctx, args[0], args[1], args[2]);
            case 4:
                return fn.call(ctx, args[0], args[1], args[2], args[3]);
            case 5:
                return fn.call(ctx, args[0], args[1], args[2], args[3], args[4]);
            case 6:
                return fn.call(ctx, args[0], args[1], args[2], args[3], args[4], args[5]);
            default:
                return fn.apply(ctx, args);
        }
    }
    return fn.call(ctx);
}
function call(fn, ctx, ...args) {
    return apply(fn, ctx, args);
}
//# sourceMappingURL=function.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/function/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/function/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FunctionExt: () => (/* reexport module object */ _main__WEBPACK_IMPORTED_MODULE_0__)
/* harmony export */ });
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main */ "./node_modules/@antv/x6-common/es/function/main.js");


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/function/main.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/function/main.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   apply: () => (/* reexport safe */ _function__WEBPACK_IMPORTED_MODULE_0__.apply),
/* harmony export */   call: () => (/* reexport safe */ _function__WEBPACK_IMPORTED_MODULE_0__.call),
/* harmony export */   debounce: () => (/* reexport safe */ _function__WEBPACK_IMPORTED_MODULE_0__.debounce),
/* harmony export */   isAsync: () => (/* reexport safe */ _async__WEBPACK_IMPORTED_MODULE_1__.isAsync),
/* harmony export */   isAsyncLike: () => (/* reexport safe */ _async__WEBPACK_IMPORTED_MODULE_1__.isAsyncLike),
/* harmony export */   throttle: () => (/* reexport safe */ _function__WEBPACK_IMPORTED_MODULE_0__.throttle),
/* harmony export */   toAsyncBoolean: () => (/* reexport safe */ _async__WEBPACK_IMPORTED_MODULE_1__.toAsyncBoolean),
/* harmony export */   toDeferredBoolean: () => (/* reexport safe */ _async__WEBPACK_IMPORTED_MODULE_1__.toDeferredBoolean)
/* harmony export */ });
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./function */ "./node_modules/@antv/x6-common/es/function/function.js");
/* harmony import */ var _async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./async */ "./node_modules/@antv/x6-common/es/function/async.js");


//# sourceMappingURL=main.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ArrayExt: () => (/* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_2__.ArrayExt),
/* harmony export */   Basecoat: () => (/* reexport safe */ _common__WEBPACK_IMPORTED_MODULE_1__.Basecoat),
/* harmony export */   Color: () => (/* reexport safe */ _color__WEBPACK_IMPORTED_MODULE_15__.Color),
/* harmony export */   CssLoader: () => (/* reexport safe */ _css_loader__WEBPACK_IMPORTED_MODULE_20__.CssLoader),
/* harmony export */   DataUri: () => (/* reexport safe */ _datauri__WEBPACK_IMPORTED_MODULE_9__.DataUri),
/* harmony export */   Dictionary: () => (/* reexport safe */ _dictionary__WEBPACK_IMPORTED_MODULE_17__.Dictionary),
/* harmony export */   Dijkstra: () => (/* reexport safe */ _algorithm__WEBPACK_IMPORTED_MODULE_14__.Dijkstra),
/* harmony export */   Disablable: () => (/* reexport safe */ _common__WEBPACK_IMPORTED_MODULE_1__.Disablable),
/* harmony export */   Disposable: () => (/* reexport safe */ _common__WEBPACK_IMPORTED_MODULE_1__.Disposable),
/* harmony export */   DisposableDelegate: () => (/* reexport safe */ _common__WEBPACK_IMPORTED_MODULE_1__.DisposableDelegate),
/* harmony export */   DisposableSet: () => (/* reexport safe */ _common__WEBPACK_IMPORTED_MODULE_1__.DisposableSet),
/* harmony export */   Dom: () => (/* reexport safe */ _dom__WEBPACK_IMPORTED_MODULE_11__.Dom),
/* harmony export */   Events: () => (/* reexport safe */ _event__WEBPACK_IMPORTED_MODULE_16__.Events),
/* harmony export */   FunctionExt: () => (/* reexport safe */ _function__WEBPACK_IMPORTED_MODULE_6__.FunctionExt),
/* harmony export */   Interp: () => (/* reexport safe */ _animation__WEBPACK_IMPORTED_MODULE_19__.Interp),
/* harmony export */   ModifierKey: () => (/* reexport safe */ _modifier__WEBPACK_IMPORTED_MODULE_18__.ModifierKey),
/* harmony export */   NumberExt: () => (/* reexport safe */ _number__WEBPACK_IMPORTED_MODULE_5__.NumberExt),
/* harmony export */   ObjectExt: () => (/* reexport safe */ _object__WEBPACK_IMPORTED_MODULE_3__.ObjectExt),
/* harmony export */   Platform: () => (/* reexport safe */ _platform__WEBPACK_IMPORTED_MODULE_7__.Platform),
/* harmony export */   PriorityQueue: () => (/* reexport safe */ _algorithm__WEBPACK_IMPORTED_MODULE_14__.PriorityQueue),
/* harmony export */   SizeSensor: () => (/* reexport safe */ _size_sensor__WEBPACK_IMPORTED_MODULE_13__.SizeSensor),
/* harmony export */   StringExt: () => (/* reexport safe */ _string__WEBPACK_IMPORTED_MODULE_4__.StringExt),
/* harmony export */   Text: () => (/* reexport safe */ _text__WEBPACK_IMPORTED_MODULE_8__.Text),
/* harmony export */   Timing: () => (/* reexport safe */ _animation__WEBPACK_IMPORTED_MODULE_19__.Timing),
/* harmony export */   Unit: () => (/* reexport safe */ _unit__WEBPACK_IMPORTED_MODULE_10__.Unit),
/* harmony export */   Vector: () => (/* reexport safe */ _vector__WEBPACK_IMPORTED_MODULE_12__.Vector)
/* harmony export */ });
/* harmony import */ var _polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polyfill */ "./node_modules/@antv/x6-common/es/polyfill/index.js");
/* harmony import */ var _polyfill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_polyfill__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common */ "./node_modules/@antv/x6-common/es/common/index.js");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./array */ "./node_modules/@antv/x6-common/es/array/index.js");
/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./object */ "./node_modules/@antv/x6-common/es/object/index.js");
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./string */ "./node_modules/@antv/x6-common/es/string/index.js");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./number */ "./node_modules/@antv/x6-common/es/number/index.js");
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./function */ "./node_modules/@antv/x6-common/es/function/index.js");
/* harmony import */ var _platform__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./platform */ "./node_modules/@antv/x6-common/es/platform/index.js");
/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./text */ "./node_modules/@antv/x6-common/es/text/index.js");
/* harmony import */ var _datauri__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./datauri */ "./node_modules/@antv/x6-common/es/datauri/index.js");
/* harmony import */ var _unit__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./unit */ "./node_modules/@antv/x6-common/es/unit/index.js");
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./dom */ "./node_modules/@antv/x6-common/es/dom/index.js");
/* harmony import */ var _vector__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./vector */ "./node_modules/@antv/x6-common/es/vector/index.js");
/* harmony import */ var _size_sensor__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./size-sensor */ "./node_modules/@antv/x6-common/es/size-sensor/index.js");
/* harmony import */ var _algorithm__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./algorithm */ "./node_modules/@antv/x6-common/es/algorithm/index.js");
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./color */ "./node_modules/@antv/x6-common/es/color/index.js");
/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./event */ "./node_modules/@antv/x6-common/es/event/index.js");
/* harmony import */ var _dictionary__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./dictionary */ "./node_modules/@antv/x6-common/es/dictionary/index.js");
/* harmony import */ var _modifier__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./modifier */ "./node_modules/@antv/x6-common/es/modifier/index.js");
/* harmony import */ var _animation__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./animation */ "./node_modules/@antv/x6-common/es/animation/index.js");
/* harmony import */ var _css_loader__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./css-loader */ "./node_modules/@antv/x6-common/es/css-loader/index.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./types */ "./node_modules/@antv/x6-common/es/types.js");






















//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/modifier/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/modifier/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ModifierKey: () => (/* binding */ ModifierKey)
/* harmony export */ });
// eslint-disable-next-line
var ModifierKey;
(function (ModifierKey) {
    function parse(modifiers) {
        const or = [];
        const and = [];
        if (Array.isArray(modifiers)) {
            or.push(...modifiers);
        }
        else {
            modifiers.split('|').forEach((item) => {
                if (item.indexOf('&') === -1) {
                    or.push(item);
                }
                else {
                    and.push(...item.split('&'));
                }
            });
        }
        return { or, and };
    }
    ModifierKey.parse = parse;
    function equals(modifiers1, modifiers2) {
        if (modifiers1 != null && modifiers2 != null) {
            const m1 = parse(modifiers1);
            const m2 = parse(modifiers2);
            const or1 = m1.or.sort();
            const or2 = m2.or.sort();
            const and1 = m1.and.sort();
            const and2 = m2.and.sort();
            const equal = (a1, a2) => {
                return (a1.length === a2.length &&
                    (a1.length === 0 || a1.every((a, i) => a === a2[i])));
            };
            return equal(or1, or2) && equal(and1, and2);
        }
        if (modifiers1 == null && modifiers2 == null) {
            return true;
        }
        return false;
    }
    ModifierKey.equals = equals;
    function isMatch(e, modifiers, strict) {
        if (modifiers == null ||
            (Array.isArray(modifiers) && modifiers.length === 0)) {
            return strict
                ? e.altKey !== true &&
                    e.ctrlKey !== true &&
                    e.metaKey !== true &&
                    e.shiftKey !== true
                : true;
        }
        const { or, and } = parse(modifiers);
        const match = (key) => {
            const name = `${key.toLowerCase()}Key`;
            return e[name] === true;
        };
        return or.some((key) => match(key)) && and.every((key) => match(key));
    }
    ModifierKey.isMatch = isMatch;
})(ModifierKey || (ModifierKey = {}));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/number/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/number/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NumberExt: () => (/* reexport module object */ _number__WEBPACK_IMPORTED_MODULE_0__)
/* harmony export */ });
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number */ "./node_modules/@antv/x6-common/es/number/number.js");


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/number/number.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/number/number.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clamp: () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   isNumber: () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   isPercentage: () => (/* binding */ isPercentage),
/* harmony export */   mod: () => (/* binding */ mod),
/* harmony export */   normalizePercentage: () => (/* binding */ normalizePercentage),
/* harmony export */   normalizeSides: () => (/* binding */ normalizeSides),
/* harmony export */   parseCssNumeric: () => (/* binding */ parseCssNumeric),
/* harmony export */   random: () => (/* binding */ random)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isNumber.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/clamp.js");

/**
 * Returns the remainder of division of `n` by `m`. You should use this
 * instead of the built-in operation as the built-in operation does not
 * properly handle negative numbers.
 */
function mod(n, m) {
    return ((n % m) + m) % m;
}
function random(lower, upper) {
    if (upper == null) {
        upper = lower == null ? 1 : lower; // eslint-disable-line
        lower = 0; // eslint-disable-line
    }
    else if (upper < lower) {
        const tmp = lower;
        lower = upper; // eslint-disable-line
        upper = tmp; // eslint-disable-line
    }
    return Math.floor(Math.random() * (upper - lower + 1) + lower);
}
function isPercentage(val) {
    return typeof val === 'string' && val.slice(-1) === '%';
}
function normalizePercentage(num, ref) {
    if (num == null) {
        return 0;
    }
    let raw;
    if (typeof num === 'string') {
        raw = parseFloat(num);
        if (isPercentage(num)) {
            raw /= 100;
            if (Number.isFinite(raw)) {
                return raw * ref;
            }
        }
    }
    else {
        raw = num;
    }
    if (!Number.isFinite(raw)) {
        return 0;
    }
    if (raw > 0 && raw < 1) {
        return raw * ref;
    }
    return raw;
}
function parseCssNumeric(val, units) {
    function getUnit(regexp) {
        const matches = new RegExp(`(?:\\d+(?:\\.\\d+)*)(${regexp})$`).exec(val);
        if (!matches) {
            return null;
        }
        return matches[1];
    }
    const number = parseFloat(val);
    if (Number.isNaN(number)) {
        return null;
    }
    // determine the unit
    let regexp;
    if (units == null) {
        // accept any unit, as well as no unit
        regexp = '[A-Za-z]*';
    }
    else if (Array.isArray(units)) {
        if (units.length === 0) {
            return null;
        }
        regexp = units.join('|');
    }
    else if (typeof units === 'string') {
        regexp = units;
    }
    const unit = getUnit(regexp);
    if (unit === null) {
        return null;
    }
    return {
        unit,
        value: number,
    };
}
function normalizeSides(box) {
    if (typeof box === 'object') {
        let left = 0;
        let top = 0;
        let right = 0;
        let bottom = 0;
        if (box.vertical != null && Number.isFinite(box.vertical)) {
            top = bottom = box.vertical;
        }
        if (box.horizontal != null && Number.isFinite(box.horizontal)) {
            right = left = box.horizontal;
        }
        if (box.left != null && Number.isFinite(box.left))
            left = box.left;
        if (box.top != null && Number.isFinite(box.top))
            top = box.top;
        if (box.right != null && Number.isFinite(box.right))
            right = box.right;
        if (box.bottom != null && Number.isFinite(box.bottom))
            bottom = box.bottom;
        return { top, right, bottom, left };
    }
    let val = 0;
    if (box != null && Number.isFinite(box)) {
        val = box;
    }
    return { top: val, right: val, bottom: val, left: val };
}
//# sourceMappingURL=number.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/object/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/object/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ObjectExt: () => (/* reexport module object */ _object__WEBPACK_IMPORTED_MODULE_0__)
/* harmony export */ });
/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./object */ "./node_modules/@antv/x6-common/es/object/object.js");


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/object/inherit.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/object/inherit.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createClass: () => (/* binding */ createClass),
/* harmony export */   inherit: () => (/* binding */ inherit)
/* harmony export */ });
const extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array &&
        function (d, b) {
            d.__proto__ = b; // eslint-disable-line no-proto
        }) ||
    function (d, b) {
        // eslint-disable-next-line no-restricted-syntax
        for (const p in b) {
            if (Object.prototype.hasOwnProperty.call(b, p)) {
                d[p] = b[p];
            }
        }
    };
/**
 * @see https://github.com/microsoft/TypeScript/blob/5c85febb0ce9d6088cbe9b09cb42f73f9ee8ea05/src/compiler/transformers/es2015.ts#L4309
 */
// eslint-disable-next-line
function inherit(cls, base) {
    extendStatics(cls, base);
    function tmp() {
        this.constructor = cls;
    }
    cls.prototype =
        base === null
            ? Object.create(base)
            : ((tmp.prototype = base.prototype), new tmp());
}
class A {
}
const isNativeClass = /^\s*class\s+/.test(`${A}`) || /^\s*class\s*\{/.test(`${class {
}}`);
/**
 * Extends class with specified class name.
 */
function createClass(className, base) {
    let cls;
    if (isNativeClass) {
        cls = class extends base {
        };
    }
    else {
        cls = function () {
            return base.apply(this, arguments); // eslint-disable-line
        };
        inherit(cls, base);
    }
    Object.defineProperty(cls, 'name', { value: className });
    return cls;
}
//# sourceMappingURL=inherit.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/object/mixins.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/object/mixins.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyMixins: () => (/* binding */ applyMixins)
/* harmony export */ });
/**
 * @see https://www.typescriptlang.org/docs/handbook/mixins.html
 */
function applyMixins(derivedCtor, ...baseCtors) {
    baseCtors.forEach((baseCtor) => {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {
            if (name !== 'constructor') {
                Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name));
            }
        });
    });
}
//# sourceMappingURL=mixins.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/object/object.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/object/object.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyMixins: () => (/* reexport safe */ _mixins__WEBPACK_IMPORTED_MODULE_11__.applyMixins),
/* harmony export */   clone: () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   cloneDeep: () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   createClass: () => (/* reexport safe */ _inherit__WEBPACK_IMPORTED_MODULE_12__.createClass),
/* harmony export */   defaults: () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   defaultsDeep: () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   ensure: () => (/* binding */ ensure),
/* harmony export */   flatten: () => (/* binding */ flatten),
/* harmony export */   getBoolean: () => (/* binding */ getBoolean),
/* harmony export */   getByPath: () => (/* binding */ getByPath),
/* harmony export */   getNumber: () => (/* binding */ getNumber),
/* harmony export */   getValue: () => (/* binding */ getValue),
/* harmony export */   has: () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   inherit: () => (/* reexport safe */ _inherit__WEBPACK_IMPORTED_MODULE_12__.inherit),
/* harmony export */   isEmpty: () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   isEqual: () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   isMaliciousProp: () => (/* binding */ isMaliciousProp),
/* harmony export */   isObject: () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   isPlainObject: () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   merge: () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   pick: () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   setByPath: () => (/* binding */ setByPath),
/* harmony export */   unsetByPath: () => (/* binding */ unsetByPath)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/has.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/pick.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/merge.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isEqual.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isEmpty.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isObject.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isPlainObject.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/clone.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/cloneDeep.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/defaults.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/defaultsDeep.js");
/* harmony import */ var _mixins__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./mixins */ "./node_modules/@antv/x6-common/es/object/mixins.js");
/* harmony import */ var _inherit__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./inherit */ "./node_modules/@antv/x6-common/es/object/inherit.js");



function ensure(value, defaultValue) {
    return value != null ? value : defaultValue;
}
function getValue(obj, key, defaultValue) {
    const value = obj != null ? obj[key] : null;
    return defaultValue !== undefined ? ensure(value, defaultValue) : value;
}
function getNumber(obj, key, defaultValue) {
    let value = obj != null ? obj[key] : null;
    if (value == null) {
        return defaultValue;
    }
    value = +value;
    if (Number.isNaN(value) || !Number.isFinite(value)) {
        return defaultValue;
    }
    return value;
}
function getBoolean(obj, key, defaultValue) {
    const value = obj != null ? obj[key] : null;
    if (value == null) {
        return defaultValue;
    }
    return !!value;
}
function isMaliciousProp(prop) {
    return prop === '__proto__';
}
function getByPath(obj, path, delimiter = '/') {
    let ret;
    const keys = Array.isArray(path) ? path : path.split(delimiter);
    if (keys.length) {
        ret = obj;
        while (keys.length) {
            const key = keys.shift();
            if (Object(ret) === ret && key && key in ret) {
                ret = ret[key];
            }
            else {
                return undefined;
            }
        }
    }
    return ret;
}
function setByPath(obj, path, value, delimiter = '/') {
    const keys = Array.isArray(path) ? path : path.split(delimiter);
    const lastKey = keys.pop();
    if (lastKey && !isMaliciousProp(lastKey)) {
        let diver = obj;
        keys.forEach((key) => {
            if (!isMaliciousProp(key)) {
                if (diver[key] == null) {
                    diver[key] = {};
                }
                diver = diver[key];
            }
        });
        diver[lastKey] = value;
    }
    return obj;
}
function unsetByPath(obj, path, delimiter = '/') {
    const keys = Array.isArray(path) ? path.slice() : path.split(delimiter);
    const propertyToRemove = keys.pop();
    if (propertyToRemove) {
        if (keys.length > 0) {
            const parent = getByPath(obj, keys);
            if (parent) {
                delete parent[propertyToRemove];
            }
        }
        else {
            delete obj[propertyToRemove];
        }
    }
    return obj;
}
// eslint-disable-next-line default-param-last
function flatten(obj, delim = '/', stop) {
    const ret = {};
    Object.keys(obj).forEach((key) => {
        const val = obj[key];
        let deep = typeof val === 'object' || Array.isArray(val);
        if (deep && stop && stop(val)) {
            deep = false;
        }
        if (deep) {
            const flatObject = flatten(val, delim, stop);
            Object.keys(flatObject).forEach((flatKey) => {
                ret[key + delim + flatKey] = flatObject[flatKey];
            });
        }
        else {
            ret[key] = val;
        }
    });
    // eslint-disable-next-line no-restricted-syntax
    for (const key in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, key)) {
            continue;
        }
    }
    return ret;
}
//# sourceMappingURL=object.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/platform/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/platform/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Platform: () => (/* binding */ Platform)
/* harmony export */ });
/* eslint-disable no-underscore-dangle */
let _IS_MAC = false;
let _IS_IOS = false;
let _IS_WINDOWS = false;
let _IS_IE = false;
let _IS_IE11 = false;
let _IS_EDGE = false;
let _IS_NETSCAPE = false;
let _IS_CHROME_APP = false;
let _IS_CHROME = false;
let _IS_OPERA = false;
let _IS_FIREFOX = false;
let _IS_SAFARI = false;
let _SUPPORT_TOUCH = false;
let _SUPPORT_POINTER = false;
let _SUPPORT_PASSIVE = false;
let _NO_FOREIGNOBJECT = false;
if (typeof navigator === 'object') {
    const ua = navigator.userAgent;
    _IS_MAC = ua.indexOf('Macintosh') >= 0;
    _IS_IOS = !!ua.match(/(iPad|iPhone|iPod)/g);
    _IS_WINDOWS = ua.indexOf('Windows') >= 0;
    _IS_IE = ua.indexOf('MSIE') >= 0;
    _IS_IE11 = !!ua.match(/Trident\/7\./);
    _IS_EDGE = !!ua.match(/Edge\//);
    _IS_NETSCAPE =
        ua.indexOf('Mozilla/') >= 0 &&
            ua.indexOf('MSIE') < 0 &&
            ua.indexOf('Edge/') < 0;
    _IS_CHROME = ua.indexOf('Chrome/') >= 0 && ua.indexOf('Edge/') < 0;
    _IS_OPERA = ua.indexOf('Opera/') >= 0 || ua.indexOf('OPR/') >= 0;
    _IS_FIREFOX = ua.indexOf('Firefox/') >= 0;
    _IS_SAFARI =
        ua.indexOf('AppleWebKit/') >= 0 &&
            ua.indexOf('Chrome/') < 0 &&
            ua.indexOf('Edge/') < 0;
    if (typeof document === 'object') {
        _NO_FOREIGNOBJECT =
            !document.createElementNS ||
                `${document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject')}` !== '[object SVGForeignObjectElement]' ||
                ua.indexOf('Opera/') >= 0;
    }
}
if (typeof window === 'object') {
    _IS_CHROME_APP =
        window.chrome != null &&
            window.chrome.app != null &&
            window.chrome.app.runtime != null;
    _SUPPORT_POINTER = window.PointerEvent != null && !_IS_MAC;
}
if (typeof document === 'object') {
    _SUPPORT_TOUCH = 'ontouchstart' in document.documentElement;
    try {
        const options = Object.defineProperty({}, 'passive', {
            get() {
                _SUPPORT_PASSIVE = true;
            },
        });
        const div = document.createElement('div');
        if (div.addEventListener) {
            div.addEventListener('click', () => { }, options);
        }
    }
    catch (err) {
        // pass
    }
}
var Platform;
(function (Platform) {
    Platform.IS_MAC = _IS_MAC;
    Platform.IS_IOS = _IS_IOS;
    Platform.IS_WINDOWS = _IS_WINDOWS;
    Platform.IS_IE = _IS_IE;
    Platform.IS_IE11 = _IS_IE11;
    Platform.IS_EDGE = _IS_EDGE;
    /**
     * A flag indicating whether the browser is Netscape (including Firefox).
     */
    Platform.IS_NETSCAPE = _IS_NETSCAPE;
    /**
     * A flag indicating whether the the this is running inside a Chrome App.
     */
    Platform.IS_CHROME_APP = _IS_CHROME_APP;
    Platform.IS_CHROME = _IS_CHROME;
    Platform.IS_OPERA = _IS_OPERA;
    Platform.IS_FIREFOX = _IS_FIREFOX;
    Platform.IS_SAFARI = _IS_SAFARI;
    /**
     * A flag indicating whether this device supports touchstart/-move/-end
     * events (Apple iOS, Android, Chromebook and Chrome Browser on touch-enabled
     * devices).
     */
    Platform.SUPPORT_TOUCH = _SUPPORT_TOUCH;
    /**
     * A flag indicating whether this device supports Microsoft pointer events.
     */
    Platform.SUPPORT_POINTER = _SUPPORT_POINTER;
    Platform.SUPPORT_PASSIVE = _SUPPORT_PASSIVE;
    /**
     * A flag indicating whether foreignObject support is not available. This
     * is the case for Opera, older SVG-based browsers and all versions of IE.
     */
    Platform.NO_FOREIGNOBJECT = _NO_FOREIGNOBJECT;
    Platform.SUPPORT_FOREIGNOBJECT = !Platform.NO_FOREIGNOBJECT;
})(Platform || (Platform = {}));
(function (Platform) {
    function getHMRStatus() {
        const mod = window.module;
        if (mod != null && mod.hot != null && mod.hot.status != null) {
            return mod.hot.status();
        }
        return 'unkonwn';
    }
    Platform.getHMRStatus = getHMRStatus;
    function isApplyingHMR() {
        return getHMRStatus() === 'apply';
    }
    Platform.isApplyingHMR = isApplyingHMR;
    // This function checks if the specified event is supported by the browser.
    // Source: http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
    const TAGNAMES = {
        select: 'input',
        change: 'input',
        submit: 'form',
        reset: 'form',
        error: 'img',
        load: 'img',
        abort: 'img',
    };
    function isEventSupported(event) {
        const elem = document.createElement(TAGNAMES[event] || 'div');
        const eventName = `on${event}`;
        let isSupported = eventName in elem;
        if (!isSupported) {
            elem.setAttribute(eventName, 'return;');
            isSupported = typeof elem[eventName] === 'function';
        }
        return isSupported;
    }
    Platform.isEventSupported = isEventSupported;
})(Platform || (Platform = {}));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/polyfill/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/polyfill/index.js ***!
  \***********************************************************/
/***/ (() => {

// compatible with NodeList.prototype.forEach() before chrome 51
// https://developer.mozilla.org/en-US/docs/Web/API/NodeList/forEach
if (typeof window === 'object' &&
    window.NodeList &&
    !NodeList.prototype.forEach) {
    NodeList.prototype.forEach = Array.prototype.forEach;
}
// compatible with ParentNode.append() before chrome 54
// https://github.com/jserz/js_piece/blob/master/DOM/ParentNode/append()/append().md
if (typeof window !== 'undefined') {
    ;
    (function (arr) {
        arr.forEach((item) => {
            if (Object.prototype.hasOwnProperty.call(item, 'append')) {
                return;
            }
            Object.defineProperty(item, 'append', {
                configurable: true,
                enumerable: true,
                writable: true,
                value(...args) {
                    const docFrag = document.createDocumentFragment();
                    args.forEach((arg) => {
                        const isNode = arg instanceof Node;
                        docFrag.appendChild(isNode ? arg : document.createTextNode(String(arg)));
                    });
                    this.appendChild(docFrag);
                },
            });
        });
    })([Element.prototype, Document.prototype, DocumentFragment.prototype]);
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/size-sensor/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/size-sensor/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SizeSensor: () => (/* binding */ SizeSensor)
/* harmony export */ });
/* harmony import */ var _sensors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sensors */ "./node_modules/@antv/x6-common/es/size-sensor/sensors/index.js");

var SizeSensor;
(function (SizeSensor) {
    const cache = new WeakMap();
    function get(element) {
        let sensor = cache.get(element);
        if (sensor) {
            return sensor;
        }
        sensor = (0,_sensors__WEBPACK_IMPORTED_MODULE_0__.createSensor)(element);
        cache.set(element, sensor);
        return sensor;
    }
    function remove(sensor) {
        sensor.destroy();
        cache.delete(sensor.element);
    }
    SizeSensor.bind = (element, cb) => {
        const sensor = get(element);
        sensor.bind(cb);
        return () => sensor.unbind(cb);
    };
    SizeSensor.clear = (element) => {
        const sensor = get(element);
        remove(sensor);
    };
})(SizeSensor || (SizeSensor = {}));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/size-sensor/sensors/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/size-sensor/sensors/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createSensor: () => (/* binding */ createSensor)
/* harmony export */ });
/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./object */ "./node_modules/@antv/x6-common/es/size-sensor/sensors/object.js");
/* harmony import */ var _observer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./observer */ "./node_modules/@antv/x6-common/es/size-sensor/sensors/observer.js");


const createSensor = typeof ResizeObserver !== 'undefined'
    ? _observer__WEBPACK_IMPORTED_MODULE_1__.createSensor
    : _object__WEBPACK_IMPORTED_MODULE_0__.createSensor;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/size-sensor/sensors/object.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/size-sensor/sensors/object.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createSensor: () => (/* binding */ createSensor)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6-common/es/size-sensor/sensors/util.js");

function createSensor(element) {
    let sensor = null;
    let listeners = [];
    const create = () => {
        if (getComputedStyle(element).position === 'static') {
            const style = element.style;
            style.position = 'relative';
        }
        const obj = document.createElement('object');
        obj.onload = () => {
            obj.contentDocument.defaultView.addEventListener('resize', trigger);
            trigger();
        };
        obj.style.display = 'block';
        obj.style.position = 'absolute';
        obj.style.top = '0';
        obj.style.left = '0';
        obj.style.height = '100%';
        obj.style.width = '100%';
        obj.style.overflow = 'hidden';
        obj.style.pointerEvents = 'none';
        obj.style.zIndex = '-1';
        obj.style.opacity = '0';
        obj.setAttribute('tabindex', '-1');
        obj.type = 'text/html';
        element.appendChild(obj);
        // for ie, should set data attribute delay, or will be white screen
        obj.data = 'about:blank';
        return obj;
    };
    const trigger = (0,_util__WEBPACK_IMPORTED_MODULE_0__.debounce)(() => {
        listeners.forEach((listener) => listener(element));
    });
    const bind = (listener) => {
        if (!sensor) {
            sensor = create();
        }
        if (listeners.indexOf(listener) === -1) {
            listeners.push(listener);
        }
    };
    const destroy = () => {
        if (sensor && sensor.parentNode) {
            if (sensor.contentDocument) {
                sensor.contentDocument.defaultView.removeEventListener('resize', trigger);
            }
            sensor.parentNode.removeChild(sensor);
            sensor = null;
            listeners = [];
        }
    };
    const unbind = (listener) => {
        const idx = listeners.indexOf(listener);
        if (idx !== -1) {
            listeners.splice(idx, 1);
        }
        // no listener, and sensor is exist then destroy the sensor
        if (listeners.length === 0 && sensor) {
            destroy();
        }
    };
    return {
        element,
        bind,
        destroy,
        unbind,
    };
}
//# sourceMappingURL=object.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/size-sensor/sensors/observer.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/size-sensor/sensors/observer.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createSensor: () => (/* binding */ createSensor)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6-common/es/size-sensor/sensors/util.js");

function createSensor(element) {
    let sensor = null;
    let listeners = [];
    const trigger = (0,_util__WEBPACK_IMPORTED_MODULE_0__.debounce)(() => {
        listeners.forEach((listener) => {
            listener(element);
        });
    });
    const create = () => {
        const s = new ResizeObserver(trigger);
        s.observe(element);
        trigger();
        return s;
    };
    const bind = (listener) => {
        if (!sensor) {
            sensor = create();
        }
        if (listeners.indexOf(listener) === -1) {
            listeners.push(listener);
        }
    };
    const destroy = () => {
        if (sensor) {
            sensor.disconnect();
            listeners = [];
            sensor = null;
        }
    };
    const unbind = (listener) => {
        const idx = listeners.indexOf(listener);
        if (idx !== -1) {
            listeners.splice(idx, 1);
        }
        // no listener, and sensor is exist then destroy the sensor
        if (listeners.length === 0 && sensor) {
            destroy();
        }
    };
    return {
        element,
        bind,
        destroy,
        unbind,
    };
}
//# sourceMappingURL=observer.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/size-sensor/sensors/util.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/size-sensor/sensors/util.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   debounce: () => (/* binding */ debounce)
/* harmony export */ });
function debounce(fn, delay = 60) {
    let timer = null;
    return (...args) => {
        if (timer) {
            clearTimeout(timer);
        }
        timer = window.setTimeout(() => {
            fn.apply(this, args);
        }, delay);
    };
}
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/string/format.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/string/format.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   camelCase: () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   constantCase: () => (/* binding */ constantCase),
/* harmony export */   dotCase: () => (/* binding */ dotCase),
/* harmony export */   kebabCase: () => (/* binding */ kebabCase),
/* harmony export */   lowerFirst: () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   pascalCase: () => (/* binding */ pascalCase),
/* harmony export */   pathCase: () => (/* binding */ pathCase),
/* harmony export */   sentenceCase: () => (/* binding */ sentenceCase),
/* harmony export */   titleCase: () => (/* binding */ titleCase),
/* harmony export */   upperFirst: () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/startCase.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/camelCase.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/upperCase.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/lowerCase.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/upperFirst.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/lowerFirst.js");


// @see: https://medium.com/@robertsavian/javascript-case-converters-using-lodash-4f2f964091cc
const cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return ((str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    });
};
const kebabCase = cacheStringFunction((s) => s.replace(/\B([A-Z])/g, '-$1').toLowerCase());
const pascalCase = cacheStringFunction((s) => (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])((0,lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])(s)).replace(/ /g, ''));
const constantCase = cacheStringFunction((s) => (0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(s).replace(/ /g, '_'));
const dotCase = cacheStringFunction((s) => (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(s).replace(/ /g, '.'));
const pathCase = cacheStringFunction((s) => (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(s).replace(/ /g, '/'));
const sentenceCase = cacheStringFunction((s) => (0,lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"])((0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(s)));
const titleCase = cacheStringFunction((s) => (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])((0,lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])(s)));
//# sourceMappingURL=format.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/string/hashcode.js":
/*!************************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/string/hashcode.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hashcode: () => (/* binding */ hashcode)
/* harmony export */ });
/* eslint-disable no-bitwise */
/**
 * Return a simple hash code from a string.
 * Source from: https://github.com/sindresorhus/fnv1a/blob/master/index.js#L25
 */
function hashcode(str) {
    let hash = 2166136261;
    let isUnicoded = false;
    let string = str;
    for (let i = 0, ii = string.length; i < ii; i += 1) {
        let characterCode = string.charCodeAt(i);
        // Non-ASCII characters trigger the Unicode escape logic
        if (characterCode > 0x7f && !isUnicoded) {
            string = unescape(encodeURIComponent(string));
            characterCode = string.charCodeAt(i);
            isUnicoded = true;
        }
        hash ^= characterCode;
        hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
    }
    return hash >>> 0;
}
//# sourceMappingURL=hashcode.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/string/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/string/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StringExt: () => (/* reexport module object */ _string__WEBPACK_IMPORTED_MODULE_0__)
/* harmony export */ });
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./string */ "./node_modules/@antv/x6-common/es/string/string.js");


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/string/string.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/string/string.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   camelCase: () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_1__.camelCase),
/* harmony export */   constantCase: () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_1__.constantCase),
/* harmony export */   dotCase: () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_1__.dotCase),
/* harmony export */   getSpellingSuggestion: () => (/* reexport safe */ _suggestion__WEBPACK_IMPORTED_MODULE_4__.getSpellingSuggestion),
/* harmony export */   hashcode: () => (/* reexport safe */ _hashcode__WEBPACK_IMPORTED_MODULE_2__.hashcode),
/* harmony export */   kebabCase: () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_1__.kebabCase),
/* harmony export */   lowerFirst: () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_1__.lowerFirst),
/* harmony export */   pascalCase: () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_1__.pascalCase),
/* harmony export */   pathCase: () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_1__.pathCase),
/* harmony export */   sentenceCase: () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_1__.sentenceCase),
/* harmony export */   titleCase: () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_1__.titleCase),
/* harmony export */   uniqueId: () => (/* reexport safe */ lodash_es__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   upperFirst: () => (/* reexport safe */ _format__WEBPACK_IMPORTED_MODULE_1__.upperFirst),
/* harmony export */   uuid: () => (/* reexport safe */ _uuid__WEBPACK_IMPORTED_MODULE_3__.uuid)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/uniqueId.js");
/* harmony import */ var _format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./format */ "./node_modules/@antv/x6-common/es/string/format.js");
/* harmony import */ var _hashcode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hashcode */ "./node_modules/@antv/x6-common/es/string/hashcode.js");
/* harmony import */ var _uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./uuid */ "./node_modules/@antv/x6-common/es/string/uuid.js");
/* harmony import */ var _suggestion__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./suggestion */ "./node_modules/@antv/x6-common/es/string/suggestion.js");





//# sourceMappingURL=string.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/string/suggestion.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/string/suggestion.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getSpellingSuggestion: () => (/* binding */ getSpellingSuggestion)
/* harmony export */ });
// @see: https://github.com/microsoft/TypeScript/blob/master/src/compiler/checker.ts
/**
 * Given a name and a list of names that are not equal to the name, return a
 * spelling suggestion if there is one that is close enough. Names less than
 * length 3 only check for case-insensitive equality, not Levenshtein distance.
 *
 * - If there is a candidate that's the same except for case, return that.
 * - If there is a candidate that's within one edit of the name, return that.
 * - Otherwise, return the candidate with the smallest Levenshtein distance,
 *     except for candidates:
 *       * With no name
 *       * Whose length differs from the target name by more than 0.34 of the
 *         length of the name.
 *       * Whose levenshtein distance is more than 0.4 of the length of the
 *         name (0.4 allows 1 substitution/transposition for every 5 characters,
 *         and 1 insertion/deletion at 3 characters)
 */
function getSpellingSuggestion(name, candidates, getName) {
    const maximumLengthDifference = Math.min(2, Math.floor(name.length * 0.34));
    // If the best result isn't better than this, don't bother.
    let bestDistance = Math.floor(name.length * 0.4) + 1;
    let bestCandidate;
    let justCheckExactMatches = false;
    const nameLowerCase = name.toLowerCase();
    // eslint-disable-next-line
    for (const candidate of candidates) {
        const candidateName = getName(candidate);
        if (candidateName !== undefined &&
            Math.abs(candidateName.length - nameLowerCase.length) <=
                maximumLengthDifference) {
            const candidateNameLowerCase = candidateName.toLowerCase();
            if (candidateNameLowerCase === nameLowerCase) {
                if (candidateName === name) {
                    continue;
                }
                return candidate;
            }
            if (justCheckExactMatches) {
                continue;
            }
            if (candidateName.length < 3) {
                // Don't bother, user would have noticed a
                // 2-character name having an extra character.
                continue;
            }
            // Only care about a result better than the best so far.
            const distance = levenshteinWithMax(nameLowerCase, candidateNameLowerCase, bestDistance - 1);
            if (distance === undefined) {
                continue;
            }
            if (distance < 3) {
                justCheckExactMatches = true;
                bestCandidate = candidate;
            }
            else {
                // Debug.assert(distance < bestDistance)
                bestDistance = distance;
                bestCandidate = candidate;
            }
        }
    }
    return bestCandidate;
}
function levenshteinWithMax(s1, s2, max) {
    let previous = new Array(s2.length + 1); // eslint-disable-line
    let current = new Array(s2.length + 1); // eslint-disable-line
    /** Represents any value > max. We don't care about the particular value. */
    const big = max + 1;
    for (let i = 0; i <= s2.length; i += 1) {
        previous[i] = i;
    }
    for (let i = 1; i <= s1.length; i += 1) {
        const c1 = s1.charCodeAt(i - 1);
        const minJ = i > max ? i - max : 1;
        const maxJ = s2.length > max + i ? max + i : s2.length;
        current[0] = i;
        /** Smallest value of the matrix in the ith column. */
        let colMin = i;
        for (let j = 1; j < minJ; j += 1) {
            current[j] = big;
        }
        for (let j = minJ; j <= maxJ; j += 1) {
            const dist = c1 === s2.charCodeAt(j - 1)
                ? previous[j - 1]
                : Math.min(
                /* delete */ previous[j] + 1, 
                /* insert */ current[j - 1] + 1, 
                /* substitute */ previous[j - 1] + 2);
            current[j] = dist;
            colMin = Math.min(colMin, dist);
        }
        for (let j = maxJ + 1; j <= s2.length; j += 1) {
            current[j] = big;
        }
        if (colMin > max) {
            // Give up -- everything in this column is > max
            // and it can't get better in future columns.
            return undefined;
        }
        const temp = previous;
        previous = current;
        current = temp;
    }
    const res = previous[s2.length];
    return res > max ? undefined : res;
}
//# sourceMappingURL=suggestion.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/string/uuid.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/string/uuid.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   uuid: () => (/* binding */ uuid)
/* harmony export */ });
/* eslint-disable no-bitwise */
function uuid() {
    // credit: http://stackoverflow.com/posts/2117523/revisions
    // return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    //   const r = (Math.random() * 16) | 0
    //   const v = c === 'x' ? r : (r & 0x3) | 0x8
    //   return v.toString(16)
    // })
    let res = '';
    const template = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';
    for (let i = 0, len = template.length; i < len; i += 1) {
        const s = template[i];
        const r = (Math.random() * 16) | 0;
        const v = s === 'x' ? r : s === 'y' ? (r & 0x3) | 0x8 : s;
        res += v.toString(16);
    }
    return res;
}
//# sourceMappingURL=uuid.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/text/annotate.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/text/annotate.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   annotate: () => (/* binding */ annotate),
/* harmony export */   findAnnotationsAtIndex: () => (/* binding */ findAnnotationsAtIndex),
/* harmony export */   findAnnotationsBetweenIndexes: () => (/* binding */ findAnnotationsBetweenIndexes),
/* harmony export */   shiftAnnotations: () => (/* binding */ shiftAnnotations)
/* harmony export */ });
/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../object */ "./node_modules/@antv/x6-common/es/object/index.js");
/* harmony import */ var _dom_attr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom/attr */ "./node_modules/@antv/x6-common/es/dom/attr.js");


function annotate(t, annotations, opt = {}) {
    const offset = opt.offset || 0;
    const compacted = [];
    const ret = [];
    let curr;
    let prev;
    let batch = null;
    for (let i = 0; i < t.length; i += 1) {
        curr = ret[i] = t[i];
        for (let j = 0, jj = annotations.length; j < jj; j += 1) {
            const annotation = annotations[j];
            const start = annotation.start + offset;
            const end = annotation.end + offset;
            if (i >= start && i < end) {
                if (typeof curr === 'string') {
                    curr = ret[i] = {
                        t: t[i],
                        attrs: annotation.attrs,
                    };
                }
                else {
                    curr.attrs = (0,_dom_attr__WEBPACK_IMPORTED_MODULE_1__.mergeAttrs)((0,_dom_attr__WEBPACK_IMPORTED_MODULE_1__.mergeAttrs)({}, curr.attrs), annotation.attrs);
                }
                if (opt.includeAnnotationIndices) {
                    if (curr.annotations == null) {
                        curr.annotations = [];
                    }
                    curr.annotations.push(j);
                }
            }
        }
        prev = ret[i - 1];
        if (!prev) {
            batch = curr;
        }
        else if (_object__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isObject(curr) && _object__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isObject(prev)) {
            batch = batch;
            // Both previous item and the current one are annotations.
            // If the attributes didn't change, merge the text.
            if (JSON.stringify(curr.attrs) === JSON.stringify(prev.attrs)) {
                batch.t += curr.t;
            }
            else {
                compacted.push(batch);
                batch = curr;
            }
        }
        else if (_object__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isObject(curr)) {
            // Previous item was a string, current item is an annotation.
            batch = batch;
            compacted.push(batch);
            batch = curr;
        }
        else if (_object__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isObject(prev)) {
            // Previous item was an annotation, current item is a string.
            batch = batch;
            compacted.push(batch);
            batch = curr;
        }
        else {
            // Both previous and current item are strings.
            batch = (batch || '') + curr;
        }
    }
    if (batch != null) {
        compacted.push(batch);
    }
    return compacted;
}
function findAnnotationsAtIndex(annotations, index) {
    return annotations
        ? annotations.filter((a) => a.start < index && index <= a.end)
        : [];
}
function findAnnotationsBetweenIndexes(annotations, start, end) {
    return annotations
        ? annotations.filter((a) => (start >= a.start && start < a.end) ||
            (end > a.start && end <= a.end) ||
            (a.start >= start && a.end < end))
        : [];
}
function shiftAnnotations(annotations, index, offset) {
    if (annotations) {
        annotations.forEach((a) => {
            if (a.start < index && a.end >= index) {
                a.end += offset;
            }
            else if (a.start >= index) {
                a.start += offset;
                a.end += offset;
            }
        });
    }
    return annotations;
}
//# sourceMappingURL=annotate.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/text/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/text/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Text: () => (/* reexport module object */ _main__WEBPACK_IMPORTED_MODULE_0__)
/* harmony export */ });
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main */ "./node_modules/@antv/x6-common/es/text/main.js");


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/text/main.js":
/*!******************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/text/main.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   annotate: () => (/* reexport safe */ _annotate__WEBPACK_IMPORTED_MODULE_0__.annotate),
/* harmony export */   findAnnotationsAtIndex: () => (/* reexport safe */ _annotate__WEBPACK_IMPORTED_MODULE_0__.findAnnotationsAtIndex),
/* harmony export */   findAnnotationsBetweenIndexes: () => (/* reexport safe */ _annotate__WEBPACK_IMPORTED_MODULE_0__.findAnnotationsBetweenIndexes),
/* harmony export */   sanitize: () => (/* reexport safe */ _sanitize__WEBPACK_IMPORTED_MODULE_1__.sanitize),
/* harmony export */   shiftAnnotations: () => (/* reexport safe */ _annotate__WEBPACK_IMPORTED_MODULE_0__.shiftAnnotations)
/* harmony export */ });
/* harmony import */ var _annotate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./annotate */ "./node_modules/@antv/x6-common/es/text/annotate.js");
/* harmony import */ var _sanitize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sanitize */ "./node_modules/@antv/x6-common/es/text/sanitize.js");


//# sourceMappingURL=main.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/text/sanitize.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/text/sanitize.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   sanitize: () => (/* binding */ sanitize)
/* harmony export */ });
/**
 * Replaces all spaces with the Unicode No-break space.
 * ref: http://www.fileformat.info/info/unicode/char/a0/index.htm
 *
 * IE would otherwise collapse all spaces into one. This is useful
 * e.g. in tests when you want to compare the actual DOM text content
 * without having to add the unicode character in the place of all spaces.
 */
function sanitize(text) {
    return text.replace(/ /g, '\u00A0');
}
//# sourceMappingURL=sanitize.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/types.js":
/*!**************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/types.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/unit/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/unit/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Unit: () => (/* binding */ Unit)
/* harmony export */ });
let millimeterSize;
const supportedUnits = {
    px(val) {
        return val;
    },
    mm(val) {
        return millimeterSize * val;
    },
    cm(val) {
        return millimeterSize * val * 10;
    },
    in(val) {
        return millimeterSize * val * 25.4;
    },
    pt(val) {
        return millimeterSize * ((25.4 * val) / 72);
    },
    pc(val) {
        return millimeterSize * ((25.4 * val) / 6);
    },
};
// eslint-disable-next-line
var Unit;
(function (Unit) {
    function measure(cssWidth, cssHeight, unit) {
        const div = document.createElement('div');
        const style = div.style;
        style.display = 'inline-block';
        style.position = 'absolute';
        style.left = '-15000px';
        style.top = '-15000px';
        style.width = cssWidth + (unit || 'px');
        style.height = cssHeight + (unit || 'px');
        document.body.appendChild(div);
        const rect = div.getBoundingClientRect();
        const size = {
            width: rect.width || 0,
            height: rect.height || 0,
        };
        document.body.removeChild(div);
        return size;
    }
    Unit.measure = measure;
    function toPx(val, unit) {
        if (millimeterSize == null) {
            millimeterSize = measure('1', '1', 'mm').width;
        }
        const convert = unit ? supportedUnits[unit] : null;
        if (convert) {
            return convert(val);
        }
        return val;
    }
    Unit.toPx = toPx;
})(Unit || (Unit = {}));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-common/es/vector/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6-common/es/vector/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Vector: () => (/* binding */ Vector)
/* harmony export */ });
/* harmony import */ var _dom_main__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom/main */ "./node_modules/@antv/x6-common/es/dom/main.js");

class Vector {
    get [Symbol.toStringTag]() {
        return Vector.toStringTag;
    }
    get type() {
        return this.node.nodeName;
    }
    get id() {
        return this.node.id;
    }
    set id(id) {
        this.node.id = id;
    }
    constructor(elem, attrs, children) {
        if (!elem) {
            throw new TypeError('Invalid element to create vector');
        }
        let node;
        if (Vector.isVector(elem)) {
            node = elem.node;
        }
        else if (typeof elem === 'string') {
            if (elem.toLowerCase() === 'svg') {
                node = _dom_main__WEBPACK_IMPORTED_MODULE_0__.createSvgDocument();
            }
            else if (elem[0] === '<') {
                const doc = _dom_main__WEBPACK_IMPORTED_MODULE_0__.createSvgDocument(elem);
                // only import the first child
                node = document.importNode(doc.firstChild, true);
            }
            else {
                node = document.createElementNS(_dom_main__WEBPACK_IMPORTED_MODULE_0__.ns.svg, elem);
            }
        }
        else {
            node = elem;
        }
        this.node = node;
        if (attrs) {
            this.setAttributes(attrs);
        }
        if (children) {
            this.append(children);
        }
    }
    transform(matrix, options) {
        if (matrix == null) {
            return _dom_main__WEBPACK_IMPORTED_MODULE_0__.transform(this.node);
        }
        _dom_main__WEBPACK_IMPORTED_MODULE_0__.transform(this.node, matrix, options);
        return this;
    }
    translate(tx, ty = 0, options = {}) {
        if (tx == null) {
            return _dom_main__WEBPACK_IMPORTED_MODULE_0__.translate(this.node);
        }
        _dom_main__WEBPACK_IMPORTED_MODULE_0__.translate(this.node, tx, ty, options);
        return this;
    }
    rotate(angle, cx, cy, options = {}) {
        if (angle == null) {
            return _dom_main__WEBPACK_IMPORTED_MODULE_0__.rotate(this.node);
        }
        _dom_main__WEBPACK_IMPORTED_MODULE_0__.rotate(this.node, angle, cx, cy, options);
        return this;
    }
    scale(sx, sy) {
        if (sx == null) {
            return _dom_main__WEBPACK_IMPORTED_MODULE_0__.scale(this.node);
        }
        _dom_main__WEBPACK_IMPORTED_MODULE_0__.scale(this.node, sx, sy);
        return this;
    }
    /**
     * Returns an SVGMatrix that specifies the transformation necessary
     * to convert this coordinate system into `target` coordinate system.
     */
    getTransformToElement(target) {
        const ref = Vector.toNode(target);
        return _dom_main__WEBPACK_IMPORTED_MODULE_0__.getTransformToElement(this.node, ref);
    }
    removeAttribute(name) {
        _dom_main__WEBPACK_IMPORTED_MODULE_0__.removeAttribute(this.node, name);
        return this;
    }
    getAttribute(name) {
        return _dom_main__WEBPACK_IMPORTED_MODULE_0__.getAttribute(this.node, name);
    }
    setAttribute(name, value) {
        _dom_main__WEBPACK_IMPORTED_MODULE_0__.setAttribute(this.node, name, value);
        return this;
    }
    setAttributes(attrs) {
        _dom_main__WEBPACK_IMPORTED_MODULE_0__.setAttributes(this.node, attrs);
        return this;
    }
    attr(name, value) {
        if (name == null) {
            return _dom_main__WEBPACK_IMPORTED_MODULE_0__.attr(this.node);
        }
        if (typeof name === 'string' && value === undefined) {
            return _dom_main__WEBPACK_IMPORTED_MODULE_0__.attr(this.node, name);
        }
        if (typeof name === 'object') {
            _dom_main__WEBPACK_IMPORTED_MODULE_0__.attr(this.node, name);
        }
        else {
            _dom_main__WEBPACK_IMPORTED_MODULE_0__.attr(this.node, name, value);
        }
        return this;
    }
    svg() {
        return this.node instanceof SVGSVGElement
            ? this
            : Vector.create(this.node.ownerSVGElement);
    }
    defs() {
        const context = this.svg() || this;
        const defsNode = context.node.getElementsByTagName('defs')[0];
        if (defsNode) {
            return Vector.create(defsNode);
        }
        return Vector.create('defs').appendTo(context);
    }
    text(content, options = {}) {
        _dom_main__WEBPACK_IMPORTED_MODULE_0__.text(this.node, content, options);
        return this;
    }
    tagName() {
        return _dom_main__WEBPACK_IMPORTED_MODULE_0__.tagName(this.node);
    }
    clone() {
        return Vector.create(this.node.cloneNode(true));
    }
    remove() {
        _dom_main__WEBPACK_IMPORTED_MODULE_0__.remove(this.node);
        return this;
    }
    empty() {
        _dom_main__WEBPACK_IMPORTED_MODULE_0__.empty(this.node);
        return this;
    }
    append(elems) {
        _dom_main__WEBPACK_IMPORTED_MODULE_0__.append(this.node, Vector.toNodes(elems));
        return this;
    }
    appendTo(target) {
        _dom_main__WEBPACK_IMPORTED_MODULE_0__.appendTo(this.node, Vector.isVector(target) ? target.node : target);
        return this;
    }
    prepend(elems) {
        _dom_main__WEBPACK_IMPORTED_MODULE_0__.prepend(this.node, Vector.toNodes(elems));
        return this;
    }
    before(elems) {
        _dom_main__WEBPACK_IMPORTED_MODULE_0__.before(this.node, Vector.toNodes(elems));
        return this;
    }
    replace(elem) {
        if (this.node.parentNode) {
            this.node.parentNode.replaceChild(Vector.toNode(elem), this.node);
        }
        return Vector.create(elem);
    }
    first() {
        return this.node.firstChild
            ? Vector.create(this.node.firstChild)
            : null;
    }
    last() {
        return this.node.lastChild
            ? Vector.create(this.node.lastChild)
            : null;
    }
    get(index) {
        const child = this.node.childNodes[index];
        return child ? Vector.create(child) : null;
    }
    indexOf(elem) {
        const children = Array.prototype.slice.call(this.node.childNodes);
        return children.indexOf(Vector.toNode(elem));
    }
    find(selector) {
        const vels = [];
        const nodes = _dom_main__WEBPACK_IMPORTED_MODULE_0__.find(this.node, selector);
        if (nodes) {
            for (let i = 0, ii = nodes.length; i < ii; i += 1) {
                vels.push(Vector.create(nodes[i]));
            }
        }
        return vels;
    }
    findOne(selector) {
        const found = _dom_main__WEBPACK_IMPORTED_MODULE_0__.findOne(this.node, selector);
        return found ? Vector.create(found) : null;
    }
    findParentByClass(className, terminator) {
        const node = _dom_main__WEBPACK_IMPORTED_MODULE_0__.findParentByClass(this.node, className, terminator);
        return node ? Vector.create(node) : null;
    }
    matches(selector) {
        const node = this.node;
        const matches = this.node.matches;
        const matcher = node.matches ||
            node.matchesSelector ||
            node.msMatchesSelector ||
            node.mozMatchesSelector ||
            node.webkitMatchesSelector ||
            node.oMatchesSelector ||
            null;
        return matcher && matcher.call(node, selector);
    }
    contains(child) {
        return _dom_main__WEBPACK_IMPORTED_MODULE_0__.contains(this.node, Vector.isVector(child) ? child.node : child);
    }
    wrap(node) {
        const vel = Vector.create(node);
        const parentNode = this.node.parentNode;
        if (parentNode != null) {
            parentNode.insertBefore(vel.node, this.node);
        }
        return vel.append(this);
    }
    parent(type) {
        let parent = this; // eslint-disable-line @typescript-eslint/no-this-alias
        // check for parent
        if (parent.node.parentNode == null) {
            return null;
        }
        // get parent element
        parent = Vector.create(parent.node.parentNode);
        if (type == null) {
            return parent;
        }
        // loop trough ancestors if type is given
        do {
            if (typeof type === 'string' ? parent.matches(type) : parent instanceof type) {
                return parent;
            }
        } while ((parent = Vector.create(parent.node.parentNode)));
        return parent;
    }
    children() {
        const children = this.node.childNodes;
        const vels = [];
        for (let i = 0; i < children.length; i += 1) {
            const currentChild = children[i];
            if (currentChild.nodeType === 1) {
                vels.push(Vector.create(children[i]));
            }
        }
        return vels;
    }
    eachChild(fn, deep) {
        const children = this.children();
        for (let i = 0, l = children.length; i < l; i += 1) {
            fn.call(children[i], children[i], i, children);
            if (deep) {
                children[i].eachChild(fn, deep);
            }
        }
        return this;
    }
    index() {
        return _dom_main__WEBPACK_IMPORTED_MODULE_0__.index(this.node);
    }
    hasClass(className) {
        return _dom_main__WEBPACK_IMPORTED_MODULE_0__.hasClass(this.node, className);
    }
    addClass(className) {
        _dom_main__WEBPACK_IMPORTED_MODULE_0__.addClass(this.node, className);
        return this;
    }
    removeClass(className) {
        _dom_main__WEBPACK_IMPORTED_MODULE_0__.removeClass(this.node, className);
        return this;
    }
    toggleClass(className, stateVal) {
        _dom_main__WEBPACK_IMPORTED_MODULE_0__.toggleClass(this.node, className, stateVal);
        return this;
    }
    toLocalPoint(x, y) {
        return _dom_main__WEBPACK_IMPORTED_MODULE_0__.toLocalPoint(this.node, x, y);
    }
    /**
     * Samples the underlying SVG element (it currently works only on
     * paths - where it is most useful anyway). Returns an array of objects
     * of the form `{ x: Number, y: Number, distance: Number }`. Each of these
     * objects represent a point on the path. This basically creates a discrete
     * representation of the path (which is possible a curve). The sampling
     * interval defines the accuracy of the sampling. In other words, we travel
     * from the beginning of the path to the end by interval distance (on the
     * path, not between the resulting points) and collect the discrete points
     * on the path. This is very useful in many situations. For example, SVG
     * does not provide a built-in mechanism to find intersections between two
     * paths. Using sampling, we can just generate bunch of points for each of
     * the path and find the closest ones from each set.
     */
    sample(interval = 1) {
        if (this.node instanceof SVGPathElement) {
            return _dom_main__WEBPACK_IMPORTED_MODULE_0__.sample(this.node, interval);
        }
        return [];
    }
    toPath() {
        return Vector.create(_dom_main__WEBPACK_IMPORTED_MODULE_0__.toPath(this.node));
    }
    toPathData() {
        return _dom_main__WEBPACK_IMPORTED_MODULE_0__.toPathData(this.node);
    }
}
(function (Vector) {
    Vector.toStringTag = `X6.${Vector.name}`;
    function isVector(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof Vector) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const vector = instance;
        if ((tag == null || tag === Vector.toStringTag) &&
            vector.node instanceof SVGElement &&
            typeof vector.sample === 'function' &&
            typeof vector.toPath === 'function') {
            return true;
        }
        return false;
    }
    Vector.isVector = isVector;
    function create(elem, attrs, children) {
        return new Vector(elem, attrs, children);
    }
    Vector.create = create;
    function createVectors(markup) {
        if (markup[0] === '<') {
            const svgDoc = _dom_main__WEBPACK_IMPORTED_MODULE_0__.createSvgDocument(markup);
            const vels = [];
            for (let i = 0, ii = svgDoc.childNodes.length; i < ii; i += 1) {
                const childNode = svgDoc.childNodes[i];
                vels.push(create(document.importNode(childNode, true)));
            }
            return vels;
        }
        return [create(markup)];
    }
    Vector.createVectors = createVectors;
    function toNode(elem) {
        if (isVector(elem)) {
            return elem.node;
        }
        return elem;
    }
    Vector.toNode = toNode;
    function toNodes(elems) {
        if (Array.isArray(elems)) {
            return elems.map((elem) => toNode(elem));
        }
        return [toNode(elems)];
    }
    Vector.toNodes = toNodes;
})(Vector || (Vector = {}));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-geometry/es/angle.js":
/*!****************************************************!*\
  !*** ./node_modules/@antv/x6-geometry/es/angle.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Angle: () => (/* binding */ Angle)
/* harmony export */ });
var Angle;
(function (Angle) {
    /**
     * Converts radian angle to degree angle.
     * @param rad The radians to convert.
     */
    function toDeg(rad) {
        return ((180 * rad) / Math.PI) % 360;
    }
    Angle.toDeg = toDeg;
    /**
     * Converts degree angle to radian angle.
     * @param deg The degree angle to convert.
     * @param over360
     */
    Angle.toRad = function (deg, over360 = false) {
        const d = over360 ? deg : deg % 360;
        return (d * Math.PI) / 180;
    };
    /**
     * Returns the angle in degrees and clamps its value between `0` and `360`.
     */
    function normalize(angle) {
        return (angle % 360) + (angle < 0 ? 360 : 0);
    }
    Angle.normalize = normalize;
})(Angle || (Angle = {}));
//# sourceMappingURL=angle.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-geometry/es/curve.js":
/*!****************************************************!*\
  !*** ./node_modules/@antv/x6-geometry/es/curve.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Curve: () => (/* binding */ Curve)
/* harmony export */ });
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./line */ "./node_modules/@antv/x6-geometry/es/line.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ "./node_modules/@antv/x6-geometry/es/point.js");
/* harmony import */ var _polyline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./polyline */ "./node_modules/@antv/x6-geometry/es/polyline.js");
/* harmony import */ var _rectangle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rectangle */ "./node_modules/@antv/x6-geometry/es/rectangle.js");
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./geometry */ "./node_modules/@antv/x6-geometry/es/geometry.js");





class Curve extends _geometry__WEBPACK_IMPORTED_MODULE_4__.Geometry {
    constructor(start, controlPoint1, controlPoint2, end) {
        super();
        this.PRECISION = 3;
        this.start = _point__WEBPACK_IMPORTED_MODULE_1__.Point.create(start);
        this.controlPoint1 = _point__WEBPACK_IMPORTED_MODULE_1__.Point.create(controlPoint1);
        this.controlPoint2 = _point__WEBPACK_IMPORTED_MODULE_1__.Point.create(controlPoint2);
        this.end = _point__WEBPACK_IMPORTED_MODULE_1__.Point.create(end);
    }
    bbox() {
        const start = this.start;
        const controlPoint1 = this.controlPoint1;
        const controlPoint2 = this.controlPoint2;
        const end = this.end;
        const x0 = start.x;
        const y0 = start.y;
        const x1 = controlPoint1.x;
        const y1 = controlPoint1.y;
        const x2 = controlPoint2.x;
        const y2 = controlPoint2.y;
        const x3 = end.x;
        const y3 = end.y;
        const points = []; // local extremes
        const tvalues = []; // t values of local extremes
        const bounds = [[], []];
        let a;
        let b;
        let c;
        let t;
        let t1;
        let t2;
        let b2ac;
        let sqrtb2ac;
        for (let i = 0; i < 2; i += 1) {
            if (i === 0) {
                b = 6 * x0 - 12 * x1 + 6 * x2;
                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
                c = 3 * x1 - 3 * x0;
            }
            else {
                b = 6 * y0 - 12 * y1 + 6 * y2;
                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
                c = 3 * y1 - 3 * y0;
            }
            if (Math.abs(a) < 1e-12) {
                if (Math.abs(b) < 1e-12) {
                    continue;
                }
                t = -c / b;
                if (t > 0 && t < 1)
                    tvalues.push(t);
                continue;
            }
            b2ac = b * b - 4 * c * a;
            sqrtb2ac = Math.sqrt(b2ac);
            if (b2ac < 0)
                continue;
            t1 = (-b + sqrtb2ac) / (2 * a);
            if (t1 > 0 && t1 < 1)
                tvalues.push(t1);
            t2 = (-b - sqrtb2ac) / (2 * a);
            if (t2 > 0 && t2 < 1)
                tvalues.push(t2);
        }
        let x;
        let y;
        let mt;
        let j = tvalues.length;
        const jlen = j;
        while (j) {
            j -= 1;
            t = tvalues[j];
            mt = 1 - t;
            x =
                mt * mt * mt * x0 +
                    3 * mt * mt * t * x1 +
                    3 * mt * t * t * x2 +
                    t * t * t * x3;
            bounds[0][j] = x;
            y =
                mt * mt * mt * y0 +
                    3 * mt * mt * t * y1 +
                    3 * mt * t * t * y2 +
                    t * t * t * y3;
            bounds[1][j] = y;
            points[j] = { X: x, Y: y };
        }
        tvalues[jlen] = 0;
        tvalues[jlen + 1] = 1;
        points[jlen] = { X: x0, Y: y0 };
        points[jlen + 1] = { X: x3, Y: y3 };
        bounds[0][jlen] = x0;
        bounds[1][jlen] = y0;
        bounds[0][jlen + 1] = x3;
        bounds[1][jlen + 1] = y3;
        tvalues.length = jlen + 2;
        bounds[0].length = jlen + 2;
        bounds[1].length = jlen + 2;
        points.length = jlen + 2;
        const left = Math.min.apply(null, bounds[0]);
        const top = Math.min.apply(null, bounds[1]);
        const right = Math.max.apply(null, bounds[0]);
        const bottom = Math.max.apply(null, bounds[1]);
        return new _rectangle__WEBPACK_IMPORTED_MODULE_3__.Rectangle(left, top, right - left, bottom - top);
    }
    closestPoint(p, options = {}) {
        return this.pointAtT(this.closestPointT(p, options));
    }
    closestPointLength(p, options = {}) {
        const opts = this.getOptions(options);
        return this.lengthAtT(this.closestPointT(p, opts), opts);
    }
    closestPointNormalizedLength(p, options = {}) {
        const opts = this.getOptions(options);
        const cpLength = this.closestPointLength(p, opts);
        if (!cpLength) {
            return 0;
        }
        const length = this.length(opts);
        if (length === 0) {
            return 0;
        }
        return cpLength / length;
    }
    closestPointT(p, options = {}) {
        const precision = this.getPrecision(options);
        const subdivisions = this.getDivisions(options);
        const precisionRatio = Math.pow(10, -precision); // eslint-disable-line
        let investigatedSubdivision = null;
        let investigatedSubdivisionStartT = 0;
        let investigatedSubdivisionEndT = 0;
        let distFromStart = 0;
        let distFromEnd = 0;
        let chordLength = 0;
        let minSumDist = null;
        const count = subdivisions.length;
        let piece = count > 0 ? 1 / count : 0;
        subdivisions.forEach((division, i) => {
            const startDist = division.start.distance(p);
            const endDist = division.end.distance(p);
            const sumDist = startDist + endDist;
            if (minSumDist == null || sumDist < minSumDist) {
                investigatedSubdivision = division;
                investigatedSubdivisionStartT = i * piece;
                investigatedSubdivisionEndT = (i + 1) * piece;
                distFromStart = startDist;
                distFromEnd = endDist;
                minSumDist = sumDist;
                chordLength = division.endpointDistance();
            }
        });
        // Recursively divide investigated subdivision, until distance between
        // baselinePoint and closest path endpoint is within `10^(-precision)`,
        // then return the closest endpoint of that final subdivision.
        // eslint-disable-next-line
        while (true) {
            // check if we have reached at least one required observed precision
            // - calculated as: the difference in distances from point to start and end divided by the distance
            // - note that this function is not monotonic = it doesn't converge stably but has "teeth"
            // - the function decreases while one of the endpoints is fixed but "jumps" whenever we switch
            // - this criterion works well for points lying far away from the curve
            const startPrecisionRatio = distFromStart
                ? Math.abs(distFromStart - distFromEnd) / distFromStart
                : 0;
            const endPrecisionRatio = distFromEnd != null
                ? Math.abs(distFromStart - distFromEnd) / distFromEnd
                : 0;
            const hasRequiredPrecision = startPrecisionRatio < precisionRatio ||
                endPrecisionRatio < precisionRatio;
            // check if we have reached at least one required minimal distance
            // - calculated as: the subdivision chord length multiplied by precisionRatio
            // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions
            // - this is a backup criterion that works well for points lying "almost at" the curve
            const hasMiniStartDistance = distFromStart
                ? distFromStart < chordLength * precisionRatio
                : true;
            const hasMiniEndDistance = distFromEnd
                ? distFromEnd < chordLength * precisionRatio
                : true;
            const hasMiniDistance = hasMiniStartDistance || hasMiniEndDistance;
            if (hasRequiredPrecision || hasMiniDistance) {
                return distFromStart <= distFromEnd
                    ? investigatedSubdivisionStartT
                    : investigatedSubdivisionEndT;
            }
            // otherwise, set up for next iteration
            const divided = investigatedSubdivision.divide(0.5);
            piece /= 2;
            const startDist1 = divided[0].start.distance(p);
            const endDist1 = divided[0].end.distance(p);
            const sumDist1 = startDist1 + endDist1;
            const startDist2 = divided[1].start.distance(p);
            const endDist2 = divided[1].end.distance(p);
            const sumDist2 = startDist2 + endDist2;
            if (sumDist1 <= sumDist2) {
                investigatedSubdivision = divided[0];
                investigatedSubdivisionEndT -= piece;
                distFromStart = startDist1;
                distFromEnd = endDist1;
            }
            else {
                investigatedSubdivision = divided[1];
                investigatedSubdivisionStartT += piece;
                distFromStart = startDist2;
                distFromEnd = endDist2;
            }
        }
    }
    closestPointTangent(p, options = {}) {
        return this.tangentAtT(this.closestPointT(p, options));
    }
    containsPoint(p, options = {}) {
        const polyline = this.toPolyline(options);
        return polyline.containsPoint(p);
    }
    divideAt(ratio, options = {}) {
        if (ratio <= 0) {
            return this.divideAtT(0);
        }
        if (ratio >= 1) {
            return this.divideAtT(1);
        }
        const t = this.tAt(ratio, options);
        return this.divideAtT(t);
    }
    divideAtLength(length, options = {}) {
        const t = this.tAtLength(length, options);
        return this.divideAtT(t);
    }
    divide(t) {
        return this.divideAtT(t);
    }
    divideAtT(t) {
        const start = this.start;
        const controlPoint1 = this.controlPoint1;
        const controlPoint2 = this.controlPoint2;
        const end = this.end;
        if (t <= 0) {
            return [
                new Curve(start, start, start, start),
                new Curve(start, controlPoint1, controlPoint2, end),
            ];
        }
        if (t >= 1) {
            return [
                new Curve(start, controlPoint1, controlPoint2, end),
                new Curve(end, end, end, end),
            ];
        }
        const dividerPoints = this.getSkeletonPoints(t);
        const startControl1 = dividerPoints.startControlPoint1;
        const startControl2 = dividerPoints.startControlPoint2;
        const divider = dividerPoints.divider;
        const dividerControl1 = dividerPoints.dividerControlPoint1;
        const dividerControl2 = dividerPoints.dividerControlPoint2;
        return [
            new Curve(start, startControl1, startControl2, divider),
            new Curve(divider, dividerControl1, dividerControl2, end),
        ];
    }
    endpointDistance() {
        return this.start.distance(this.end);
    }
    getSkeletonPoints(t) {
        const start = this.start;
        const control1 = this.controlPoint1;
        const control2 = this.controlPoint2;
        const end = this.end;
        // shortcuts for `t` values that are out of range
        if (t <= 0) {
            return {
                startControlPoint1: start.clone(),
                startControlPoint2: start.clone(),
                divider: start.clone(),
                dividerControlPoint1: control1.clone(),
                dividerControlPoint2: control2.clone(),
            };
        }
        if (t >= 1) {
            return {
                startControlPoint1: control1.clone(),
                startControlPoint2: control2.clone(),
                divider: end.clone(),
                dividerControlPoint1: end.clone(),
                dividerControlPoint2: end.clone(),
            };
        }
        const midpoint1 = new _line__WEBPACK_IMPORTED_MODULE_0__.Line(start, control1).pointAt(t);
        const midpoint2 = new _line__WEBPACK_IMPORTED_MODULE_0__.Line(control1, control2).pointAt(t);
        const midpoint3 = new _line__WEBPACK_IMPORTED_MODULE_0__.Line(control2, end).pointAt(t);
        const subControl1 = new _line__WEBPACK_IMPORTED_MODULE_0__.Line(midpoint1, midpoint2).pointAt(t);
        const subControl2 = new _line__WEBPACK_IMPORTED_MODULE_0__.Line(midpoint2, midpoint3).pointAt(t);
        const divideLine = new _line__WEBPACK_IMPORTED_MODULE_0__.Line(subControl1, subControl2).pointAt(t);
        return {
            startControlPoint1: midpoint1,
            startControlPoint2: subControl1,
            divider: divideLine,
            dividerControlPoint1: subControl2,
            dividerControlPoint2: midpoint3,
        };
    }
    getSubdivisions(options = {}) {
        const precision = this.getPrecision(options);
        let subdivisions = [
            new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end),
        ];
        if (precision === 0) {
            return subdivisions;
        }
        let previousLength = this.endpointDistance();
        const precisionRatio = Math.pow(10, -precision); // eslint-disable-line
        // Recursively divide curve at `t = 0.5`, until the difference between
        // observed length at subsequent iterations is lower than precision.
        let iteration = 0;
        // eslint-disable-next-line
        while (true) {
            iteration += 1;
            const divisions = [];
            subdivisions.forEach((c) => {
                // dividing at t = 0.5 (not at middle length!)
                const divided = c.divide(0.5);
                divisions.push(divided[0], divided[1]);
            });
            // measure new length
            const length = divisions.reduce((memo, c) => memo + c.endpointDistance(), 0);
            // check if we have reached required observed precision
            // sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1
            // not a problem for further iterations because cubic curves cannot have more than two local extrema
            // (i.e. cubic curves cannot intersect the baseline more than once)
            // therefore two subsequent iterations cannot produce sampling with equal length
            const ratio = length !== 0 ? (length - previousLength) / length : 0;
            if (iteration > 1 && ratio < precisionRatio) {
                return divisions;
            }
            subdivisions = divisions;
            previousLength = length;
        }
    }
    length(options = {}) {
        const divisions = this.getDivisions(options);
        return divisions.reduce((memo, c) => {
            return memo + c.endpointDistance();
        }, 0);
    }
    lengthAtT(t, options = {}) {
        if (t <= 0) {
            return 0;
        }
        const precision = options.precision === undefined ? this.PRECISION : options.precision;
        const subCurve = this.divide(t)[0];
        return subCurve.length({ precision });
    }
    pointAt(ratio, options = {}) {
        if (ratio <= 0) {
            return this.start.clone();
        }
        if (ratio >= 1) {
            return this.end.clone();
        }
        const t = this.tAt(ratio, options);
        return this.pointAtT(t);
    }
    pointAtLength(length, options = {}) {
        const t = this.tAtLength(length, options);
        return this.pointAtT(t);
    }
    pointAtT(t) {
        if (t <= 0) {
            return this.start.clone();
        }
        if (t >= 1) {
            return this.end.clone();
        }
        return this.getSkeletonPoints(t).divider;
    }
    isDifferentiable() {
        const start = this.start;
        const control1 = this.controlPoint1;
        const control2 = this.controlPoint2;
        const end = this.end;
        return !(start.equals(control1) &&
            control1.equals(control2) &&
            control2.equals(end));
    }
    tangentAt(ratio, options = {}) {
        if (!this.isDifferentiable())
            return null;
        if (ratio < 0) {
            ratio = 0; // eslint-disable-line
        }
        else if (ratio > 1) {
            ratio = 1; // eslint-disable-line
        }
        const t = this.tAt(ratio, options);
        return this.tangentAtT(t);
    }
    tangentAtLength(length, options = {}) {
        if (!this.isDifferentiable()) {
            return null;
        }
        const t = this.tAtLength(length, options);
        return this.tangentAtT(t);
    }
    tangentAtT(t) {
        if (!this.isDifferentiable()) {
            return null;
        }
        if (t < 0) {
            t = 0; // eslint-disable-line
        }
        if (t > 1) {
            t = 1; // eslint-disable-line
        }
        const skeletonPoints = this.getSkeletonPoints(t);
        const p1 = skeletonPoints.startControlPoint2;
        const p2 = skeletonPoints.dividerControlPoint1;
        const tangentStart = skeletonPoints.divider;
        const tangentLine = new _line__WEBPACK_IMPORTED_MODULE_0__.Line(p1, p2);
        // move so that tangent line starts at the point requested
        tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y);
        return tangentLine;
    }
    getPrecision(options = {}) {
        return options.precision == null ? this.PRECISION : options.precision;
    }
    getDivisions(options = {}) {
        if (options.subdivisions != null) {
            return options.subdivisions;
        }
        const precision = this.getPrecision(options);
        return this.getSubdivisions({ precision });
    }
    getOptions(options = {}) {
        const precision = this.getPrecision(options);
        const subdivisions = this.getDivisions(options);
        return { precision, subdivisions };
    }
    tAt(ratio, options = {}) {
        if (ratio <= 0) {
            return 0;
        }
        if (ratio >= 1) {
            return 1;
        }
        const opts = this.getOptions(options);
        const total = this.length(opts);
        const length = total * ratio;
        return this.tAtLength(length, opts);
    }
    tAtLength(length, options = {}) {
        let fromStart = true;
        if (length < 0) {
            fromStart = false;
            length = -length; // eslint-disable-line
        }
        const precision = this.getPrecision(options);
        const subdivisions = this.getDivisions(options);
        const opts = { precision, subdivisions };
        let investigatedSubdivision = null;
        let investigatedSubdivisionStartT;
        let investigatedSubdivisionEndT;
        let baselinePointDistFromStart = 0;
        let baselinePointDistFromEnd = 0;
        let memo = 0;
        const count = subdivisions.length;
        let piece = count > 0 ? 1 / count : 0;
        for (let i = 0; i < count; i += 1) {
            const index = fromStart ? i : count - 1 - i;
            const division = subdivisions[i];
            const dist = division.endpointDistance();
            if (length <= memo + dist) {
                investigatedSubdivision = division;
                investigatedSubdivisionStartT = index * piece;
                investigatedSubdivisionEndT = (index + 1) * piece;
                baselinePointDistFromStart = fromStart
                    ? length - memo
                    : dist + memo - length;
                baselinePointDistFromEnd = fromStart
                    ? dist + memo - length
                    : length - memo;
                break;
            }
            memo += dist;
        }
        if (investigatedSubdivision == null) {
            return fromStart ? 1 : 0;
        }
        // note that precision affects what length is recorded
        // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)
        // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1
        const total = this.length(opts);
        const precisionRatio = Math.pow(10, -precision); // eslint-disable-line
        // recursively divide investigated subdivision:
        // until distance between baselinePoint and closest path endpoint is within 10^(-precision)
        // then return the closest endpoint of that final subdivision
        // eslint-disable-next-line
        while (true) {
            let ratio;
            ratio = total !== 0 ? baselinePointDistFromStart / total : 0;
            if (ratio < precisionRatio) {
                return investigatedSubdivisionStartT;
            }
            ratio = total !== 0 ? baselinePointDistFromEnd / total : 0;
            if (ratio < precisionRatio) {
                return investigatedSubdivisionEndT;
            }
            // otherwise, set up for next iteration
            let newBaselinePointDistFromStart;
            let newBaselinePointDistFromEnd;
            const divided = investigatedSubdivision.divide(0.5);
            piece /= 2;
            const baseline1Length = divided[0].endpointDistance();
            const baseline2Length = divided[1].endpointDistance();
            if (baselinePointDistFromStart <= baseline1Length) {
                investigatedSubdivision = divided[0];
                investigatedSubdivisionEndT -= piece;
                newBaselinePointDistFromStart = baselinePointDistFromStart;
                newBaselinePointDistFromEnd =
                    baseline1Length - newBaselinePointDistFromStart;
            }
            else {
                investigatedSubdivision = divided[1];
                investigatedSubdivisionStartT += piece;
                newBaselinePointDistFromStart =
                    baselinePointDistFromStart - baseline1Length;
                newBaselinePointDistFromEnd =
                    baseline2Length - newBaselinePointDistFromStart;
            }
            baselinePointDistFromStart = newBaselinePointDistFromStart;
            baselinePointDistFromEnd = newBaselinePointDistFromEnd;
        }
    }
    toPoints(options = {}) {
        const subdivisions = this.getDivisions(options);
        const points = [subdivisions[0].start.clone()];
        subdivisions.forEach((c) => points.push(c.end.clone()));
        return points;
    }
    toPolyline(options = {}) {
        return new _polyline__WEBPACK_IMPORTED_MODULE_2__.Polyline(this.toPoints(options));
    }
    scale(sx, sy, origin) {
        this.start.scale(sx, sy, origin);
        this.controlPoint1.scale(sx, sy, origin);
        this.controlPoint2.scale(sx, sy, origin);
        this.end.scale(sx, sy, origin);
        return this;
    }
    rotate(angle, origin) {
        this.start.rotate(angle, origin);
        this.controlPoint1.rotate(angle, origin);
        this.controlPoint2.rotate(angle, origin);
        this.end.rotate(angle, origin);
        return this;
    }
    translate(tx, ty) {
        if (typeof tx === 'number') {
            this.start.translate(tx, ty);
            this.controlPoint1.translate(tx, ty);
            this.controlPoint2.translate(tx, ty);
            this.end.translate(tx, ty);
        }
        else {
            this.start.translate(tx);
            this.controlPoint1.translate(tx);
            this.controlPoint2.translate(tx);
            this.end.translate(tx);
        }
        return this;
    }
    equals(c) {
        return (c != null &&
            this.start.equals(c.start) &&
            this.controlPoint1.equals(c.controlPoint1) &&
            this.controlPoint2.equals(c.controlPoint2) &&
            this.end.equals(c.end));
    }
    clone() {
        return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);
    }
    toJSON() {
        return {
            start: this.start.toJSON(),
            controlPoint1: this.controlPoint1.toJSON(),
            controlPoint2: this.controlPoint2.toJSON(),
            end: this.end.toJSON(),
        };
    }
    serialize() {
        return [
            this.start.serialize(),
            this.controlPoint1.serialize(),
            this.controlPoint2.serialize(),
            this.end.serialize(),
        ].join(' ');
    }
}
(function (Curve) {
    function isCurve(instance) {
        return instance != null && instance instanceof Curve;
    }
    Curve.isCurve = isCurve;
})(Curve || (Curve = {}));
(function (Curve) {
    function getFirstControlPoints(rhs) {
        const n = rhs.length;
        const x = []; // `x` is a solution vector.
        const tmp = [];
        let b = 2.0;
        x[0] = rhs[0] / b;
        // Decomposition and forward substitution.
        for (let i = 1; i < n; i += 1) {
            tmp[i] = 1 / b;
            b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];
            x[i] = (rhs[i] - x[i - 1]) / b;
        }
        for (let i = 1; i < n; i += 1) {
            // Backsubstitution.
            x[n - i - 1] -= tmp[n - i] * x[n - i];
        }
        return x;
    }
    function getCurveControlPoints(points) {
        const knots = points.map((p) => _point__WEBPACK_IMPORTED_MODULE_1__.Point.clone(p));
        const firstControlPoints = [];
        const secondControlPoints = [];
        const n = knots.length - 1;
        // Special case: Bezier curve should be a straight line.
        if (n === 1) {
            // 3P1 = 2P0 + P3
            firstControlPoints[0] = new _point__WEBPACK_IMPORTED_MODULE_1__.Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3);
            // P2 = 2P1 – P0
            secondControlPoints[0] = new _point__WEBPACK_IMPORTED_MODULE_1__.Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);
            return [firstControlPoints, secondControlPoints];
        }
        // Calculate first Bezier control points.
        // Right hand side vector.
        const rhs = [];
        // Set right hand side X values.
        for (let i = 1; i < n - 1; i += 1) {
            rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;
        }
        rhs[0] = knots[0].x + 2 * knots[1].x;
        rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;
        // Get first control points X-values.
        const x = getFirstControlPoints(rhs);
        // Set right hand side Y values.
        for (let i = 1; i < n - 1; i += 1) {
            rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;
        }
        rhs[0] = knots[0].y + 2 * knots[1].y;
        rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;
        // Get first control points Y-values.
        const y = getFirstControlPoints(rhs);
        // Fill output arrays.
        for (let i = 0; i < n; i += 1) {
            // First control point.
            firstControlPoints.push(new _point__WEBPACK_IMPORTED_MODULE_1__.Point(x[i], y[i]));
            // Second control point.
            if (i < n - 1) {
                secondControlPoints.push(new _point__WEBPACK_IMPORTED_MODULE_1__.Point(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]));
            }
            else {
                secondControlPoints.push(new _point__WEBPACK_IMPORTED_MODULE_1__.Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));
            }
        }
        return [firstControlPoints, secondControlPoints];
    }
    function throughPoints(points) {
        if (points == null || (Array.isArray(points) && points.length < 2)) {
            throw new Error('At least 2 points are required');
        }
        const controlPoints = getCurveControlPoints(points);
        const curves = [];
        for (let i = 0, ii = controlPoints[0].length; i < ii; i += 1) {
            const controlPoint1 = new _point__WEBPACK_IMPORTED_MODULE_1__.Point(controlPoints[0][i].x, controlPoints[0][i].y);
            const controlPoint2 = new _point__WEBPACK_IMPORTED_MODULE_1__.Point(controlPoints[1][i].x, controlPoints[1][i].y);
            curves.push(new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]));
        }
        return curves;
    }
    Curve.throughPoints = throughPoints;
})(Curve || (Curve = {}));
//# sourceMappingURL=curve.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-geometry/es/ellipse.js":
/*!******************************************************!*\
  !*** ./node_modules/@antv/x6-geometry/es/ellipse.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ellipse: () => (/* binding */ Ellipse)
/* harmony export */ });
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point */ "./node_modules/@antv/x6-geometry/es/point.js");
/* harmony import */ var _rectangle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rectangle */ "./node_modules/@antv/x6-geometry/es/rectangle.js");
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./geometry */ "./node_modules/@antv/x6-geometry/es/geometry.js");



class Ellipse extends _geometry__WEBPACK_IMPORTED_MODULE_2__.Geometry {
    get center() {
        return new _point__WEBPACK_IMPORTED_MODULE_0__.Point(this.x, this.y);
    }
    constructor(x, y, a, b) {
        super();
        this.x = x == null ? 0 : x;
        this.y = y == null ? 0 : y;
        this.a = a == null ? 0 : a;
        this.b = b == null ? 0 : b;
    }
    /**
     * Returns a rectangle that is the bounding box of the ellipse.
     */
    bbox() {
        return _rectangle__WEBPACK_IMPORTED_MODULE_1__.Rectangle.fromEllipse(this);
    }
    /**
     * Returns a point that is the center of the ellipse.
     */
    getCenter() {
        return this.center;
    }
    inflate(dx, dy) {
        const w = dx;
        const h = dy != null ? dy : dx;
        this.a += 2 * w;
        this.b += 2 * h;
        return this;
    }
    normalizedDistance(x, y) {
        const ref = _point__WEBPACK_IMPORTED_MODULE_0__.Point.create(x, y);
        const dx = ref.x - this.x;
        const dy = ref.y - this.y;
        const a = this.a;
        const b = this.b;
        return (dx * dx) / (a * a) + (dy * dy) / (b * b);
    }
    containsPoint(x, y) {
        return this.normalizedDistance(x, y) <= 1;
    }
    /**
     * Returns an array of the intersection points of the ellipse and the line.
     * Returns `null` if no intersection exists.
     */
    intersectsWithLine(line) {
        const intersections = [];
        const rx = this.a;
        const ry = this.b;
        const a1 = line.start;
        const a2 = line.end;
        const dir = line.vector();
        const diff = a1.diff(new _point__WEBPACK_IMPORTED_MODULE_0__.Point(this.x, this.y));
        const mDir = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(dir.x / (rx * rx), dir.y / (ry * ry));
        const mDiff = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(diff.x / (rx * rx), diff.y / (ry * ry));
        const a = dir.dot(mDir);
        const b = dir.dot(mDiff);
        const c = diff.dot(mDiff) - 1.0;
        const d = b * b - a * c;
        if (d < 0) {
            return null;
        }
        if (d > 0) {
            const root = Math.sqrt(d);
            const ta = (-b - root) / a;
            const tb = (-b + root) / a;
            if ((ta < 0 || ta > 1) && (tb < 0 || tb > 1)) {
                // outside
                return null;
            }
            if (ta >= 0 && ta <= 1) {
                intersections.push(a1.lerp(a2, ta));
            }
            if (tb >= 0 && tb <= 1) {
                intersections.push(a1.lerp(a2, tb));
            }
        }
        else {
            const t = -b / a;
            if (t >= 0 && t <= 1) {
                intersections.push(a1.lerp(a2, t));
            }
            else {
                // outside
                return null;
            }
        }
        return intersections;
    }
    /**
     * Returns the point on the boundary of the ellipse that is the
     * intersection of the ellipse with a line starting in the center
     * of the ellipse ending in the point `p`.
     *
     * If angle is specified, the intersection will take into account
     * the rotation of the ellipse by angle degrees around its center.
     */
    intersectsWithLineFromCenterToPoint(p, angle = 0) {
        const ref = _point__WEBPACK_IMPORTED_MODULE_0__.Point.clone(p);
        if (angle) {
            ref.rotate(angle, this.getCenter());
        }
        const dx = ref.x - this.x;
        const dy = ref.y - this.y;
        let result;
        if (dx === 0) {
            result = this.bbox().getNearestPointToPoint(ref);
            if (angle) {
                return result.rotate(-angle, this.getCenter());
            }
            return result;
        }
        const m = dy / dx;
        const mSquared = m * m;
        const aSquared = this.a * this.a;
        const bSquared = this.b * this.b;
        let x = Math.sqrt(1 / (1 / aSquared + mSquared / bSquared));
        x = dx < 0 ? -x : x;
        const y = m * x;
        result = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(this.x + x, this.y + y);
        if (angle) {
            return result.rotate(-angle, this.getCenter());
        }
        return result;
    }
    /**
     * Returns the angle between the x-axis and the tangent from a point. It is
     * valid for points lying on the ellipse boundary only.
     */
    tangentTheta(p) {
        const ref = _point__WEBPACK_IMPORTED_MODULE_0__.Point.clone(p);
        const x0 = ref.x;
        const y0 = ref.y;
        const a = this.a;
        const b = this.b;
        const center = this.bbox().center;
        const cx = center.x;
        const cy = center.y;
        const refPointDelta = 30;
        const q1 = x0 > center.x + a / 2;
        const q3 = x0 < center.x - a / 2;
        let x;
        let y;
        if (q1 || q3) {
            y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;
            x =
                (a * a) / (x0 - cx) -
                    (a * a * (y0 - cy) * (y - cy)) / (b * b * (x0 - cx)) +
                    cx;
        }
        else {
            x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;
            y =
                (b * b) / (y0 - cy) -
                    (b * b * (x0 - cx) * (x - cx)) / (a * a * (y0 - cy)) +
                    cy;
        }
        return new _point__WEBPACK_IMPORTED_MODULE_0__.Point(x, y).theta(ref);
    }
    scale(sx, sy) {
        this.a *= sx;
        this.b *= sy;
        return this;
    }
    rotate(angle, origin) {
        const rect = _rectangle__WEBPACK_IMPORTED_MODULE_1__.Rectangle.fromEllipse(this);
        rect.rotate(angle, origin);
        const ellipse = Ellipse.fromRect(rect);
        this.a = ellipse.a;
        this.b = ellipse.b;
        this.x = ellipse.x;
        this.y = ellipse.y;
        return this;
    }
    translate(dx, dy) {
        const p = _point__WEBPACK_IMPORTED_MODULE_0__.Point.create(dx, dy);
        this.x += p.x;
        this.y += p.y;
        return this;
    }
    equals(ellipse) {
        return (ellipse != null &&
            ellipse.x === this.x &&
            ellipse.y === this.y &&
            ellipse.a === this.a &&
            ellipse.b === this.b);
    }
    clone() {
        return new Ellipse(this.x, this.y, this.a, this.b);
    }
    toJSON() {
        return { x: this.x, y: this.y, a: this.a, b: this.b };
    }
    serialize() {
        return `${this.x} ${this.y} ${this.a} ${this.b}`;
    }
}
(function (Ellipse) {
    function isEllipse(instance) {
        return instance != null && instance instanceof Ellipse;
    }
    Ellipse.isEllipse = isEllipse;
})(Ellipse || (Ellipse = {}));
(function (Ellipse) {
    function create(x, y, a, b) {
        if (x == null || typeof x === 'number') {
            return new Ellipse(x, y, a, b);
        }
        return parse(x);
    }
    Ellipse.create = create;
    function parse(e) {
        if (Ellipse.isEllipse(e)) {
            return e.clone();
        }
        if (Array.isArray(e)) {
            return new Ellipse(e[0], e[1], e[2], e[3]);
        }
        return new Ellipse(e.x, e.y, e.a, e.b);
    }
    Ellipse.parse = parse;
    function fromRect(rect) {
        const center = rect.center;
        return new Ellipse(center.x, center.y, rect.width / 2, rect.height / 2);
    }
    Ellipse.fromRect = fromRect;
})(Ellipse || (Ellipse = {}));
//# sourceMappingURL=ellipse.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-geometry/es/geometry.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/x6-geometry/es/geometry.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Geometry: () => (/* binding */ Geometry)
/* harmony export */ });
class Geometry {
    valueOf() {
        return this.toJSON();
    }
    toString() {
        return JSON.stringify(this.toJSON());
    }
}
//# sourceMappingURL=geometry.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-geometry/es/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@antv/x6-geometry/es/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Angle: () => (/* reexport safe */ _angle__WEBPACK_IMPORTED_MODULE_0__.Angle),
/* harmony export */   Curve: () => (/* reexport safe */ _curve__WEBPACK_IMPORTED_MODULE_6__.Curve),
/* harmony export */   Ellipse: () => (/* reexport safe */ _ellipse__WEBPACK_IMPORTED_MODULE_3__.Ellipse),
/* harmony export */   GeometryUtil: () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_8__.GeometryUtil),
/* harmony export */   Line: () => (/* reexport safe */ _line__WEBPACK_IMPORTED_MODULE_2__.Line),
/* harmony export */   Path: () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_5__.Path),
/* harmony export */   Point: () => (/* reexport safe */ _point__WEBPACK_IMPORTED_MODULE_1__.Point),
/* harmony export */   Polyline: () => (/* reexport safe */ _polyline__WEBPACK_IMPORTED_MODULE_7__.Polyline),
/* harmony export */   Rectangle: () => (/* reexport safe */ _rectangle__WEBPACK_IMPORTED_MODULE_4__.Rectangle),
/* harmony export */   Segment: () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_5__.Segment),
/* harmony export */   normalizePathData: () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_5__.normalizePathData)
/* harmony export */ });
/* harmony import */ var _angle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./angle */ "./node_modules/@antv/x6-geometry/es/angle.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ "./node_modules/@antv/x6-geometry/es/point.js");
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line */ "./node_modules/@antv/x6-geometry/es/line.js");
/* harmony import */ var _ellipse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ellipse */ "./node_modules/@antv/x6-geometry/es/ellipse.js");
/* harmony import */ var _rectangle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rectangle */ "./node_modules/@antv/x6-geometry/es/rectangle.js");
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./path */ "./node_modules/@antv/x6-geometry/es/path/index.js");
/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./curve */ "./node_modules/@antv/x6-geometry/es/curve.js");
/* harmony import */ var _polyline__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./polyline */ "./node_modules/@antv/x6-geometry/es/polyline.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6-geometry/es/util.js");









//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-geometry/es/line.js":
/*!***************************************************!*\
  !*** ./node_modules/@antv/x6-geometry/es/line.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Line: () => (/* binding */ Line)
/* harmony export */ });
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point */ "./node_modules/@antv/x6-geometry/es/point.js");
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./geometry */ "./node_modules/@antv/x6-geometry/es/geometry.js");
/* harmony import */ var _rectangle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rectangle */ "./node_modules/@antv/x6-geometry/es/rectangle.js");



class Line extends _geometry__WEBPACK_IMPORTED_MODULE_1__.Geometry {
    get center() {
        return new _point__WEBPACK_IMPORTED_MODULE_0__.Point((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);
    }
    constructor(x1, y1, x2, y2) {
        super();
        if (typeof x1 === 'number' && typeof y1 === 'number') {
            this.start = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(x1, y1);
            this.end = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(x2, y2);
        }
        else {
            this.start = _point__WEBPACK_IMPORTED_MODULE_0__.Point.create(x1);
            this.end = _point__WEBPACK_IMPORTED_MODULE_0__.Point.create(y1);
        }
    }
    getCenter() {
        return this.center;
    }
    /**
     * Rounds the line to the given `precision`.
     */
    round(precision = 0) {
        this.start.round(precision);
        this.end.round(precision);
        return this;
    }
    translate(tx, ty) {
        if (typeof tx === 'number') {
            this.start.translate(tx, ty);
            this.end.translate(tx, ty);
        }
        else {
            this.start.translate(tx);
            this.end.translate(tx);
        }
        return this;
    }
    /**
     * Rotate the line by `angle` around `origin`.
     */
    rotate(angle, origin) {
        this.start.rotate(angle, origin);
        this.end.rotate(angle, origin);
        return this;
    }
    /**
     * Scale the line by `sx` and `sy` about the given `origin`. If origin is not
     * specified, the line is scaled around `0,0`.
     */
    scale(sx, sy, origin) {
        this.start.scale(sx, sy, origin);
        this.end.scale(sx, sy, origin);
        return this;
    }
    /**
     * Returns the length of the line.
     */
    length() {
        return Math.sqrt(this.squaredLength());
    }
    /**
     * Useful for distance comparisons in which real length is not necessary
     * (saves one `Math.sqrt()` operation).
     */
    squaredLength() {
        const dx = this.start.x - this.end.x;
        const dy = this.start.y - this.end.y;
        return dx * dx + dy * dy;
    }
    /**
     * Scale the line so that it has the requested length. The start point of
     * the line is preserved.
     */
    setLength(length) {
        const total = this.length();
        if (!total) {
            return this;
        }
        const scale = length / total;
        return this.scale(scale, scale, this.start);
    }
    parallel(distance) {
        const line = this.clone();
        if (!line.isDifferentiable()) {
            return line;
        }
        const { start, end } = line;
        const eRef = start.clone().rotate(270, end);
        const sRef = end.clone().rotate(90, start);
        start.move(sRef, distance);
        end.move(eRef, distance);
        return line;
    }
    /**
     * Returns the vector of the line with length equal to length of the line.
     */
    vector() {
        return new _point__WEBPACK_IMPORTED_MODULE_0__.Point(this.end.x - this.start.x, this.end.y - this.start.y);
    }
    /**
     * Returns the angle of incline of the line.
     *
     * The function returns `NaN` if the start and end endpoints of the line
     * both lie at the same coordinates(it is impossible to determine the angle
     * of incline of a line that appears to be a point). The
     * `line.isDifferentiable()` function may be used in advance to determine
     * whether the angle of incline can be computed for a given line.
     */
    angle() {
        const ref = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(this.start.x + 1, this.start.y);
        return this.start.angleBetween(this.end, ref);
    }
    /**
     * Returns a rectangle that is the bounding box of the line.
     */
    bbox() {
        const left = Math.min(this.start.x, this.end.x);
        const top = Math.min(this.start.y, this.end.y);
        const right = Math.max(this.start.x, this.end.x);
        const bottom = Math.max(this.start.y, this.end.y);
        return new _rectangle__WEBPACK_IMPORTED_MODULE_2__.Rectangle(left, top, right - left, bottom - top);
    }
    /**
     * Returns the bearing (cardinal direction) of the line.
     *
     * The return value is one of the following strings:
     * 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW' and 'N'.
     *
     * The function returns 'N' if the two endpoints of the line are coincident.
     */
    bearing() {
        return this.start.bearing(this.end);
    }
    /**
     * Returns the point on the line that lies closest to point `p`.
     */
    closestPoint(p) {
        return this.pointAt(this.closestPointNormalizedLength(p));
    }
    /**
     * Returns the length of the line up to the point that lies closest to point `p`.
     */
    closestPointLength(p) {
        return this.closestPointNormalizedLength(p) * this.length();
    }
    /**
     * Returns a line that is tangent to the line at the point that lies closest
     * to point `p`.
     */
    closestPointTangent(p) {
        return this.tangentAt(this.closestPointNormalizedLength(p));
    }
    /**
     * Returns the normalized length (distance from the start of the line / total
     * line length) of the line up to the point that lies closest to point.
     */
    closestPointNormalizedLength(p) {
        const product = this.vector().dot(new Line(this.start, p).vector());
        const normalized = Math.min(1, Math.max(0, product / this.squaredLength()));
        // normalized returns `NaN` if this line has zero length
        if (Number.isNaN(normalized)) {
            return 0;
        }
        return normalized;
    }
    /**
     * Returns a point on the line that lies `rate` (normalized length) away from
     * the beginning of the line.
     */
    pointAt(ratio) {
        const start = this.start;
        const end = this.end;
        if (ratio <= 0) {
            return start.clone();
        }
        if (ratio >= 1) {
            return end.clone();
        }
        return start.lerp(end, ratio);
    }
    /**
     * Returns a point on the line that lies length away from the beginning of
     * the line.
     */
    pointAtLength(length) {
        const start = this.start;
        const end = this.end;
        let fromStart = true;
        if (length < 0) {
            fromStart = false; // start calculation from end point
            length = -length; // eslint-disable-line
        }
        const total = this.length();
        if (length >= total) {
            return fromStart ? end.clone() : start.clone();
        }
        const rate = (fromStart ? length : total - length) / total;
        return this.pointAt(rate);
    }
    /**
     * Divides the line into two lines at the point that lies `rate` (normalized
     * length) away from the beginning of the line.
     */
    divideAt(ratio) {
        const dividerPoint = this.pointAt(ratio);
        return [
            new Line(this.start, dividerPoint),
            new Line(dividerPoint, this.end),
        ];
    }
    /**
     * Divides the line into two lines at the point that lies length away from
     * the beginning of the line.
     */
    divideAtLength(length) {
        const dividerPoint = this.pointAtLength(length);
        return [
            new Line(this.start, dividerPoint),
            new Line(dividerPoint, this.end),
        ];
    }
    /**
     * Returns `true` if the point `p` lies on the line. Return `false` otherwise.
     */
    containsPoint(p) {
        const start = this.start;
        const end = this.end;
        // cross product of 0 indicates that this line and
        // the vector to `p` are collinear.
        if (start.cross(p, end) !== 0) {
            return false;
        }
        const length = this.length();
        if (new Line(start, p).length() > length) {
            return false;
        }
        if (new Line(p, end).length() > length) {
            return false;
        }
        return true;
    }
    intersect(shape, options) {
        const ret = shape.intersectsWithLine(this, options);
        if (ret) {
            return Array.isArray(ret) ? ret : [ret];
        }
        return null;
    }
    /**
     * Returns the intersection point of the line with another line. Returns
     * `null` if no intersection exists.
     */
    intersectsWithLine(line) {
        const pt1Dir = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(this.end.x - this.start.x, this.end.y - this.start.y);
        const pt2Dir = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(line.end.x - line.start.x, line.end.y - line.start.y);
        const det = pt1Dir.x * pt2Dir.y - pt1Dir.y * pt2Dir.x;
        const deltaPt = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(line.start.x - this.start.x, line.start.y - this.start.y);
        const alpha = deltaPt.x * pt2Dir.y - deltaPt.y * pt2Dir.x;
        const beta = deltaPt.x * pt1Dir.y - deltaPt.y * pt1Dir.x;
        if (det === 0 || alpha * det < 0 || beta * det < 0) {
            return null;
        }
        if (det > 0) {
            if (alpha > det || beta > det) {
                return null;
            }
        }
        else if (alpha < det || beta < det) {
            return null;
        }
        return new _point__WEBPACK_IMPORTED_MODULE_0__.Point(this.start.x + (alpha * pt1Dir.x) / det, this.start.y + (alpha * pt1Dir.y) / det);
    }
    /**
     * Returns `true` if a tangent line can be found for the line.
     *
     * Tangents cannot be found if both of the line endpoints are coincident
     * (the line appears to be a point).
     */
    isDifferentiable() {
        return !this.start.equals(this.end);
    }
    /**
     * Returns the perpendicular distance between the line and point. The
     * distance is positive if the point lies to the right of the line, negative
     * if the point lies to the left of the line, and `0` if the point lies on
     * the line.
     */
    pointOffset(p) {
        const ref = _point__WEBPACK_IMPORTED_MODULE_0__.Point.clone(p);
        const start = this.start;
        const end = this.end;
        const determinant = (end.x - start.x) * (ref.y - start.y) -
            (end.y - start.y) * (ref.x - start.x);
        return determinant / this.length();
    }
    pointSquaredDistance(x, y) {
        const p = _point__WEBPACK_IMPORTED_MODULE_0__.Point.create(x, y);
        return this.closestPoint(p).squaredDistance(p);
    }
    pointDistance(x, y) {
        const p = _point__WEBPACK_IMPORTED_MODULE_0__.Point.create(x, y);
        return this.closestPoint(p).distance(p);
    }
    /**
     * Returns a line tangent to the line at point that lies `rate` (normalized
     * length) away from the beginning of the line.
     */
    tangentAt(ratio) {
        if (!this.isDifferentiable()) {
            return null;
        }
        const start = this.start;
        const end = this.end;
        const tangentStart = this.pointAt(ratio);
        const tangentLine = new Line(start, end);
        tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y);
        return tangentLine;
    }
    /**
     * Returns a line tangent to the line at point that lies `length` away from
     * the beginning of the line.
     */
    tangentAtLength(length) {
        if (!this.isDifferentiable()) {
            return null;
        }
        const start = this.start;
        const end = this.end;
        const tangentStart = this.pointAtLength(length);
        const tangentLine = new Line(start, end);
        tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y);
        return tangentLine;
    }
    relativeCcw(x, y) {
        const ref = _point__WEBPACK_IMPORTED_MODULE_0__.Point.create(x, y);
        let dx1 = ref.x - this.start.x;
        let dy1 = ref.y - this.start.y;
        const dx2 = this.end.x - this.start.x;
        const dy2 = this.end.y - this.start.y;
        let ccw = dx1 * dy2 - dy1 * dx2;
        if (ccw === 0) {
            ccw = dx1 * dx2 + dy1 * dy2;
            if (ccw > 0.0) {
                dx1 -= dx2;
                dy1 -= dy2;
                ccw = dx1 * dx2 + dy1 * dy2;
                if (ccw < 0.0) {
                    ccw = 0.0;
                }
            }
        }
        return ccw < 0.0 ? -1 : ccw > 0.0 ? 1 : 0;
    }
    /**
     * Return `true` if the line equals the other line.
     */
    equals(l) {
        return (l != null &&
            this.start.x === l.start.x &&
            this.start.y === l.start.y &&
            this.end.x === l.end.x &&
            this.end.y === l.end.y);
    }
    /**
     * Returns another line which is a clone of the line.
     */
    clone() {
        return new Line(this.start, this.end);
    }
    toJSON() {
        return { start: this.start.toJSON(), end: this.end.toJSON() };
    }
    serialize() {
        return [this.start.serialize(), this.end.serialize()].join(' ');
    }
}
(function (Line) {
    function isLine(instance) {
        return instance != null && instance instanceof Line;
    }
    Line.isLine = isLine;
})(Line || (Line = {}));
//# sourceMappingURL=line.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-geometry/es/path/close.js":
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6-geometry/es/path/close.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Close: () => (/* binding */ Close)
/* harmony export */ });
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../line */ "./node_modules/@antv/x6-geometry/es/line.js");
/* harmony import */ var _lineto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lineto */ "./node_modules/@antv/x6-geometry/es/path/lineto.js");
/* harmony import */ var _segment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./segment */ "./node_modules/@antv/x6-geometry/es/path/segment.js");



class Close extends _segment__WEBPACK_IMPORTED_MODULE_2__.Segment {
    get end() {
        if (!this.subpathStartSegment) {
            throw new Error('Missing subpath start segment. (This segment needs a subpath ' +
                'start segment (e.g. MoveTo), or segment has not yet been added' +
                ' to a path.)');
        }
        return this.subpathStartSegment.end;
    }
    get type() {
        return 'Z';
    }
    get line() {
        return new _line__WEBPACK_IMPORTED_MODULE_0__.Line(this.start, this.end);
    }
    bbox() {
        return this.line.bbox();
    }
    closestPoint(p) {
        return this.line.closestPoint(p);
    }
    closestPointLength(p) {
        return this.line.closestPointLength(p);
    }
    closestPointNormalizedLength(p) {
        return this.line.closestPointNormalizedLength(p);
    }
    closestPointTangent(p) {
        return this.line.closestPointTangent(p);
    }
    length() {
        return this.line.length();
    }
    divideAt(ratio) {
        const divided = this.line.divideAt(ratio);
        return [
            // do not actually cut into the segment, first divided part can stay as Z
            divided[1].isDifferentiable() ? new _lineto__WEBPACK_IMPORTED_MODULE_1__.LineTo(divided[0]) : this.clone(),
            new _lineto__WEBPACK_IMPORTED_MODULE_1__.LineTo(divided[1]),
        ];
    }
    divideAtLength(length) {
        const divided = this.line.divideAtLength(length);
        return [
            divided[1].isDifferentiable() ? new _lineto__WEBPACK_IMPORTED_MODULE_1__.LineTo(divided[0]) : this.clone(),
            new _lineto__WEBPACK_IMPORTED_MODULE_1__.LineTo(divided[1]),
        ];
    }
    getSubdivisions() {
        return [];
    }
    pointAt(ratio) {
        return this.line.pointAt(ratio);
    }
    pointAtLength(length) {
        return this.line.pointAtLength(length);
    }
    tangentAt(ratio) {
        return this.line.tangentAt(ratio);
    }
    tangentAtLength(length) {
        return this.line.tangentAtLength(length);
    }
    isDifferentiable() {
        if (!this.previousSegment || !this.subpathStartSegment) {
            return false;
        }
        return !this.start.equals(this.end);
    }
    scale() {
        return this;
    }
    rotate() {
        return this;
    }
    translate() {
        return this;
    }
    equals(s) {
        return (this.type === s.type &&
            this.start.equals(s.start) &&
            this.end.equals(s.end));
    }
    clone() {
        return new Close();
    }
    toJSON() {
        return {
            type: this.type,
            start: this.start.toJSON(),
            end: this.end.toJSON(),
        };
    }
    serialize() {
        return this.type;
    }
}
(function (Close) {
    function create() {
        return new Close();
    }
    Close.create = create;
})(Close || (Close = {}));
//# sourceMappingURL=close.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-geometry/es/path/curveto.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6-geometry/es/path/curveto.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CurveTo: () => (/* binding */ CurveTo)
/* harmony export */ });
/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../curve */ "./node_modules/@antv/x6-geometry/es/curve.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../point */ "./node_modules/@antv/x6-geometry/es/point.js");
/* harmony import */ var _segment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./segment */ "./node_modules/@antv/x6-geometry/es/path/segment.js");



class CurveTo extends _segment__WEBPACK_IMPORTED_MODULE_2__.Segment {
    constructor(arg0, arg1, arg2, arg3, arg4, arg5) {
        super();
        if (_curve__WEBPACK_IMPORTED_MODULE_0__.Curve.isCurve(arg0)) {
            this.controlPoint1 = arg0.controlPoint1.clone().round(2);
            this.controlPoint2 = arg0.controlPoint2.clone().round(2);
            this.endPoint = arg0.end.clone().round(2);
        }
        else if (typeof arg0 === 'number') {
            this.controlPoint1 = new _point__WEBPACK_IMPORTED_MODULE_1__.Point(arg0, arg1).round(2);
            this.controlPoint2 = new _point__WEBPACK_IMPORTED_MODULE_1__.Point(arg2, arg3).round(2);
            this.endPoint = new _point__WEBPACK_IMPORTED_MODULE_1__.Point(arg4, arg5).round(2);
        }
        else {
            this.controlPoint1 = _point__WEBPACK_IMPORTED_MODULE_1__.Point.create(arg0).round(2);
            this.controlPoint2 = _point__WEBPACK_IMPORTED_MODULE_1__.Point.create(arg1).round(2);
            this.endPoint = _point__WEBPACK_IMPORTED_MODULE_1__.Point.create(arg2).round(2);
        }
    }
    get type() {
        return 'C';
    }
    get curve() {
        return new _curve__WEBPACK_IMPORTED_MODULE_0__.Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);
    }
    bbox() {
        return this.curve.bbox();
    }
    closestPoint(p) {
        return this.curve.closestPoint(p);
    }
    closestPointLength(p) {
        return this.curve.closestPointLength(p);
    }
    closestPointNormalizedLength(p) {
        return this.curve.closestPointNormalizedLength(p);
    }
    closestPointTangent(p) {
        return this.curve.closestPointTangent(p);
    }
    length() {
        return this.curve.length();
    }
    divideAt(ratio, options = {}) {
        // TODO: fix options
        const divided = this.curve.divideAt(ratio, options);
        return [new CurveTo(divided[0]), new CurveTo(divided[1])];
    }
    divideAtLength(length, options = {}) {
        // TODO: fix options
        const divided = this.curve.divideAtLength(length, options);
        return [new CurveTo(divided[0]), new CurveTo(divided[1])];
    }
    divideAtT(t) {
        const divided = this.curve.divideAtT(t);
        return [new CurveTo(divided[0]), new CurveTo(divided[1])];
    }
    getSubdivisions() {
        return [];
    }
    pointAt(ratio) {
        return this.curve.pointAt(ratio);
    }
    pointAtLength(length) {
        return this.curve.pointAtLength(length);
    }
    tangentAt(ratio) {
        return this.curve.tangentAt(ratio);
    }
    tangentAtLength(length) {
        return this.curve.tangentAtLength(length);
    }
    isDifferentiable() {
        if (!this.previousSegment) {
            return false;
        }
        const start = this.start;
        const control1 = this.controlPoint1;
        const control2 = this.controlPoint2;
        const end = this.end;
        return !(start.equals(control1) &&
            control1.equals(control2) &&
            control2.equals(end));
    }
    scale(sx, sy, origin) {
        this.controlPoint1.scale(sx, sy, origin);
        this.controlPoint2.scale(sx, sy, origin);
        this.end.scale(sx, sy, origin);
        return this;
    }
    rotate(angle, origin) {
        this.controlPoint1.rotate(angle, origin);
        this.controlPoint2.rotate(angle, origin);
        this.end.rotate(angle, origin);
        return this;
    }
    translate(tx, ty) {
        if (typeof tx === 'number') {
            this.controlPoint1.translate(tx, ty);
            this.controlPoint2.translate(tx, ty);
            this.end.translate(tx, ty);
        }
        else {
            this.controlPoint1.translate(tx);
            this.controlPoint2.translate(tx);
            this.end.translate(tx);
        }
        return this;
    }
    equals(s) {
        return (this.start.equals(s.start) &&
            this.end.equals(s.end) &&
            this.controlPoint1.equals(s.controlPoint1) &&
            this.controlPoint2.equals(s.controlPoint2));
    }
    clone() {
        return new CurveTo(this.controlPoint1, this.controlPoint2, this.end);
    }
    toJSON() {
        return {
            type: this.type,
            start: this.start.toJSON(),
            controlPoint1: this.controlPoint1.toJSON(),
            controlPoint2: this.controlPoint2.toJSON(),
            end: this.end.toJSON(),
        };
    }
    serialize() {
        const c1 = this.controlPoint1;
        const c2 = this.controlPoint2;
        const end = this.end;
        return [this.type, c1.x, c1.y, c2.x, c2.y, end.x, end.y].join(' ');
    }
}
(function (CurveTo) {
    function create(...args) {
        const len = args.length;
        const arg0 = args[0];
        // curve provided
        if (_curve__WEBPACK_IMPORTED_MODULE_0__.Curve.isCurve(arg0)) {
            return new CurveTo(arg0);
        }
        // points provided
        if (_point__WEBPACK_IMPORTED_MODULE_1__.Point.isPointLike(arg0)) {
            if (len === 3) {
                return new CurveTo(args[0], args[1], args[2]);
            }
            // this is a poly-bezier segment
            const segments = [];
            for (let i = 0; i < len; i += 3) {
                segments.push(new CurveTo(args[i], args[i + 1], args[i + 2]));
            }
            return segments;
        }
        // coordinates provided
        if (len === 6) {
            return new CurveTo(args[0], args[1], args[2], args[3], args[4], args[5]);
        }
        // this is a poly-bezier segment
        const segments = [];
        for (let i = 0; i < len; i += 6) {
            segments.push(new CurveTo(args[i], args[i + 1], args[i + 2], args[i + 3], args[i + 4], args[i + 5]));
        }
        return segments;
    }
    CurveTo.create = create;
})(CurveTo || (CurveTo = {}));
//# sourceMappingURL=curveto.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-geometry/es/path/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6-geometry/es/path/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Path: () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_0__.Path),
/* harmony export */   Segment: () => (/* reexport safe */ _segment__WEBPACK_IMPORTED_MODULE_1__.Segment),
/* harmony export */   normalizePathData: () => (/* reexport safe */ _normalize__WEBPACK_IMPORTED_MODULE_2__.normalizePathData)
/* harmony export */ });
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./path */ "./node_modules/@antv/x6-geometry/es/path/path.js");
/* harmony import */ var _segment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./segment */ "./node_modules/@antv/x6-geometry/es/path/segment.js");
/* harmony import */ var _normalize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./normalize */ "./node_modules/@antv/x6-geometry/es/path/normalize.js");



//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-geometry/es/path/lineto.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6-geometry/es/path/lineto.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LineTo: () => (/* binding */ LineTo)
/* harmony export */ });
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../line */ "./node_modules/@antv/x6-geometry/es/line.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../point */ "./node_modules/@antv/x6-geometry/es/point.js");
/* harmony import */ var _segment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./segment */ "./node_modules/@antv/x6-geometry/es/path/segment.js");



class LineTo extends _segment__WEBPACK_IMPORTED_MODULE_2__.Segment {
    constructor(x, y) {
        super();
        if (_line__WEBPACK_IMPORTED_MODULE_0__.Line.isLine(x)) {
            this.endPoint = x.end.clone().round(2);
        }
        else {
            this.endPoint = _point__WEBPACK_IMPORTED_MODULE_1__.Point.create(x, y).round(2);
        }
    }
    get type() {
        return 'L';
    }
    get line() {
        return new _line__WEBPACK_IMPORTED_MODULE_0__.Line(this.start, this.end);
    }
    bbox() {
        return this.line.bbox();
    }
    closestPoint(p) {
        return this.line.closestPoint(p);
    }
    closestPointLength(p) {
        return this.line.closestPointLength(p);
    }
    closestPointNormalizedLength(p) {
        return this.line.closestPointNormalizedLength(p);
    }
    closestPointTangent(p) {
        return this.line.closestPointTangent(p);
    }
    length() {
        return this.line.length();
    }
    divideAt(ratio) {
        const divided = this.line.divideAt(ratio);
        return [new LineTo(divided[0]), new LineTo(divided[1])];
    }
    divideAtLength(length) {
        const divided = this.line.divideAtLength(length);
        return [new LineTo(divided[0]), new LineTo(divided[1])];
    }
    getSubdivisions() {
        return [];
    }
    pointAt(ratio) {
        return this.line.pointAt(ratio);
    }
    pointAtLength(length) {
        return this.line.pointAtLength(length);
    }
    tangentAt(ratio) {
        return this.line.tangentAt(ratio);
    }
    tangentAtLength(length) {
        return this.line.tangentAtLength(length);
    }
    isDifferentiable() {
        if (this.previousSegment == null) {
            return false;
        }
        return !this.start.equals(this.end);
    }
    clone() {
        return new LineTo(this.end);
    }
    scale(sx, sy, origin) {
        this.end.scale(sx, sy, origin);
        return this;
    }
    rotate(angle, origin) {
        this.end.rotate(angle, origin);
        return this;
    }
    translate(tx, ty) {
        if (typeof tx === 'number') {
            this.end.translate(tx, ty);
        }
        else {
            this.end.translate(tx);
        }
        return this;
    }
    equals(s) {
        return (this.type === s.type &&
            this.start.equals(s.start) &&
            this.end.equals(s.end));
    }
    toJSON() {
        return {
            type: this.type,
            start: this.start.toJSON(),
            end: this.end.toJSON(),
        };
    }
    serialize() {
        const end = this.end;
        return `${this.type} ${end.x} ${end.y}`;
    }
}
(function (LineTo) {
    function create(...args) {
        const len = args.length;
        const arg0 = args[0];
        // line provided
        if (_line__WEBPACK_IMPORTED_MODULE_0__.Line.isLine(arg0)) {
            return new LineTo(arg0);
        }
        // points provided
        if (_point__WEBPACK_IMPORTED_MODULE_1__.Point.isPointLike(arg0)) {
            if (len === 1) {
                return new LineTo(arg0);
            }
            // poly-line segment
            return args.map((arg) => new LineTo(arg));
        }
        // coordinates provided
        if (len === 2) {
            return new LineTo(+args[0], +args[1]);
        }
        // poly-line segment
        const segments = [];
        for (let i = 0; i < len; i += 2) {
            const x = +args[i];
            const y = +args[i + 1];
            segments.push(new LineTo(x, y));
        }
        return segments;
    }
    LineTo.create = create;
})(LineTo || (LineTo = {}));
//# sourceMappingURL=lineto.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-geometry/es/path/moveto.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6-geometry/es/path/moveto.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MoveTo: () => (/* binding */ MoveTo)
/* harmony export */ });
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../line */ "./node_modules/@antv/x6-geometry/es/line.js");
/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../curve */ "./node_modules/@antv/x6-geometry/es/curve.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../point */ "./node_modules/@antv/x6-geometry/es/point.js");
/* harmony import */ var _lineto__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lineto */ "./node_modules/@antv/x6-geometry/es/path/lineto.js");
/* harmony import */ var _segment__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./segment */ "./node_modules/@antv/x6-geometry/es/path/segment.js");





class MoveTo extends _segment__WEBPACK_IMPORTED_MODULE_4__.Segment {
    constructor(x, y) {
        super();
        this.isVisible = false;
        this.isSubpathStart = true;
        if (_line__WEBPACK_IMPORTED_MODULE_0__.Line.isLine(x) || _curve__WEBPACK_IMPORTED_MODULE_1__.Curve.isCurve(x)) {
            this.endPoint = x.end.clone().round(2);
        }
        else {
            this.endPoint = _point__WEBPACK_IMPORTED_MODULE_2__.Point.create(x, y).round(2);
        }
    }
    get start() {
        throw new Error('Illegal access. Moveto segments should not need a start property.');
    }
    get type() {
        return 'M';
    }
    bbox() {
        return null;
    }
    closestPoint() {
        return this.end.clone();
    }
    closestPointLength() {
        return 0;
    }
    closestPointNormalizedLength() {
        return 0;
    }
    closestPointT() {
        return 1;
    }
    closestPointTangent() {
        return null;
    }
    length() {
        return 0;
    }
    lengthAtT() {
        return 0;
    }
    divideAt() {
        return [this.clone(), this.clone()];
    }
    divideAtLength() {
        return [this.clone(), this.clone()];
    }
    getSubdivisions() {
        return [];
    }
    pointAt() {
        return this.end.clone();
    }
    pointAtLength() {
        return this.end.clone();
    }
    pointAtT() {
        return this.end.clone();
    }
    tangentAt() {
        return null;
    }
    tangentAtLength() {
        return null;
    }
    tangentAtT() {
        return null;
    }
    isDifferentiable() {
        return false;
    }
    scale(sx, sy, origin) {
        this.end.scale(sx, sy, origin);
        return this;
    }
    rotate(angle, origin) {
        this.end.rotate(angle, origin);
        return this;
    }
    translate(tx, ty) {
        if (typeof tx === 'number') {
            this.end.translate(tx, ty);
        }
        else {
            this.end.translate(tx);
        }
        return this;
    }
    clone() {
        return new MoveTo(this.end);
    }
    equals(s) {
        return this.type === s.type && this.end.equals(s.end);
    }
    toJSON() {
        return {
            type: this.type,
            end: this.end.toJSON(),
        };
    }
    serialize() {
        const end = this.end;
        return `${this.type} ${end.x} ${end.y}`;
    }
}
(function (MoveTo) {
    function create(...args) {
        const len = args.length;
        const arg0 = args[0];
        // line provided
        if (_line__WEBPACK_IMPORTED_MODULE_0__.Line.isLine(arg0)) {
            return new MoveTo(arg0);
        }
        // curve provided
        if (_curve__WEBPACK_IMPORTED_MODULE_1__.Curve.isCurve(arg0)) {
            return new MoveTo(arg0);
        }
        // points provided
        if (_point__WEBPACK_IMPORTED_MODULE_2__.Point.isPointLike(arg0)) {
            if (len === 1) {
                return new MoveTo(arg0);
            }
            // this is a moveto-with-subsequent-poly-line segment
            const segments = [];
            // points come one by one
            for (let i = 0; i < len; i += 1) {
                if (i === 0) {
                    segments.push(new MoveTo(args[i]));
                }
                else {
                    segments.push(new _lineto__WEBPACK_IMPORTED_MODULE_3__.LineTo(args[i]));
                }
            }
            return segments;
        }
        // coordinates provided
        if (len === 2) {
            return new MoveTo(+args[0], +args[1]);
        }
        // this is a moveto-with-subsequent-poly-line segment
        const segments = [];
        for (let i = 0; i < len; i += 2) {
            const x = +args[i];
            const y = +args[i + 1];
            if (i === 0) {
                segments.push(new MoveTo(x, y));
            }
            else {
                segments.push(new _lineto__WEBPACK_IMPORTED_MODULE_3__.LineTo(x, y));
            }
        }
        return segments;
    }
    MoveTo.create = create;
})(MoveTo || (MoveTo = {}));
//# sourceMappingURL=moveto.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-geometry/es/path/normalize.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/x6-geometry/es/path/normalize.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   normalizePathData: () => (/* binding */ normalizePathData)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/x6-geometry/es/util.js");

function rotate(x, y, rad) {
    return {
        x: x * Math.cos(rad) - y * Math.sin(rad),
        y: x * Math.sin(rad) + y * Math.cos(rad),
    };
}
function q2c(x1, y1, ax, ay, x2, y2) {
    const v13 = 1 / 3;
    const v23 = 2 / 3;
    return [
        v13 * x1 + v23 * ax,
        v13 * y1 + v23 * ay,
        v13 * x2 + v23 * ax,
        v13 * y2 + v23 * ay,
        x2,
        y2,
    ];
}
function a2c(x1, y1, rx, ry, angle, largeArcFlag, sweepFlag, x2, y2, recursive) {
    // for more information of where this math came from visit:
    // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
    const v120 = (Math.PI * 120) / 180;
    const rad = (Math.PI / 180) * (+angle || 0);
    let res = [];
    let xy;
    let f1;
    let f2;
    let cx;
    let cy;
    if (!recursive) {
        xy = rotate(x1, y1, -rad);
        x1 = xy.x; // eslint-disable-line
        y1 = xy.y; // eslint-disable-line
        xy = rotate(x2, y2, -rad);
        x2 = xy.x; // eslint-disable-line
        y2 = xy.y; // eslint-disable-line
        const x = (x1 - x2) / 2;
        const y = (y1 - y2) / 2;
        let h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
        if (h > 1) {
            h = Math.sqrt(h);
            rx = h * rx; // eslint-disable-line
            ry = h * ry; // eslint-disable-line
        }
        const rx2 = rx * rx;
        const ry2 = ry * ry;
        const k = (largeArcFlag === sweepFlag ? -1 : 1) *
            Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
        cx = (k * rx * y) / ry + (x1 + x2) / 2;
        cy = (k * -ry * x) / rx + (y1 + y2) / 2;
        f1 = Math.asin((y1 - cy) / ry);
        f2 = Math.asin((y2 - cy) / ry);
        f1 = x1 < cx ? Math.PI - f1 : f1;
        f2 = x2 < cx ? Math.PI - f2 : f2;
        if (f1 < 0) {
            f1 = Math.PI * 2 + f1;
        }
        if (f2 < 0) {
            f2 = Math.PI * 2 + f2;
        }
        if (sweepFlag && f1 > f2) {
            f1 -= Math.PI * 2;
        }
        if (!sweepFlag && f2 > f1) {
            f2 -= Math.PI * 2;
        }
    }
    else {
        f1 = recursive[0];
        f2 = recursive[1];
        cx = recursive[2];
        cy = recursive[3];
    }
    let df = f2 - f1;
    if (Math.abs(df) > v120) {
        const f2old = f2;
        const x2old = x2;
        const y2old = y2;
        f2 = f1 + v120 * (sweepFlag && f2 > f1 ? 1 : -1);
        x2 = cx + rx * Math.cos(f2); // eslint-disable-line
        y2 = cy + ry * Math.sin(f2); // eslint-disable-line
        res = a2c(x2, y2, rx, ry, angle, 0, sweepFlag, x2old, y2old, [
            f2,
            f2old,
            cx,
            cy,
        ]);
    }
    df = f2 - f1;
    const c1 = Math.cos(f1);
    const s1 = Math.sin(f1);
    const c2 = Math.cos(f2);
    const s2 = Math.sin(f2);
    const t = Math.tan(df / 4);
    const hx = (4 / 3) * (rx * t);
    const hy = (4 / 3) * (ry * t);
    const m1 = [x1, y1];
    const m2 = [x1 + hx * s1, y1 - hy * c1];
    const m3 = [x2 + hx * s2, y2 - hy * c2];
    const m4 = [x2, y2];
    m2[0] = 2 * m1[0] - m2[0];
    m2[1] = 2 * m1[1] - m2[1];
    if (recursive) {
        return [m2, m3, m4].concat(res);
    }
    {
        res = [m2, m3, m4].concat(res).join().split(',');
        const newres = [];
        const ii = res.length;
        for (let i = 0; i < ii; i += 1) {
            newres[i] =
                i % 2
                    ? rotate(+res[i - 1], +res[i], rad).y
                    : rotate(+res[i], +res[i + 1], rad).x;
        }
        return newres;
    }
}
function parse(pathData) {
    if (!pathData) {
        return null;
    }
    const spaces = '\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029';
    // https://regexper.com/#%28%5Ba-z%5D%29%5B%5Cs%2C%5D*%28%28-%3F%5Cd*%5C.%3F%5C%5Cd*%28%3F%3Ae%5B%5C-%2B%5D%3F%5Cd%2B%29%3F%5B%5Cs%5D*%2C%3F%5B%5Cs%5D*%29%2B%29
    const segmentReg = new RegExp(`([a-z])[${spaces},]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[${spaces}]*,?[${spaces}]*)+)`, // eslint-disable-line
    'ig');
    // https://regexper.com/#%28-%3F%5Cd*%5C.%3F%5Cd*%28%3F%3Ae%5B%5C-%2B%5D%3F%5Cd%2B%29%3F%29%5B%5Cs%5D*%2C%3F%5B%5Cs%5D*
    const commandParamReg = new RegExp(
    // eslint-disable-next-line
    `(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[${spaces}]*,?[${spaces}]*`, 'ig');
    const paramsCount = {
        a: 7,
        c: 6,
        h: 1,
        l: 2,
        m: 2,
        q: 4,
        s: 4,
        t: 2,
        v: 1,
        z: 0,
    };
    const segmetns = [];
    pathData.replace(segmentReg, (input, cmd, args) => {
        const params = [];
        let command = cmd.toLowerCase();
        args.replace(commandParamReg, (a, b) => {
            if (b) {
                params.push(+b);
            }
            return a;
        });
        if (command === 'm' && params.length > 2) {
            segmetns.push([cmd, ...params.splice(0, 2)]);
            command = 'l';
            cmd = cmd === 'm' ? 'l' : 'L'; // eslint-disable-line
        }
        const count = paramsCount[command];
        while (params.length >= count) {
            segmetns.push([cmd, ...params.splice(0, count)]);
            if (!count) {
                break;
            }
        }
        return input;
    });
    return segmetns;
}
function abs(pathString) {
    const pathArray = parse(pathString);
    // if invalid string, return 'M 0 0'
    if (!pathArray || !pathArray.length) {
        return [['M', 0, 0]];
    }
    let x = 0;
    let y = 0;
    let mx = 0;
    let my = 0;
    const segments = [];
    for (let i = 0, ii = pathArray.length; i < ii; i += 1) {
        const r = [];
        segments.push(r);
        const segment = pathArray[i];
        const command = segment[0];
        if (command !== command.toUpperCase()) {
            r[0] = command.toUpperCase();
            switch (r[0]) {
                case 'A':
                    r[1] = segment[1];
                    r[2] = segment[2];
                    r[3] = segment[3];
                    r[4] = segment[4];
                    r[5] = segment[5];
                    r[6] = +segment[6] + x;
                    r[7] = +segment[7] + y;
                    break;
                case 'V':
                    r[1] = +segment[1] + y;
                    break;
                case 'H':
                    r[1] = +segment[1] + x;
                    break;
                case 'M':
                    mx = +segment[1] + x;
                    my = +segment[2] + y;
                    for (let j = 1, jj = segment.length; j < jj; j += 1) {
                        r[j] = +segment[j] + (j % 2 ? x : y);
                    }
                    break;
                default:
                    for (let j = 1, jj = segment.length; j < jj; j += 1) {
                        r[j] = +segment[j] + (j % 2 ? x : y);
                    }
                    break;
            }
        }
        else {
            for (let j = 0, jj = segment.length; j < jj; j += 1) {
                r[j] = segment[j];
            }
        }
        switch (r[0]) {
            case 'Z':
                x = +mx;
                y = +my;
                break;
            case 'H':
                x = r[1];
                break;
            case 'V':
                y = r[1];
                break;
            case 'M':
                mx = r[r.length - 2];
                my = r[r.length - 1];
                x = r[r.length - 2];
                y = r[r.length - 1];
                break;
            default:
                x = r[r.length - 2];
                y = r[r.length - 1];
                break;
        }
    }
    return segments;
}
function normalize(path) {
    const pathArray = abs(path);
    const attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null };
    function processPath(path, d, pcom) {
        let nx;
        let ny;
        if (!path) {
            return ['C', d.x, d.y, d.x, d.y, d.x, d.y];
        }
        if (!(path[0] in { T: 1, Q: 1 })) {
            d.qx = null;
            d.qy = null;
        }
        switch (path[0]) {
            case 'M':
                d.X = path[1];
                d.Y = path[2];
                break;
            case 'A':
                if (parseFloat(path[1]) === 0 || parseFloat(path[2]) === 0) {
                    // https://www.w3.org/TR/SVG/paths.html#ArcOutOfRangeParameters
                    // "If either rx or ry is 0, then this arc is treated as a
                    // straight line segment (a "lineto") joining the endpoints."
                    return ['L', path[6], path[7]];
                }
                return ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));
            case 'S':
                if (pcom === 'C' || pcom === 'S') {
                    // In 'S' case we have to take into account, if the previous command is C/S.
                    nx = d.x * 2 - d.bx; // And reflect the previous
                    ny = d.y * 2 - d.by; // command's control point relative to the current point.
                }
                else {
                    // or some else or nothing
                    nx = d.x;
                    ny = d.y;
                }
                return ['C', nx, ny].concat(path.slice(1));
            case 'T':
                if (pcom === 'Q' || pcom === 'T') {
                    // In 'T' case we have to take into account, if the previous command is Q/T.
                    d.qx = d.x * 2 - d.qx; // And make a reflection similar
                    d.qy = d.y * 2 - d.qy; // to case 'S'.
                }
                else {
                    // or something else or nothing
                    d.qx = d.x;
                    d.qy = d.y;
                }
                return ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
            case 'Q':
                d.qx = path[1];
                d.qy = path[2];
                return ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
            case 'H':
                return ['L'].concat(path[1], d.y);
            case 'V':
                return ['L'].concat(d.x, path[1]);
            case 'L':
                break;
            case 'Z':
                break;
            default:
                break;
        }
        return path;
    }
    function fixArc(pp, i) {
        if (pp[i].length > 7) {
            pp[i].shift();
            const pi = pp[i];
            while (pi.length) {
                // if created multiple 'C's, their original seg is saved
                commands[i] = 'A';
                i += 1; // eslint-disable-line
                pp.splice(i, 0, ['C'].concat(pi.splice(0, 6)));
            }
            pp.splice(i, 1);
            ii = pathArray.length;
        }
    }
    const commands = []; // path commands of original path p
    let prevCommand = ''; // holder for previous path command of original path
    let ii = pathArray.length;
    for (let i = 0; i < ii; i += 1) {
        let command = ''; // temporary holder for original path command
        if (pathArray[i]) {
            command = pathArray[i][0]; // save current path command
        }
        if (command !== 'C') {
            // C is not saved yet, because it may be result of conversion
            commands[i] = command; // Save current path command
            if (i > 0) {
                prevCommand = commands[i - 1]; // Get previous path command pcom
            }
        }
        // Previous path command is inputted to processPath
        pathArray[i] = processPath(pathArray[i], attrs, prevCommand);
        if (commands[i] !== 'A' && command === 'C') {
            commands[i] = 'C'; // 'A' is the only command
        }
        // which may produce multiple 'C's
        // so we have to make sure that 'C' is also 'C' in original path
        fixArc(pathArray, i); // fixArc adds also the right amount of 'A's to pcoms
        const seg = pathArray[i];
        const seglen = seg.length;
        attrs.x = seg[seglen - 2];
        attrs.y = seg[seglen - 1];
        attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
        attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
    }
    // make sure normalized path data string starts with an M segment
    if (!pathArray[0][0] || pathArray[0][0] !== 'M') {
        pathArray.unshift(['M', 0, 0]);
    }
    return pathArray;
}
/**
 * Converts provided SVG path data string into a normalized path data string.
 *
 * The normalization uses a restricted subset of path commands; all segments
 * are translated into lineto, curveto, moveto, and closepath segments.
 *
 * Relative path commands are changed into their absolute counterparts,
 * and chaining of coordinates is disallowed.
 *
 * The function will always return a valid path data string; if an input
 * string cannot be normalized, 'M 0 0' is returned.
 */
function normalizePathData(pathData) {
    return normalize(pathData)
        .map((segment) => segment.map((item) => typeof item === 'string' ? item : _util__WEBPACK_IMPORTED_MODULE_0__.GeometryUtil.round(item, 2)))
        .join(',')
        .split(',')
        .join(' ');
}
//# sourceMappingURL=normalize.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-geometry/es/path/path.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6-geometry/es/path/path.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Path: () => (/* binding */ Path)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/x6-geometry/es/util.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6-geometry/es/path/util.js");
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../line */ "./node_modules/@antv/x6-geometry/es/line.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../point */ "./node_modules/@antv/x6-geometry/es/point.js");
/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../curve */ "./node_modules/@antv/x6-geometry/es/curve.js");
/* harmony import */ var _polyline__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../polyline */ "./node_modules/@antv/x6-geometry/es/polyline.js");
/* harmony import */ var _rectangle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../rectangle */ "./node_modules/@antv/x6-geometry/es/rectangle.js");
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../geometry */ "./node_modules/@antv/x6-geometry/es/geometry.js");
/* harmony import */ var _close__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./close */ "./node_modules/@antv/x6-geometry/es/path/close.js");
/* harmony import */ var _lineto__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lineto */ "./node_modules/@antv/x6-geometry/es/path/lineto.js");
/* harmony import */ var _moveto__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./moveto */ "./node_modules/@antv/x6-geometry/es/path/moveto.js");
/* harmony import */ var _curveto__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./curveto */ "./node_modules/@antv/x6-geometry/es/path/curveto.js");
/* harmony import */ var _normalize__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./normalize */ "./node_modules/@antv/x6-geometry/es/path/normalize.js");













class Path extends _geometry__WEBPACK_IMPORTED_MODULE_7__.Geometry {
    constructor(args) {
        super();
        this.PRECISION = 3;
        this.segments = [];
        if (Array.isArray(args)) {
            if (_line__WEBPACK_IMPORTED_MODULE_2__.Line.isLine(args[0]) || _curve__WEBPACK_IMPORTED_MODULE_4__.Curve.isCurve(args[0])) {
                let previousObj = null;
                const arr = args;
                arr.forEach((o, i) => {
                    if (i === 0) {
                        this.appendSegment(Path.createSegment('M', o.start));
                    }
                    if (previousObj != null && !previousObj.end.equals(o.start)) {
                        this.appendSegment(Path.createSegment('M', o.start));
                    }
                    if (_line__WEBPACK_IMPORTED_MODULE_2__.Line.isLine(o)) {
                        this.appendSegment(Path.createSegment('L', o.end));
                    }
                    else if (_curve__WEBPACK_IMPORTED_MODULE_4__.Curve.isCurve(o)) {
                        this.appendSegment(Path.createSegment('C', o.controlPoint1, o.controlPoint2, o.end));
                    }
                    previousObj = o;
                });
            }
            else {
                const arr = args;
                arr.forEach((s) => {
                    if (s.isSegment) {
                        this.appendSegment(s);
                    }
                });
            }
        }
        else if (args != null) {
            if (_line__WEBPACK_IMPORTED_MODULE_2__.Line.isLine(args)) {
                this.appendSegment(Path.createSegment('M', args.start));
                this.appendSegment(Path.createSegment('L', args.end));
            }
            else if (_curve__WEBPACK_IMPORTED_MODULE_4__.Curve.isCurve(args)) {
                this.appendSegment(Path.createSegment('M', args.start));
                this.appendSegment(Path.createSegment('C', args.controlPoint1, args.controlPoint2, args.end));
            }
            else if (_polyline__WEBPACK_IMPORTED_MODULE_5__.Polyline.isPolyline(args)) {
                if (args.points && args.points.length) {
                    args.points.forEach((point, index) => {
                        const segment = index === 0
                            ? Path.createSegment('M', point)
                            : Path.createSegment('L', point);
                        this.appendSegment(segment);
                    });
                }
            }
            else if (args.isSegment) {
                this.appendSegment(args);
            }
        }
    }
    get start() {
        const segments = this.segments;
        const count = segments.length;
        if (count === 0) {
            return null;
        }
        for (let i = 0; i < count; i += 1) {
            const segment = segments[i];
            if (segment.isVisible) {
                return segment.start;
            }
        }
        // if no visible segment, return last segment end point
        return segments[count - 1].end;
    }
    get end() {
        const segments = this.segments;
        const count = segments.length;
        if (count === 0) {
            return null;
        }
        for (let i = count - 1; i >= 0; i -= 1) {
            const segment = segments[i];
            if (segment.isVisible) {
                return segment.end;
            }
        }
        // if no visible segment, return last segment end point
        return segments[count - 1].end;
    }
    moveTo(...args) {
        return this.appendSegment(_moveto__WEBPACK_IMPORTED_MODULE_10__.MoveTo.create.call(null, ...args));
    }
    lineTo(...args) {
        return this.appendSegment(_lineto__WEBPACK_IMPORTED_MODULE_9__.LineTo.create.call(null, ...args));
    }
    curveTo(...args) {
        return this.appendSegment(_curveto__WEBPACK_IMPORTED_MODULE_11__.CurveTo.create.call(null, ...args));
    }
    arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX, endY) {
        const start = this.end || new _point__WEBPACK_IMPORTED_MODULE_3__.Point();
        const points = typeof endX === 'number'
            ? _util__WEBPACK_IMPORTED_MODULE_1__.arcToCurves(start.x, start.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX, endY)
            : _util__WEBPACK_IMPORTED_MODULE_1__.arcToCurves(start.x, start.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX.x, endX.y);
        if (points != null) {
            for (let i = 0, ii = points.length; i < ii; i += 6) {
                this.curveTo(points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5]);
            }
        }
        return this;
    }
    quadTo(x1, y1, x, y) {
        const start = this.end || new _point__WEBPACK_IMPORTED_MODULE_3__.Point();
        const data = ['M', start.x, start.y];
        if (typeof x1 === 'number') {
            data.push('Q', x1, y1, x, y);
        }
        else {
            const p = y1;
            data.push(`Q`, x1.x, x1.y, p.x, p.y);
        }
        const path = Path.parse(data.join(' '));
        this.appendSegment(path.segments.slice(1));
        return this;
    }
    close() {
        return this.appendSegment(_close__WEBPACK_IMPORTED_MODULE_8__.Close.create());
    }
    drawPoints(points, options = {}) {
        const raw = _util__WEBPACK_IMPORTED_MODULE_1__.drawPoints(points, options);
        const sub = Path.parse(raw);
        if (sub && sub.segments) {
            this.appendSegment(sub.segments);
        }
    }
    bbox() {
        const segments = this.segments;
        const count = segments.length;
        if (count === 0) {
            return null;
        }
        let bbox;
        for (let i = 0; i < count; i += 1) {
            const segment = segments[i];
            if (segment.isVisible) {
                const segmentBBox = segment.bbox();
                if (segmentBBox != null) {
                    bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;
                }
            }
        }
        if (bbox != null) {
            return bbox;
        }
        // if the path has only invisible elements, return end point of last segment
        const lastSegment = segments[count - 1];
        return new _rectangle__WEBPACK_IMPORTED_MODULE_6__.Rectangle(lastSegment.end.x, lastSegment.end.y, 0, 0);
    }
    appendSegment(seg) {
        const count = this.segments.length;
        let previousSegment = count !== 0 ? this.segments[count - 1] : null;
        let currentSegment;
        const nextSegment = null;
        if (Array.isArray(seg)) {
            for (let i = 0, ii = seg.length; i < ii; i += 1) {
                const segment = seg[i];
                currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);
                this.segments.push(currentSegment);
                previousSegment = currentSegment;
            }
        }
        else if (seg != null && seg.isSegment) {
            currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);
            this.segments.push(currentSegment);
        }
        return this;
    }
    insertSegment(index, seg) {
        const count = this.segments.length;
        if (index < 0) {
            index = count + index + 1; // eslint-disable-line
        }
        if (index > count || index < 0) {
            throw new Error('Index out of range.');
        }
        let currentSegment;
        let previousSegment = null;
        let nextSegment = null;
        if (count !== 0) {
            if (index >= 1) {
                previousSegment = this.segments[index - 1];
                nextSegment = previousSegment.nextSegment;
            }
            else {
                previousSegment = null;
                nextSegment = this.segments[0];
            }
        }
        if (!Array.isArray(seg)) {
            currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);
            this.segments.splice(index, 0, currentSegment);
        }
        else {
            for (let i = 0, ii = seg.length; i < ii; i += 1) {
                const segment = seg[i];
                currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);
                this.segments.splice(index + i, 0, currentSegment);
                previousSegment = currentSegment;
            }
        }
        return this;
    }
    removeSegment(index) {
        const idx = this.fixIndex(index);
        const removedSegment = this.segments.splice(idx, 1)[0];
        const previousSegment = removedSegment.previousSegment;
        const nextSegment = removedSegment.nextSegment;
        // link the previous and next segments together (if present)
        if (previousSegment) {
            previousSegment.nextSegment = nextSegment;
        }
        if (nextSegment) {
            nextSegment.previousSegment = previousSegment;
        }
        if (removedSegment.isSubpathStart && nextSegment) {
            this.updateSubpathStartSegment(nextSegment);
        }
        return removedSegment;
    }
    replaceSegment(index, seg) {
        const idx = this.fixIndex(index);
        let currentSegment;
        const replacedSegment = this.segments[idx];
        let previousSegment = replacedSegment.previousSegment;
        const nextSegment = replacedSegment.nextSegment;
        let updateSubpathStart = replacedSegment.isSubpathStart;
        if (!Array.isArray(seg)) {
            currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);
            this.segments.splice(idx, 1, currentSegment);
            if (updateSubpathStart && currentSegment.isSubpathStart) {
                // already updated by `prepareSegment`
                updateSubpathStart = false;
            }
        }
        else {
            this.segments.splice(index, 1);
            for (let i = 0, ii = seg.length; i < ii; i += 1) {
                const segment = seg[i];
                currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);
                this.segments.splice(index + i, 0, currentSegment);
                previousSegment = currentSegment;
                if (updateSubpathStart && currentSegment.isSubpathStart) {
                    updateSubpathStart = false;
                }
            }
        }
        if (updateSubpathStart && nextSegment) {
            this.updateSubpathStartSegment(nextSegment);
        }
    }
    getSegment(index) {
        const idx = this.fixIndex(index);
        return this.segments[idx];
    }
    fixIndex(index) {
        const length = this.segments.length;
        if (length === 0) {
            throw new Error('Path has no segments.');
        }
        let i = index;
        while (i < 0) {
            i = length + i;
        }
        if (i >= length || i < 0) {
            throw new Error('Index out of range.');
        }
        return i;
    }
    segmentAt(ratio, options = {}) {
        const index = this.segmentIndexAt(ratio, options);
        if (!index) {
            return null;
        }
        return this.getSegment(index);
    }
    segmentAtLength(length, options = {}) {
        const index = this.segmentIndexAtLength(length, options);
        if (!index)
            return null;
        return this.getSegment(index);
    }
    segmentIndexAt(ratio, options = {}) {
        if (this.segments.length === 0) {
            return null;
        }
        const rate = _util__WEBPACK_IMPORTED_MODULE_0__.GeometryUtil.clamp(ratio, 0, 1);
        const opt = this.getOptions(options);
        const len = this.length(opt);
        const length = len * rate;
        return this.segmentIndexAtLength(length, opt);
    }
    segmentIndexAtLength(length, options = {}) {
        const count = this.segments.length;
        if (count === 0) {
            return null;
        }
        let fromStart = true;
        if (length < 0) {
            fromStart = false;
            length = -length; // eslint-disable-line
        }
        const precision = this.getPrecision(options);
        const segmentSubdivisions = this.getSubdivisions(options);
        let memo = 0;
        let lastVisibleIndex = null;
        for (let i = 0; i < count; i += 1) {
            const index = fromStart ? i : count - 1 - i;
            const segment = this.segments[index];
            const subdivisions = segmentSubdivisions[index];
            const len = segment.length({ precision, subdivisions });
            if (segment.isVisible) {
                if (length <= memo + len) {
                    return index;
                }
                lastVisibleIndex = index;
            }
            memo += len;
        }
        // If length requested is higher than the length of the path, return
        // last visible segment index. If no visible segment, return null.
        return lastVisibleIndex;
    }
    getSegmentSubdivisions(options = {}) {
        const precision = this.getPrecision(options);
        const segmentSubdivisions = [];
        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
            const segment = this.segments[i];
            const subdivisions = segment.getSubdivisions({ precision });
            segmentSubdivisions.push(subdivisions);
        }
        return segmentSubdivisions;
    }
    updateSubpathStartSegment(segment) {
        let previous = segment.previousSegment;
        let current = segment;
        while (current && !current.isSubpathStart) {
            // assign previous segment's subpath start segment to this segment
            if (previous != null) {
                current.subpathStartSegment = previous.subpathStartSegment;
            }
            else {
                current.subpathStartSegment = null;
            }
            previous = current;
            current = current.nextSegment;
        }
    }
    prepareSegment(segment, previousSegment, nextSegment) {
        segment.previousSegment = previousSegment;
        segment.nextSegment = nextSegment;
        if (previousSegment != null) {
            previousSegment.nextSegment = segment;
        }
        if (nextSegment != null) {
            nextSegment.previousSegment = segment;
        }
        let updateSubpathStart = segment;
        if (segment.isSubpathStart) {
            // move to
            segment.subpathStartSegment = segment;
            updateSubpathStart = nextSegment;
        }
        // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments
        if (updateSubpathStart != null) {
            this.updateSubpathStartSegment(updateSubpathStart);
        }
        return segment;
    }
    closestPoint(p, options = {}) {
        const t = this.closestPointT(p, options);
        if (!t) {
            return null;
        }
        return this.pointAtT(t);
    }
    closestPointLength(p, options = {}) {
        const opts = this.getOptions(options);
        const t = this.closestPointT(p, opts);
        if (!t) {
            return 0;
        }
        return this.lengthAtT(t, opts);
    }
    closestPointNormalizedLength(p, options = {}) {
        const opts = this.getOptions(options);
        const cpLength = this.closestPointLength(p, opts);
        if (cpLength === 0) {
            return 0;
        }
        const length = this.length(opts);
        if (length === 0) {
            return 0;
        }
        return cpLength / length;
    }
    closestPointT(p, options = {}) {
        if (this.segments.length === 0) {
            return null;
        }
        const precision = this.getPrecision(options);
        const segmentSubdivisions = this.getSubdivisions(options);
        let closestPointT;
        let minSquaredDistance = Infinity;
        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
            const segment = this.segments[i];
            const subdivisions = segmentSubdivisions[i];
            if (segment.isVisible) {
                const segmentClosestPointT = segment.closestPointT(p, {
                    precision,
                    subdivisions,
                });
                const segmentClosestPoint = segment.pointAtT(segmentClosestPointT);
                const squaredDistance = _util__WEBPACK_IMPORTED_MODULE_0__.GeometryUtil.squaredLength(segmentClosestPoint, p);
                if (squaredDistance < minSquaredDistance) {
                    closestPointT = { segmentIndex: i, value: segmentClosestPointT };
                    minSquaredDistance = squaredDistance;
                }
            }
        }
        if (closestPointT) {
            return closestPointT;
        }
        return { segmentIndex: this.segments.length - 1, value: 1 };
    }
    closestPointTangent(p, options = {}) {
        if (this.segments.length === 0) {
            return null;
        }
        const precision = this.getPrecision(options);
        const segmentSubdivisions = this.getSubdivisions(options);
        let closestPointTangent;
        let minSquaredDistance = Infinity;
        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
            const segment = this.segments[i];
            const subdivisions = segmentSubdivisions[i];
            if (segment.isDifferentiable()) {
                const segmentClosestPointT = segment.closestPointT(p, {
                    precision,
                    subdivisions,
                });
                const segmentClosestPoint = segment.pointAtT(segmentClosestPointT);
                const squaredDistance = _util__WEBPACK_IMPORTED_MODULE_0__.GeometryUtil.squaredLength(segmentClosestPoint, p);
                if (squaredDistance < minSquaredDistance) {
                    closestPointTangent = segment.tangentAtT(segmentClosestPointT);
                    minSquaredDistance = squaredDistance;
                }
            }
        }
        if (closestPointTangent) {
            return closestPointTangent;
        }
        return null;
    }
    containsPoint(p, options = {}) {
        const polylines = this.toPolylines(options);
        if (!polylines) {
            return false;
        }
        let numIntersections = 0;
        for (let i = 0, ii = polylines.length; i < ii; i += 1) {
            const polyline = polylines[i];
            if (polyline.containsPoint(p)) {
                numIntersections += 1;
            }
        }
        // returns `true` for odd numbers of intersections (even-odd algorithm)
        return numIntersections % 2 === 1;
    }
    pointAt(ratio, options = {}) {
        if (this.segments.length === 0) {
            return null;
        }
        if (ratio <= 0) {
            return this.start.clone();
        }
        if (ratio >= 1) {
            return this.end.clone();
        }
        const opts = this.getOptions(options);
        const pathLength = this.length(opts);
        const length = pathLength * ratio;
        return this.pointAtLength(length, opts);
    }
    pointAtLength(length, options = {}) {
        if (this.segments.length === 0) {
            return null;
        }
        if (length === 0) {
            return this.start.clone();
        }
        let fromStart = true;
        if (length < 0) {
            fromStart = false;
            length = -length; // eslint-disable-line
        }
        const precision = this.getPrecision(options);
        const segmentSubdivisions = this.getSubdivisions(options);
        let lastVisibleSegment;
        let memo = 0;
        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
            const index = fromStart ? i : ii - 1 - i;
            const segment = this.segments[index];
            const subdivisions = segmentSubdivisions[index];
            const d = segment.length({
                precision,
                subdivisions,
            });
            if (segment.isVisible) {
                if (length <= memo + d) {
                    return segment.pointAtLength((fromStart ? 1 : -1) * (length - memo), {
                        precision,
                        subdivisions,
                    });
                }
                lastVisibleSegment = segment;
            }
            memo += d;
        }
        // if length requested is higher than the length of the path,
        // return last visible segment endpoint
        if (lastVisibleSegment) {
            return fromStart ? lastVisibleSegment.end : lastVisibleSegment.start;
        }
        // if no visible segment, return last segment end point
        const lastSegment = this.segments[this.segments.length - 1];
        return lastSegment.end.clone();
    }
    pointAtT(t) {
        const segments = this.segments;
        const numSegments = segments.length;
        if (numSegments === 0)
            return null; // if segments is an empty array
        const segmentIndex = t.segmentIndex;
        if (segmentIndex < 0)
            return segments[0].pointAtT(0);
        if (segmentIndex >= numSegments) {
            return segments[numSegments - 1].pointAtT(1);
        }
        const tValue = _util__WEBPACK_IMPORTED_MODULE_0__.GeometryUtil.clamp(t.value, 0, 1);
        return segments[segmentIndex].pointAtT(tValue);
    }
    divideAt(ratio, options = {}) {
        if (this.segments.length === 0) {
            return null;
        }
        const rate = _util__WEBPACK_IMPORTED_MODULE_0__.GeometryUtil.clamp(ratio, 0, 1);
        const opts = this.getOptions(options);
        const len = this.length(opts);
        const length = len * rate;
        return this.divideAtLength(length, opts);
    }
    divideAtLength(length, options = {}) {
        if (this.segments.length === 0) {
            return null;
        }
        let fromStart = true;
        if (length < 0) {
            fromStart = false;
            length = -length; // eslint-disable-line
        }
        const precision = this.getPrecision(options);
        const segmentSubdivisions = this.getSubdivisions(options);
        let memo = 0;
        let divided;
        let dividedSegmentIndex;
        let lastValidSegment;
        let lastValidSegmentIndex;
        let t;
        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
            const index = fromStart ? i : ii - 1 - i;
            const segment = this.getSegment(index);
            const subdivisions = segmentSubdivisions[index];
            const opts = { precision, subdivisions };
            const len = segment.length(opts);
            if (segment.isDifferentiable()) {
                lastValidSegment = segment;
                lastValidSegmentIndex = index;
                if (length <= memo + len) {
                    dividedSegmentIndex = index;
                    divided = segment.divideAtLength((fromStart ? 1 : -1) * (length - memo), opts);
                    break;
                }
            }
            memo += len;
        }
        if (!lastValidSegment) {
            return null;
        }
        if (!divided) {
            dividedSegmentIndex = lastValidSegmentIndex;
            t = fromStart ? 1 : 0;
            divided = lastValidSegment.divideAtT(t);
        }
        // create a copy of this path and replace the identified segment with its two divided parts:
        const pathCopy = this.clone();
        const index = dividedSegmentIndex;
        pathCopy.replaceSegment(index, divided);
        const divisionStartIndex = index;
        let divisionMidIndex = index + 1;
        let divisionEndIndex = index + 2;
        // do not insert the part if it looks like a point
        if (!divided[0].isDifferentiable()) {
            pathCopy.removeSegment(divisionStartIndex);
            divisionMidIndex -= 1;
            divisionEndIndex -= 1;
        }
        // insert a Moveto segment to ensure secondPath will be valid:
        const movetoEnd = pathCopy.getSegment(divisionMidIndex).start;
        pathCopy.insertSegment(divisionMidIndex, Path.createSegment('M', movetoEnd));
        divisionEndIndex += 1;
        // do not insert the part if it looks like a point
        if (!divided[1].isDifferentiable()) {
            pathCopy.removeSegment(divisionEndIndex - 1);
            divisionEndIndex -= 1;
        }
        // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:
        const secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;
        for (let i = divisionEndIndex, ii = pathCopy.segments.length; i < ii; i += 1) {
            const originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);
            const segment = pathCopy.getSegment(i);
            if (segment.type === 'Z' &&
                !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {
                // pathCopy segment's subpathStartSegment is different from original segment's one
                // convert this Closepath segment to a Lineto and replace it in pathCopy
                const convertedSegment = Path.createSegment('L', originalSegment.end);
                pathCopy.replaceSegment(i, convertedSegment);
            }
        }
        // distribute pathCopy segments into two paths and return those:
        const firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex));
        const secondPath = new Path(pathCopy.segments.slice(divisionMidIndex));
        return [firstPath, secondPath];
    }
    intersectsWithLine(line, options = {}) {
        const polylines = this.toPolylines(options);
        if (polylines == null) {
            return null;
        }
        let intersections = null;
        for (let i = 0, ii = polylines.length; i < ii; i += 1) {
            const polyline = polylines[i];
            const intersection = line.intersect(polyline);
            if (intersection) {
                if (intersections == null) {
                    intersections = [];
                }
                if (Array.isArray(intersection)) {
                    intersections.push(...intersection);
                }
                else {
                    intersections.push(intersection);
                }
            }
        }
        return intersections;
    }
    isDifferentiable() {
        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
            const segment = this.segments[i];
            if (segment.isDifferentiable()) {
                return true;
            }
        }
        return false;
    }
    isValid() {
        const segments = this.segments;
        const isValid = segments.length === 0 || segments[0].type === 'M';
        return isValid;
    }
    length(options = {}) {
        if (this.segments.length === 0) {
            return 0;
        }
        const segmentSubdivisions = this.getSubdivisions(options);
        let length = 0;
        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
            const segment = this.segments[i];
            const subdivisions = segmentSubdivisions[i];
            length += segment.length({ subdivisions });
        }
        return length;
    }
    lengthAtT(t, options = {}) {
        const count = this.segments.length;
        if (count === 0) {
            return 0;
        }
        let segmentIndex = t.segmentIndex;
        if (segmentIndex < 0) {
            return 0;
        }
        let tValue = _util__WEBPACK_IMPORTED_MODULE_0__.GeometryUtil.clamp(t.value, 0, 1);
        if (segmentIndex >= count) {
            segmentIndex = count - 1;
            tValue = 1;
        }
        const precision = this.getPrecision(options);
        const segmentSubdivisions = this.getSubdivisions(options);
        let length = 0;
        for (let i = 0; i < segmentIndex; i += 1) {
            const segment = this.segments[i];
            const subdivisions = segmentSubdivisions[i];
            length += segment.length({ precision, subdivisions });
        }
        const segment = this.segments[segmentIndex];
        const subdivisions = segmentSubdivisions[segmentIndex];
        length += segment.lengthAtT(tValue, { precision, subdivisions });
        return length;
    }
    tangentAt(ratio, options = {}) {
        if (this.segments.length === 0) {
            return null;
        }
        const rate = _util__WEBPACK_IMPORTED_MODULE_0__.GeometryUtil.clamp(ratio, 0, 1);
        const opts = this.getOptions(options);
        const len = this.length(opts);
        const length = len * rate;
        return this.tangentAtLength(length, opts);
    }
    tangentAtLength(length, options = {}) {
        if (this.segments.length === 0) {
            return null;
        }
        let fromStart = true;
        if (length < 0) {
            fromStart = false;
            length = -length; // eslint-disable-line
        }
        const precision = this.getPrecision(options);
        const segmentSubdivisions = this.getSubdivisions(options);
        let lastValidSegment;
        let memo = 0;
        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {
            const index = fromStart ? i : ii - 1 - i;
            const segment = this.segments[index];
            const subdivisions = segmentSubdivisions[index];
            const len = segment.length({ precision, subdivisions });
            if (segment.isDifferentiable()) {
                if (length <= memo + len) {
                    return segment.tangentAtLength((fromStart ? 1 : -1) * (length - memo), {
                        precision,
                        subdivisions,
                    });
                }
                lastValidSegment = segment;
            }
            memo += len;
        }
        // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment
        if (lastValidSegment) {
            const t = fromStart ? 1 : 0;
            return lastValidSegment.tangentAtT(t);
        }
        // if no valid segment, return null
        return null;
    }
    tangentAtT(t) {
        const count = this.segments.length;
        if (count === 0) {
            return null;
        }
        const segmentIndex = t.segmentIndex;
        if (segmentIndex < 0) {
            return this.segments[0].tangentAtT(0);
        }
        if (segmentIndex >= count) {
            return this.segments[count - 1].tangentAtT(1);
        }
        const tValue = _util__WEBPACK_IMPORTED_MODULE_0__.GeometryUtil.clamp(t.value, 0, 1);
        return this.segments[segmentIndex].tangentAtT(tValue);
    }
    getPrecision(options = {}) {
        return options.precision == null ? this.PRECISION : options.precision;
    }
    getSubdivisions(options = {}) {
        if (options.segmentSubdivisions == null) {
            const precision = this.getPrecision(options);
            return this.getSegmentSubdivisions({ precision });
        }
        return options.segmentSubdivisions;
    }
    getOptions(options = {}) {
        const precision = this.getPrecision(options);
        const segmentSubdivisions = this.getSubdivisions(options);
        return { precision, segmentSubdivisions };
    }
    toPoints(options = {}) {
        const segments = this.segments;
        const count = segments.length;
        if (count === 0) {
            return null;
        }
        const segmentSubdivisions = this.getSubdivisions(options);
        const points = [];
        let partialPoints = [];
        for (let i = 0; i < count; i += 1) {
            const segment = segments[i];
            if (segment.isVisible) {
                const divisions = segmentSubdivisions[i];
                if (divisions.length > 0) {
                    // eslint-disable-next-line no-loop-func
                    divisions.forEach((c) => partialPoints.push(c.start));
                }
                else {
                    partialPoints.push(segment.start);
                }
            }
            else if (partialPoints.length > 0) {
                partialPoints.push(segments[i - 1].end);
                points.push(partialPoints);
                partialPoints = [];
            }
        }
        if (partialPoints.length > 0) {
            partialPoints.push(this.end);
            points.push(partialPoints);
        }
        return points;
    }
    toPolylines(options = {}) {
        const points = this.toPoints(options);
        if (!points) {
            return null;
        }
        return points.map((arr) => new _polyline__WEBPACK_IMPORTED_MODULE_5__.Polyline(arr));
    }
    scale(sx, sy, origin) {
        this.segments.forEach((s) => s.scale(sx, sy, origin));
        return this;
    }
    rotate(angle, origin) {
        this.segments.forEach((segment) => segment.rotate(angle, origin));
        return this;
    }
    translate(tx, ty) {
        if (typeof tx === 'number') {
            this.segments.forEach((s) => s.translate(tx, ty));
        }
        else {
            this.segments.forEach((s) => s.translate(tx));
        }
        return this;
    }
    clone() {
        const path = new Path();
        this.segments.forEach((s) => path.appendSegment(s.clone()));
        return path;
    }
    equals(p) {
        if (p == null) {
            return false;
        }
        const segments = this.segments;
        const otherSegments = p.segments;
        const count = segments.length;
        if (otherSegments.length !== count) {
            return false;
        }
        for (let i = 0; i < count; i += 1) {
            const a = segments[i];
            const b = otherSegments[i];
            if (a.type !== b.type || !a.equals(b)) {
                return false;
            }
        }
        return true;
    }
    toJSON() {
        return this.segments.map((s) => s.toJSON());
    }
    serialize() {
        if (!this.isValid()) {
            throw new Error('Invalid path segments.');
        }
        return this.segments.map((s) => s.serialize()).join(' ');
    }
    toString() {
        return this.serialize();
    }
}
(function (Path) {
    function isPath(instance) {
        return instance != null && instance instanceof Path;
    }
    Path.isPath = isPath;
})(Path || (Path = {}));
(function (Path) {
    function parse(pathData) {
        if (!pathData) {
            return new Path();
        }
        const path = new Path();
        const commandRe = /(?:[a-zA-Z] *)(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)? *,? *)|(?:-?\.\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\d|-|\.)/g;
        const commands = Path.normalize(pathData).match(commandRe);
        if (commands != null) {
            for (let i = 0, ii = commands.length; i < ii; i += 1) {
                const command = commands[i];
                const argRe = /(?:[a-zA-Z])|(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)?))|(?:(?:-?\.\d+))/g;
                const args = command.match(argRe); // [type, coordinate1, coordinate2...]
                if (args != null) {
                    const type = args[0];
                    const coords = args.slice(1).map((a) => +a);
                    const segment = createSegment.call(null, type, ...coords);
                    path.appendSegment(segment);
                }
            }
        }
        return path;
    }
    Path.parse = parse;
    function createSegment(type, ...args) {
        if (type === 'M') {
            return _moveto__WEBPACK_IMPORTED_MODULE_10__.MoveTo.create.call(null, ...args);
        }
        if (type === 'L') {
            return _lineto__WEBPACK_IMPORTED_MODULE_9__.LineTo.create.call(null, ...args);
        }
        if (type === 'C') {
            return _curveto__WEBPACK_IMPORTED_MODULE_11__.CurveTo.create.call(null, ...args);
        }
        if (type === 'z' || type === 'Z') {
            return _close__WEBPACK_IMPORTED_MODULE_8__.Close.create();
        }
        throw new Error(`Invalid path segment type "${type}"`);
    }
    Path.createSegment = createSegment;
})(Path || (Path = {}));
(function (Path) {
    Path.normalize = _normalize__WEBPACK_IMPORTED_MODULE_12__.normalizePathData;
    Path.isValid = _util__WEBPACK_IMPORTED_MODULE_1__.isValid;
    Path.drawArc = _util__WEBPACK_IMPORTED_MODULE_1__.drawArc;
    Path.drawPoints = _util__WEBPACK_IMPORTED_MODULE_1__.drawPoints;
    Path.arcToCurves = _util__WEBPACK_IMPORTED_MODULE_1__.arcToCurves;
})(Path || (Path = {}));
//# sourceMappingURL=path.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-geometry/es/path/segment.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6-geometry/es/path/segment.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Segment: () => (/* binding */ Segment)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry */ "./node_modules/@antv/x6-geometry/es/geometry.js");

class Segment extends _geometry__WEBPACK_IMPORTED_MODULE_0__.Geometry {
    constructor() {
        super(...arguments);
        this.isVisible = true;
        this.isSegment = true;
        this.isSubpathStart = false;
    }
    get end() {
        return this.endPoint;
    }
    get start() {
        if (this.previousSegment == null) {
            throw new Error('Missing previous segment. (This segment cannot be the ' +
                'first segment of a path, or segment has not yet been ' +
                'added to a path.)');
        }
        return this.previousSegment.end;
    }
    closestPointT(p, options) {
        if (this.closestPointNormalizedLength) {
            return this.closestPointNormalizedLength(p);
        }
        throw new Error('Neither `closestPointT` nor `closestPointNormalizedLength` method is implemented.');
    }
    // eslint-disable-next-line
    lengthAtT(t, options) {
        if (t <= 0) {
            return 0;
        }
        const length = this.length();
        if (t >= 1) {
            return length;
        }
        return length * t;
    }
    divideAtT(t) {
        if (this.divideAt) {
            return this.divideAt(t);
        }
        throw new Error('Neither `divideAtT` nor `divideAt` method is implemented.');
    }
    pointAtT(t) {
        if (this.pointAt) {
            return this.pointAt(t);
        }
        throw new Error('Neither `pointAtT` nor `pointAt` method is implemented.');
    }
    tangentAtT(t) {
        if (this.tangentAt) {
            return this.tangentAt(t);
        }
        throw new Error('Neither `tangentAtT` nor `tangentAt` method is implemented.');
    }
}
//# sourceMappingURL=segment.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-geometry/es/path/util.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6-geometry/es/path/util.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arcToCurves: () => (/* binding */ arcToCurves),
/* harmony export */   drawArc: () => (/* binding */ drawArc),
/* harmony export */   drawPoints: () => (/* binding */ drawPoints),
/* harmony export */   isValid: () => (/* binding */ isValid)
/* harmony export */ });
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../point */ "./node_modules/@antv/x6-geometry/es/point.js");
/* eslint-disable default-param-last */

const regexSupportedData = new RegExp(`^[\\s\\dLMCZz,.]*$`); // eslint-disable-line prefer-regex-literals
function isValid(data) {
    if (typeof data !== 'string') {
        return false;
    }
    return regexSupportedData.test(data);
}
/**
 * Returns the remainder of division of `n` by `m`. You should use this
 * instead of the built-in operation as the built-in operation does not
 * properly handle negative numbers.
 */
function mod(n, m) {
    return ((n % m) + m) % m;
}
function draw(points, round, initialMove, close, exclude) {
    const data = [];
    const end = points[points.length - 1];
    const rounded = round != null && round > 0;
    const arcSize = round || 0;
    // Adds virtual waypoint in the center between start and end point
    if (close && rounded) {
        points = points.slice(); // eslint-disable-line
        const p0 = points[0];
        const wp = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(end.x + (p0.x - end.x) / 2, end.y + (p0.y - end.y) / 2);
        points.splice(0, 0, wp);
    }
    let pt = points[0];
    let i = 1;
    // Draws the line segments
    if (initialMove) {
        data.push('M', pt.x, pt.y);
    }
    else {
        data.push('L', pt.x, pt.y);
    }
    while (i < (close ? points.length : points.length - 1)) {
        let tmp = points[mod(i, points.length)];
        let dx = pt.x - tmp.x;
        let dy = pt.y - tmp.y;
        if (rounded &&
            (dx !== 0 || dy !== 0) &&
            (exclude == null || exclude.indexOf(i - 1) < 0)) {
            // Draws a line from the last point to the current
            // point with a spacing of size off the current point
            // into direction of the last point
            let dist = Math.sqrt(dx * dx + dy * dy);
            const nx1 = (dx * Math.min(arcSize, dist / 2)) / dist;
            const ny1 = (dy * Math.min(arcSize, dist / 2)) / dist;
            const x1 = tmp.x + nx1;
            const y1 = tmp.y + ny1;
            data.push('L', x1, y1);
            // Draws a curve from the last point to the current
            // point with a spacing of size off the current point
            // into direction of the next point
            let next = points[mod(i + 1, points.length)];
            // Uses next non-overlapping point
            while (i < points.length - 2 &&
                Math.round(next.x - tmp.x) === 0 &&
                Math.round(next.y - tmp.y) === 0) {
                next = points[mod(i + 2, points.length)];
                i += 1;
            }
            dx = next.x - tmp.x;
            dy = next.y - tmp.y;
            dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));
            const nx2 = (dx * Math.min(arcSize, dist / 2)) / dist;
            const ny2 = (dy * Math.min(arcSize, dist / 2)) / dist;
            const x2 = tmp.x + nx2;
            const y2 = tmp.y + ny2;
            data.push('Q', tmp.x, tmp.y, x2, y2);
            tmp = new _point__WEBPACK_IMPORTED_MODULE_0__.Point(x2, y2);
        }
        else {
            data.push('L', tmp.x, tmp.y);
        }
        pt = tmp;
        i += 1;
    }
    if (close) {
        data.push('Z');
    }
    else {
        data.push('L', end.x, end.y);
    }
    return data.map((v) => (typeof v === 'string' ? v : +v.toFixed(3))).join(' ');
}
function drawPoints(points, options = {}) {
    const pts = [];
    if (points && points.length) {
        points.forEach((p) => {
            if (Array.isArray(p)) {
                pts.push({ x: p[0], y: p[1] });
            }
            else {
                pts.push({ x: p.x, y: p.y });
            }
        });
    }
    return draw(pts, options.round, options.initialMove == null || options.initialMove, options.close, options.exclude);
}
/**
 * Converts the given arc to a series of curves.
 */
function arcToCurves(x0, y0, r1, r2, angle = 0, largeArcFlag = 0, sweepFlag = 0, x, y) {
    if (r1 === 0 || r2 === 0) {
        return [];
    }
    x -= x0; // eslint-disable-line
    y -= y0; // eslint-disable-line
    r1 = Math.abs(r1); // eslint-disable-line
    r2 = Math.abs(r2); // eslint-disable-line
    const ctx = -x / 2;
    const cty = -y / 2;
    const cpsi = Math.cos((angle * Math.PI) / 180);
    const spsi = Math.sin((angle * Math.PI) / 180);
    const rxd = cpsi * ctx + spsi * cty;
    const ryd = -1 * spsi * ctx + cpsi * cty;
    const rxdd = rxd * rxd;
    const rydd = ryd * ryd;
    const r1x = r1 * r1;
    const r2y = r2 * r2;
    const lamda = rxdd / r1x + rydd / r2y;
    let sds;
    if (lamda > 1) {
        r1 = Math.sqrt(lamda) * r1; // eslint-disable-line
        r2 = Math.sqrt(lamda) * r2; // eslint-disable-line
        sds = 0;
    }
    else {
        let seif = 1;
        if (largeArcFlag === sweepFlag) {
            seif = -1;
        }
        sds =
            seif *
                Math.sqrt((r1x * r2y - r1x * rydd - r2y * rxdd) / (r1x * rydd + r2y * rxdd));
    }
    const txd = (sds * r1 * ryd) / r2;
    const tyd = (-1 * sds * r2 * rxd) / r1;
    const tx = cpsi * txd - spsi * tyd + x / 2;
    const ty = spsi * txd + cpsi * tyd + y / 2;
    let rad = Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1) - Math.atan2(0, 1);
    let s1 = rad >= 0 ? rad : 2 * Math.PI + rad;
    rad =
        Math.atan2((-ryd - tyd) / r2, (-rxd - txd) / r1) -
            Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1);
    let dr = rad >= 0 ? rad : 2 * Math.PI + rad;
    if (sweepFlag === 0 && dr > 0) {
        dr -= 2 * Math.PI;
    }
    else if (sweepFlag !== 0 && dr < 0) {
        dr += 2 * Math.PI;
    }
    const sse = (dr * 2) / Math.PI;
    const seg = Math.ceil(sse < 0 ? -1 * sse : sse);
    const segr = dr / seg;
    const t = ((8 / 3) * Math.sin(segr / 4) * Math.sin(segr / 4)) / Math.sin(segr / 2);
    const cpsir1 = cpsi * r1;
    const cpsir2 = cpsi * r2;
    const spsir1 = spsi * r1;
    const spsir2 = spsi * r2;
    let mc = Math.cos(s1);
    let ms = Math.sin(s1);
    let x2 = -t * (cpsir1 * ms + spsir2 * mc);
    let y2 = -t * (spsir1 * ms - cpsir2 * mc);
    let x3 = 0;
    let y3 = 0;
    const result = [];
    for (let n = 0; n < seg; n += 1) {
        s1 += segr;
        mc = Math.cos(s1);
        ms = Math.sin(s1);
        x3 = cpsir1 * mc - spsir2 * ms + tx;
        y3 = spsir1 * mc + cpsir2 * ms + ty;
        const dx = -t * (cpsir1 * ms + spsir2 * mc);
        const dy = -t * (spsir1 * ms - cpsir2 * mc);
        // CurveTo updates x0, y0 so need to restore it
        const index = n * 6;
        result[index] = Number(x2 + x0);
        result[index + 1] = Number(y2 + y0);
        result[index + 2] = Number(x3 - dx + x0);
        result[index + 3] = Number(y3 - dy + y0);
        result[index + 4] = Number(x3 + x0);
        result[index + 5] = Number(y3 + y0);
        x2 = x3 + dx;
        y2 = y3 + dy;
    }
    return result.map((num) => +num.toFixed(2));
}
function drawArc(startX, startY, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0, stopX, stopY) {
    const data = [];
    const points = arcToCurves(startX, startY, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, stopX, stopY);
    if (points != null) {
        for (let i = 0, ii = points.length; i < ii; i += 6) {
            data.push('C', points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5]);
        }
    }
    return data.join(' ');
}
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-geometry/es/point.js":
/*!****************************************************!*\
  !*** ./node_modules/@antv/x6-geometry/es/point.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Point: () => (/* binding */ Point)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6-geometry/es/util.js");
/* harmony import */ var _angle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./angle */ "./node_modules/@antv/x6-geometry/es/angle.js");
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./geometry */ "./node_modules/@antv/x6-geometry/es/geometry.js");



class Point extends _geometry__WEBPACK_IMPORTED_MODULE_2__.Geometry {
    constructor(x, y) {
        super();
        this.x = x == null ? 0 : x;
        this.y = y == null ? 0 : y;
    }
    /**
     * Rounds the point to the given precision.
     */
    round(precision = 0) {
        this.x = _util__WEBPACK_IMPORTED_MODULE_0__.GeometryUtil.round(this.x, precision);
        this.y = _util__WEBPACK_IMPORTED_MODULE_0__.GeometryUtil.round(this.y, precision);
        return this;
    }
    add(x, y) {
        const p = Point.create(x, y);
        this.x += p.x;
        this.y += p.y;
        return this;
    }
    update(x, y) {
        const p = Point.create(x, y);
        this.x = p.x;
        this.y = p.y;
        return this;
    }
    translate(dx, dy) {
        const t = Point.create(dx, dy);
        this.x += t.x;
        this.y += t.y;
        return this;
    }
    /**
     * Rotate the point by `degree` around `center`.
     */
    rotate(degree, center) {
        const p = Point.rotate(this, degree, center);
        this.x = p.x;
        this.y = p.y;
        return this;
    }
    /**
     * Scale point by `sx` and `sy` around the given `origin`. If origin is
     * not specified, the point is scaled around `0, 0`.
     */
    scale(sx, sy, origin = new Point()) {
        const ref = Point.create(origin);
        this.x = ref.x + sx * (this.x - ref.x);
        this.y = ref.y + sy * (this.y - ref.y);
        return this;
    }
    /**
     * Chooses the point closest to this point from among `points`. If `points`
     * is an empty array, `null` is returned.
     */
    closest(points) {
        if (points.length === 1) {
            return Point.create(points[0]);
        }
        let ret = null;
        let min = Infinity;
        points.forEach((p) => {
            const dist = this.squaredDistance(p);
            if (dist < min) {
                ret = p;
                min = dist;
            }
        });
        return ret ? Point.create(ret) : null;
    }
    /**
     * Returns the distance between the point and another point `p`.
     */
    distance(p) {
        return Math.sqrt(this.squaredDistance(p));
    }
    /**
     * Returns the squared distance between the point and another point `p`.
     *
     * Useful for distance comparisons in which real distance is not necessary
     * (saves one `Math.sqrt()` operation).
     */
    squaredDistance(p) {
        const ref = Point.create(p);
        const dx = this.x - ref.x;
        const dy = this.y - ref.y;
        return dx * dx + dy * dy;
    }
    manhattanDistance(p) {
        const ref = Point.create(p);
        return Math.abs(ref.x - this.x) + Math.abs(ref.y - this.y);
    }
    /**
     * Returns the magnitude of the point vector.
     *
     * @see http://en.wikipedia.org/wiki/Magnitude_(mathematics)
     */
    magnitude() {
        return Math.sqrt(this.x * this.x + this.y * this.y) || 0.01;
    }
    /**
     * Returns the angle(in degrees) between vector from this point to `p` and
     * the x-axis.
     */
    theta(p = new Point()) {
        const ref = Point.create(p);
        const y = -(ref.y - this.y); // invert the y-axis.
        const x = ref.x - this.x;
        let rad = Math.atan2(y, x);
        // Correction for III. and IV. quadrant.
        if (rad < 0) {
            rad = 2 * Math.PI + rad;
        }
        return (180 * rad) / Math.PI;
    }
    /**
     * Returns the angle(in degrees) between vector from this point to `p1` and
     * the vector from this point to `p2`.
     *
     * The ordering of points `p1` and `p2` is important.
     *
     * The function returns a value between `0` and `180` when the angle (in the
     * direction from `p1` to `p2`) is clockwise, and a value between `180` and
     * `360` when the angle is counterclockwise.
     *
     * Returns `NaN` if either of the points `p1` and `p2` is equal with this point.
     */
    angleBetween(p1, p2) {
        if (this.equals(p1) || this.equals(p2)) {
            return NaN;
        }
        let angle = this.theta(p2) - this.theta(p1);
        if (angle < 0) {
            angle += 360;
        }
        return angle;
    }
    /**
     * Returns the angle(in degrees) between the line from `(0,0)` and this point
     * and the line from `(0,0)` to `p`.
     *
     * The function returns a value between `0` and `180` when the angle (in the
     * direction from this point to `p`) is clockwise, and a value between `180`
     * and `360` when the angle is counterclockwise. Returns `NaN` if called from
     * point `(0,0)` or if `p` is `(0,0)`.
     */
    vectorAngle(p) {
        const zero = new Point(0, 0);
        return zero.angleBetween(this, p);
    }
    /**
     * Converts rectangular to polar coordinates.
     */
    toPolar(origin) {
        this.update(Point.toPolar(this, origin));
        return this;
    }
    /**
     * Returns the change in angle(in degrees) that is the result of moving the
     * point from its previous position to its current position.
     *
     * More specifically, this function computes the angle between the line from
     * the ref point to the previous position of this point(i.e. current position
     * `-dx`, `-dy`) and the line from the `ref` point to the current position of
     * this point.
     *
     * The function returns a positive value between `0` and `180` when the angle
     * (in the direction from previous position of this point to its current
     * position) is clockwise, and a negative value between `0` and `-180` when
     * the angle is counterclockwise.
     *
     * The function returns `0` if the previous and current positions of this
     * point are the same (i.e. both `dx` and `dy` are `0`).
     */
    changeInAngle(dx, dy, ref = new Point()) {
        // Revert the translation and measure the change in angle around x-axis.
        return this.clone().translate(-dx, -dy).theta(ref) - this.theta(ref);
    }
    /**
     * If the point lies outside the rectangle `rect`, adjust the point so that
     * it becomes the nearest point on the boundary of `rect`.
     */
    adhereToRect(rect) {
        if (!_util__WEBPACK_IMPORTED_MODULE_0__.GeometryUtil.containsPoint(rect, this)) {
            this.x = Math.min(Math.max(this.x, rect.x), rect.x + rect.width);
            this.y = Math.min(Math.max(this.y, rect.y), rect.y + rect.height);
        }
        return this;
    }
    /**
     * Returns the bearing(cardinal direction) between me and the given point.
     *
     * @see https://en.wikipedia.org/wiki/Cardinal_direction
     */
    bearing(p) {
        const ref = Point.create(p);
        const lat1 = _angle__WEBPACK_IMPORTED_MODULE_1__.Angle.toRad(this.y);
        const lat2 = _angle__WEBPACK_IMPORTED_MODULE_1__.Angle.toRad(ref.y);
        const lon1 = this.x;
        const lon2 = ref.x;
        const dLon = _angle__WEBPACK_IMPORTED_MODULE_1__.Angle.toRad(lon2 - lon1);
        const y = Math.sin(dLon) * Math.cos(lat2);
        const x = Math.cos(lat1) * Math.sin(lat2) -
            Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
        const brng = _angle__WEBPACK_IMPORTED_MODULE_1__.Angle.toDeg(Math.atan2(y, x));
        const bearings = ['NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'];
        let index = brng - 22.5;
        if (index < 0) {
            index += 360;
        }
        index = parseInt((index / 45), 10);
        return bearings[index];
    }
    /**
     * Returns the cross product of the vector from me to `p1` and the vector
     * from me to `p2`.
     *
     * The left-hand rule is used because the coordinate system is left-handed.
     */
    cross(p1, p2) {
        if (p1 != null && p2 != null) {
            const a = Point.create(p1);
            const b = Point.create(p2);
            return (b.x - this.x) * (a.y - this.y) - (b.y - this.y) * (a.x - this.x);
        }
        return NaN;
    }
    /**
     * Returns the dot product of this point with given other point.
     */
    dot(p) {
        const ref = Point.create(p);
        return this.x * ref.x + this.y * ref.y;
    }
    diff(dx, dy) {
        if (typeof dx === 'number') {
            return new Point(this.x - dx, this.y - dy);
        }
        const p = Point.create(dx);
        return new Point(this.x - p.x, this.y - p.y);
    }
    /**
     * Returns an interpolation between me and point `p` for a parametert in
     * the closed interval `[0, 1]`.
     */
    lerp(p, t) {
        const ref = Point.create(p);
        return new Point((1 - t) * this.x + t * ref.x, (1 - t) * this.y + t * ref.y);
    }
    /**
     * Normalize the point vector, scale the line segment between `(0, 0)`
     * and the point in order for it to have the given length. If length is
     * not specified, it is considered to be `1`; in that case, a unit vector
     * is computed.
     */
    normalize(length = 1) {
        const scale = length / this.magnitude();
        return this.scale(scale, scale);
    }
    /**
     * Moves this point along the line starting from `ref` to this point by a
     * certain `distance`.
     */
    move(ref, distance) {
        const p = Point.create(ref);
        const rad = _angle__WEBPACK_IMPORTED_MODULE_1__.Angle.toRad(p.theta(this));
        return this.translate(Math.cos(rad) * distance, -Math.sin(rad) * distance);
    }
    /**
     * Returns a point that is the reflection of me with the center of inversion
     * in `ref` point.
     */
    reflection(ref) {
        return Point.create(ref).move(this, this.distance(ref));
    }
    snapToGrid(gx, gy) {
        this.x = _util__WEBPACK_IMPORTED_MODULE_0__.GeometryUtil.snapToGrid(this.x, gx);
        this.y = _util__WEBPACK_IMPORTED_MODULE_0__.GeometryUtil.snapToGrid(this.y, gy == null ? gx : gy);
        return this;
    }
    equals(p) {
        const ref = Point.create(p);
        return ref != null && ref.x === this.x && ref.y === this.y;
    }
    clone() {
        return Point.clone(this);
    }
    /**
     * Returns the point as a simple JSON object. For example: `{ x: 0, y: 0 }`.
     */
    toJSON() {
        return Point.toJSON(this);
    }
    serialize() {
        return `${this.x} ${this.y}`;
    }
}
(function (Point) {
    function isPoint(instance) {
        return instance != null && instance instanceof Point;
    }
    Point.isPoint = isPoint;
})(Point || (Point = {}));
(function (Point) {
    function isPointLike(p) {
        return (p != null &&
            typeof p === 'object' &&
            typeof p.x === 'number' &&
            typeof p.y === 'number');
    }
    Point.isPointLike = isPointLike;
    function isPointData(p) {
        return (p != null &&
            Array.isArray(p) &&
            p.length === 2 &&
            typeof p[0] === 'number' &&
            typeof p[1] === 'number');
    }
    Point.isPointData = isPointData;
})(Point || (Point = {}));
(function (Point) {
    function create(x, y) {
        if (x == null || typeof x === 'number') {
            return new Point(x, y);
        }
        return clone(x);
    }
    Point.create = create;
    function clone(p) {
        if (Point.isPoint(p)) {
            return new Point(p.x, p.y);
        }
        if (Array.isArray(p)) {
            return new Point(p[0], p[1]);
        }
        return new Point(p.x, p.y);
    }
    Point.clone = clone;
    function toJSON(p) {
        if (Point.isPoint(p)) {
            return { x: p.x, y: p.y };
        }
        if (Array.isArray(p)) {
            return { x: p[0], y: p[1] };
        }
        return { x: p.x, y: p.y };
    }
    Point.toJSON = toJSON;
    /**
     * Returns a new Point object from the given polar coordinates.
     * @see http://en.wikipedia.org/wiki/Polar_coordinate_system
     */
    function fromPolar(r, rad, origin = new Point()) {
        let x = Math.abs(r * Math.cos(rad));
        let y = Math.abs(r * Math.sin(rad));
        const org = clone(origin);
        const deg = _angle__WEBPACK_IMPORTED_MODULE_1__.Angle.normalize(_angle__WEBPACK_IMPORTED_MODULE_1__.Angle.toDeg(rad));
        if (deg < 90) {
            y = -y;
        }
        else if (deg < 180) {
            x = -x;
            y = -y;
        }
        else if (deg < 270) {
            x = -x;
        }
        return new Point(org.x + x, org.y + y);
    }
    Point.fromPolar = fromPolar;
    /**
     * Converts rectangular to polar coordinates.
     */
    function toPolar(point, origin = new Point()) {
        const p = clone(point);
        const o = clone(origin);
        const dx = p.x - o.x;
        const dy = p.y - o.y;
        return new Point(Math.sqrt(dx * dx + dy * dy), // r
        _angle__WEBPACK_IMPORTED_MODULE_1__.Angle.toRad(o.theta(p)));
    }
    Point.toPolar = toPolar;
    function equals(p1, p2) {
        if (p1 === p2) {
            return true;
        }
        if (p1 != null && p2 != null) {
            return p1.x === p2.x && p1.y === p2.y;
        }
        return false;
    }
    Point.equals = equals;
    function equalPoints(p1, p2) {
        if ((p1 == null && p2 != null) ||
            (p1 != null && p2 == null) ||
            (p1 != null && p2 != null && p1.length !== p2.length)) {
            return false;
        }
        if (p1 != null && p2 != null) {
            for (let i = 0, ii = p1.length; i < ii; i += 1) {
                if (!equals(p1[i], p2[i])) {
                    return false;
                }
            }
        }
        return true;
    }
    Point.equalPoints = equalPoints;
    /**
     * Returns a point with random coordinates that fall within the range
     * `[x1, x2]` and `[y1, y2]`.
     */
    function random(x1, x2, y1, y2) {
        return new Point(_util__WEBPACK_IMPORTED_MODULE_0__.GeometryUtil.random(x1, x2), _util__WEBPACK_IMPORTED_MODULE_0__.GeometryUtil.random(y1, y2));
    }
    Point.random = random;
    function rotate(point, angle, center) {
        const rad = _angle__WEBPACK_IMPORTED_MODULE_1__.Angle.toRad(_angle__WEBPACK_IMPORTED_MODULE_1__.Angle.normalize(-angle));
        const sin = Math.sin(rad);
        const cos = Math.cos(rad);
        return rotateEx(point, cos, sin, center);
    }
    Point.rotate = rotate;
    function rotateEx(point, cos, sin, center = new Point()) {
        const source = clone(point);
        const origin = clone(center);
        const dx = source.x - origin.x;
        const dy = source.y - origin.y;
        const x1 = dx * cos - dy * sin;
        const y1 = dy * cos + dx * sin;
        return new Point(x1 + origin.x, y1 + origin.y);
    }
    Point.rotateEx = rotateEx;
})(Point || (Point = {}));
//# sourceMappingURL=point.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-geometry/es/polyline.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/x6-geometry/es/polyline.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Polyline: () => (/* binding */ Polyline)
/* harmony export */ });
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./line */ "./node_modules/@antv/x6-geometry/es/line.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ "./node_modules/@antv/x6-geometry/es/point.js");
/* harmony import */ var _rectangle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rectangle */ "./node_modules/@antv/x6-geometry/es/rectangle.js");
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./geometry */ "./node_modules/@antv/x6-geometry/es/geometry.js");
/* eslint-disable no-constructor-return */




class Polyline extends _geometry__WEBPACK_IMPORTED_MODULE_3__.Geometry {
    get start() {
        return this.points[0] || null;
    }
    get end() {
        return this.points[this.points.length - 1] || null;
    }
    constructor(points) {
        super();
        if (points != null) {
            if (typeof points === 'string') {
                return Polyline.parse(points);
            }
            this.points = points.map((p) => _point__WEBPACK_IMPORTED_MODULE_1__.Point.create(p));
        }
        else {
            this.points = [];
        }
    }
    scale(sx, sy, origin = new _point__WEBPACK_IMPORTED_MODULE_1__.Point()) {
        this.points.forEach((p) => p.scale(sx, sy, origin));
        return this;
    }
    rotate(angle, origin) {
        this.points.forEach((p) => p.rotate(angle, origin));
        return this;
    }
    translate(dx, dy) {
        const t = _point__WEBPACK_IMPORTED_MODULE_1__.Point.create(dx, dy);
        this.points.forEach((p) => p.translate(t.x, t.y));
        return this;
    }
    round(precision = 0) {
        this.points.forEach((p) => p.round(precision));
        return this;
    }
    bbox() {
        if (this.points.length === 0) {
            return new _rectangle__WEBPACK_IMPORTED_MODULE_2__.Rectangle();
        }
        let x1 = Infinity;
        let x2 = -Infinity;
        let y1 = Infinity;
        let y2 = -Infinity;
        const points = this.points;
        for (let i = 0, ii = points.length; i < ii; i += 1) {
            const point = points[i];
            const x = point.x;
            const y = point.y;
            if (x < x1)
                x1 = x;
            if (x > x2)
                x2 = x;
            if (y < y1)
                y1 = y;
            if (y > y2)
                y2 = y;
        }
        return new _rectangle__WEBPACK_IMPORTED_MODULE_2__.Rectangle(x1, y1, x2 - x1, y2 - y1);
    }
    closestPoint(p) {
        const cpLength = this.closestPointLength(p);
        return this.pointAtLength(cpLength);
    }
    closestPointLength(p) {
        const points = this.points;
        const count = points.length;
        if (count === 0 || count === 1) {
            return 0;
        }
        let length = 0;
        let cpLength = 0;
        let minSqrDistance = Infinity;
        for (let i = 0, ii = count - 1; i < ii; i += 1) {
            const line = new _line__WEBPACK_IMPORTED_MODULE_0__.Line(points[i], points[i + 1]);
            const lineLength = line.length();
            const cpNormalizedLength = line.closestPointNormalizedLength(p);
            const cp = line.pointAt(cpNormalizedLength);
            const sqrDistance = cp.squaredDistance(p);
            if (sqrDistance < minSqrDistance) {
                minSqrDistance = sqrDistance;
                cpLength = length + cpNormalizedLength * lineLength;
            }
            length += lineLength;
        }
        return cpLength;
    }
    closestPointNormalizedLength(p) {
        const length = this.length();
        if (length === 0) {
            return 0;
        }
        const cpLength = this.closestPointLength(p);
        return cpLength / length;
    }
    closestPointTangent(p) {
        const cpLength = this.closestPointLength(p);
        return this.tangentAtLength(cpLength);
    }
    containsPoint(p) {
        if (this.points.length === 0) {
            return false;
        }
        const ref = _point__WEBPACK_IMPORTED_MODULE_1__.Point.clone(p);
        const x = ref.x;
        const y = ref.y;
        const points = this.points;
        const count = points.length;
        let startIndex = count - 1;
        let intersectionCount = 0;
        for (let endIndex = 0; endIndex < count; endIndex += 1) {
            const start = points[startIndex];
            const end = points[endIndex];
            if (ref.equals(start)) {
                return true;
            }
            const segment = new _line__WEBPACK_IMPORTED_MODULE_0__.Line(start, end);
            if (segment.containsPoint(p)) {
                return true;
            }
            // do we have an intersection?
            if ((y <= start.y && y > end.y) || (y > start.y && y <= end.y)) {
                // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`
                // (when `y === start.y === end.y`)
                // this conditional branch IS entered when `segment` touches `ray` at only one point
                // (e.g. when `y === start.y !== end.y`)
                // since this branch is entered again for the following segment, the two touches cancel out
                const xDifference = start.x - x > end.x - x ? start.x - x : end.x - x;
                if (xDifference >= 0) {
                    // segment lies at least partially to the right of `p`
                    const rayEnd = new _point__WEBPACK_IMPORTED_MODULE_1__.Point(x + xDifference, y); // right
                    const ray = new _line__WEBPACK_IMPORTED_MODULE_0__.Line(p, rayEnd);
                    if (segment.intersectsWithLine(ray)) {
                        // an intersection was detected to the right of `p`
                        intersectionCount += 1;
                    }
                } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)
            }
            // move to check the next polyline segment
            startIndex = endIndex;
        }
        // returns `true` for odd numbers of intersections (even-odd algorithm)
        return intersectionCount % 2 === 1;
    }
    intersectsWithLine(line) {
        const intersections = [];
        for (let i = 0, n = this.points.length - 1; i < n; i += 1) {
            const a = this.points[i];
            const b = this.points[i + 1];
            const int = line.intersectsWithLine(new _line__WEBPACK_IMPORTED_MODULE_0__.Line(a, b));
            if (int) {
                intersections.push(int);
            }
        }
        return intersections.length > 0 ? intersections : null;
    }
    isDifferentiable() {
        for (let i = 0, ii = this.points.length - 1; i < ii; i += 1) {
            const a = this.points[i];
            const b = this.points[i + 1];
            const line = new _line__WEBPACK_IMPORTED_MODULE_0__.Line(a, b);
            if (line.isDifferentiable()) {
                return true;
            }
        }
        return false;
    }
    length() {
        let len = 0;
        for (let i = 0, ii = this.points.length - 1; i < ii; i += 1) {
            const a = this.points[i];
            const b = this.points[i + 1];
            len += a.distance(b);
        }
        return len;
    }
    pointAt(ratio) {
        const points = this.points;
        const count = points.length;
        if (count === 0) {
            return null;
        }
        if (count === 1) {
            return points[0].clone();
        }
        if (ratio <= 0) {
            return points[0].clone();
        }
        if (ratio >= 1) {
            return points[count - 1].clone();
        }
        const total = this.length();
        const length = total * ratio;
        return this.pointAtLength(length);
    }
    pointAtLength(length) {
        const points = this.points;
        const count = points.length;
        if (count === 0) {
            return null;
        }
        if (count === 1) {
            return points[0].clone();
        }
        let fromStart = true;
        if (length < 0) {
            fromStart = false;
            length = -length; // eslint-disable-line
        }
        let tmp = 0;
        for (let i = 0, ii = count - 1; i < ii; i += 1) {
            const index = fromStart ? i : ii - 1 - i;
            const a = points[index];
            const b = points[index + 1];
            const l = new _line__WEBPACK_IMPORTED_MODULE_0__.Line(a, b);
            const d = a.distance(b);
            if (length <= tmp + d) {
                return l.pointAtLength((fromStart ? 1 : -1) * (length - tmp));
            }
            tmp += d;
        }
        const lastPoint = fromStart ? points[count - 1] : points[0];
        return lastPoint.clone();
    }
    tangentAt(ratio) {
        const points = this.points;
        const count = points.length;
        if (count === 0 || count === 1) {
            return null;
        }
        if (ratio < 0) {
            ratio = 0; // eslint-disable-line
        }
        if (ratio > 1) {
            ratio = 1; // eslint-disable-line
        }
        const total = this.length();
        const length = total * ratio;
        return this.tangentAtLength(length);
    }
    tangentAtLength(length) {
        const points = this.points;
        const count = points.length;
        if (count === 0 || count === 1) {
            return null;
        }
        let fromStart = true;
        if (length < 0) {
            fromStart = false;
            length = -length; // eslint-disable-line
        }
        let lastValidLine;
        let tmp = 0;
        for (let i = 0, ii = count - 1; i < ii; i += 1) {
            const index = fromStart ? i : ii - 1 - i;
            const a = points[index];
            const b = points[index + 1];
            const l = new _line__WEBPACK_IMPORTED_MODULE_0__.Line(a, b);
            const d = a.distance(b);
            if (l.isDifferentiable()) {
                // has a tangent line (line length is not 0)
                if (length <= tmp + d) {
                    return l.tangentAtLength((fromStart ? 1 : -1) * (length - tmp));
                }
                lastValidLine = l;
            }
            tmp += d;
        }
        if (lastValidLine) {
            const ratio = fromStart ? 1 : 0;
            return lastValidLine.tangentAt(ratio);
        }
        return null;
    }
    simplify(
    // TODO: Accept startIndex and endIndex to specify where to start and end simplification
    options = {}) {
        const points = this.points;
        // we need at least 3 points
        if (points.length < 3) {
            return this;
        }
        const threshold = options.threshold || 0;
        // start at the beginning of the polyline and go forward
        let currentIndex = 0;
        // we need at least one intermediate point (3 points) in every iteration
        // as soon as that stops being true, we know we reached the end of the polyline
        while (points[currentIndex + 2]) {
            const firstIndex = currentIndex;
            const middleIndex = currentIndex + 1;
            const lastIndex = currentIndex + 2;
            const firstPoint = points[firstIndex];
            const middlePoint = points[middleIndex];
            const lastPoint = points[lastIndex];
            const chord = new _line__WEBPACK_IMPORTED_MODULE_0__.Line(firstPoint, lastPoint); // = connection between first and last point
            const closestPoint = chord.closestPoint(middlePoint); // = closest point on chord from middle point
            const closestPointDistance = closestPoint.distance(middlePoint);
            if (closestPointDistance <= threshold) {
                // middle point is close enough to the chord = simplify
                // 1) remove middle point:
                points.splice(middleIndex, 1);
                // 2) in next iteration, investigate the newly-created triplet of points
                //    - do not change `currentIndex`
                //    = (first point stays, point after removed point becomes middle point)
            }
            else {
                // middle point is far from the chord
                // 1) preserve middle point
                // 2) in next iteration, move `currentIndex` by one step:
                currentIndex += 1;
                //    = (point after first point becomes first point)
            }
        }
        // `points` array was modified in-place
        return this;
    }
    toHull() {
        const points = this.points;
        const count = points.length;
        if (count === 0) {
            return new Polyline();
        }
        // Step 1: find the starting point -- point with
        // the lowest y (if equality, highest x).
        let startPoint = points[0];
        for (let i = 1; i < count; i += 1) {
            if (points[i].y < startPoint.y) {
                startPoint = points[i];
            }
            else if (points[i].y === startPoint.y && points[i].x > startPoint.x) {
                startPoint = points[i];
            }
        }
        // Step 2: sort the list of points by angle between line
        // from start point to current point and the x-axis (theta).
        // Step 2a: create the point records = [point, originalIndex, angle]
        const sortedRecords = [];
        for (let i = 0; i < count; i += 1) {
            let angle = startPoint.theta(points[i]);
            if (angle === 0) {
                // Give highest angle to start point.
                // The start point will end up at end of sorted list.
                // The start point will end up at beginning of hull points list.
                angle = 360;
            }
            sortedRecords.push([points[i], i, angle]);
        }
        // Step 2b: sort the list in place
        sortedRecords.sort((record1, record2) => {
            let ret = record1[2] - record2[2];
            if (ret === 0) {
                ret = record2[1] - record1[1];
            }
            return ret;
        });
        // Step 2c: duplicate start record from the top of
        // the stack to the bottom of the stack.
        if (sortedRecords.length > 2) {
            const startPoint = sortedRecords[sortedRecords.length - 1];
            sortedRecords.unshift(startPoint);
        }
        // Step 3
        // ------
        // Step 3a: go through sorted points in order and find those with
        // right turns, and we want to get our results in clockwise order.
        // Dictionary of points with left turns - cannot be on the hull.
        const insidePoints = {};
        // Stack of records with right turns - hull point candidates.
        const hullRecords = [];
        const getKey = (record) => `${record[0].toString()}@${record[1]}`;
        while (sortedRecords.length !== 0) {
            const currentRecord = sortedRecords.pop();
            const currentPoint = currentRecord[0];
            // Check if point has already been discarded.
            if (insidePoints[getKey(currentRecord)]) {
                continue;
            }
            let correctTurnFound = false;
            while (!correctTurnFound) {
                if (hullRecords.length < 2) {
                    // Not enough points for comparison, just add current point.
                    hullRecords.push(currentRecord);
                    correctTurnFound = true;
                }
                else {
                    const lastHullRecord = hullRecords.pop();
                    const lastHullPoint = lastHullRecord[0];
                    const secondLastHullRecord = hullRecords.pop();
                    const secondLastHullPoint = secondLastHullRecord[0];
                    const crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);
                    if (crossProduct < 0) {
                        // Found a right turn.
                        hullRecords.push(secondLastHullRecord);
                        hullRecords.push(lastHullRecord);
                        hullRecords.push(currentRecord);
                        correctTurnFound = true;
                    }
                    else if (crossProduct === 0) {
                        // the three points are collinear
                        // three options:
                        // there may be a 180 or 0 degree angle at lastHullPoint
                        // or two of the three points are coincident
                        // we have to take rounding errors into account
                        const THRESHOLD = 1e-10;
                        const angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);
                        if (Math.abs(angleBetween - 180) < THRESHOLD) {
                            // rouding around 180 to 180
                            // if the cross product is 0 because the angle is 180 degrees
                            // discard last hull point (add to insidePoints)
                            // insidePoints.unshift(lastHullPoint);
                            insidePoints[getKey(lastHullRecord)] = lastHullPoint;
                            // reenter second-to-last hull point (will be last at next iter)
                            hullRecords.push(secondLastHullRecord);
                            // do not do anything with current point
                            // correct turn not found
                        }
                        else if (lastHullPoint.equals(currentPoint) ||
                            secondLastHullPoint.equals(lastHullPoint)) {
                            // if the cross product is 0 because two points are the same
                            // discard last hull point (add to insidePoints)
                            // insidePoints.unshift(lastHullPoint);
                            insidePoints[getKey(lastHullRecord)] = lastHullPoint;
                            // reenter second-to-last hull point (will be last at next iter)
                            hullRecords.push(secondLastHullRecord);
                            // do not do anything with current point
                            // correct turn not found
                        }
                        else if (Math.abs(((angleBetween + 1) % 360) - 1) < THRESHOLD) {
                            // rounding around 0 and 360 to 0
                            // if the cross product is 0 because the angle is 0 degrees
                            // remove last hull point from hull BUT do not discard it
                            // reenter second-to-last hull point (will be last at next iter)
                            hullRecords.push(secondLastHullRecord);
                            // put last hull point back into the sorted point records list
                            sortedRecords.push(lastHullRecord);
                            // we are switching the order of the 0deg and 180deg points
                            // correct turn not found
                        }
                    }
                    else {
                        // found a left turn
                        // discard last hull point (add to insidePoints)
                        // insidePoints.unshift(lastHullPoint);
                        insidePoints[getKey(lastHullRecord)] = lastHullPoint;
                        // reenter second-to-last hull point (will be last at next iter of loop)
                        hullRecords.push(secondLastHullRecord);
                        // do not do anything with current point
                        // correct turn not found
                    }
                }
            }
        }
        // At this point, hullPointRecords contains the output points in clockwise order
        // the points start with lowest-y,highest-x startPoint, and end at the same point
        // Step 3b: remove duplicated startPointRecord from the end of the array
        if (hullRecords.length > 2) {
            hullRecords.pop();
        }
        // Step 4: find the lowest originalIndex record and put it at the beginning of hull
        let lowestHullIndex; // the lowest originalIndex on the hull
        let indexOfLowestHullIndexRecord = -1; // the index of the record with lowestHullIndex
        for (let i = 0, n = hullRecords.length; i < n; i += 1) {
            const currentHullIndex = hullRecords[i][1];
            if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {
                lowestHullIndex = currentHullIndex;
                indexOfLowestHullIndexRecord = i;
            }
        }
        let hullPointRecordsReordered = [];
        if (indexOfLowestHullIndexRecord > 0) {
            const newFirstChunk = hullRecords.slice(indexOfLowestHullIndexRecord);
            const newSecondChunk = hullRecords.slice(0, indexOfLowestHullIndexRecord);
            hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);
        }
        else {
            hullPointRecordsReordered = hullRecords;
        }
        const hullPoints = [];
        for (let i = 0, n = hullPointRecordsReordered.length; i < n; i += 1) {
            hullPoints.push(hullPointRecordsReordered[i][0]);
        }
        return new Polyline(hullPoints);
    }
    equals(p) {
        if (p == null) {
            return false;
        }
        if (p.points.length !== this.points.length) {
            return false;
        }
        return p.points.every((a, i) => a.equals(this.points[i]));
    }
    clone() {
        return new Polyline(this.points.map((p) => p.clone()));
    }
    toJSON() {
        return this.points.map((p) => p.toJSON());
    }
    serialize() {
        return this.points.map((p) => `${p.serialize()}`).join(' ');
    }
}
(function (Polyline) {
    function isPolyline(instance) {
        return instance != null && instance instanceof Polyline;
    }
    Polyline.isPolyline = isPolyline;
})(Polyline || (Polyline = {}));
(function (Polyline) {
    function parse(svgString) {
        const str = svgString.trim();
        if (str === '') {
            return new Polyline();
        }
        const points = [];
        const coords = str.split(/\s*,\s*|\s+/);
        for (let i = 0, ii = coords.length; i < ii; i += 2) {
            points.push({ x: +coords[i], y: +coords[i + 1] });
        }
        return new Polyline(points);
    }
    Polyline.parse = parse;
})(Polyline || (Polyline = {}));
//# sourceMappingURL=polyline.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-geometry/es/rectangle.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6-geometry/es/rectangle.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Rectangle: () => (/* binding */ Rectangle)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6-geometry/es/util.js");
/* harmony import */ var _angle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./angle */ "./node_modules/@antv/x6-geometry/es/angle.js");
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line */ "./node_modules/@antv/x6-geometry/es/line.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./point */ "./node_modules/@antv/x6-geometry/es/point.js");
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./geometry */ "./node_modules/@antv/x6-geometry/es/geometry.js");





class Rectangle extends _geometry__WEBPACK_IMPORTED_MODULE_4__.Geometry {
    get left() {
        return this.x;
    }
    get top() {
        return this.y;
    }
    get right() {
        return this.x + this.width;
    }
    get bottom() {
        return this.y + this.height;
    }
    get origin() {
        return new _point__WEBPACK_IMPORTED_MODULE_3__.Point(this.x, this.y);
    }
    get topLeft() {
        return new _point__WEBPACK_IMPORTED_MODULE_3__.Point(this.x, this.y);
    }
    get topCenter() {
        return new _point__WEBPACK_IMPORTED_MODULE_3__.Point(this.x + this.width / 2, this.y);
    }
    get topRight() {
        return new _point__WEBPACK_IMPORTED_MODULE_3__.Point(this.x + this.width, this.y);
    }
    get center() {
        return new _point__WEBPACK_IMPORTED_MODULE_3__.Point(this.x + this.width / 2, this.y + this.height / 2);
    }
    get bottomLeft() {
        return new _point__WEBPACK_IMPORTED_MODULE_3__.Point(this.x, this.y + this.height);
    }
    get bottomCenter() {
        return new _point__WEBPACK_IMPORTED_MODULE_3__.Point(this.x + this.width / 2, this.y + this.height);
    }
    get bottomRight() {
        return new _point__WEBPACK_IMPORTED_MODULE_3__.Point(this.x + this.width, this.y + this.height);
    }
    get corner() {
        return new _point__WEBPACK_IMPORTED_MODULE_3__.Point(this.x + this.width, this.y + this.height);
    }
    get rightMiddle() {
        return new _point__WEBPACK_IMPORTED_MODULE_3__.Point(this.x + this.width, this.y + this.height / 2);
    }
    get leftMiddle() {
        return new _point__WEBPACK_IMPORTED_MODULE_3__.Point(this.x, this.y + this.height / 2);
    }
    get topLine() {
        return new _line__WEBPACK_IMPORTED_MODULE_2__.Line(this.topLeft, this.topRight);
    }
    get rightLine() {
        return new _line__WEBPACK_IMPORTED_MODULE_2__.Line(this.topRight, this.bottomRight);
    }
    get bottomLine() {
        return new _line__WEBPACK_IMPORTED_MODULE_2__.Line(this.bottomLeft, this.bottomRight);
    }
    get leftLine() {
        return new _line__WEBPACK_IMPORTED_MODULE_2__.Line(this.topLeft, this.bottomLeft);
    }
    constructor(x, y, width, height) {
        super();
        this.x = x == null ? 0 : x;
        this.y = y == null ? 0 : y;
        this.width = width == null ? 0 : width;
        this.height = height == null ? 0 : height;
    }
    getOrigin() {
        return this.origin;
    }
    getTopLeft() {
        return this.topLeft;
    }
    getTopCenter() {
        return this.topCenter;
    }
    getTopRight() {
        return this.topRight;
    }
    getCenter() {
        return this.center;
    }
    getCenterX() {
        return this.x + this.width / 2;
    }
    getCenterY() {
        return this.y + this.height / 2;
    }
    getBottomLeft() {
        return this.bottomLeft;
    }
    getBottomCenter() {
        return this.bottomCenter;
    }
    getBottomRight() {
        return this.bottomRight;
    }
    getCorner() {
        return this.corner;
    }
    getRightMiddle() {
        return this.rightMiddle;
    }
    getLeftMiddle() {
        return this.leftMiddle;
    }
    getTopLine() {
        return this.topLine;
    }
    getRightLine() {
        return this.rightLine;
    }
    getBottomLine() {
        return this.bottomLine;
    }
    getLeftLine() {
        return this.leftLine;
    }
    /**
     * Returns a rectangle that is the bounding box of the rectangle.
     *
     * If `angle` is specified, the bounding box calculation will take into
     * account the rotation of the rectangle by angle degrees around its center.
     */
    bbox(angle) {
        if (!angle) {
            return this.clone();
        }
        const rad = _angle__WEBPACK_IMPORTED_MODULE_1__.Angle.toRad(angle);
        const st = Math.abs(Math.sin(rad));
        const ct = Math.abs(Math.cos(rad));
        const w = this.width * ct + this.height * st;
        const h = this.width * st + this.height * ct;
        return new Rectangle(this.x + (this.width - w) / 2, this.y + (this.height - h) / 2, w, h);
    }
    round(precision = 0) {
        this.x = _util__WEBPACK_IMPORTED_MODULE_0__.GeometryUtil.round(this.x, precision);
        this.y = _util__WEBPACK_IMPORTED_MODULE_0__.GeometryUtil.round(this.y, precision);
        this.width = _util__WEBPACK_IMPORTED_MODULE_0__.GeometryUtil.round(this.width, precision);
        this.height = _util__WEBPACK_IMPORTED_MODULE_0__.GeometryUtil.round(this.height, precision);
        return this;
    }
    add(x, y, width, height) {
        const rect = Rectangle.create(x, y, width, height);
        const minX = Math.min(this.x, rect.x);
        const minY = Math.min(this.y, rect.y);
        const maxX = Math.max(this.x + this.width, rect.x + rect.width);
        const maxY = Math.max(this.y + this.height, rect.y + rect.height);
        this.x = minX;
        this.y = minY;
        this.width = maxX - minX;
        this.height = maxY - minY;
        return this;
    }
    update(x, y, width, height) {
        const rect = Rectangle.create(x, y, width, height);
        this.x = rect.x;
        this.y = rect.y;
        this.width = rect.width;
        this.height = rect.height;
        return this;
    }
    inflate(dx, dy) {
        const w = dx;
        const h = dy != null ? dy : dx;
        this.x -= w;
        this.y -= h;
        this.width += 2 * w;
        this.height += 2 * h;
        return this;
    }
    snapToGrid(gx, gy) {
        const origin = this.origin.snapToGrid(gx, gy);
        const corner = this.corner.snapToGrid(gx, gy);
        this.x = origin.x;
        this.y = origin.y;
        this.width = corner.x - origin.x;
        this.height = corner.y - origin.y;
        return this;
    }
    translate(tx, ty) {
        const p = _point__WEBPACK_IMPORTED_MODULE_3__.Point.create(tx, ty);
        this.x += p.x;
        this.y += p.y;
        return this;
    }
    scale(sx, sy, origin = new _point__WEBPACK_IMPORTED_MODULE_3__.Point()) {
        const pos = this.origin.scale(sx, sy, origin);
        this.x = pos.x;
        this.y = pos.y;
        this.width *= sx;
        this.height *= sy;
        return this;
    }
    rotate(degree, center = this.getCenter()) {
        if (degree !== 0) {
            const rad = _angle__WEBPACK_IMPORTED_MODULE_1__.Angle.toRad(degree);
            const cos = Math.cos(rad);
            const sin = Math.sin(rad);
            let p1 = this.getOrigin();
            let p2 = this.getTopRight();
            let p3 = this.getBottomRight();
            let p4 = this.getBottomLeft();
            p1 = _point__WEBPACK_IMPORTED_MODULE_3__.Point.rotateEx(p1, cos, sin, center);
            p2 = _point__WEBPACK_IMPORTED_MODULE_3__.Point.rotateEx(p2, cos, sin, center);
            p3 = _point__WEBPACK_IMPORTED_MODULE_3__.Point.rotateEx(p3, cos, sin, center);
            p4 = _point__WEBPACK_IMPORTED_MODULE_3__.Point.rotateEx(p4, cos, sin, center);
            const rect = new Rectangle(p1.x, p1.y, 0, 0);
            rect.add(p2.x, p2.y, 0, 0);
            rect.add(p3.x, p3.y, 0, 0);
            rect.add(p4.x, p4.y, 0, 0);
            this.update(rect);
        }
        return this;
    }
    rotate90() {
        const t = (this.width - this.height) / 2;
        this.x += t;
        this.y -= t;
        const tmp = this.width;
        this.width = this.height;
        this.height = tmp;
        return this;
    }
    /**
     * Translates the rectangle by `rect.x` and `rect.y` and expand it by
     * `rect.width` and `rect.height`.
     */
    moveAndExpand(rect) {
        const ref = Rectangle.clone(rect);
        this.x += ref.x || 0;
        this.y += ref.y || 0;
        this.width += ref.width || 0;
        this.height += ref.height || 0;
        return this;
    }
    /**
     * Returns an object where `sx` and `sy` give the maximum scaling that can be
     * applied to the rectangle so that it would still fit into `limit`. If
     * `origin` is specified, the rectangle is scaled around it; otherwise, it is
     * scaled around its center.
     */
    getMaxScaleToFit(limit, origin = this.center) {
        const rect = Rectangle.clone(limit);
        const ox = origin.x;
        const oy = origin.y;
        // Find the maximal possible scale for all corners, so when the scale
        // is applied the point is still inside the rectangle.
        let sx1 = Infinity;
        let sx2 = Infinity;
        let sx3 = Infinity;
        let sx4 = Infinity;
        let sy1 = Infinity;
        let sy2 = Infinity;
        let sy3 = Infinity;
        let sy4 = Infinity;
        // Top Left
        const p1 = rect.topLeft;
        if (p1.x < ox) {
            sx1 = (this.x - ox) / (p1.x - ox);
        }
        if (p1.y < oy) {
            sy1 = (this.y - oy) / (p1.y - oy);
        }
        // Bottom Right
        const p2 = rect.bottomRight;
        if (p2.x > ox) {
            sx2 = (this.x + this.width - ox) / (p2.x - ox);
        }
        if (p2.y > oy) {
            sy2 = (this.y + this.height - oy) / (p2.y - oy);
        }
        // Top Right
        const p3 = rect.topRight;
        if (p3.x > ox) {
            sx3 = (this.x + this.width - ox) / (p3.x - ox);
        }
        if (p3.y < oy) {
            sy3 = (this.y - oy) / (p3.y - oy);
        }
        // Bottom Left
        const p4 = rect.bottomLeft;
        if (p4.x < ox) {
            sx4 = (this.x - ox) / (p4.x - ox);
        }
        if (p4.y > oy) {
            sy4 = (this.y + this.height - oy) / (p4.y - oy);
        }
        return {
            sx: Math.min(sx1, sx2, sx3, sx4),
            sy: Math.min(sy1, sy2, sy3, sy4),
        };
    }
    /**
     * Returns a number that specifies the maximum scaling that can be applied to
     * the rectangle along both axes so that it would still fit into `limit`. If
     * `origin` is specified, the rectangle is scaled around it; otherwise, it is
     * scaled around its center.
     */
    getMaxUniformScaleToFit(limit, origin = this.center) {
        const scale = this.getMaxScaleToFit(limit, origin);
        return Math.min(scale.sx, scale.sy);
    }
    containsPoint(x, y) {
        return _util__WEBPACK_IMPORTED_MODULE_0__.GeometryUtil.containsPoint(this, _point__WEBPACK_IMPORTED_MODULE_3__.Point.create(x, y));
    }
    containsRect(x, y, width, height) {
        const b = Rectangle.create(x, y, width, height);
        const x1 = this.x;
        const y1 = this.y;
        const w1 = this.width;
        const h1 = this.height;
        const x2 = b.x;
        const y2 = b.y;
        const w2 = b.width;
        const h2 = b.height;
        // one of the dimensions is 0
        if (w1 === 0 || h1 === 0 || w2 === 0 || h2 === 0) {
            return false;
        }
        return x2 >= x1 && y2 >= y1 && x2 + w2 <= x1 + w1 && y2 + h2 <= y1 + h1;
    }
    /**
     * Returns an array of the intersection points of the rectangle and the line.
     * Return `null` if no intersection exists.
     */
    intersectsWithLine(line) {
        const rectLines = [
            this.topLine,
            this.rightLine,
            this.bottomLine,
            this.leftLine,
        ];
        const points = [];
        const dedupeArr = [];
        rectLines.forEach((l) => {
            const p = line.intersectsWithLine(l);
            if (p !== null && dedupeArr.indexOf(p.toString()) < 0) {
                points.push(p);
                dedupeArr.push(p.toString());
            }
        });
        return points.length > 0 ? points : null;
    }
    /**
     * Returns the point on the boundary of the rectangle that is the intersection
     * of the rectangle with a line starting in the center the rectangle ending in
     * the point `p`.
     *
     * If `angle` is specified, the intersection will take into account the
     * rotation of the rectangle by `angle` degrees around its center.
     */
    intersectsWithLineFromCenterToPoint(p, angle) {
        const ref = _point__WEBPACK_IMPORTED_MODULE_3__.Point.clone(p);
        const center = this.center;
        let result = null;
        if (angle != null && angle !== 0) {
            ref.rotate(angle, center);
        }
        const sides = [this.topLine, this.rightLine, this.bottomLine, this.leftLine];
        const connector = new _line__WEBPACK_IMPORTED_MODULE_2__.Line(center, ref);
        for (let i = sides.length - 1; i >= 0; i -= 1) {
            const intersection = sides[i].intersectsWithLine(connector);
            if (intersection !== null) {
                result = intersection;
                break;
            }
        }
        if (result && angle != null && angle !== 0) {
            result.rotate(-angle, center);
        }
        return result;
    }
    intersectsWithRect(x, y, width, height) {
        const ref = Rectangle.create(x, y, width, height);
        // no intersection
        if (!this.isIntersectWithRect(ref)) {
            return null;
        }
        const myOrigin = this.origin;
        const myCorner = this.corner;
        const rOrigin = ref.origin;
        const rCorner = ref.corner;
        const xx = Math.max(myOrigin.x, rOrigin.x);
        const yy = Math.max(myOrigin.y, rOrigin.y);
        return new Rectangle(xx, yy, Math.min(myCorner.x, rCorner.x) - xx, Math.min(myCorner.y, rCorner.y) - yy);
    }
    isIntersectWithRect(x, y, width, height) {
        const ref = Rectangle.create(x, y, width, height);
        const myOrigin = this.origin;
        const myCorner = this.corner;
        const rOrigin = ref.origin;
        const rCorner = ref.corner;
        if (rCorner.x <= myOrigin.x ||
            rCorner.y <= myOrigin.y ||
            rOrigin.x >= myCorner.x ||
            rOrigin.y >= myCorner.y) {
            return false;
        }
        return true;
    }
    /**
     * Normalize the rectangle, i.e. make it so that it has non-negative
     * width and height. If width is less than `0`, the function swaps left and
     * right corners and if height is less than `0`, the top and bottom corners
     * are swapped.
     */
    normalize() {
        let newx = this.x;
        let newy = this.y;
        let newwidth = this.width;
        let newheight = this.height;
        if (this.width < 0) {
            newx = this.x + this.width;
            newwidth = -this.width;
        }
        if (this.height < 0) {
            newy = this.y + this.height;
            newheight = -this.height;
        }
        this.x = newx;
        this.y = newy;
        this.width = newwidth;
        this.height = newheight;
        return this;
    }
    /**
     * Returns a rectangle that is a union of this rectangle and rectangle `rect`.
     */
    union(rect) {
        const ref = Rectangle.clone(rect);
        const myOrigin = this.origin;
        const myCorner = this.corner;
        const rOrigin = ref.origin;
        const rCorner = ref.corner;
        const originX = Math.min(myOrigin.x, rOrigin.x);
        const originY = Math.min(myOrigin.y, rOrigin.y);
        const cornerX = Math.max(myCorner.x, rCorner.x);
        const cornerY = Math.max(myCorner.y, rCorner.y);
        return new Rectangle(originX, originY, cornerX - originX, cornerY - originY);
    }
    /**
     * Returns a string ("top", "left", "right" or "bottom") denoting the side of
     * the rectangle which is nearest to the point `p`.
     */
    getNearestSideToPoint(p) {
        const ref = _point__WEBPACK_IMPORTED_MODULE_3__.Point.clone(p);
        const distLeft = ref.x - this.x;
        const distRight = this.x + this.width - ref.x;
        const distTop = ref.y - this.y;
        const distBottom = this.y + this.height - ref.y;
        let closest = distLeft;
        let side = 'left';
        if (distRight < closest) {
            closest = distRight;
            side = 'right';
        }
        if (distTop < closest) {
            closest = distTop;
            side = 'top';
        }
        if (distBottom < closest) {
            side = 'bottom';
        }
        return side;
    }
    /**
     * Returns a point on the boundary of the rectangle nearest to the point `p`.
     */
    getNearestPointToPoint(p) {
        const ref = _point__WEBPACK_IMPORTED_MODULE_3__.Point.clone(p);
        if (this.containsPoint(ref)) {
            const side = this.getNearestSideToPoint(ref);
            if (side === 'left') {
                return new _point__WEBPACK_IMPORTED_MODULE_3__.Point(this.x, ref.y);
            }
            if (side === 'top') {
                return new _point__WEBPACK_IMPORTED_MODULE_3__.Point(ref.x, this.y);
            }
            if (side === 'right') {
                return new _point__WEBPACK_IMPORTED_MODULE_3__.Point(this.x + this.width, ref.y);
            }
            if (side === 'bottom') {
                return new _point__WEBPACK_IMPORTED_MODULE_3__.Point(ref.x, this.y + this.height);
            }
        }
        return ref.adhereToRect(this);
    }
    equals(rect) {
        return (rect != null &&
            rect.x === this.x &&
            rect.y === this.y &&
            rect.width === this.width &&
            rect.height === this.height);
    }
    clone() {
        return new Rectangle(this.x, this.y, this.width, this.height);
    }
    toJSON() {
        return { x: this.x, y: this.y, width: this.width, height: this.height };
    }
    serialize() {
        return `${this.x} ${this.y} ${this.width} ${this.height}`;
    }
}
(function (Rectangle) {
    function isRectangle(instance) {
        return instance != null && instance instanceof Rectangle;
    }
    Rectangle.isRectangle = isRectangle;
})(Rectangle || (Rectangle = {}));
(function (Rectangle) {
    function isRectangleLike(o) {
        return (o != null &&
            typeof o === 'object' &&
            typeof o.x === 'number' &&
            typeof o.y === 'number' &&
            typeof o.width === 'number' &&
            typeof o.height === 'number');
    }
    Rectangle.isRectangleLike = isRectangleLike;
})(Rectangle || (Rectangle = {}));
(function (Rectangle) {
    function create(x, y, width, height) {
        if (x == null || typeof x === 'number') {
            return new Rectangle(x, y, width, height);
        }
        return clone(x);
    }
    Rectangle.create = create;
    function clone(rect) {
        if (Rectangle.isRectangle(rect)) {
            return rect.clone();
        }
        if (Array.isArray(rect)) {
            return new Rectangle(rect[0], rect[1], rect[2], rect[3]);
        }
        return new Rectangle(rect.x, rect.y, rect.width, rect.height);
    }
    Rectangle.clone = clone;
    /**
     * Returns a new rectangle from the given ellipse.
     */
    function fromEllipse(ellipse) {
        return new Rectangle(ellipse.x - ellipse.a, ellipse.y - ellipse.b, 2 * ellipse.a, 2 * ellipse.b);
    }
    Rectangle.fromEllipse = fromEllipse;
    function fromSize(size) {
        return new Rectangle(0, 0, size.width, size.height);
    }
    Rectangle.fromSize = fromSize;
    function fromPositionAndSize(pos, size) {
        return new Rectangle(pos.x, pos.y, size.width, size.height);
    }
    Rectangle.fromPositionAndSize = fromPositionAndSize;
})(Rectangle || (Rectangle = {}));
//# sourceMappingURL=rectangle.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-geometry/es/util.js":
/*!***************************************************!*\
  !*** ./node_modules/@antv/x6-geometry/es/util.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GeometryUtil: () => (/* binding */ GeometryUtil)
/* harmony export */ });
var GeometryUtil;
(function (GeometryUtil) {
    function round(num, precision = 0) {
        return Number.isInteger(num) ? num : +num.toFixed(precision);
    }
    GeometryUtil.round = round;
    function random(min, max) {
        let mmin;
        let mmax;
        if (max == null) {
            mmax = min == null ? 1 : min;
            mmin = 0;
        }
        else {
            mmax = max;
            mmin = min == null ? 0 : min;
        }
        if (mmax < mmin) {
            const temp = mmin;
            mmin = mmax;
            mmax = temp;
        }
        return Math.floor(Math.random() * (mmax - mmin + 1) + mmin);
    }
    GeometryUtil.random = random;
    function clamp(value, min, max) {
        if (Number.isNaN(value)) {
            return NaN;
        }
        if (Number.isNaN(min) || Number.isNaN(max)) {
            return 0;
        }
        return min < max
            ? value < min
                ? min
                : value > max
                    ? max
                    : value
            : value < max
                ? max
                : value > min
                    ? min
                    : value;
    }
    GeometryUtil.clamp = clamp;
    function snapToGrid(value, gridSize) {
        return gridSize * Math.round(value / gridSize);
    }
    GeometryUtil.snapToGrid = snapToGrid;
    function containsPoint(rect, point) {
        return (point != null &&
            rect != null &&
            point.x >= rect.x &&
            point.x <= rect.x + rect.width &&
            point.y >= rect.y &&
            point.y <= rect.y + rect.height);
    }
    GeometryUtil.containsPoint = containsPoint;
    function squaredLength(p1, p2) {
        const dx = p1.x - p2.x;
        const dy = p1.y - p2.y;
        return dx * dx + dy * dy;
    }
    GeometryUtil.squaredLength = squaredLength;
})(GeometryUtil || (GeometryUtil = {}));
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-plugin-clipboard/es/api.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6-plugin-clipboard/es/api.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _antv_x6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6 */ "./node_modules/@antv/x6/es/index.js");

_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.isClipboardEnabled = function () {
    const clipboard = this.getPlugin('clipboard');
    if (clipboard) {
        return clipboard.isEnabled();
    }
    return false;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.enableClipboard = function () {
    const clipboard = this.getPlugin('clipboard');
    if (clipboard) {
        clipboard.enable();
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.disableClipboard = function () {
    const clipboard = this.getPlugin('clipboard');
    if (clipboard) {
        clipboard.disable();
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.toggleClipboard = function (enabled) {
    const clipboard = this.getPlugin('clipboard');
    if (clipboard) {
        clipboard.toggleEnabled(enabled);
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.isClipboardEmpty = function (options) {
    const clipboard = this.getPlugin('clipboard');
    if (clipboard) {
        return clipboard.isEmpty(options);
    }
    return true;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.getCellsInClipboard = function () {
    const clipboard = this.getPlugin('clipboard');
    if (clipboard) {
        return clipboard.getCellsInClipboard();
    }
    return [];
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.cleanClipboard = function () {
    const clipboard = this.getPlugin('clipboard');
    if (clipboard) {
        clipboard.clean();
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.copy = function (cells, options) {
    const clipboard = this.getPlugin('clipboard');
    if (clipboard) {
        clipboard.copy(cells, options);
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.cut = function (cells, options) {
    const clipboard = this.getPlugin('clipboard');
    if (clipboard) {
        clipboard.cut(cells, options);
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.paste = function (options, graph) {
    const clipboard = this.getPlugin('clipboard');
    if (clipboard) {
        return clipboard.paste(options, graph);
    }
    return [];
};
//# sourceMappingURL=api.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-plugin-clipboard/es/clipboard.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/x6-plugin-clipboard/es/clipboard.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ClipboardImpl: () => (/* binding */ ClipboardImpl)
/* harmony export */ });
/* harmony import */ var _antv_x6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6 */ "./node_modules/@antv/x6/es/index.js");

class ClipboardImpl {
    constructor() {
        this.cells = [];
    }
    copy(cells, graph, options = {}) {
        this.options = Object.assign({}, options);
        const model = _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Model.isModel(graph) ? graph : graph.model;
        const cloned = model.cloneSubGraph(cells, options);
        // sort asc by cell type
        this.cells = _antv_x6__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.sortBy(Object.keys(cloned).map((key) => cloned[key]), (cell) => (cell.isEdge() ? 2 : 1));
        this.serialize(options);
    }
    cut(cells, graph, options = {}) {
        this.copy(cells, graph, options);
        const model = _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.isGraph(graph) ? graph.model : graph;
        model.batchUpdate('cut', () => {
            cells.forEach((cell) => cell.remove());
        });
    }
    paste(graph, options = {}) {
        const localOptions = Object.assign(Object.assign({}, this.options), options);
        const { offset, edgeProps, nodeProps } = localOptions;
        let dx = 20;
        let dy = 20;
        if (offset) {
            dx = typeof offset === 'number' ? offset : offset.dx;
            dy = typeof offset === 'number' ? offset : offset.dy;
        }
        this.deserialize(localOptions);
        const cells = this.cells;
        cells.forEach((cell) => {
            cell.model = null;
            cell.removeProp('zIndex');
            if (dx || dy) {
                cell.translate(dx, dy);
            }
            if (nodeProps && cell.isNode()) {
                cell.prop(nodeProps);
            }
            if (edgeProps && cell.isEdge()) {
                cell.prop(edgeProps);
            }
        });
        const model = _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.isGraph(graph) ? graph.model : graph;
        model.batchUpdate('paste', () => {
            model.addCells(this.cells);
        });
        this.copy(cells, graph, options);
        return cells;
    }
    serialize(options) {
        if (options.useLocalStorage !== false) {
            Storage.save(this.cells);
        }
    }
    deserialize(options) {
        if (options.useLocalStorage) {
            const cells = Storage.fetch();
            if (cells) {
                this.cells = cells;
            }
        }
    }
    isEmpty(options = {}) {
        if (options.useLocalStorage) {
            // With useLocalStorage turned on, no real cells can be obtained without deserialize first
            // https://github.com/antvis/X6/issues/2573
            this.deserialize(options);
        }
        return this.cells.length <= 0;
    }
    clean() {
        this.options = {};
        this.cells = [];
        Storage.clean();
    }
}
var Storage;
(function (Storage) {
    const LOCAL_STORAGE_KEY = `${_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Config.prefixCls}.clipboard.cells`;
    function save(cells) {
        if (window.localStorage) {
            const data = cells.map((cell) => cell.toJSON());
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(data));
        }
    }
    Storage.save = save;
    function fetch() {
        if (window.localStorage) {
            const raw = localStorage.getItem(LOCAL_STORAGE_KEY);
            const cells = raw ? JSON.parse(raw) : [];
            if (cells) {
                return _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Model.fromJSON(cells);
            }
        }
    }
    Storage.fetch = fetch;
    function clean() {
        if (window.localStorage) {
            localStorage.removeItem(LOCAL_STORAGE_KEY);
        }
    }
    Storage.clean = clean;
})(Storage || (Storage = {}));
//# sourceMappingURL=clipboard.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-plugin-clipboard/es/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@antv/x6-plugin-clipboard/es/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Clipboard: () => (/* binding */ Clipboard)
/* harmony export */ });
/* harmony import */ var _antv_x6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6 */ "./node_modules/@antv/x6/es/index.js");
/* harmony import */ var _clipboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./clipboard */ "./node_modules/@antv/x6-plugin-clipboard/es/clipboard.js");
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./api */ "./node_modules/@antv/x6-plugin-clipboard/es/api.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};



class Clipboard extends _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Basecoat {
    get disabled() {
        return this.options.enabled !== true;
    }
    get cells() {
        return this.clipboardImpl.cells;
    }
    constructor(options = {}) {
        super();
        this.name = 'clipboard';
        this.options = Object.assign({ enabled: true }, options);
    }
    init(graph) {
        this.graph = graph;
        this.clipboardImpl = new _clipboard__WEBPACK_IMPORTED_MODULE_1__.ClipboardImpl();
        this.clipboardImpl.deserialize(this.options);
    }
    // #region api
    isEnabled() {
        return !this.disabled;
    }
    enable() {
        if (this.disabled) {
            this.options.enabled = true;
        }
    }
    disable() {
        if (!this.disabled) {
            this.options.enabled = false;
        }
    }
    toggleEnabled(enabled) {
        if (enabled != null) {
            if (enabled !== this.isEnabled()) {
                if (enabled) {
                    this.enable();
                }
                else {
                    this.disable();
                }
            }
        }
        else if (this.isEnabled()) {
            this.disable();
        }
        else {
            this.enable();
        }
        return this;
    }
    isEmpty(options = {}) {
        return this.clipboardImpl.isEmpty(options);
    }
    getCellsInClipboard() {
        return this.cells;
    }
    clean(force) {
        if (!this.disabled || force) {
            this.clipboardImpl.clean();
            this.notify('clipboard:changed', { cells: [] });
        }
        return this;
    }
    copy(cells, options = {}) {
        if (!this.disabled) {
            this.clipboardImpl.copy(cells, this.graph, Object.assign(Object.assign({}, this.commonOptions), options));
            this.notify('clipboard:changed', { cells });
        }
        return this;
    }
    cut(cells, options = {}) {
        if (!this.disabled) {
            this.clipboardImpl.cut(cells, this.graph, Object.assign(Object.assign({}, this.commonOptions), options));
            this.notify('clipboard:changed', { cells });
        }
        return this;
    }
    paste(options = {}, graph = this.graph) {
        if (!this.disabled) {
            return this.clipboardImpl.paste(graph, Object.assign(Object.assign({}, this.commonOptions), options));
        }
        return [];
    }
    // #endregion
    get commonOptions() {
        const _a = this.options, { enabled } = _a, others = __rest(_a, ["enabled"]);
        return others;
    }
    notify(name, args) {
        this.trigger(name, args);
        this.graph.trigger(name, args);
    }
    dispose() {
        this.clean(true);
        this.off();
    }
}
__decorate([
    _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Basecoat.dispose()
], Clipboard.prototype, "dispose", null);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-plugin-history/es/api.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6-plugin-history/es/api.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _antv_x6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6 */ "./node_modules/@antv/x6/es/index.js");

_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.isHistoryEnabled = function () {
    const history = this.getPlugin('history');
    if (history) {
        return history.isEnabled();
    }
    return false;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.enableHistory = function () {
    const history = this.getPlugin('history');
    if (history) {
        history.enable();
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.disableHistory = function () {
    const history = this.getPlugin('history');
    if (history) {
        history.disable();
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.toggleHistory = function (enabled) {
    const history = this.getPlugin('history');
    if (history) {
        history.toggleEnabled(enabled);
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.undo = function (options) {
    const history = this.getPlugin('history');
    if (history) {
        history.undo(options);
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.redo = function (options) {
    const history = this.getPlugin('history');
    if (history) {
        history.redo(options);
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.undoAndCancel = function (options) {
    const history = this.getPlugin('history');
    if (history) {
        history.cancel(options);
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.canUndo = function () {
    const history = this.getPlugin('history');
    if (history) {
        return history.canUndo();
    }
    return false;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.canRedo = function () {
    const history = this.getPlugin('history');
    if (history) {
        return history.canRedo();
    }
    return false;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.cleanHistory = function (options) {
    const history = this.getPlugin('history');
    if (history) {
        history.clean(options);
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.getHistoryStackSize = function () {
    const history = this.getPlugin('history');
    return history.getSize();
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.getUndoStackSize = function () {
    const history = this.getPlugin('history');
    return history.getUndoSize();
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.getRedoStackSize = function () {
    const history = this.getPlugin('history');
    return history.getRedoSize();
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.getUndoRemainSize = function () {
    const history = this.getPlugin('history');
    return history.getUndoRemainSize();
};
//# sourceMappingURL=api.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-plugin-history/es/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6-plugin-history/es/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   History: () => (/* binding */ History)
/* harmony export */ });
/* harmony import */ var _antv_x6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6 */ "./node_modules/@antv/x6/es/index.js");
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./api */ "./node_modules/@antv/x6-plugin-history/es/api.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


class History extends _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Basecoat {
    constructor(options = {}) {
        super();
        this.name = 'history';
        this.batchCommands = null;
        this.batchLevel = 0;
        this.lastBatchIndex = -1;
        this.freezed = false;
        this.stackSize = 0; // 0: not limit
        this.handlers = [];
        const { stackSize = 0 } = options;
        this.stackSize = stackSize;
        this.options = Util.getOptions(options);
        this.validator = new History.Validator({
            history: this,
            cancelInvalid: this.options.cancelInvalid,
        });
    }
    init(graph) {
        this.graph = graph;
        this.model = this.graph.model;
        this.clean();
        this.startListening();
    }
    // #region api
    isEnabled() {
        return !this.disabled;
    }
    enable() {
        if (this.disabled) {
            this.options.enabled = true;
        }
    }
    disable() {
        if (!this.disabled) {
            this.options.enabled = false;
        }
    }
    toggleEnabled(enabled) {
        if (enabled != null) {
            if (enabled !== this.isEnabled()) {
                if (enabled) {
                    this.enable();
                }
                else {
                    this.disable();
                }
            }
        }
        else if (this.isEnabled()) {
            this.disable();
        }
        else {
            this.enable();
        }
        return this;
    }
    undo(options = {}) {
        if (!this.disabled) {
            const cmd = this.undoStack.pop();
            if (cmd) {
                this.revertCommand(cmd, options);
                this.redoStack.push(cmd);
                this.notify('undo', cmd, options);
            }
        }
        return this;
    }
    redo(options = {}) {
        if (!this.disabled) {
            const cmd = this.redoStack.pop();
            if (cmd) {
                this.applyCommand(cmd, options);
                this.undoStackPush(cmd);
                this.notify('redo', cmd, options);
            }
        }
        return this;
    }
    /**
     * Same as `undo()` but does not store the undo-ed command to the
     * `redoStack`. Canceled command therefore cannot be redo-ed.
     */
    cancel(options = {}) {
        if (!this.disabled) {
            const cmd = this.undoStack.pop();
            if (cmd) {
                this.revertCommand(cmd, options);
                this.redoStack = [];
                this.notify('cancel', cmd, options);
            }
        }
        return this;
    }
    getSize() {
        return this.stackSize;
    }
    getUndoRemainSize() {
        const ul = this.undoStack.length;
        return this.stackSize - ul;
    }
    getUndoSize() {
        return this.undoStack.length;
    }
    getRedoSize() {
        return this.redoStack.length;
    }
    canUndo() {
        return !this.disabled && this.undoStack.length > 0;
    }
    canRedo() {
        return !this.disabled && this.redoStack.length > 0;
    }
    clean(options = {}) {
        this.undoStack = [];
        this.redoStack = [];
        this.notify('clean', null, options);
        return this;
    }
    // #endregion
    get disabled() {
        return this.options.enabled !== true;
    }
    validate(events, ...callbacks) {
        this.validator.validate(events, ...callbacks);
        return this;
    }
    startListening() {
        this.model.on('batch:start', this.initBatchCommand, this);
        this.model.on('batch:stop', this.storeBatchCommand, this);
        if (this.options.eventNames) {
            this.options.eventNames.forEach((name, index) => {
                this.handlers[index] = this.addCommand.bind(this, name);
                this.model.on(name, this.handlers[index]);
            });
        }
        this.validator.on('invalid', (args) => this.trigger('invalid', args));
    }
    stopListening() {
        this.model.off('batch:start', this.initBatchCommand, this);
        this.model.off('batch:stop', this.storeBatchCommand, this);
        if (this.options.eventNames) {
            this.options.eventNames.forEach((name, index) => {
                this.model.off(name, this.handlers[index]);
            });
            this.handlers.length = 0;
        }
        this.validator.off('invalid');
    }
    createCommand(options) {
        return {
            batch: options ? options.batch : false,
            data: {},
        };
    }
    revertCommand(cmd, options) {
        this.freezed = true;
        const cmds = Array.isArray(cmd) ? Util.sortBatchCommands(cmd) : [cmd];
        for (let i = cmds.length - 1; i >= 0; i -= 1) {
            const cmd = cmds[i];
            const localOptions = Object.assign(Object.assign({}, options), _antv_x6__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.pick(cmd.options, this.options.revertOptionsList || []));
            this.executeCommand(cmd, true, localOptions);
        }
        this.freezed = false;
    }
    applyCommand(cmd, options) {
        this.freezed = true;
        const cmds = Array.isArray(cmd) ? Util.sortBatchCommands(cmd) : [cmd];
        for (let i = 0; i < cmds.length; i += 1) {
            const cmd = cmds[i];
            const localOptions = Object.assign(Object.assign({}, options), _antv_x6__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.pick(cmd.options, this.options.applyOptionsList || []));
            this.executeCommand(cmd, false, localOptions);
        }
        this.freezed = false;
    }
    executeCommand(cmd, revert, options) {
        const model = this.model;
        // const cell = cmd.modelChange ? model : model.getCell(cmd.data.id!)
        const cell = model.getCell(cmd.data.id);
        const event = cmd.event;
        if ((Util.isAddEvent(event) && revert) ||
            (Util.isRemoveEvent(event) && !revert)) {
            cell && cell.remove(options);
        }
        else if ((Util.isAddEvent(event) && !revert) ||
            (Util.isRemoveEvent(event) && revert)) {
            const data = cmd.data;
            if (data.node) {
                model.addNode(data.props, options);
            }
            else if (data.edge) {
                model.addEdge(data.props, options);
            }
        }
        else if (Util.isChangeEvent(event)) {
            const data = cmd.data;
            const key = data.key;
            if (key && cell) {
                const value = revert ? data.prev[key] : data.next[key];
                if (data.key === 'attrs') {
                    const hasUndefinedAttr = this.ensureUndefinedAttrs(value, revert ? data.next[key] : data.prev[key]);
                    if (hasUndefinedAttr) {
                        // recognize a `dirty` flag and re-render itself in order to remove
                        // the attribute from SVGElement.
                        options.dirty = true;
                    }
                }
                cell.prop(key, value, options);
            }
        }
        else {
            const executeCommand = this.options.executeCommand;
            if (executeCommand) {
                _antv_x6__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(executeCommand, this, cmd, revert, options);
            }
        }
    }
    addCommand(event, args) {
        if (this.freezed || this.disabled) {
            return;
        }
        const eventArgs = args;
        const options = eventArgs.options || {};
        if (options.dryrun) {
            return;
        }
        if ((Util.isAddEvent(event) && this.options.ignoreAdd) ||
            (Util.isRemoveEvent(event) && this.options.ignoreRemove) ||
            (Util.isChangeEvent(event) && this.options.ignoreChange)) {
            return;
        }
        // before
        // ------
        const before = this.options.beforeAddCommand;
        if (before != null &&
            _antv_x6__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(before, this, event, args) === false) {
            return;
        }
        if (event === 'cell:change:*') {
            // eslint-disable-next-line
            event = `cell:change:${eventArgs.key}`;
        }
        const cell = eventArgs.cell;
        const isModelChange = _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Model.isModel(cell);
        let cmd;
        if (this.batchCommands) {
            // In most cases we are working with same object, doing
            // same action etc. translate an object piece by piece.
            cmd = this.batchCommands[Math.max(this.lastBatchIndex, 0)];
            // Check if we are start working with new object or performing different
            // action with it. Note, that command is uninitialized when lastCmdIndex
            // equals -1. In that case we are done, command we were looking for is
            // already set
            const diffId = (isModelChange && !cmd.modelChange) || cmd.data.id !== cell.id;
            const diffName = cmd.event !== event;
            if (this.lastBatchIndex >= 0 && (diffId || diffName)) {
                // Trying to find command first, which was performing same
                // action with the object as we are doing now with cell.
                const index = this.batchCommands.findIndex((cmd) => ((isModelChange && cmd.modelChange) || cmd.data.id === cell.id) &&
                    cmd.event === event);
                if (index < 0 || Util.isAddEvent(event) || Util.isRemoveEvent(event)) {
                    cmd = this.createCommand({ batch: true });
                }
                else {
                    cmd = this.batchCommands[index];
                    this.batchCommands.splice(index, 1);
                }
                this.batchCommands.push(cmd);
                this.lastBatchIndex = this.batchCommands.length - 1;
            }
        }
        else {
            cmd = this.createCommand({ batch: false });
        }
        // add & remove
        // ------------
        if (Util.isAddEvent(event) || Util.isRemoveEvent(event)) {
            const data = cmd.data;
            cmd.event = event;
            cmd.options = options;
            data.id = cell.id;
            data.props = _antv_x6__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(cell.toJSON());
            if (cell.isEdge()) {
                data.edge = true;
            }
            else if (cell.isNode()) {
                data.node = true;
            }
            return this.push(cmd, options);
        }
        // change:*
        // --------
        if (Util.isChangeEvent(event)) {
            const key = args.key;
            const data = cmd.data;
            if (!cmd.batch || !cmd.event) {
                // Do this only once. Set previous data and action (also
                // serves as a flag so that we don't repeat this branche).
                cmd.event = event;
                cmd.options = options;
                data.key = key;
                if (data.prev == null) {
                    data.prev = {};
                }
                data.prev[key] = _antv_x6__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(cell.previous(key));
                if (isModelChange) {
                    cmd.modelChange = true;
                }
                else {
                    data.id = cell.id;
                }
            }
            if (data.next == null) {
                data.next = {};
            }
            data.next[key] = _antv_x6__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(cell.prop(key));
            return this.push(cmd, options);
        }
        // others
        // ------
        const afterAddCommand = this.options.afterAddCommand;
        if (afterAddCommand) {
            _antv_x6__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(afterAddCommand, this, event, args, cmd);
        }
        this.push(cmd, options);
    }
    /**
     * Gather multiple changes into a single command. These commands could
     * be reverted with single `undo()` call. From the moment the function
     * is called every change made on model is not stored into the undoStack.
     * Changes are temporarily kept until `storeBatchCommand()` is called.
     */
    // eslint-disable-next-line
    initBatchCommand(options) {
        if (this.freezed) {
            return;
        }
        if (this.batchCommands) {
            this.batchLevel += 1;
        }
        else {
            this.batchCommands = [this.createCommand({ batch: true })];
            this.batchLevel = 0;
            this.lastBatchIndex = -1;
        }
    }
    /**
     * Store changes temporarily kept in the undoStack. You have to call this
     * function as many times as `initBatchCommand()` been called.
     */
    storeBatchCommand(options) {
        if (this.freezed) {
            return;
        }
        if (this.batchCommands && this.batchLevel <= 0) {
            const cmds = this.filterBatchCommand(this.batchCommands);
            if (cmds.length > 0) {
                this.redoStack = [];
                this.undoStackPush(cmds);
                this.consolidateCommands();
                this.notify('add', cmds, options);
            }
            this.batchCommands = null;
            this.lastBatchIndex = -1;
            this.batchLevel = 0;
        }
        else if (this.batchCommands && this.batchLevel > 0) {
            this.batchLevel -= 1;
        }
    }
    filterBatchCommand(batchCommands) {
        let cmds = batchCommands.slice();
        const result = [];
        while (cmds.length > 0) {
            const cmd = cmds.shift();
            const evt = cmd.event;
            const id = cmd.data.id;
            if (evt != null && (id != null || cmd.modelChange)) {
                if (Util.isAddEvent(evt)) {
                    const index = cmds.findIndex((c) => Util.isRemoveEvent(c.event) && c.data.id === id);
                    if (index >= 0) {
                        cmds = cmds.filter((c, i) => index < i || c.data.id !== id);
                        continue;
                    }
                }
                else if (Util.isRemoveEvent(evt)) {
                    const index = cmds.findIndex((c) => Util.isAddEvent(c.event) && c.data.id === id);
                    if (index >= 0) {
                        cmds.splice(index, 1);
                        continue;
                    }
                }
                else if (Util.isChangeEvent(evt)) {
                    const data = cmd.data;
                    if (_antv_x6__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isEqual(data.prev, data.next)) {
                        continue;
                    }
                }
                else {
                    // pass
                }
                result.push(cmd);
            }
        }
        return result;
    }
    notify(event, cmd, options) {
        const cmds = cmd == null ? null : Array.isArray(cmd) ? cmd : [cmd];
        this.emit(event, { cmds, options });
        this.graph.trigger(`history:${event}`, { cmds, options });
        this.emit('change', { cmds, options });
        this.graph.trigger('history:change', { cmds, options });
    }
    push(cmd, options) {
        this.redoStack = [];
        if (cmd.batch) {
            this.lastBatchIndex = Math.max(this.lastBatchIndex, 0);
            this.emit('batch', { cmd, options });
        }
        else {
            this.undoStackPush(cmd);
            this.consolidateCommands();
            this.notify('add', cmd, options);
        }
    }
    /**
     * Conditionally combine multiple undo items into one.
     *
     * Currently this is only used combine a `cell:changed:position` event
     * followed by multiple `cell:change:parent` and `cell:change:children`
     * events, such that a "move + embed" action can be undone in one step.
     *
     * See https://github.com/antvis/X6/issues/2421
     *
     * This is an ugly WORKAROUND. It does not solve deficiencies in the batch
     * system itself.
     */
    consolidateCommands() {
        var _a;
        const lastCommandGroup = this.undoStack[this.undoStack.length - 1];
        const penultimateCommandGroup = this.undoStack[this.undoStack.length - 2];
        // We are looking for at least one cell:change:parent
        // and one cell:change:children
        if (!Array.isArray(lastCommandGroup)) {
            return;
        }
        const eventTypes = new Set(lastCommandGroup.map((cmd) => cmd.event));
        if (eventTypes.size !== 2 ||
            !eventTypes.has('cell:change:parent') ||
            !eventTypes.has('cell:change:children')) {
            return;
        }
        // We are looking for events from user interactions
        if (!lastCommandGroup.every((cmd) => { var _a; return cmd.batch && ((_a = cmd.options) === null || _a === void 0 ? void 0 : _a.ui); })) {
            return;
        }
        // We are looking for a command group with exactly one event, whose event
        // type is cell:change:position, and is from user interactions
        if (!Array.isArray(penultimateCommandGroup) ||
            penultimateCommandGroup.length !== 1) {
            return;
        }
        const maybePositionChange = penultimateCommandGroup[0];
        if (maybePositionChange.event !== 'cell:change:position' ||
            !((_a = maybePositionChange.options) === null || _a === void 0 ? void 0 : _a.ui)) {
            return;
        }
        // Actually consolidating the commands we get
        penultimateCommandGroup.push(...lastCommandGroup);
        this.undoStack.pop();
    }
    undoStackPush(cmd) {
        if (this.stackSize === 0) {
            this.undoStack.push(cmd);
            return;
        }
        if (this.undoStack.length >= this.stackSize) {
            this.undoStack.shift();
        }
        this.undoStack.push(cmd);
    }
    ensureUndefinedAttrs(newAttrs, oldAttrs) {
        let hasUndefinedAttr = false;
        if (newAttrs !== null &&
            oldAttrs !== null &&
            typeof newAttrs === 'object' &&
            typeof oldAttrs === 'object') {
            Object.keys(oldAttrs).forEach((key) => {
                // eslint-disable-next-line no-prototype-builtins
                if (newAttrs[key] === undefined && oldAttrs[key] !== undefined) {
                    newAttrs[key] = undefined;
                    hasUndefinedAttr = true;
                }
                else if (typeof newAttrs[key] === 'object' &&
                    typeof oldAttrs[key] === 'object') {
                    hasUndefinedAttr = this.ensureUndefinedAttrs(newAttrs[key], oldAttrs[key]);
                }
            });
        }
        return hasUndefinedAttr;
    }
    dispose() {
        this.validator.dispose();
        this.clean();
        this.stopListening();
        this.off();
    }
}
__decorate([
    _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Basecoat.dispose()
], History.prototype, "dispose", null);
(function (History) {
    /**
     * Runs a set of callbacks to determine if a command is valid. This is
     * useful for checking if a certain action in your application does
     * lead to an invalid state of the graph.
     */
    class Validator extends _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Basecoat {
        constructor(options) {
            super();
            this.map = {};
            this.command = options.history;
            this.cancelInvalid = options.cancelInvalid !== false;
            this.command.on('add', this.onCommandAdded, this);
        }
        onCommandAdded({ cmds }) {
            return Array.isArray(cmds)
                ? cmds.every((cmd) => this.isValidCommand(cmd))
                : this.isValidCommand(cmds);
        }
        isValidCommand(cmd) {
            if (cmd.options && cmd.options.validation === false) {
                return true;
            }
            const callbacks = (cmd.event && this.map[cmd.event]) || [];
            let handoverErr = null;
            callbacks.forEach((routes) => {
                let i = 0;
                const rollup = (err) => {
                    const fn = routes[i];
                    i += 1;
                    try {
                        if (fn) {
                            fn(err, cmd, rollup);
                        }
                        else {
                            handoverErr = err;
                            return;
                        }
                    }
                    catch (err) {
                        rollup(err);
                    }
                };
                rollup(handoverErr);
            });
            if (handoverErr) {
                if (this.cancelInvalid) {
                    this.command.cancel();
                }
                this.emit('invalid', { err: handoverErr });
                return false;
            }
            return true;
        }
        validate(events, ...callbacks) {
            const evts = Array.isArray(events) ? events : events.split(/\s+/);
            callbacks.forEach((callback) => {
                if (typeof callback !== 'function') {
                    throw new Error(`${evts.join(' ')} requires callback functions.`);
                }
            });
            evts.forEach((event) => {
                if (this.map[event] == null) {
                    this.map[event] = [];
                }
                this.map[event].push(callbacks);
            });
            return this;
        }
        dispose() {
            this.command.off('add', this.onCommandAdded, this);
        }
    }
    __decorate([
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Basecoat.dispose()
    ], Validator.prototype, "dispose", null);
    History.Validator = Validator;
})(History || (History = {}));
var Util;
(function (Util) {
    function isAddEvent(event) {
        return event === 'cell:added';
    }
    Util.isAddEvent = isAddEvent;
    function isRemoveEvent(event) {
        return event === 'cell:removed';
    }
    Util.isRemoveEvent = isRemoveEvent;
    function isChangeEvent(event) {
        return event != null && event.startsWith('cell:change:');
    }
    Util.isChangeEvent = isChangeEvent;
    function getOptions(options) {
        const reservedNames = [
            'cell:added',
            'cell:removed',
            'cell:change:*',
        ];
        const batchEvents = ['batch:start', 'batch:stop'];
        const eventNames = options.eventNames
            ? options.eventNames.filter((event) => !(Util.isChangeEvent(event) ||
                reservedNames.includes(event) ||
                batchEvents.includes(event)))
            : reservedNames;
        return Object.assign(Object.assign({ enabled: true }, options), { eventNames, applyOptionsList: options.applyOptionsList || ['propertyPath'], revertOptionsList: options.revertOptionsList || ['propertyPath'] });
    }
    Util.getOptions = getOptions;
    function sortBatchCommands(cmds) {
        const results = [];
        for (let i = 0, ii = cmds.length; i < ii; i += 1) {
            const cmd = cmds[i];
            let index = null;
            if (Util.isAddEvent(cmd.event)) {
                const id = cmd.data.id;
                for (let j = 0; j < i; j += 1) {
                    if (cmds[j].data.id === id) {
                        index = j;
                        break;
                    }
                }
            }
            if (index !== null) {
                results.splice(index, 0, cmd);
            }
            else {
                results.push(cmd);
            }
        }
        return results;
    }
    Util.sortBatchCommands = sortBatchCommands;
})(Util || (Util = {}));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-plugin-keyboard/es/api.js":
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6-plugin-keyboard/es/api.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _antv_x6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6 */ "./node_modules/@antv/x6/es/index.js");

_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.isKeyboardEnabled = function () {
    const keyboard = this.getPlugin('keyboard');
    if (keyboard) {
        return keyboard.isEnabled();
    }
    return false;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.enableKeyboard = function () {
    const keyboard = this.getPlugin('keyboard');
    if (keyboard) {
        keyboard.enable();
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.disableKeyboard = function () {
    const keyboard = this.getPlugin('keyboard');
    if (keyboard) {
        keyboard.disable();
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.toggleKeyboard = function (enabled) {
    const keyboard = this.getPlugin('keyboard');
    if (keyboard) {
        keyboard.toggleEnabled(enabled);
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.bindKey = function (keys, callback, action) {
    const keyboard = this.getPlugin('keyboard');
    if (keyboard) {
        keyboard.bindKey(keys, callback, action);
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.unbindKey = function (keys, action) {
    const keyboard = this.getPlugin('keyboard');
    if (keyboard) {
        keyboard.unbindKey(keys, action);
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.clearKeys = function () {
    const keyboard = this.getPlugin('keyboard');
    if (keyboard) {
        keyboard.clear();
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.triggerKey = function (key, action) {
    const keyboard = this.getPlugin('keyboard');
    if (keyboard) {
        keyboard.trigger(key, action);
    }
    return this;
};
//# sourceMappingURL=api.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-plugin-keyboard/es/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6-plugin-keyboard/es/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Keyboard: () => (/* binding */ Keyboard)
/* harmony export */ });
/* harmony import */ var _antv_x6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6 */ "./node_modules/@antv/x6/es/index.js");
/* harmony import */ var _keyboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keyboard */ "./node_modules/@antv/x6-plugin-keyboard/es/keyboard.js");
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./api */ "./node_modules/@antv/x6-plugin-keyboard/es/api.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};



class Keyboard extends _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Disposable {
    constructor(options = {}) {
        super();
        this.name = 'keyboard';
        this.options = Object.assign({ enabled: true }, options);
    }
    init(graph) {
        this.keyboardImpl = new _keyboard__WEBPACK_IMPORTED_MODULE_1__.KeyboardImpl(Object.assign(Object.assign({}, this.options), { graph }));
    }
    // #region api
    isEnabled() {
        return !this.keyboardImpl.disabled;
    }
    enable() {
        this.keyboardImpl.enable();
    }
    disable() {
        this.keyboardImpl.disable();
    }
    toggleEnabled(enabled) {
        if (enabled != null) {
            if (enabled !== this.isEnabled()) {
                if (enabled) {
                    this.enable();
                }
                else {
                    this.disable();
                }
            }
        }
        else if (this.isEnabled()) {
            this.disable();
        }
        else {
            this.enable();
        }
        return this;
    }
    bindKey(keys, callback, action) {
        this.keyboardImpl.on(keys, callback, action);
        return this;
    }
    trigger(key, action) {
        this.keyboardImpl.trigger(key, action);
        return this;
    }
    clear() {
        this.keyboardImpl.clear();
        return this;
    }
    unbindKey(keys, action) {
        this.keyboardImpl.off(keys, action);
        return this;
    }
    // #endregion
    dispose() {
        this.keyboardImpl.dispose();
    }
}
__decorate([
    _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Disposable.dispose()
], Keyboard.prototype, "dispose", null);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-plugin-keyboard/es/keyboard.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/x6-plugin-keyboard/es/keyboard.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KeyboardImpl: () => (/* binding */ KeyboardImpl)
/* harmony export */ });
/* harmony import */ var mousetrap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mousetrap */ "./node_modules/mousetrap/mousetrap.js");
/* harmony import */ var mousetrap__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(mousetrap__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _antv_x6__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6 */ "./node_modules/@antv/x6/es/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


class KeyboardImpl extends _antv_x6__WEBPACK_IMPORTED_MODULE_1__.Disposable {
    get graph() {
        return this.options.graph;
    }
    constructor(options) {
        super();
        this.options = options;
        const scroller = this.graph.getPlugin('scroller');
        this.container = scroller ? scroller.container : this.graph.container;
        if (options.global) {
            this.target = document;
        }
        else {
            this.target = this.container;
            if (!this.disabled) {
                // ensure the container focusable
                this.target.setAttribute('tabindex', '-1');
            }
            // change to mouseup event，prevent page stalling caused by focus
            this.graph.on('cell:mouseup', this.focus, this);
            this.graph.on('blank:mouseup', this.focus, this);
        }
        this.mousetrap = KeyboardImpl.createMousetrap(this);
    }
    get disabled() {
        return this.options.enabled !== true;
    }
    enable() {
        if (this.disabled) {
            this.options.enabled = true;
            if (this.target instanceof HTMLElement) {
                this.target.setAttribute('tabindex', '-1');
            }
        }
    }
    disable() {
        if (!this.disabled) {
            this.options.enabled = false;
            if (this.target instanceof HTMLElement) {
                this.target.removeAttribute('tabindex');
            }
        }
    }
    on(keys, callback, action) {
        this.mousetrap.bind(this.getKeys(keys), callback, action);
    }
    off(keys, action) {
        this.mousetrap.unbind(this.getKeys(keys), action);
    }
    clear() {
        this.mousetrap.reset();
    }
    trigger(key, action) {
        this.mousetrap.trigger(key, action);
    }
    focus(e) {
        const isInputEvent = this.isInputEvent(e.e);
        if (isInputEvent) {
            return;
        }
        const target = this.target;
        target.focus({
            preventScroll: true,
        });
    }
    getKeys(keys) {
        return (Array.isArray(keys) ? keys : [keys]).map((key) => this.formatkey(key));
    }
    formatkey(key) {
        const formated = key
            .toLocaleLowerCase()
            .replace(/\s/g, '')
            .replace('delete', 'del')
            .replace('cmd', 'command')
            .replace('arrowup', 'up')
            .replace('arrowright', 'right')
            .replace('arrowdown', 'down')
            .replace('arrowleft', 'left');
        const formatFn = this.options.format;
        if (formatFn) {
            return _antv_x6__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(formatFn, this.graph, formated);
        }
        return formated;
    }
    isGraphEvent(e) {
        const target = e.target;
        const currentTarget = e.currentTarget;
        if (target) {
            if (target === this.target ||
                currentTarget === this.target ||
                target === document.body) {
                return true;
            }
            return _antv_x6__WEBPACK_IMPORTED_MODULE_1__.Dom.contains(this.container, target);
        }
        return false;
    }
    isInputEvent(e) {
        var _a;
        const target = e.target;
        const tagName = (_a = target === null || target === void 0 ? void 0 : target.tagName) === null || _a === void 0 ? void 0 : _a.toLowerCase();
        let isInput = ['input', 'textarea'].includes(tagName);
        if (_antv_x6__WEBPACK_IMPORTED_MODULE_1__.Dom.attr(target, 'contenteditable') === 'true') {
            isInput = true;
        }
        return isInput;
    }
    isEnabledForEvent(e) {
        const allowed = !this.disabled && this.isGraphEvent(e);
        const isInputEvent = this.isInputEvent(e);
        if (allowed) {
            if (isInputEvent && (e.key === 'Backspace' || e.key === 'Delete')) {
                return false;
            }
            if (this.options.guard) {
                return _antv_x6__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(this.options.guard, this.graph, e);
            }
        }
        return allowed;
    }
    dispose() {
        this.mousetrap.reset();
    }
}
__decorate([
    _antv_x6__WEBPACK_IMPORTED_MODULE_1__.Disposable.dispose()
], KeyboardImpl.prototype, "dispose", null);
(function (KeyboardImpl) {
    function createMousetrap(keyboard) {
        const mousetrap = new (mousetrap__WEBPACK_IMPORTED_MODULE_0___default())(keyboard.target);
        const stopCallback = mousetrap.stopCallback;
        mousetrap.stopCallback = (e, elem, combo) => {
            if (keyboard.isEnabledForEvent(e)) {
                if (stopCallback) {
                    return stopCallback.call(mousetrap, e, elem, combo);
                }
                return false;
            }
            return true;
        };
        return mousetrap;
    }
    KeyboardImpl.createMousetrap = createMousetrap;
})(KeyboardImpl || (KeyboardImpl = {}));
//# sourceMappingURL=keyboard.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-plugin-selection/es/api.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6-plugin-selection/es/api.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _antv_x6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6 */ "./node_modules/@antv/x6/es/index.js");

_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.isSelectionEnabled = function () {
    const selection = this.getPlugin('selection');
    if (selection) {
        return selection.isEnabled();
    }
    return false;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.enableSelection = function () {
    const selection = this.getPlugin('selection');
    if (selection) {
        selection.enable();
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.disableSelection = function () {
    const selection = this.getPlugin('selection');
    if (selection) {
        selection.disable();
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.toggleSelection = function (enabled) {
    const selection = this.getPlugin('selection');
    if (selection) {
        selection.toggleEnabled(enabled);
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.isMultipleSelection = function () {
    const selection = this.getPlugin('selection');
    if (selection) {
        return selection.isMultipleSelection();
    }
    return false;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.enableMultipleSelection = function () {
    const selection = this.getPlugin('selection');
    if (selection) {
        selection.enableMultipleSelection();
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.disableMultipleSelection = function () {
    const selection = this.getPlugin('selection');
    if (selection) {
        selection.disableMultipleSelection();
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.toggleMultipleSelection = function (multiple) {
    const selection = this.getPlugin('selection');
    if (selection) {
        selection.toggleMultipleSelection(multiple);
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.isSelectionMovable = function () {
    const selection = this.getPlugin('selection');
    if (selection) {
        return selection.isSelectionMovable();
    }
    return false;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.enableSelectionMovable = function () {
    const selection = this.getPlugin('selection');
    if (selection) {
        selection.enableSelectionMovable();
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.disableSelectionMovable = function () {
    const selection = this.getPlugin('selection');
    if (selection) {
        selection.disableSelectionMovable();
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.toggleSelectionMovable = function (movable) {
    const selection = this.getPlugin('selection');
    if (selection) {
        selection.toggleSelectionMovable(movable);
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.isRubberbandEnabled = function () {
    const selection = this.getPlugin('selection');
    if (selection) {
        return selection.isRubberbandEnabled();
    }
    return false;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.enableRubberband = function () {
    const selection = this.getPlugin('selection');
    if (selection) {
        selection.enableRubberband();
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.disableRubberband = function () {
    const selection = this.getPlugin('selection');
    if (selection) {
        selection.disableRubberband();
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.toggleRubberband = function (enabled) {
    const selection = this.getPlugin('selection');
    if (selection) {
        selection.toggleRubberband(enabled);
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.isStrictRubberband = function () {
    const selection = this.getPlugin('selection');
    if (selection) {
        return selection.isStrictRubberband();
    }
    return false;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.enableStrictRubberband = function () {
    const selection = this.getPlugin('selection');
    if (selection) {
        selection.enableStrictRubberband();
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.disableStrictRubberband = function () {
    const selection = this.getPlugin('selection');
    if (selection) {
        selection.disableStrictRubberband();
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.toggleStrictRubberband = function (strict) {
    const selection = this.getPlugin('selection');
    if (selection) {
        selection.toggleStrictRubberband(strict);
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.setRubberbandModifiers = function (modifiers) {
    const selection = this.getPlugin('selection');
    if (selection) {
        selection.setRubberbandModifiers(modifiers);
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.setSelectionFilter = function (filter) {
    const selection = this.getPlugin('selection');
    if (selection) {
        selection.setSelectionFilter(filter);
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.setSelectionDisplayContent = function (content) {
    const selection = this.getPlugin('selection');
    if (selection) {
        selection.setSelectionDisplayContent(content);
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.isSelectionEmpty = function () {
    const selection = this.getPlugin('selection');
    if (selection) {
        return selection.isEmpty();
    }
    return true;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.cleanSelection = function (options) {
    const selection = this.getPlugin('selection');
    if (selection) {
        selection.clean(options);
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.resetSelection = function (cells, options) {
    const selection = this.getPlugin('selection');
    if (selection) {
        selection.reset(cells, options);
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.getSelectedCells = function () {
    const selection = this.getPlugin('selection');
    if (selection) {
        return selection.getSelectedCells();
    }
    return [];
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.getSelectedCellCount = function () {
    const selection = this.getPlugin('selection');
    if (selection) {
        return selection.getSelectedCellCount();
    }
    return 0;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.isSelected = function (cell) {
    const selection = this.getPlugin('selection');
    if (selection) {
        return selection.isSelected(cell);
    }
    return false;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.select = function (cells, options) {
    const selection = this.getPlugin('selection');
    if (selection) {
        selection.select(cells, options);
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.unselect = function (cells, options) {
    const selection = this.getPlugin('selection');
    if (selection) {
        selection.unselect(cells, options);
    }
    return this;
};
//# sourceMappingURL=api.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-plugin-selection/es/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@antv/x6-plugin-selection/es/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Selection: () => (/* binding */ Selection)
/* harmony export */ });
/* harmony import */ var _antv_x6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6 */ "./node_modules/@antv/x6/es/index.js");
/* harmony import */ var _selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selection */ "./node_modules/@antv/x6-plugin-selection/es/selection.js");
/* harmony import */ var _style_raw__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./style/raw */ "./node_modules/@antv/x6-plugin-selection/es/style/raw.js");
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./api */ "./node_modules/@antv/x6-plugin-selection/es/api.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};




class Selection extends _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Basecoat {
    get rubberbandDisabled() {
        return this.options.enabled !== true || this.options.rubberband !== true;
    }
    get disabled() {
        return this.options.enabled !== true;
    }
    get length() {
        return this.selectionImpl.length;
    }
    get cells() {
        return this.selectionImpl.cells;
    }
    constructor(options = {}) {
        super();
        this.name = 'selection';
        this.movedMap = new WeakMap();
        this.unselectMap = new WeakMap();
        this.options = Object.assign(Object.assign({ enabled: true }, Selection.defaultOptions), options);
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.CssLoader.ensure(this.name, _style_raw__WEBPACK_IMPORTED_MODULE_2__.content);
    }
    init(graph) {
        this.graph = graph;
        this.selectionImpl = new _selection__WEBPACK_IMPORTED_MODULE_1__.SelectionImpl(Object.assign(Object.assign({}, this.options), { graph }));
        this.setup();
        this.startListening();
    }
    // #region api
    isEnabled() {
        return !this.disabled;
    }
    enable() {
        if (this.disabled) {
            this.options.enabled = true;
        }
    }
    disable() {
        if (!this.disabled) {
            this.options.enabled = false;
        }
    }
    toggleEnabled(enabled) {
        if (enabled != null) {
            if (enabled !== this.isEnabled()) {
                if (enabled) {
                    this.enable();
                }
                else {
                    this.disable();
                }
            }
        }
        else if (this.isEnabled()) {
            this.disable();
        }
        else {
            this.enable();
        }
        return this;
    }
    isMultipleSelection() {
        return this.isMultiple();
    }
    enableMultipleSelection() {
        this.enableMultiple();
        return this;
    }
    disableMultipleSelection() {
        this.disableMultiple();
        return this;
    }
    toggleMultipleSelection(multiple) {
        if (multiple != null) {
            if (multiple !== this.isMultipleSelection()) {
                if (multiple) {
                    this.enableMultipleSelection();
                }
                else {
                    this.disableMultipleSelection();
                }
            }
        }
        else if (this.isMultipleSelection()) {
            this.disableMultipleSelection();
        }
        else {
            this.enableMultipleSelection();
        }
        return this;
    }
    isSelectionMovable() {
        return this.options.movable !== false;
    }
    enableSelectionMovable() {
        this.selectionImpl.options.movable = true;
        return this;
    }
    disableSelectionMovable() {
        this.selectionImpl.options.movable = false;
        return this;
    }
    toggleSelectionMovable(movable) {
        if (movable != null) {
            if (movable !== this.isSelectionMovable()) {
                if (movable) {
                    this.enableSelectionMovable();
                }
                else {
                    this.disableSelectionMovable();
                }
            }
        }
        else if (this.isSelectionMovable()) {
            this.disableSelectionMovable();
        }
        else {
            this.enableSelectionMovable();
        }
        return this;
    }
    isRubberbandEnabled() {
        return !this.rubberbandDisabled;
    }
    enableRubberband() {
        if (this.rubberbandDisabled) {
            this.options.rubberband = true;
        }
        return this;
    }
    disableRubberband() {
        if (!this.rubberbandDisabled) {
            this.options.rubberband = false;
        }
        return this;
    }
    toggleRubberband(enabled) {
        if (enabled != null) {
            if (enabled !== this.isRubberbandEnabled()) {
                if (enabled) {
                    this.enableRubberband();
                }
                else {
                    this.disableRubberband();
                }
            }
        }
        else if (this.isRubberbandEnabled()) {
            this.disableRubberband();
        }
        else {
            this.enableRubberband();
        }
        return this;
    }
    isStrictRubberband() {
        return this.selectionImpl.options.strict === true;
    }
    enableStrictRubberband() {
        this.selectionImpl.options.strict = true;
        return this;
    }
    disableStrictRubberband() {
        this.selectionImpl.options.strict = false;
        return this;
    }
    toggleStrictRubberband(strict) {
        if (strict != null) {
            if (strict !== this.isStrictRubberband()) {
                if (strict) {
                    this.enableStrictRubberband();
                }
                else {
                    this.disableStrictRubberband();
                }
            }
        }
        else if (this.isStrictRubberband()) {
            this.disableStrictRubberband();
        }
        else {
            this.enableStrictRubberband();
        }
        return this;
    }
    setRubberbandModifiers(modifiers) {
        this.setModifiers(modifiers);
    }
    setSelectionFilter(filter) {
        this.setFilter(filter);
        return this;
    }
    setSelectionDisplayContent(content) {
        this.setContent(content);
        return this;
    }
    isEmpty() {
        return this.length <= 0;
    }
    clean(options = {}) {
        this.selectionImpl.clean(options);
        return this;
    }
    reset(cells, options = {}) {
        this.selectionImpl.reset(cells ? this.getCells(cells) : [], options);
        return this;
    }
    getSelectedCells() {
        return this.cells;
    }
    getSelectedCellCount() {
        return this.length;
    }
    isSelected(cell) {
        return this.selectionImpl.isSelected(cell);
    }
    select(cells, options = {}) {
        const selected = this.getCells(cells);
        if (selected.length) {
            if (this.isMultiple()) {
                this.selectionImpl.select(selected, options);
            }
            else {
                this.reset(selected.slice(0, 1), options);
            }
        }
        return this;
    }
    unselect(cells, options = {}) {
        this.selectionImpl.unselect(this.getCells(cells), options);
        return this;
    }
    // #endregion
    setup() {
        this.selectionImpl.on('*', (name, args) => {
            this.trigger(name, args);
            this.graph.trigger(name, args);
        });
    }
    startListening() {
        this.graph.on('blank:mousedown', this.onBlankMouseDown, this);
        this.graph.on('blank:click', this.onBlankClick, this);
        this.graph.on('cell:mousemove', this.onCellMouseMove, this);
        this.graph.on('cell:mouseup', this.onCellMouseUp, this);
        this.selectionImpl.on('box:mousedown', this.onBoxMouseDown, this);
    }
    stopListening() {
        this.graph.off('blank:mousedown', this.onBlankMouseDown, this);
        this.graph.off('blank:click', this.onBlankClick, this);
        this.graph.off('cell:mousemove', this.onCellMouseMove, this);
        this.graph.off('cell:mouseup', this.onCellMouseUp, this);
        this.selectionImpl.off('box:mousedown', this.onBoxMouseDown, this);
    }
    onBlankMouseDown({ e }) {
        if (!this.allowBlankMouseDown(e)) {
            return;
        }
        const allowGraphPanning = this.graph.panning.allowPanning(e, true);
        const scroller = this.graph.getPlugin('scroller');
        const allowScrollerPanning = scroller && scroller.allowPanning(e, true);
        if (this.allowRubberband(e, true) ||
            (this.allowRubberband(e) && !allowScrollerPanning && !allowGraphPanning)) {
            this.startRubberband(e);
        }
    }
    allowBlankMouseDown(e) {
        const eventTypes = this.options.eventTypes;
        return (((eventTypes === null || eventTypes === void 0 ? void 0 : eventTypes.includes('leftMouseDown')) && e.button === 0) ||
            ((eventTypes === null || eventTypes === void 0 ? void 0 : eventTypes.includes('mouseWheelDown')) && e.button === 1));
    }
    onBlankClick() {
        this.clean();
    }
    allowRubberband(e, strict) {
        return (!this.rubberbandDisabled &&
            _antv_x6__WEBPACK_IMPORTED_MODULE_0__.ModifierKey.isMatch(e, this.options.modifiers, strict));
    }
    allowMultipleSelection(e) {
        return (this.isMultiple() &&
            _antv_x6__WEBPACK_IMPORTED_MODULE_0__.ModifierKey.isMatch(e, this.options.multipleSelectionModifiers));
    }
    onCellMouseMove({ cell }) {
        this.movedMap.set(cell, true);
    }
    onCellMouseUp({ e, cell }) {
        const options = this.options;
        let disabled = this.disabled;
        if (!disabled && this.movedMap.has(cell)) {
            disabled = options.selectCellOnMoved === false;
            if (!disabled) {
                disabled = options.selectNodeOnMoved === false && cell.isNode();
            }
            if (!disabled) {
                disabled = options.selectEdgeOnMoved === false && cell.isEdge();
            }
        }
        if (!disabled) {
            if (!this.allowMultipleSelection(e)) {
                this.reset(cell);
            }
            else if (this.unselectMap.has(cell)) {
                this.unselectMap.delete(cell);
            }
            else if (this.isSelected(cell)) {
                this.unselect(cell);
            }
            else {
                this.select(cell);
            }
        }
        this.movedMap.delete(cell);
    }
    onBoxMouseDown({ e, cell, }) {
        if (!this.disabled) {
            if (this.allowMultipleSelection(e)) {
                this.unselect(cell);
                this.unselectMap.set(cell, true);
            }
        }
    }
    getCells(cells) {
        return (Array.isArray(cells) ? cells : [cells])
            .map((cell) => typeof cell === 'string' ? this.graph.getCellById(cell) : cell)
            .filter((cell) => cell != null);
    }
    startRubberband(e) {
        if (!this.rubberbandDisabled) {
            this.selectionImpl.startSelecting(e);
        }
        return this;
    }
    isMultiple() {
        return this.options.multiple !== false;
    }
    enableMultiple() {
        this.options.multiple = true;
        return this;
    }
    disableMultiple() {
        this.options.multiple = false;
        return this;
    }
    setModifiers(modifiers) {
        this.options.modifiers = modifiers;
        return this;
    }
    setContent(content) {
        this.selectionImpl.setContent(content);
        return this;
    }
    setFilter(filter) {
        this.selectionImpl.setFilter(filter);
        return this;
    }
    dispose() {
        this.stopListening();
        this.off();
        this.selectionImpl.dispose();
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.CssLoader.clean(this.name);
    }
}
__decorate([
    _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Basecoat.dispose()
], Selection.prototype, "dispose", null);
(function (Selection) {
    Selection.defaultOptions = {
        rubberband: false,
        rubberNode: true,
        rubberEdge: false,
        pointerEvents: 'auto',
        multiple: true,
        multipleSelectionModifiers: ['ctrl', 'meta'],
        movable: true,
        strict: false,
        selectCellOnMoved: false,
        selectNodeOnMoved: false,
        selectEdgeOnMoved: false,
        following: true,
        content: null,
        eventTypes: ['leftMouseDown', 'mouseWheelDown'],
    };
})(Selection || (Selection = {}));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-plugin-selection/es/selection.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/x6-plugin-selection/es/selection.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SelectionImpl: () => (/* binding */ SelectionImpl)
/* harmony export */ });
/* harmony import */ var _antv_x6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6 */ "./node_modules/@antv/x6/es/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

class SelectionImpl extends _antv_x6__WEBPACK_IMPORTED_MODULE_0__.View {
    get graph() {
        return this.options.graph;
    }
    get boxClassName() {
        return this.prefixClassName(Private.classNames.box);
    }
    get $boxes() {
        return _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.children(this.container, this.boxClassName);
    }
    get handleOptions() {
        return this.options;
    }
    constructor(options) {
        super();
        this.options = options;
        if (this.options.model) {
            this.options.collection = this.options.model.collection;
        }
        if (this.options.collection) {
            this.collection = this.options.collection;
        }
        else {
            this.collection = new _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Collection([], {
                comparator: Private.depthComparator,
            });
            this.options.collection = this.collection;
        }
        this.boxCount = 0;
        this.createContainer();
        this.startListening();
    }
    startListening() {
        const graph = this.graph;
        const collection = this.collection;
        this.delegateEvents({
            [`mousedown .${this.boxClassName}`]: 'onSelectionBoxMouseDown',
            [`touchstart .${this.boxClassName}`]: 'onSelectionBoxMouseDown',
        }, true);
        graph.on('scale', this.onGraphTransformed, this);
        graph.on('translate', this.onGraphTransformed, this);
        graph.model.on('updated', this.onModelUpdated, this);
        collection.on('added', this.onCellAdded, this);
        collection.on('removed', this.onCellRemoved, this);
        collection.on('reseted', this.onReseted, this);
        collection.on('updated', this.onCollectionUpdated, this);
        collection.on('node:change:position', this.onNodePositionChanged, this);
        collection.on('cell:changed', this.onCellChanged, this);
    }
    stopListening() {
        const graph = this.graph;
        const collection = this.collection;
        this.undelegateEvents();
        graph.off('scale', this.onGraphTransformed, this);
        graph.off('translate', this.onGraphTransformed, this);
        graph.model.off('updated', this.onModelUpdated, this);
        collection.off('added', this.onCellAdded, this);
        collection.off('removed', this.onCellRemoved, this);
        collection.off('reseted', this.onReseted, this);
        collection.off('updated', this.onCollectionUpdated, this);
        collection.off('node:change:position', this.onNodePositionChanged, this);
        collection.off('cell:changed', this.onCellChanged, this);
    }
    onRemove() {
        this.stopListening();
    }
    onGraphTransformed() {
        this.updateSelectionBoxes();
    }
    onCellChanged() {
        this.updateSelectionBoxes();
    }
    onNodePositionChanged({ node, options, }) {
        const { showNodeSelectionBox, pointerEvents } = this.options;
        const { ui, selection, translateBy, snapped } = options;
        const allowTranslating = (showNodeSelectionBox !== true || (pointerEvents && this.getPointerEventsValue(pointerEvents) === 'none')) &&
            !this.translating &&
            !selection;
        const translateByUi = ui && translateBy && node.id === translateBy;
        if (allowTranslating && (translateByUi || snapped)) {
            this.translating = true;
            const current = node.position();
            const previous = node.previous('position');
            const dx = current.x - previous.x;
            const dy = current.y - previous.y;
            if (dx !== 0 || dy !== 0) {
                this.translateSelectedNodes(dx, dy, node, options);
            }
            this.translating = false;
        }
    }
    onModelUpdated({ removed }) {
        if (removed && removed.length) {
            this.unselect(removed);
        }
    }
    isEmpty() {
        return this.length <= 0;
    }
    isSelected(cell) {
        return this.collection.has(cell);
    }
    get length() {
        return this.collection.length;
    }
    get cells() {
        return this.collection.toArray();
    }
    select(cells, options = {}) {
        options.dryrun = true;
        const items = this.filter(Array.isArray(cells) ? cells : [cells]);
        this.collection.add(items, options);
        return this;
    }
    unselect(cells, options = {}) {
        // dryrun to prevent cell be removed from graph
        options.dryrun = true;
        this.collection.remove(Array.isArray(cells) ? cells : [cells], options);
        return this;
    }
    reset(cells, options = {}) {
        if (cells) {
            if (options.batch) {
                const filterCells = this.filter(Array.isArray(cells) ? cells : [cells]);
                this.collection.reset(filterCells, Object.assign(Object.assign({}, options), { ui: true }));
                return this;
            }
            const prev = this.cells;
            const next = this.filter(Array.isArray(cells) ? cells : [cells]);
            const prevMap = {};
            const nextMap = {};
            prev.forEach((cell) => (prevMap[cell.id] = cell));
            next.forEach((cell) => (nextMap[cell.id] = cell));
            const added = [];
            const removed = [];
            next.forEach((cell) => {
                if (!prevMap[cell.id]) {
                    added.push(cell);
                }
            });
            prev.forEach((cell) => {
                if (!nextMap[cell.id]) {
                    removed.push(cell);
                }
            });
            if (removed.length) {
                this.unselect(removed, Object.assign(Object.assign({}, options), { ui: true }));
            }
            if (added.length) {
                this.select(added, Object.assign(Object.assign({}, options), { ui: true }));
            }
            if (removed.length === 0 && added.length === 0) {
                this.updateContainer();
            }
            return this;
        }
        return this.clean(options);
    }
    clean(options = {}) {
        if (this.length) {
            if (options.batch === false) {
                this.unselect(this.cells, options);
            }
            else {
                this.collection.reset([], Object.assign(Object.assign({}, options), { ui: true }));
            }
        }
        return this;
    }
    setFilter(filter) {
        this.options.filter = filter;
    }
    setContent(content) {
        this.options.content = content;
    }
    startSelecting(evt) {
        // Flow: startSelecting => adjustSelection => stopSelecting
        evt = this.normalizeEvent(evt); // eslint-disable-line
        this.clean();
        let x;
        let y;
        const graphContainer = this.graph.container;
        if (evt.offsetX != null &&
            evt.offsetY != null &&
            graphContainer.contains(evt.target)) {
            x = evt.offsetX;
            y = evt.offsetY;
        }
        else {
            const offset = _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.offset(graphContainer);
            const scrollLeft = graphContainer.scrollLeft;
            const scrollTop = graphContainer.scrollTop;
            x = evt.clientX - offset.left + window.pageXOffset + scrollLeft;
            y = evt.clientY - offset.top + window.pageYOffset + scrollTop;
        }
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.css(this.container, {
            top: y,
            left: x,
            width: 1,
            height: 1,
        });
        this.setEventData(evt, {
            action: 'selecting',
            clientX: evt.clientX,
            clientY: evt.clientY,
            offsetX: x,
            offsetY: y,
            scrollerX: 0,
            scrollerY: 0,
            moving: false,
        });
        this.delegateDocumentEvents(Private.documentEvents, evt.data);
    }
    filter(cells) {
        const filter = this.options.filter;
        return cells.filter((cell) => {
            if (Array.isArray(filter)) {
                return filter.some((item) => {
                    if (typeof item === 'string') {
                        return cell.shape === item;
                    }
                    return cell.id === item.id;
                });
            }
            if (typeof filter === 'function') {
                return _antv_x6__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(filter, this.graph, cell);
            }
            return true;
        });
    }
    stopSelecting(evt) {
        const graph = this.graph;
        const eventData = this.getEventData(evt);
        const action = eventData.action;
        switch (action) {
            case 'selecting': {
                let width = _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.width(this.container);
                let height = _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.height(this.container);
                const offset = _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.offset(this.container);
                const origin = graph.pageToLocal(offset.left, offset.top);
                const scale = graph.transform.getScale();
                width /= scale.sx;
                height /= scale.sy;
                const rect = new _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Rectangle(origin.x, origin.y, width, height);
                const cells = this.getCellViewsInArea(rect).map((view) => view.cell);
                this.reset(cells, { batch: true });
                this.hideRubberband();
                break;
            }
            case 'translating': {
                const client = graph.snapToGrid(evt.clientX, evt.clientY);
                if (!this.options.following) {
                    const data = eventData;
                    this.updateSelectedNodesPosition({
                        dx: data.clientX - data.originX,
                        dy: data.clientY - data.originY,
                    });
                }
                this.graph.model.stopBatch('move-selection');
                this.notifyBoxEvent('box:mouseup', evt, client.x, client.y);
                break;
            }
            default: {
                this.clean();
                break;
            }
        }
    }
    onMouseUp(evt) {
        const action = this.getEventData(evt).action;
        if (action) {
            this.stopSelecting(evt);
            this.undelegateDocumentEvents();
        }
    }
    onSelectionBoxMouseDown(evt) {
        if (!this.options.following) {
            evt.stopPropagation();
        }
        const e = this.normalizeEvent(evt);
        if (this.options.movable) {
            this.startTranslating(e);
        }
        const activeView = this.getCellViewFromElem(e.target);
        this.setEventData(e, { activeView });
        const client = this.graph.snapToGrid(e.clientX, e.clientY);
        this.notifyBoxEvent('box:mousedown', e, client.x, client.y);
        this.delegateDocumentEvents(Private.documentEvents, e.data);
    }
    startTranslating(evt) {
        this.graph.model.startBatch('move-selection');
        const client = this.graph.snapToGrid(evt.clientX, evt.clientY);
        this.setEventData(evt, {
            action: 'translating',
            clientX: client.x,
            clientY: client.y,
            originX: client.x,
            originY: client.y,
        });
    }
    getRestrictArea() {
        const restrict = this.graph.options.translating.restrict;
        const area = typeof restrict === 'function'
            ? _antv_x6__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(restrict, this.graph, null)
            : restrict;
        if (typeof area === 'number') {
            return this.graph.transform.getGraphArea().inflate(area);
        }
        if (area === true) {
            return this.graph.transform.getGraphArea();
        }
        return area || null;
    }
    getSelectionOffset(client, data) {
        let dx = client.x - data.clientX;
        let dy = client.y - data.clientY;
        const restrict = this.getRestrictArea();
        if (restrict) {
            const cells = this.collection.toArray();
            const totalBBox = _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Cell.getCellsBBox(cells, { deep: true }) || _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Rectangle.create();
            const minDx = restrict.x - totalBBox.x;
            const minDy = restrict.y - totalBBox.y;
            const maxDx = restrict.x + restrict.width - (totalBBox.x + totalBBox.width);
            const maxDy = restrict.y + restrict.height - (totalBBox.y + totalBBox.height);
            if (dx < minDx) {
                dx = minDx;
            }
            if (dy < minDy) {
                dy = minDy;
            }
            if (maxDx < dx) {
                dx = maxDx;
            }
            if (maxDy < dy) {
                dy = maxDy;
            }
            if (!this.options.following) {
                const offsetX = client.x - data.originX;
                const offsetY = client.y - data.originY;
                dx = offsetX <= minDx || offsetX >= maxDx ? 0 : dx;
                dy = offsetY <= minDy || offsetY >= maxDy ? 0 : dy;
            }
        }
        return {
            dx,
            dy,
        };
    }
    updateElementPosition(elem, dLeft, dTop) {
        const strLeft = _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.css(elem, 'left');
        const strTop = _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.css(elem, 'top');
        const left = strLeft ? parseFloat(strLeft) : 0;
        const top = strTop ? parseFloat(strTop) : 0;
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.css(elem, 'left', left + dLeft);
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.css(elem, 'top', top + dTop);
    }
    updateSelectedNodesPosition(offset) {
        const { dx, dy } = offset;
        if (dx || dy) {
            if ((this.translateSelectedNodes(dx, dy), this.boxesUpdated)) {
                if (this.collection.length > 1) {
                    this.updateSelectionBoxes();
                }
            }
            else {
                const scale = this.graph.transform.getScale();
                for (let i = 0, $boxes = this.$boxes, len = $boxes.length; i < len; i += 1) {
                    this.updateElementPosition($boxes[i], dx * scale.sx, dy * scale.sy);
                }
                this.updateElementPosition(this.selectionContainer, dx * scale.sx, dy * scale.sy);
            }
        }
    }
    autoScrollGraph(x, y) {
        const scroller = this.graph.getPlugin('scroller');
        if (scroller) {
            return scroller.autoScroll(x, y);
        }
        return { scrollerX: 0, scrollerY: 0 };
    }
    adjustSelection(evt) {
        const e = this.normalizeEvent(evt);
        const eventData = this.getEventData(e);
        const action = eventData.action;
        switch (action) {
            case 'selecting': {
                const data = eventData;
                if (data.moving !== true) {
                    _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.appendTo(this.container, this.graph.container);
                    this.showRubberband();
                    data.moving = true;
                }
                const { scrollerX, scrollerY } = this.autoScrollGraph(e.clientX, e.clientY);
                data.scrollerX += scrollerX;
                data.scrollerY += scrollerY;
                const dx = e.clientX - data.clientX + data.scrollerX;
                const dy = e.clientY - data.clientY + data.scrollerY;
                const left = parseInt(_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.css(this.container, 'left') || '0', 10);
                const top = parseInt(_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.css(this.container, 'top') || '0', 10);
                _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.css(this.container, {
                    left: dx < 0 ? data.offsetX + dx : left,
                    top: dy < 0 ? data.offsetY + dy : top,
                    width: Math.abs(dx),
                    height: Math.abs(dy),
                });
                break;
            }
            case 'translating': {
                const client = this.graph.snapToGrid(e.clientX, e.clientY);
                const data = eventData;
                const offset = this.getSelectionOffset(client, data);
                if (this.options.following) {
                    this.updateSelectedNodesPosition(offset);
                }
                else {
                    this.updateContainerPosition(offset);
                }
                if (offset.dx) {
                    data.clientX = client.x;
                }
                if (offset.dy) {
                    data.clientY = client.y;
                }
                this.notifyBoxEvent('box:mousemove', evt, client.x, client.y);
                break;
            }
            default:
                break;
        }
        this.boxesUpdated = false;
    }
    translateSelectedNodes(dx, dy, exclude, otherOptions) {
        const map = {};
        const excluded = [];
        if (exclude) {
            map[exclude.id] = true;
        }
        this.collection.toArray().forEach((cell) => {
            cell.getDescendants({ deep: true }).forEach((child) => {
                map[child.id] = true;
            });
        });
        if (otherOptions && otherOptions.translateBy) {
            const currentCell = this.graph.getCellById(otherOptions.translateBy);
            if (currentCell) {
                map[currentCell.id] = true;
                currentCell.getDescendants({ deep: true }).forEach((child) => {
                    map[child.id] = true;
                });
                excluded.push(currentCell);
            }
        }
        this.collection.toArray().forEach((cell) => {
            if (!map[cell.id]) {
                const options = Object.assign(Object.assign({}, otherOptions), { selection: this.cid, exclude: excluded });
                cell.translate(dx, dy, options);
                this.graph.model.getConnectedEdges(cell).forEach((edge) => {
                    if (!map[edge.id]) {
                        edge.translate(dx, dy, options);
                        map[edge.id] = true;
                    }
                });
            }
        });
    }
    getCellViewsInArea(rect) {
        const graph = this.graph;
        const options = {
            strict: this.options.strict,
        };
        let views = [];
        if (this.options.rubberNode) {
            views = views.concat(graph.model
                .getNodesInArea(rect, options)
                .map((node) => graph.renderer.findViewByCell(node))
                .filter((view) => view != null));
        }
        if (this.options.rubberEdge) {
            views = views.concat(graph.model
                .getEdgesInArea(rect, options)
                .map((edge) => graph.renderer.findViewByCell(edge))
                .filter((view) => view != null));
        }
        return views;
    }
    notifyBoxEvent(name, e, x, y) {
        const data = this.getEventData(e);
        const view = data.activeView;
        this.trigger(name, { e, view, x, y, cell: view.cell });
    }
    getSelectedClassName(cell) {
        return this.prefixClassName(`${cell.isNode() ? 'node' : 'edge'}-selected`);
    }
    addCellSelectedClassName(cell) {
        const view = this.graph.renderer.findViewByCell(cell);
        if (view) {
            view.addClass(this.getSelectedClassName(cell));
        }
    }
    removeCellUnSelectedClassName(cell) {
        const view = this.graph.renderer.findViewByCell(cell);
        if (view) {
            view.removeClass(this.getSelectedClassName(cell));
        }
    }
    destroySelectionBox(cell) {
        this.removeCellUnSelectedClassName(cell);
        if (this.canShowSelectionBox(cell)) {
            _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.remove(this.container.querySelector(`[data-cell-id="${cell.id}"]`));
            if (this.$boxes.length === 0) {
                this.hide();
            }
            this.boxCount = Math.max(0, this.boxCount - 1);
        }
    }
    destroyAllSelectionBoxes(cells) {
        cells.forEach((cell) => this.removeCellUnSelectedClassName(cell));
        this.hide();
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.remove(this.$boxes);
        this.boxCount = 0;
    }
    hide() {
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.removeClass(this.container, this.prefixClassName(Private.classNames.rubberband));
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.removeClass(this.container, this.prefixClassName(Private.classNames.selected));
    }
    showRubberband() {
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.container, this.prefixClassName(Private.classNames.rubberband));
    }
    hideRubberband() {
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.removeClass(this.container, this.prefixClassName(Private.classNames.rubberband));
    }
    showSelected() {
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.removeAttribute(this.container, 'style');
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.container, this.prefixClassName(Private.classNames.selected));
    }
    createContainer() {
        this.container = document.createElement('div');
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.container, this.prefixClassName(Private.classNames.root));
        if (this.options.className) {
            _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.container, this.options.className);
        }
        this.selectionContainer = document.createElement('div');
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.selectionContainer, this.prefixClassName(Private.classNames.inner));
        this.selectionContent = document.createElement('div');
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.selectionContent, this.prefixClassName(Private.classNames.content));
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.append(this.selectionContainer, this.selectionContent);
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.attr(this.selectionContainer, 'data-selection-length', this.collection.length);
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.prepend(this.container, this.selectionContainer);
    }
    updateContainerPosition(offset) {
        if (offset.dx || offset.dy) {
            this.updateElementPosition(this.selectionContainer, offset.dx, offset.dy);
        }
    }
    updateContainer() {
        const origin = { x: Infinity, y: Infinity };
        const corner = { x: 0, y: 0 };
        const cells = this.collection
            .toArray()
            .filter((cell) => this.canShowSelectionBox(cell));
        cells.forEach((cell) => {
            const view = this.graph.renderer.findViewByCell(cell);
            if (view) {
                const bbox = view.getBBox({
                    useCellGeometry: true,
                });
                origin.x = Math.min(origin.x, bbox.x);
                origin.y = Math.min(origin.y, bbox.y);
                corner.x = Math.max(corner.x, bbox.x + bbox.width);
                corner.y = Math.max(corner.y, bbox.y + bbox.height);
            }
        });
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.css(this.selectionContainer, {
            position: 'absolute',
            pointerEvents: 'none',
            left: origin.x,
            top: origin.y,
            width: corner.x - origin.x,
            height: corner.y - origin.y,
        });
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.attr(this.selectionContainer, 'data-selection-length', this.collection.length);
        const boxContent = this.options.content;
        if (boxContent) {
            if (typeof boxContent === 'function') {
                const content = _antv_x6__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(boxContent, this.graph, this, this.selectionContent);
                if (content) {
                    this.selectionContent.innerHTML = content;
                }
            }
            else {
                this.selectionContent.innerHTML = boxContent;
            }
        }
        if (this.collection.length > 0 && !this.container.parentNode) {
            _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.appendTo(this.container, this.graph.container);
        }
        else if (this.collection.length <= 0 && this.container.parentNode) {
            this.container.parentNode.removeChild(this.container);
        }
    }
    canShowSelectionBox(cell) {
        return ((cell.isNode() && this.options.showNodeSelectionBox === true) ||
            (cell.isEdge() && this.options.showEdgeSelectionBox === true));
    }
    getPointerEventsValue(pointerEvents) {
        return typeof pointerEvents === 'string'
            ? pointerEvents
            : pointerEvents(this.cells);
    }
    createSelectionBox(cell) {
        this.addCellSelectedClassName(cell);
        if (this.canShowSelectionBox(cell)) {
            const view = this.graph.renderer.findViewByCell(cell);
            if (view) {
                const bbox = view.getBBox({
                    useCellGeometry: true,
                });
                const className = this.boxClassName;
                const box = document.createElement('div');
                const pointerEvents = this.options.pointerEvents;
                _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(box, className);
                _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(box, `${className}-${cell.isNode() ? 'node' : 'edge'}`);
                _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.attr(box, 'data-cell-id', cell.id);
                _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.css(box, {
                    position: 'absolute',
                    left: bbox.x,
                    top: bbox.y,
                    width: bbox.width,
                    height: bbox.height,
                    pointerEvents: pointerEvents
                        ? this.getPointerEventsValue(pointerEvents)
                        : 'auto',
                });
                _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.appendTo(box, this.container);
                this.showSelected();
                this.boxCount += 1;
            }
        }
    }
    updateSelectionBoxes() {
        if (this.collection.length > 0) {
            this.boxesUpdated = true;
            this.confirmUpdate();
            // this.graph.renderer.requestViewUpdate(this as any, 1, options)
        }
    }
    confirmUpdate() {
        if (this.boxCount) {
            this.hide();
            for (let i = 0, $boxes = this.$boxes, len = $boxes.length; i < len; i += 1) {
                const box = $boxes[i];
                const cellId = _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.attr(box, 'data-cell-id');
                _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.remove(box);
                this.boxCount -= 1;
                const cell = this.collection.get(cellId);
                if (cell) {
                    this.createSelectionBox(cell);
                }
            }
            this.updateContainer();
        }
        return 0;
    }
    getCellViewFromElem(elem) {
        const id = elem.getAttribute('data-cell-id');
        if (id) {
            const cell = this.collection.get(id);
            if (cell) {
                return this.graph.renderer.findViewByCell(cell);
            }
        }
        return null;
    }
    onCellRemoved({ cell }) {
        this.destroySelectionBox(cell);
        this.updateContainer();
    }
    onReseted({ previous, current }) {
        this.destroyAllSelectionBoxes(previous);
        current.forEach((cell) => {
            this.listenCellRemoveEvent(cell);
            this.createSelectionBox(cell);
        });
        this.updateContainer();
    }
    onCellAdded({ cell }) {
        // The collection do not known the cell was removed when cell was
        // removed by interaction(such as, by "delete" shortcut), so we should
        // manually listen to cell's remove event.
        this.listenCellRemoveEvent(cell);
        this.createSelectionBox(cell);
        this.updateContainer();
    }
    listenCellRemoveEvent(cell) {
        cell.off('removed', this.onCellRemoved, this);
        cell.on('removed', this.onCellRemoved, this);
    }
    onCollectionUpdated({ added, removed, options, }) {
        added.forEach((cell) => {
            this.trigger('cell:selected', { cell, options });
            if (cell.isNode()) {
                this.trigger('node:selected', { cell, options, node: cell });
            }
            else if (cell.isEdge()) {
                this.trigger('edge:selected', { cell, options, edge: cell });
            }
        });
        removed.forEach((cell) => {
            this.trigger('cell:unselected', { cell, options });
            if (cell.isNode()) {
                this.trigger('node:unselected', { cell, options, node: cell });
            }
            else if (cell.isEdge()) {
                this.trigger('edge:unselected', { cell, options, edge: cell });
            }
        });
        const args = {
            added,
            removed,
            options,
            selected: this.cells.filter((cell) => !!this.graph.getCellById(cell.id)),
        };
        this.trigger('selection:changed', args);
    }
    // #endregion
    dispose() {
        this.clean();
        this.remove();
        this.off();
    }
}
__decorate([
    _antv_x6__WEBPACK_IMPORTED_MODULE_0__.View.dispose()
], SelectionImpl.prototype, "dispose", null);
// private
// -------
var Private;
(function (Private) {
    const base = 'widget-selection';
    Private.classNames = {
        root: base,
        inner: `${base}-inner`,
        box: `${base}-box`,
        content: `${base}-content`,
        rubberband: `${base}-rubberband`,
        selected: `${base}-selected`,
    };
    Private.documentEvents = {
        mousemove: 'adjustSelection',
        touchmove: 'adjustSelection',
        mouseup: 'onMouseUp',
        touchend: 'onMouseUp',
        touchcancel: 'onMouseUp',
    };
    function depthComparator(cell) {
        return cell.getAncestors().length;
    }
    Private.depthComparator = depthComparator;
})(Private || (Private = {}));
//# sourceMappingURL=selection.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-plugin-selection/es/style/raw.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/x6-plugin-selection/es/style/raw.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   content: () => (/* binding */ content)
/* harmony export */ });
/* eslint-disable */
/**
 * Auto generated file, do not modify it!
 */
const content = `.x6-widget-selection {
  position: absolute;
  top: 0;
  left: 0;
  display: none;
  width: 0;
  height: 0;
  touch-action: none;
}
.x6-widget-selection-rubberband {
  display: block;
  overflow: visible;
  opacity: 0.3;
}
.x6-widget-selection-selected {
  display: block;
}
.x6-widget-selection-box {
  cursor: move;
}
.x6-widget-selection-inner[data-selection-length='0'],
.x6-widget-selection-inner[data-selection-length='1'] {
  display: none;
}
.x6-widget-selection-content {
  position: absolute;
  top: 100%;
  right: -20px;
  left: -20px;
  margin-top: 30px;
  padding: 6px;
  line-height: 14px;
  text-align: center;
  border-radius: 6px;
}
.x6-widget-selection-content:empty {
  display: none;
}
.x6-widget-selection-rubberband {
  background-color: #3498db;
  border: 2px solid #2980b9;
}
.x6-widget-selection-box {
  box-sizing: content-box !important;
  margin-top: -4px;
  margin-left: -4px;
  padding-right: 4px;
  padding-bottom: 4px;
  border: 2px dashed #feb663;
  box-shadow: 2px 2px 5px #d3d3d3;
}
.x6-widget-selection-inner {
  box-sizing: content-box !important;
  margin-top: -8px;
  margin-left: -8px;
  padding-right: 12px;
  padding-bottom: 12px;
  border: 2px solid #feb663;
  box-shadow: 2px 2px 5px #d3d3d3;
}
.x6-widget-selection-content {
  color: #fff;
  font-size: 10px;
  background-color: #6a6b8a;
}
`;
//# sourceMappingURL=raw.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-plugin-snapline/es/api.js":
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6-plugin-snapline/es/api.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _antv_x6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6 */ "./node_modules/@antv/x6/es/index.js");

_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.isSnaplineEnabled = function () {
    const snapline = this.getPlugin('snapline');
    if (snapline) {
        return snapline.isEnabled();
    }
    return false;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.enableSnapline = function () {
    const snapline = this.getPlugin('snapline');
    if (snapline) {
        snapline.enable();
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.disableSnapline = function () {
    const snapline = this.getPlugin('snapline');
    if (snapline) {
        snapline.disable();
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.toggleSnapline = function () {
    const snapline = this.getPlugin('snapline');
    if (snapline) {
        snapline.toggleEnabled();
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.hideSnapline = function () {
    const snapline = this.getPlugin('snapline');
    if (snapline) {
        snapline.hide();
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.setSnaplineFilter = function (filter) {
    const snapline = this.getPlugin('snapline');
    if (snapline) {
        snapline.setFilter(filter);
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.isSnaplineOnResizingEnabled = function () {
    const snapline = this.getPlugin('snapline');
    if (snapline) {
        return snapline.isOnResizingEnabled();
    }
    return false;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.enableSnaplineOnResizing = function () {
    const snapline = this.getPlugin('snapline');
    if (snapline) {
        snapline.enableOnResizing();
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.disableSnaplineOnResizing = function () {
    const snapline = this.getPlugin('snapline');
    if (snapline) {
        snapline.disableOnResizing();
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.toggleSnaplineOnResizing = function (enableOnResizing) {
    const snapline = this.getPlugin('snapline');
    if (snapline) {
        snapline.toggleOnResizing(enableOnResizing);
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.isSharpSnapline = function () {
    const snapline = this.getPlugin('snapline');
    if (snapline) {
        return snapline.isSharp();
    }
    return false;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.enableSharpSnapline = function () {
    const snapline = this.getPlugin('snapline');
    if (snapline) {
        snapline.enableSharp();
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.disableSharpSnapline = function () {
    const snapline = this.getPlugin('snapline');
    if (snapline) {
        snapline.disableSharp();
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.toggleSharpSnapline = function (sharp) {
    const snapline = this.getPlugin('snapline');
    if (snapline) {
        snapline.toggleSharp(sharp);
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.getSnaplineTolerance = function () {
    const snapline = this.getPlugin('snapline');
    if (snapline) {
        return snapline.getTolerance();
    }
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.setSnaplineTolerance = function (tolerance) {
    const snapline = this.getPlugin('snapline');
    if (snapline) {
        snapline.setTolerance(tolerance);
    }
    return this;
};
//# sourceMappingURL=api.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-plugin-snapline/es/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6-plugin-snapline/es/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Snapline: () => (/* binding */ Snapline)
/* harmony export */ });
/* harmony import */ var _antv_x6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6 */ "./node_modules/@antv/x6/es/index.js");
/* harmony import */ var _snapline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./snapline */ "./node_modules/@antv/x6-plugin-snapline/es/snapline.js");
/* harmony import */ var _style_raw__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./style/raw */ "./node_modules/@antv/x6-plugin-snapline/es/style/raw.js");
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./api */ "./node_modules/@antv/x6-plugin-snapline/es/api.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};




class Snapline extends _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Disposable {
    constructor(options = {}) {
        super();
        this.name = 'snapline';
        this.options = Object.assign({ enabled: true, tolerance: 10 }, options);
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.CssLoader.ensure(this.name, _style_raw__WEBPACK_IMPORTED_MODULE_2__.content);
    }
    init(graph) {
        this.snaplineImpl = new _snapline__WEBPACK_IMPORTED_MODULE_1__.SnaplineImpl(Object.assign(Object.assign({}, this.options), { graph }));
    }
    // #region api
    isEnabled() {
        return !this.snaplineImpl.disabled;
    }
    enable() {
        this.snaplineImpl.enable();
    }
    disable() {
        this.snaplineImpl.disable();
    }
    toggleEnabled(enabled) {
        if (enabled != null) {
            if (enabled !== this.isEnabled()) {
                if (enabled) {
                    this.enable();
                }
                else {
                    this.disable();
                }
            }
        }
        else {
            if (this.isEnabled()) {
                this.disable();
            }
            else {
                this.enable();
            }
            return this;
        }
    }
    hide() {
        this.snaplineImpl.hide();
        return this;
    }
    setFilter(filter) {
        this.snaplineImpl.setFilter(filter);
        return this;
    }
    isOnResizingEnabled() {
        return this.snaplineImpl.options.resizing === true;
    }
    enableOnResizing() {
        this.snaplineImpl.options.resizing = true;
        return this;
    }
    disableOnResizing() {
        this.snaplineImpl.options.resizing = false;
        return this;
    }
    toggleOnResizing(enableOnResizing) {
        if (enableOnResizing != null) {
            if (enableOnResizing !== this.isOnResizingEnabled()) {
                if (enableOnResizing) {
                    this.enableOnResizing();
                }
                else {
                    this.disableOnResizing();
                }
            }
        }
        else if (this.isOnResizingEnabled()) {
            this.disableOnResizing();
        }
        else {
            this.enableOnResizing();
        }
        return this;
    }
    isSharp() {
        return this.snaplineImpl.options.sharp === true;
    }
    enableSharp() {
        this.snaplineImpl.options.sharp = true;
        return this;
    }
    disableSharp() {
        this.snaplineImpl.options.sharp = false;
        return this;
    }
    toggleSharp(sharp) {
        if (sharp != null) {
            if (sharp !== this.isSharp()) {
                if (sharp) {
                    this.enableSharp();
                }
                else {
                    this.disableSharp();
                }
            }
        }
        else if (this.isSharp()) {
            this.disableSharp();
        }
        else {
            this.enableSharp();
        }
        return this;
    }
    getTolerance() {
        return this.snaplineImpl.options.tolerance;
    }
    setTolerance(tolerance) {
        this.snaplineImpl.options.tolerance = tolerance;
        return this;
    }
    captureCursorOffset(e) {
        this.snaplineImpl.captureCursorOffset(e);
    }
    snapOnMoving(args) {
        this.snaplineImpl.snapOnMoving(args);
    }
    // #endregion
    dispose() {
        this.snaplineImpl.dispose();
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.CssLoader.clean(this.name);
    }
}
__decorate([
    _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Disposable.dispose()
], Snapline.prototype, "dispose", null);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-plugin-snapline/es/snapline.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/x6-plugin-snapline/es/snapline.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SnaplineImpl: () => (/* binding */ SnaplineImpl)
/* harmony export */ });
/* harmony import */ var _antv_x6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6 */ "./node_modules/@antv/x6/es/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};

class SnaplineImpl extends _antv_x6__WEBPACK_IMPORTED_MODULE_0__.View {
    get model() {
        return this.graph.model;
    }
    get containerClassName() {
        return this.prefixClassName('widget-snapline');
    }
    get verticalClassName() {
        return `${this.containerClassName}-vertical`;
    }
    get horizontalClassName() {
        return `${this.containerClassName}-horizontal`;
    }
    constructor(options) {
        super();
        const { graph } = options, others = __rest(options, ["graph"]);
        this.graph = graph;
        this.options = Object.assign({}, others);
        this.offset = { x: 0, y: 0 };
        this.render();
        if (!this.disabled) {
            this.startListening();
        }
    }
    get disabled() {
        return this.options.enabled !== true;
    }
    enable() {
        if (this.disabled) {
            this.options.enabled = true;
            this.startListening();
        }
    }
    disable() {
        if (!this.disabled) {
            this.options.enabled = false;
            this.stopListening();
        }
    }
    setFilter(filter) {
        this.options.filter = filter;
    }
    render() {
        const container = (this.containerWrapper = new _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Vector('svg'));
        const horizontal = (this.horizontal = new _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Vector('line'));
        const vertical = (this.vertical = new _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Vector('line'));
        container.addClass(this.containerClassName);
        horizontal.addClass(this.horizontalClassName);
        vertical.addClass(this.verticalClassName);
        container.setAttribute('width', '100%');
        container.setAttribute('height', '100%');
        horizontal.setAttribute('display', 'none');
        vertical.setAttribute('display', 'none');
        container.append([horizontal, vertical]);
        if (this.options.className) {
            container.addClass(this.options.className);
        }
        this.container = this.containerWrapper.node;
    }
    startListening() {
        this.stopListening();
        this.graph.on('node:mousedown', this.captureCursorOffset, this);
        this.graph.on('node:mousemove', this.snapOnMoving, this);
        this.model.on('batch:stop', this.onBatchStop, this);
        this.delegateDocumentEvents({
            mouseup: 'hide',
            touchend: 'hide',
        });
    }
    stopListening() {
        this.graph.off('node:mousedown', this.captureCursorOffset, this);
        this.graph.off('node:mousemove', this.snapOnMoving, this);
        this.model.off('batch:stop', this.onBatchStop, this);
        this.undelegateDocumentEvents();
    }
    onBatchStop({ name, data }) {
        if (name === 'resize') {
            this.snapOnResizing(data.cell, data);
        }
    }
    captureCursorOffset({ view, x, y }) {
        const targetView = view.getDelegatedView();
        if (targetView && this.isNodeMovable(targetView)) {
            const pos = view.cell.getPosition();
            this.offset = {
                x: x - pos.x,
                y: y - pos.y,
            };
        }
    }
    isNodeMovable(view) {
        return view && view.cell.isNode() && view.can('nodeMovable');
    }
    getRestrictArea(view) {
        const restrict = this.graph.options.translating.restrict;
        const area = typeof restrict === 'function'
            ? _antv_x6__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(restrict, this.graph, view)
            : restrict;
        if (typeof area === 'number') {
            return this.graph.transform.getGraphArea().inflate(area);
        }
        if (area === true) {
            return this.graph.transform.getGraphArea();
        }
        return area || null;
    }
    snapOnResizing(node, options) {
        if (this.options.resizing &&
            !options.snapped &&
            options.ui &&
            options.direction &&
            options.trueDirection) {
            const view = this.graph.renderer.findViewByCell(node);
            if (view && view.cell.isNode()) {
                const nodeBbox = node.getBBox();
                const nodeBBoxRotated = nodeBbox.bbox(node.getAngle());
                const nodeTopLeft = nodeBBoxRotated.getTopLeft();
                const nodeBottomRight = nodeBBoxRotated.getBottomRight();
                const angle = _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Angle.normalize(node.getAngle());
                const tolerance = this.options.tolerance || 0;
                let verticalLeft;
                let verticalTop;
                let verticalHeight;
                let horizontalTop;
                let horizontalLeft;
                let horizontalWidth;
                const snapOrigin = {
                    vertical: 0,
                    horizontal: 0,
                };
                const direction = options.direction;
                const trueDirection = options.trueDirection;
                const relativeDirection = options.relativeDirection;
                if (trueDirection.indexOf('right') !== -1) {
                    snapOrigin.vertical = nodeBottomRight.x;
                }
                else {
                    snapOrigin.vertical = nodeTopLeft.x;
                }
                if (trueDirection.indexOf('bottom') !== -1) {
                    snapOrigin.horizontal = nodeBottomRight.y;
                }
                else {
                    snapOrigin.horizontal = nodeTopLeft.y;
                }
                this.model.getNodes().some((cell) => {
                    if (this.isIgnored(node, cell)) {
                        return false;
                    }
                    const snapBBox = cell.getBBox().bbox(cell.getAngle());
                    const snapTopLeft = snapBBox.getTopLeft();
                    const snapBottomRight = snapBBox.getBottomRight();
                    const groups = {
                        vertical: [snapTopLeft.x, snapBottomRight.x],
                        horizontal: [snapTopLeft.y, snapBottomRight.y],
                    };
                    const distances = {};
                    Object.keys(groups).forEach((k) => {
                        const key = k;
                        const list = groups[key]
                            .map((value) => ({
                            position: value,
                            distance: Math.abs(value - snapOrigin[key]),
                        }))
                            .filter((item) => item.distance <= tolerance);
                        distances[key] = _antv_x6__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.sortBy(list, (item) => item.distance);
                    });
                    if (verticalLeft == null && distances.vertical.length > 0) {
                        verticalLeft = distances.vertical[0].position;
                        verticalTop = Math.min(nodeBBoxRotated.y, snapBBox.y);
                        verticalHeight =
                            Math.max(nodeBottomRight.y, snapBottomRight.y) - verticalTop;
                    }
                    if (horizontalTop == null && distances.horizontal.length > 0) {
                        horizontalTop = distances.horizontal[0].position;
                        horizontalLeft = Math.min(nodeBBoxRotated.x, snapBBox.x);
                        horizontalWidth =
                            Math.max(nodeBottomRight.x, snapBottomRight.x) - horizontalLeft;
                    }
                    return verticalLeft != null && horizontalTop != null;
                });
                this.hide();
                let dx = 0;
                let dy = 0;
                if (horizontalTop != null || verticalLeft != null) {
                    if (verticalLeft != null) {
                        dx =
                            trueDirection.indexOf('right') !== -1
                                ? verticalLeft - nodeBottomRight.x
                                : nodeTopLeft.x - verticalLeft;
                    }
                    if (horizontalTop != null) {
                        dy =
                            trueDirection.indexOf('bottom') !== -1
                                ? horizontalTop - nodeBottomRight.y
                                : nodeTopLeft.y - horizontalTop;
                    }
                }
                let dWidth = 0;
                let dHeight = 0;
                if (angle % 90 === 0) {
                    if (angle === 90 || angle === 270) {
                        dWidth = dy;
                        dHeight = dx;
                    }
                    else {
                        dWidth = dx;
                        dHeight = dy;
                    }
                }
                else {
                    const quadrant = angle >= 0 && angle < 90
                        ? 1
                        : angle >= 90 && angle < 180
                            ? 4
                            : angle >= 180 && angle < 270
                                ? 3
                                : 2;
                    if (horizontalTop != null && verticalLeft != null) {
                        if (dx < dy) {
                            dy = 0;
                            horizontalTop = undefined;
                        }
                        else {
                            dx = 0;
                            verticalLeft = undefined;
                        }
                    }
                    const rad = _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Angle.toRad(angle % 90);
                    if (dx) {
                        dWidth = quadrant === 3 ? dx / Math.cos(rad) : dx / Math.sin(rad);
                    }
                    if (dy) {
                        dHeight = quadrant === 3 ? dy / Math.cos(rad) : dy / Math.sin(rad);
                    }
                    const quadrant13 = quadrant === 1 || quadrant === 3;
                    switch (relativeDirection) {
                        case 'top':
                        case 'bottom':
                            dHeight = dy
                                ? dy / (quadrant13 ? Math.cos(rad) : Math.sin(rad))
                                : dx / (quadrant13 ? Math.sin(rad) : Math.cos(rad));
                            break;
                        case 'left':
                        case 'right':
                            dWidth = dx
                                ? dx / (quadrant13 ? Math.cos(rad) : Math.sin(rad))
                                : dy / (quadrant13 ? Math.sin(rad) : Math.cos(rad));
                            break;
                        default:
                            break;
                    }
                }
                switch (relativeDirection) {
                    case 'top':
                    case 'bottom':
                        dWidth = 0;
                        break;
                    case 'left':
                    case 'right':
                        dHeight = 0;
                        break;
                    default:
                        break;
                }
                const gridSize = this.graph.getGridSize();
                let newWidth = Math.max(nodeBbox.width + dWidth, gridSize);
                let newHeight = Math.max(nodeBbox.height + dHeight, gridSize);
                if (options.minWidth && options.minWidth > gridSize) {
                    newWidth = Math.max(newWidth, options.minWidth);
                }
                if (options.minHeight && options.minHeight > gridSize) {
                    newHeight = Math.max(newHeight, options.minHeight);
                }
                if (options.maxWidth) {
                    newWidth = Math.min(newWidth, options.maxWidth);
                }
                if (options.maxHeight) {
                    newHeight = Math.min(newHeight, options.maxHeight);
                }
                if (options.preserveAspectRatio) {
                    if (dHeight < dWidth) {
                        newHeight = newWidth * (nodeBbox.height / nodeBbox.width);
                    }
                    else {
                        newWidth = newHeight * (nodeBbox.width / nodeBbox.height);
                    }
                }
                if (newWidth !== nodeBbox.width || newHeight !== nodeBbox.height) {
                    node.resize(newWidth, newHeight, {
                        direction,
                        relativeDirection,
                        trueDirection,
                        snapped: true,
                        snaplines: this.cid,
                        restrict: this.getRestrictArea(view),
                    });
                    if (verticalHeight) {
                        verticalHeight += newHeight - nodeBbox.height;
                    }
                    if (horizontalWidth) {
                        horizontalWidth += newWidth - nodeBbox.width;
                    }
                }
                const newRotatedBBox = node.getBBox().bbox(angle);
                if (verticalLeft &&
                    Math.abs(newRotatedBBox.x - verticalLeft) > 1 &&
                    Math.abs(newRotatedBBox.width + newRotatedBBox.x - verticalLeft) > 1) {
                    verticalLeft = undefined;
                }
                if (horizontalTop &&
                    Math.abs(newRotatedBBox.y - horizontalTop) > 1 &&
                    Math.abs(newRotatedBBox.height + newRotatedBBox.y - horizontalTop) > 1) {
                    horizontalTop = undefined;
                }
                this.update({
                    verticalLeft,
                    verticalTop,
                    verticalHeight,
                    horizontalTop,
                    horizontalLeft,
                    horizontalWidth,
                });
            }
        }
    }
    snapOnMoving({ view, e, x, y }) {
        const targetView = view.getEventData(e).delegatedView || view;
        if (!this.isNodeMovable(targetView)) {
            return;
        }
        const node = targetView.cell;
        const size = node.getSize();
        const position = node.getPosition();
        const cellBBox = new _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Rectangle(x - this.offset.x, y - this.offset.y, size.width, size.height);
        const angle = node.getAngle();
        const nodeCenter = cellBBox.getCenter();
        const nodeBBoxRotated = cellBBox.bbox(angle);
        const nodeTopLeft = nodeBBoxRotated.getTopLeft();
        const nodeBottomRight = nodeBBoxRotated.getBottomRight();
        const distance = this.options.tolerance || 0;
        let verticalLeft;
        let verticalTop;
        let verticalHeight;
        let horizontalTop;
        let horizontalLeft;
        let horizontalWidth;
        let verticalFix = 0;
        let horizontalFix = 0;
        this.model.getNodes().some((targetNode) => {
            if (this.isIgnored(node, targetNode)) {
                return false;
            }
            const snapBBox = targetNode.getBBox().bbox(targetNode.getAngle());
            const snapCenter = snapBBox.getCenter();
            const snapTopLeft = snapBBox.getTopLeft();
            const snapBottomRight = snapBBox.getBottomRight();
            if (verticalLeft == null) {
                if (Math.abs(snapCenter.x - nodeCenter.x) < distance) {
                    verticalLeft = snapCenter.x;
                    verticalFix = 0.5;
                }
                else if (Math.abs(snapTopLeft.x - nodeTopLeft.x) < distance) {
                    verticalLeft = snapTopLeft.x;
                    verticalFix = 0;
                }
                else if (Math.abs(snapTopLeft.x - nodeBottomRight.x) < distance) {
                    verticalLeft = snapTopLeft.x;
                    verticalFix = 1;
                }
                else if (Math.abs(snapBottomRight.x - nodeBottomRight.x) < distance) {
                    verticalLeft = snapBottomRight.x;
                    verticalFix = 1;
                }
                else if (Math.abs(snapBottomRight.x - nodeTopLeft.x) < distance) {
                    verticalLeft = snapBottomRight.x;
                }
                if (verticalLeft != null) {
                    verticalTop = Math.min(nodeBBoxRotated.y, snapBBox.y);
                    verticalHeight =
                        Math.max(nodeBottomRight.y, snapBottomRight.y) - verticalTop;
                }
            }
            if (horizontalTop == null) {
                if (Math.abs(snapCenter.y - nodeCenter.y) < distance) {
                    horizontalTop = snapCenter.y;
                    horizontalFix = 0.5;
                }
                else if (Math.abs(snapTopLeft.y - nodeTopLeft.y) < distance) {
                    horizontalTop = snapTopLeft.y;
                }
                else if (Math.abs(snapTopLeft.y - nodeBottomRight.y) < distance) {
                    horizontalTop = snapTopLeft.y;
                    horizontalFix = 1;
                }
                else if (Math.abs(snapBottomRight.y - nodeBottomRight.y) < distance) {
                    horizontalTop = snapBottomRight.y;
                    horizontalFix = 1;
                }
                else if (Math.abs(snapBottomRight.y - nodeTopLeft.y) < distance) {
                    horizontalTop = snapBottomRight.y;
                }
                if (horizontalTop != null) {
                    horizontalLeft = Math.min(nodeBBoxRotated.x, snapBBox.x);
                    horizontalWidth =
                        Math.max(nodeBottomRight.x, snapBottomRight.x) - horizontalLeft;
                }
            }
            return verticalLeft != null && horizontalTop != null;
        });
        this.hide();
        if (horizontalTop != null || verticalLeft != null) {
            if (horizontalTop != null) {
                nodeBBoxRotated.y =
                    horizontalTop - horizontalFix * nodeBBoxRotated.height;
            }
            if (verticalLeft != null) {
                nodeBBoxRotated.x = verticalLeft - verticalFix * nodeBBoxRotated.width;
            }
            const newCenter = nodeBBoxRotated.getCenter();
            const newX = newCenter.x - cellBBox.width / 2;
            const newY = newCenter.y - cellBBox.height / 2;
            const dx = newX - position.x;
            const dy = newY - position.y;
            if (dx !== 0 || dy !== 0) {
                node.translate(dx, dy, {
                    snapped: true,
                    restrict: this.getRestrictArea(targetView),
                });
                if (horizontalWidth) {
                    horizontalWidth += dx;
                }
                if (verticalHeight) {
                    verticalHeight += dy;
                }
            }
            this.update({
                verticalLeft,
                verticalTop,
                verticalHeight,
                horizontalTop,
                horizontalLeft,
                horizontalWidth,
            });
        }
    }
    isIgnored(snapNode, targetNode) {
        return (targetNode.id === snapNode.id ||
            targetNode.isDescendantOf(snapNode) ||
            !this.filter(targetNode));
    }
    filter(node) {
        const filter = this.options.filter;
        if (Array.isArray(filter)) {
            return filter.some((item) => {
                if (typeof item === 'string') {
                    return node.shape === item;
                }
                return node.id === item.id;
            });
        }
        if (typeof filter === 'function') {
            return _antv_x6__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(filter, this.graph, node);
        }
        return true;
    }
    update(metadata) {
        // https://en.wikipedia.org/wiki/Transformation_matrix#Affine_transformations
        if (metadata.horizontalTop) {
            const start = this.graph.localToGraph(new _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Point(metadata.horizontalLeft, metadata.horizontalTop));
            const end = this.graph.localToGraph(new _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Point(metadata.horizontalLeft + metadata.horizontalWidth, metadata.horizontalTop));
            this.horizontal.setAttributes({
                x1: this.options.sharp ? `${start.x}` : '0',
                y1: `${start.y}`,
                x2: this.options.sharp ? `${end.x}` : '100%',
                y2: `${end.y}`,
                display: 'inherit',
            });
        }
        else {
            this.horizontal.setAttribute('display', 'none');
        }
        if (metadata.verticalLeft) {
            const start = this.graph.localToGraph(new _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Point(metadata.verticalLeft, metadata.verticalTop));
            const end = this.graph.localToGraph(new _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Point(metadata.verticalLeft, metadata.verticalTop + metadata.verticalHeight));
            this.vertical.setAttributes({
                x1: `${start.x}`,
                y1: this.options.sharp ? `${start.y}` : '0',
                x2: `${end.x}`,
                y2: this.options.sharp ? `${end.y}` : '100%',
                display: 'inherit',
            });
        }
        else {
            this.vertical.setAttribute('display', 'none');
        }
        this.show();
    }
    resetTimer() {
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
    }
    show() {
        this.resetTimer();
        if (this.container.parentNode == null) {
            this.graph.container.appendChild(this.container);
        }
        return this;
    }
    hide() {
        this.resetTimer();
        this.vertical.setAttribute('display', 'none');
        this.horizontal.setAttribute('display', 'none');
        const clean = this.options.clean;
        const delay = typeof clean === 'number' ? clean : clean !== false ? 3000 : 0;
        if (delay > 0) {
            this.timer = window.setTimeout(() => {
                if (this.container.parentNode !== null) {
                    this.unmount();
                }
            }, delay);
        }
        return this;
    }
    onRemove() {
        this.stopListening();
        this.hide();
    }
    dispose() {
        this.remove();
    }
}
__decorate([
    _antv_x6__WEBPACK_IMPORTED_MODULE_0__.View.dispose()
], SnaplineImpl.prototype, "dispose", null);
//# sourceMappingURL=snapline.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-plugin-snapline/es/style/raw.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6-plugin-snapline/es/style/raw.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   content: () => (/* binding */ content)
/* harmony export */ });
/* eslint-disable */
/**
 * Auto generated file, do not modify it!
 */
const content = `.x6-widget-snapline {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  pointer-events: none;
}
.x6-widget-snapline-vertical,
.x6-widget-snapline-horizontal {
  stroke: #2ecc71;
  stroke-width: 1px;
}
`;
//# sourceMappingURL=raw.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-plugin-transform/es/api.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6-plugin-transform/es/api.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _antv_x6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6 */ "./node_modules/@antv/x6/es/index.js");

_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.createTransformWidget = function (node) {
    const transform = this.getPlugin('transform');
    if (transform) {
        transform.createWidget(node);
    }
    return this;
};
_antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.prototype.clearTransformWidgets = function () {
    const transform = this.getPlugin('transform');
    if (transform) {
        transform.clearWidgets();
    }
    return this;
};
//# sourceMappingURL=api.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-plugin-transform/es/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@antv/x6-plugin-transform/es/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Transform: () => (/* binding */ Transform)
/* harmony export */ });
/* harmony import */ var _antv_x6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6 */ "./node_modules/@antv/x6/es/index.js");
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform */ "./node_modules/@antv/x6-plugin-transform/es/transform.js");
/* harmony import */ var _style_raw__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./style/raw */ "./node_modules/@antv/x6-plugin-transform/es/style/raw.js");
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./api */ "./node_modules/@antv/x6-plugin-transform/es/api.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};




class Transform extends _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Basecoat {
    constructor(options = {}) {
        super();
        this.name = 'transform';
        this.widgets = new Map();
        this.disabled = false;
        this.options = options;
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.CssLoader.ensure(this.name, _style_raw__WEBPACK_IMPORTED_MODULE_2__.content);
    }
    init(graph) {
        this.graph = graph;
        if (this.disabled) {
            return;
        }
        this.startListening();
    }
    startListening() {
        this.graph.on('node:click', this.onNodeClick, this);
        this.graph.on('blank:mousedown', this.onBlankMouseDown, this);
    }
    stopListening() {
        this.graph.off('node:click', this.onNodeClick, this);
        this.graph.off('blank:mousedown', this.onBlankMouseDown, this);
    }
    enable() {
        if (this.disabled) {
            this.disabled = false;
            this.startListening();
        }
    }
    disable() {
        if (!this.disabled) {
            this.disabled = true;
            this.stopListening();
        }
    }
    isEnabled() {
        return !this.disabled;
    }
    createWidget(node) {
        this.clearWidgets();
        const widget = this.createTransform(node);
        if (widget) {
            this.widgets.set(node, widget);
            widget.on('*', (name, args) => {
                this.trigger(name, args);
                this.graph.trigger(name, args);
            });
        }
    }
    onNodeClick({ node }) {
        this.createWidget(node);
    }
    onBlankMouseDown() {
        this.clearWidgets();
    }
    createTransform(node) {
        const options = this.getTransformOptions(node);
        if (options.resizable || options.rotatable) {
            return new _transform__WEBPACK_IMPORTED_MODULE_1__.TransformImpl(options, node, this.graph);
        }
        return null;
    }
    getTransformOptions(node) {
        if (!this.options.resizing) {
            this.options.resizing = {
                enabled: false,
            };
        }
        if (!this.options.rotating) {
            this.options.rotating = {
                enabled: false,
            };
        }
        if (typeof this.options.resizing === 'boolean') {
            this.options.resizing = {
                enabled: this.options.resizing,
            };
        }
        if (typeof this.options.rotating === 'boolean') {
            this.options.rotating = {
                enabled: this.options.rotating,
            };
        }
        const resizing = Transform.parseOptionGroup(this.graph, node, this.options.resizing);
        const rotating = Transform.parseOptionGroup(this.graph, node, this.options.rotating);
        const options = {
            resizable: !!resizing.enabled,
            minWidth: resizing.minWidth || 0,
            maxWidth: resizing.maxWidth || Number.MAX_SAFE_INTEGER,
            minHeight: resizing.minHeight || 0,
            maxHeight: resizing.maxHeight || Number.MAX_SAFE_INTEGER,
            orthogonalResizing: typeof resizing.orthogonal === 'boolean' ? resizing.orthogonal : true,
            restrictedResizing: !!resizing.restrict,
            autoScrollOnResizing: typeof resizing.autoScroll === 'boolean' ? resizing.autoScroll : true,
            preserveAspectRatio: !!resizing.preserveAspectRatio,
            allowReverse: typeof resizing.allowReverse === 'boolean'
                ? resizing.allowReverse
                : true,
            rotatable: !!rotating.enabled,
            rotateGrid: rotating.grid || 15,
        };
        return options;
    }
    clearWidgets() {
        this.widgets.forEach((widget, node) => {
            if (this.graph.getCellById(node.id)) {
                widget.dispose();
            }
        });
        this.widgets.clear();
    }
    dispose() {
        this.clearWidgets();
        this.stopListening();
        this.off();
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.CssLoader.clean(this.name);
    }
}
__decorate([
    _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Basecoat.dispose()
], Transform.prototype, "dispose", null);
(function (Transform) {
    function parseOptionGroup(graph, arg, options) {
        const result = {};
        Object.keys(options || {}).forEach((key) => {
            const val = options[key];
            result[key] = typeof val === 'function' ? val.call(graph, arg) : val;
        });
        return result;
    }
    Transform.parseOptionGroup = parseOptionGroup;
})(Transform || (Transform = {}));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-plugin-transform/es/style/raw.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/x6-plugin-transform/es/style/raw.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   content: () => (/* binding */ content)
/* harmony export */ });
/* eslint-disable */
/**
 * Auto generated file, do not modify it!
 */
const content = `.x6-widget-transform {
  position: absolute;
  box-sizing: content-box !important;
  margin: -5px 0 0 -5px;
  padding: 4px;
  border: 1px dashed #000;
  border-radius: 5px;
  user-select: none;
  pointer-events: none;
}
.x6-widget-transform > div {
  position: absolute;
  box-sizing: border-box;
  background-color: #fff;
  border: 1px solid #000;
  transition: background-color 0.2s;
  pointer-events: auto;
  -webkit-user-drag: none;
  user-drag: none;
  /* stylelint-disable-line */
}
.x6-widget-transform > div:hover {
  background-color: #d3d3d3;
}
.x6-widget-transform-cursor-n {
  cursor: n-resize;
}
.x6-widget-transform-cursor-s {
  cursor: s-resize;
}
.x6-widget-transform-cursor-e {
  cursor: e-resize;
}
.x6-widget-transform-cursor-w {
  cursor: w-resize;
}
.x6-widget-transform-cursor-ne {
  cursor: ne-resize;
}
.x6-widget-transform-cursor-nw {
  cursor: nw-resize;
}
.x6-widget-transform-cursor-se {
  cursor: se-resize;
}
.x6-widget-transform-cursor-sw {
  cursor: sw-resize;
}
.x6-widget-transform-resize {
  width: 10px;
  height: 10px;
  border-radius: 6px;
}
.x6-widget-transform-resize[data-position='top-left'] {
  top: -5px;
  left: -5px;
}
.x6-widget-transform-resize[data-position='top-right'] {
  top: -5px;
  right: -5px;
}
.x6-widget-transform-resize[data-position='bottom-left'] {
  bottom: -5px;
  left: -5px;
}
.x6-widget-transform-resize[data-position='bottom-right'] {
  right: -5px;
  bottom: -5px;
}
.x6-widget-transform-resize[data-position='top'] {
  top: -5px;
  left: 50%;
  margin-left: -5px;
}
.x6-widget-transform-resize[data-position='bottom'] {
  bottom: -5px;
  left: 50%;
  margin-left: -5px;
}
.x6-widget-transform-resize[data-position='left'] {
  top: 50%;
  left: -5px;
  margin-top: -5px;
}
.x6-widget-transform-resize[data-position='right'] {
  top: 50%;
  right: -5px;
  margin-top: -5px;
}
.x6-widget-transform.prevent-aspect-ratio .x6-widget-transform-resize[data-position='top'],
.x6-widget-transform.prevent-aspect-ratio .x6-widget-transform-resize[data-position='bottom'],
.x6-widget-transform.prevent-aspect-ratio .x6-widget-transform-resize[data-position='left'],
.x6-widget-transform.prevent-aspect-ratio .x6-widget-transform-resize[data-position='right'] {
  display: none;
}
.x6-widget-transform.no-orth-resize .x6-widget-transform-resize[data-position='bottom'],
.x6-widget-transform.no-orth-resize .x6-widget-transform-resize[data-position='left'],
.x6-widget-transform.no-orth-resize .x6-widget-transform-resize[data-position='right'],
.x6-widget-transform.no-orth-resize .x6-widget-transform-resize[data-position='top'] {
  display: none;
}
.x6-widget-transform.no-resize .x6-widget-transform-resize {
  display: none;
}
.x6-widget-transform-rotate {
  top: -20px;
  left: -20px;
  width: 12px;
  height: 12px;
  border-radius: 6px;
  cursor: crosshair;
}
.x6-widget-transform.no-rotate .x6-widget-transform-rotate {
  display: none;
}
.x6-widget-transform-active {
  border-color: transparent;
  pointer-events: all;
}
.x6-widget-transform-active > div {
  display: none;
}
.x6-widget-transform-active > .x6-widget-transform-active-handle {
  display: block;
  background-color: #808080;
}
`;
//# sourceMappingURL=raw.js.map

/***/ }),

/***/ "./node_modules/@antv/x6-plugin-transform/es/transform.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/x6-plugin-transform/es/transform.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TransformImpl: () => (/* binding */ TransformImpl)
/* harmony export */ });
/* harmony import */ var _antv_x6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6 */ "./node_modules/@antv/x6/es/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

class TransformImpl extends _antv_x6__WEBPACK_IMPORTED_MODULE_0__.View {
    get model() {
        return this.graph.model;
    }
    get view() {
        return this.graph.renderer.findViewByCell(this.node);
    }
    get containerClassName() {
        return this.prefixClassName('widget-transform');
    }
    get resizeClassName() {
        return `${this.containerClassName}-resize`;
    }
    get rotateClassName() {
        return `${this.containerClassName}-rotate`;
    }
    constructor(options, node, graph) {
        super();
        this.node = node;
        this.graph = graph;
        this.options = Object.assign(Object.assign({}, Private.defaultOptions), options);
        this.render();
        this.startListening();
    }
    startListening() {
        this.delegateEvents({
            [`mousedown .${this.resizeClassName}`]: 'startResizing',
            [`touchstart .${this.resizeClassName}`]: 'startResizing',
            [`mousedown .${this.rotateClassName}`]: 'startRotating',
            [`touchstart .${this.rotateClassName}`]: 'startRotating',
        });
        this.model.on('*', this.update, this);
        this.graph.on('scale', this.update, this);
        this.graph.on('translate', this.update, this);
        this.node.on('removed', this.remove, this);
        this.model.on('reseted', this.remove, this);
        this.view.on('cell:knob:mousedown', this.onKnobMouseDown, this);
        this.view.on('cell:knob:mouseup', this.onKnobMouseUp, this);
    }
    stopListening() {
        this.undelegateEvents();
        this.model.off('*', this.update, this);
        this.graph.off('scale', this.update, this);
        this.graph.off('translate', this.update, this);
        this.node.off('removed', this.remove, this);
        this.model.off('reseted', this.remove, this);
        this.view.off('cell:knob:mousedown', this.onKnobMouseDown, this);
        this.view.off('cell:knob:mouseup', this.onKnobMouseUp, this);
    }
    renderHandles() {
        this.container = document.createElement('div');
        const knob = document.createElement('div');
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.attr(knob, 'draggable', 'false');
        const rotate = knob.cloneNode(true);
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(rotate, this.rotateClassName);
        const resizes = Private.POSITIONS.map((pos) => {
            const elem = knob.cloneNode(true);
            _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(elem, this.resizeClassName);
            _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.attr(elem, 'data-position', pos);
            return elem;
        });
        this.empty();
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.append(this.container, [...resizes, rotate]);
    }
    render() {
        this.renderHandles();
        if (this.view) {
            this.view.addClass(Private.NODE_CLS);
        }
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.container, this.containerClassName);
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.toggleClass(this.container, 'no-orth-resize', this.options.preserveAspectRatio || !this.options.orthogonalResizing);
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.toggleClass(this.container, 'no-resize', !this.options.resizable);
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.toggleClass(this.container, 'no-rotate', !this.options.rotatable);
        if (this.options.className) {
            _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.container, this.options.className);
        }
        this.graph.container.appendChild(this.container);
        return this.update();
    }
    update() {
        const ctm = this.graph.matrix();
        const bbox = this.node.getBBox();
        bbox.x *= ctm.a;
        bbox.x += ctm.e;
        bbox.y *= ctm.d;
        bbox.y += ctm.f;
        bbox.width *= ctm.a;
        bbox.height *= ctm.d;
        const angle = _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Angle.normalize(this.node.getAngle());
        const transform = angle !== 0 ? `rotate(${angle}deg)` : '';
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.css(this.container, {
            transform,
            width: bbox.width,
            height: bbox.height,
            left: bbox.x,
            top: bbox.y,
        });
        this.updateResizerDirections();
        return this;
    }
    remove() {
        if (this.view) {
            this.view.removeClass(Private.NODE_CLS);
        }
        return super.remove();
    }
    onKnobMouseDown() {
        this.startHandle();
    }
    onKnobMouseUp() {
        this.stopHandle();
    }
    updateResizerDirections() {
        // Update the directions on the resizer divs while the node being rotated.
        // The directions are represented by cardinal points (N,S,E,W). For example
        // the div originally pointed to north needs to be changed to point to south
        // if the node was rotated by 180 degrees.
        const angle = _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Angle.normalize(this.node.getAngle());
        const shift = Math.floor(angle * (Private.DIRECTIONS.length / 360));
        if (shift !== this.prevShift) {
            // Create the current directions array based on the calculated shift.
            const directions = Private.DIRECTIONS.slice(shift).concat(Private.DIRECTIONS.slice(0, shift));
            const className = (dir) => `${this.containerClassName}-cursor-${dir}`;
            const resizes = this.container.querySelectorAll(`.${this.resizeClassName}`);
            resizes.forEach((resize, index) => {
                _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.removeClass(resize, Private.DIRECTIONS.map((dir) => className(dir)).join(' '));
                _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(resize, className(directions[index]));
            });
            this.prevShift = shift;
        }
    }
    getTrueDirection(dir) {
        const angle = _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Angle.normalize(this.node.getAngle());
        let index = Private.POSITIONS.indexOf(dir);
        index += Math.floor(angle * (Private.POSITIONS.length / 360));
        index %= Private.POSITIONS.length;
        return Private.POSITIONS[index];
    }
    toValidResizeDirection(dir) {
        return ({
            top: 'top-left',
            bottom: 'bottom-right',
            left: 'bottom-left',
            right: 'top-right',
        }[dir] || dir);
    }
    startResizing(evt) {
        evt.stopPropagation();
        this.model.startBatch('resize', { cid: this.cid });
        const dir = _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.attr(evt.target, 'data-position');
        this.prepareResizing(evt, dir);
        this.startAction(evt);
    }
    prepareResizing(evt, relativeDirection) {
        const trueDirection = this.getTrueDirection(relativeDirection);
        let rx = 0;
        let ry = 0;
        relativeDirection.split('-').forEach((direction) => {
            rx = { left: -1, right: 1 }[direction] || rx;
            ry = { top: -1, bottom: 1 }[direction] || ry;
        });
        const direction = this.toValidResizeDirection(relativeDirection);
        const selector = {
            'top-right': 'bottomLeft',
            'top-left': 'bottomRight',
            'bottom-left': 'topRight',
            'bottom-right': 'topLeft',
        }[direction];
        const angle = _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Angle.normalize(this.node.getAngle());
        this.setEventData(evt, {
            selector,
            direction,
            trueDirection,
            relativeDirection,
            angle,
            resizeX: rx,
            resizeY: ry,
            action: 'resizing',
        });
    }
    startRotating(evt) {
        evt.stopPropagation();
        this.model.startBatch('rotate', { cid: this.cid });
        const center = this.node.getBBox().getCenter();
        const e = this.normalizeEvent(evt);
        const client = this.graph.snapToGrid(e.clientX, e.clientY);
        this.setEventData(evt, {
            center,
            action: 'rotating',
            angle: _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Angle.normalize(this.node.getAngle()),
            start: _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Point.create(client).theta(center),
        });
        this.startAction(evt);
    }
    onMouseMove(evt) {
        const view = this.graph.findViewByCell(this.node);
        let data = this.getEventData(evt);
        if (data.action) {
            const e = this.normalizeEvent(evt);
            let clientX = e.clientX;
            let clientY = e.clientY;
            const scroller = this.graph.getPlugin('scroller');
            const restrict = this.options.restrictedResizing;
            if (restrict === true || typeof restrict === 'number') {
                const factor = restrict === true ? 0 : restrict;
                const fix = scroller ? Math.max(factor, 8) : factor;
                const rect = this.graph.container.getBoundingClientRect();
                clientX = _antv_x6__WEBPACK_IMPORTED_MODULE_0__.NumberExt.clamp(clientX, rect.left + fix, rect.right - fix);
                clientY = _antv_x6__WEBPACK_IMPORTED_MODULE_0__.NumberExt.clamp(clientY, rect.top + fix, rect.bottom - fix);
            }
            else if (this.options.autoScrollOnResizing && scroller) {
                scroller.autoScroll(clientX, clientY);
            }
            const pos = this.graph.snapToGrid(clientX, clientY);
            const gridSize = this.graph.getGridSize();
            const node = this.node;
            const options = this.options;
            if (data.action === 'resizing') {
                data = data;
                if (!data.resized) {
                    if (view) {
                        view.addClass('node-resizing');
                        this.notify('node:resize', evt, view);
                    }
                    data.resized = true;
                }
                const currentBBox = node.getBBox();
                const requestedSize = _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Point.create(pos)
                    .rotate(data.angle, currentBBox.getCenter())
                    .diff(currentBBox[data.selector]);
                let width = data.resizeX
                    ? requestedSize.x * data.resizeX
                    : currentBBox.width;
                let height = data.resizeY
                    ? requestedSize.y * data.resizeY
                    : currentBBox.height;
                const rawWidth = width;
                const rawHeight = height;
                width = _antv_x6__WEBPACK_IMPORTED_MODULE_0__.GeometryUtil.snapToGrid(width, gridSize);
                height = _antv_x6__WEBPACK_IMPORTED_MODULE_0__.GeometryUtil.snapToGrid(height, gridSize);
                width = Math.max(width, options.minWidth || gridSize);
                height = Math.max(height, options.minHeight || gridSize);
                width = Math.min(width, options.maxWidth || Infinity);
                height = Math.min(height, options.maxHeight || Infinity);
                if (options.preserveAspectRatio) {
                    const candidateWidth = (currentBBox.width * height) / currentBBox.height;
                    const candidateHeight = (currentBBox.height * width) / currentBBox.width;
                    if (width < candidateWidth) {
                        height = candidateHeight;
                    }
                    else {
                        width = candidateWidth;
                    }
                }
                const relativeDirection = data.relativeDirection;
                if (options.allowReverse &&
                    (rawWidth <= -width || rawHeight <= -height)) {
                    let reverted;
                    if (relativeDirection === 'left') {
                        if (rawWidth <= -width) {
                            reverted = 'right';
                        }
                    }
                    else if (relativeDirection === 'right') {
                        if (rawWidth <= -width) {
                            reverted = 'left';
                        }
                    }
                    else if (relativeDirection === 'top') {
                        if (rawHeight <= -height) {
                            reverted = 'bottom';
                        }
                    }
                    else if (relativeDirection === 'bottom') {
                        if (rawHeight <= -height) {
                            reverted = 'top';
                        }
                    }
                    else if (relativeDirection === 'top-left') {
                        if (rawWidth <= -width && rawHeight <= -height) {
                            reverted = 'bottom-right';
                        }
                        else if (rawWidth <= -width) {
                            reverted = 'top-right';
                        }
                        else if (rawHeight <= -height) {
                            reverted = 'bottom-left';
                        }
                    }
                    else if (relativeDirection === 'top-right') {
                        if (rawWidth <= -width && rawHeight <= -height) {
                            reverted = 'bottom-left';
                        }
                        else if (rawWidth <= -width) {
                            reverted = 'top-left';
                        }
                        else if (rawHeight <= -height) {
                            reverted = 'bottom-right';
                        }
                    }
                    else if (relativeDirection === 'bottom-left') {
                        if (rawWidth <= -width && rawHeight <= -height) {
                            reverted = 'top-right';
                        }
                        else if (rawWidth <= -width) {
                            reverted = 'bottom-right';
                        }
                        else if (rawHeight <= -height) {
                            reverted = 'top-left';
                        }
                    }
                    else if (relativeDirection === 'bottom-right') {
                        if (rawWidth <= -width && rawHeight <= -height) {
                            reverted = 'top-left';
                        }
                        else if (rawWidth <= -width) {
                            reverted = 'bottom-left';
                        }
                        else if (rawHeight <= -height) {
                            reverted = 'top-right';
                        }
                    }
                    const revertedDir = reverted;
                    this.stopHandle();
                    const handle = this.container.querySelector(`.${this.resizeClassName}[data-position="${revertedDir}"]`);
                    this.startHandle(handle);
                    this.prepareResizing(evt, revertedDir);
                    this.onMouseMove(evt);
                }
                if (currentBBox.width !== width || currentBBox.height !== height) {
                    const resizeOptions = {
                        ui: true,
                        direction: data.direction,
                        relativeDirection: data.relativeDirection,
                        trueDirection: data.trueDirection,
                        minWidth: options.minWidth,
                        minHeight: options.minHeight,
                        maxWidth: options.maxWidth,
                        maxHeight: options.maxHeight,
                        preserveAspectRatio: options.preserveAspectRatio === true,
                    };
                    node.resize(width, height, resizeOptions);
                    this.notify('node:resizing', evt, view);
                }
            }
            else if (data.action === 'rotating') {
                data = data;
                if (!data.rotated) {
                    if (view) {
                        view.addClass('node-rotating');
                        this.notify('node:rotate', evt, view);
                    }
                    data.rotated = true;
                }
                const currentAngle = node.getAngle();
                const theta = data.start - _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Point.create(pos).theta(data.center);
                let target = data.angle + theta;
                if (options.rotateGrid) {
                    target = _antv_x6__WEBPACK_IMPORTED_MODULE_0__.GeometryUtil.snapToGrid(target, options.rotateGrid);
                }
                target = _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Angle.normalize(target);
                if (currentAngle !== target) {
                    node.rotate(target, { absolute: true });
                    this.notify('node:rotating', evt, view);
                }
            }
        }
    }
    onMouseUp(evt) {
        const data = this.getEventData(evt);
        if (data.action) {
            this.stopAction(evt);
            this.model.stopBatch(data.action === 'resizing' ? 'resize' : 'rotate', {
                cid: this.cid,
            });
        }
    }
    startHandle(handle) {
        this.handle = handle || null;
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.container, `${this.containerClassName}-active`);
        if (handle) {
            _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(handle, `${this.containerClassName}-active-handle`);
            const pos = handle.getAttribute('data-position');
            if (pos) {
                const dir = Private.DIRECTIONS[Private.POSITIONS.indexOf(pos)];
                _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.container, `${this.containerClassName}-cursor-${dir}`);
            }
        }
    }
    stopHandle() {
        _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.removeClass(this.container, `${this.containerClassName}-active`);
        if (this.handle) {
            _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.removeClass(this.handle, `${this.containerClassName}-active-handle`);
            const pos = this.handle.getAttribute('data-position');
            if (pos) {
                const dir = Private.DIRECTIONS[Private.POSITIONS.indexOf(pos)];
                _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Dom.removeClass(this.container, `${this.containerClassName}-cursor-${dir}`);
            }
            this.handle = null;
        }
    }
    startAction(evt) {
        this.startHandle(evt.target);
        this.graph.view.undelegateEvents();
        this.delegateDocumentEvents(Private.documentEvents, evt.data);
    }
    stopAction(evt) {
        this.stopHandle();
        this.undelegateDocumentEvents();
        this.graph.view.delegateEvents();
        const view = this.graph.findViewByCell(this.node);
        const data = this.getEventData(evt);
        if (view) {
            view.removeClass(`node-${data.action}`);
            if (data.action === 'resizing' && data.resized) {
                this.notify('node:resized', evt, view);
            }
            else if (data.action === 'rotating' && data.rotated) {
                this.notify('node:rotated', evt, view);
            }
        }
    }
    notify(name, evt, view, args = {}) {
        if (view) {
            const graph = view.graph;
            const e = graph.view.normalizeEvent(evt);
            const localPoint = graph.snapToGrid(e.clientX, e.clientY);
            this.trigger(name, Object.assign({ e,
                view, node: view.cell, cell: view.cell, x: localPoint.x, y: localPoint.y }, args));
        }
    }
    dispose() {
        this.stopListening();
        this.remove();
        this.off();
    }
}
__decorate([
    _antv_x6__WEBPACK_IMPORTED_MODULE_0__.View.dispose()
], TransformImpl.prototype, "dispose", null);
var Private;
(function (Private) {
    Private.NODE_CLS = 'has-widget-transform';
    Private.DIRECTIONS = ['nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w'];
    Private.POSITIONS = [
        'top-left',
        'top',
        'top-right',
        'right',
        'bottom-right',
        'bottom',
        'bottom-left',
        'left',
    ];
    Private.documentEvents = {
        mousemove: 'onMouseMove',
        touchmove: 'onMouseMove',
        mouseup: 'onMouseUp',
        touchend: 'onMouseUp',
    };
    Private.defaultOptions = {
        minWidth: 0,
        minHeight: 0,
        maxWidth: Infinity,
        maxHeight: Infinity,
        rotateGrid: 15,
        rotatable: true,
        preserveAspectRatio: false,
        orthogonalResizing: true,
        restrictedResizing: false,
        autoScrollOnResizing: true,
        allowReverse: true,
    };
})(Private || (Private = {}));
//# sourceMappingURL=transform.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/config/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@antv/x6/es/config/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Config: () => (/* binding */ Config)
/* harmony export */ });
const Config = {
    prefixCls: 'x6',
    autoInsertCSS: true,
    useCSSSelector: true,
    prefix(suffix) {
        return `${Config.prefixCls}-${suffix}`;
    },
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/graph/background.js":
/*!******************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/background.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BackgroundManager: () => (/* binding */ BackgroundManager)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../registry */ "./node_modules/@antv/x6/es/registry/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base */ "./node_modules/@antv/x6/es/graph/base.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};




class BackgroundManager extends _base__WEBPACK_IMPORTED_MODULE_3__.Base {
    get elem() {
        return this.view.background;
    }
    init() {
        this.startListening();
        if (this.options.background) {
            this.draw(this.options.background);
        }
    }
    startListening() {
        this.graph.on('scale', this.update, this);
        this.graph.on('translate', this.update, this);
    }
    stopListening() {
        this.graph.off('scale', this.update, this);
        this.graph.off('translate', this.update, this);
    }
    updateBackgroundImage(options = {}) {
        let backgroundSize = options.size || 'auto auto';
        let backgroundPosition = options.position || 'center';
        const scale = this.graph.transform.getScale();
        const ts = this.graph.translate();
        // backgroundPosition
        if (typeof backgroundPosition === 'object') {
            const x = ts.tx + scale.sx * (backgroundPosition.x || 0);
            const y = ts.ty + scale.sy * (backgroundPosition.y || 0);
            backgroundPosition = `${x}px ${y}px`;
        }
        // backgroundSize
        if (typeof backgroundSize === 'object') {
            backgroundSize = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.fromSize(backgroundSize).scale(scale.sx, scale.sy);
            backgroundSize = `${backgroundSize.width}px ${backgroundSize.height}px`;
        }
        this.elem.style.backgroundSize = backgroundSize;
        this.elem.style.backgroundPosition = backgroundPosition;
    }
    drawBackgroundImage(img, options = {}) {
        if (!(img instanceof HTMLImageElement)) {
            this.elem.style.backgroundImage = '';
            return;
        }
        // draw multiple times to show the last image
        const cache = this.optionsCache;
        if (cache && cache.image !== options.image) {
            return;
        }
        let uri;
        const opacity = options.opacity;
        const backgroundSize = options.size;
        let backgroundRepeat = options.repeat || 'no-repeat';
        const pattern = _registry__WEBPACK_IMPORTED_MODULE_2__.Background.registry.get(backgroundRepeat);
        if (typeof pattern === 'function') {
            const quality = options.quality || 1;
            img.width *= quality;
            img.height *= quality;
            const canvas = pattern(img, options);
            if (!(canvas instanceof HTMLCanvasElement)) {
                throw new Error('Background pattern must return an HTML Canvas instance');
            }
            uri = canvas.toDataURL('image/png');
            // `repeat` was changed in pattern function
            if (options.repeat && backgroundRepeat !== options.repeat) {
                backgroundRepeat = options.repeat;
            }
            else {
                backgroundRepeat = 'repeat';
            }
            if (typeof backgroundSize === 'object') {
                // recalculate the tile size if an object passed in
                backgroundSize.width *= canvas.width / img.width;
                backgroundSize.height *= canvas.height / img.height;
            }
            else if (backgroundSize === undefined) {
                // calcule the tile size if no provided
                options.size = {
                    width: canvas.width / quality,
                    height: canvas.height / quality,
                };
            }
        }
        else {
            uri = img.src;
            if (backgroundSize === undefined) {
                options.size = {
                    width: img.width,
                    height: img.height,
                };
            }
        }
        if (cache != null &&
            typeof options.size === 'object' &&
            options.image === cache.image &&
            options.repeat === cache.repeat &&
            options.quality ===
                cache.quality) {
            cache.size = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.clone(options.size);
        }
        const style = this.elem.style;
        style.backgroundImage = `url(${uri})`;
        style.backgroundRepeat = backgroundRepeat;
        style.opacity = opacity == null || opacity >= 1 ? '' : `${opacity}`;
        this.updateBackgroundImage(options);
    }
    updateBackgroundColor(color) {
        this.elem.style.backgroundColor = color || '';
    }
    updateBackgroundOptions(options) {
        this.graph.options.background = options;
    }
    update() {
        if (this.optionsCache) {
            this.updateBackgroundImage(this.optionsCache);
        }
    }
    draw(options) {
        const opts = options || {};
        this.updateBackgroundOptions(options);
        this.updateBackgroundColor(opts.color);
        if (opts.image) {
            this.optionsCache = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.clone(opts);
            const img = document.createElement('img');
            img.onload = () => this.drawBackgroundImage(img, options);
            img.setAttribute('crossorigin', 'anonymous');
            img.src = opts.image;
        }
        else {
            this.drawBackgroundImage(null);
            this.optionsCache = null;
        }
    }
    clear() {
        this.draw();
    }
    dispose() {
        this.clear();
        this.stopListening();
    }
}
__decorate([
    _base__WEBPACK_IMPORTED_MODULE_3__.Base.dispose()
], BackgroundManager.prototype, "dispose", null);
//# sourceMappingURL=background.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/graph/base.js":
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/base.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Base: () => (/* binding */ Base)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");

class Base extends _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Disposable {
    get options() {
        return this.graph.options;
    }
    get model() {
        return this.graph.model;
    }
    get view() {
        return this.graph.view;
    }
    constructor(graph) {
        super();
        this.graph = graph;
        this.init();
    }
    init() { }
}
//# sourceMappingURL=base.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/graph/coord.js":
/*!*************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/coord.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CoordManager: () => (/* binding */ CoordManager)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base */ "./node_modules/@antv/x6/es/graph/base.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/x6/es/util/index.js");




class CoordManager extends _base__WEBPACK_IMPORTED_MODULE_2__.Base {
    getClientMatrix() {
        return _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.createSVGMatrix(this.view.stage.getScreenCTM());
    }
    /**
     * Returns coordinates of the graph viewport, relative to the window.
     */
    getClientOffset() {
        // see: https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect
        const rect = this.view.svg.getBoundingClientRect();
        return new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(rect.left, rect.top);
    }
    /**
     * Returns coordinates of the graph viewport, relative to the document.
     */
    getPageOffset() {
        // see: https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect
        return this.getClientOffset().translate(window.scrollX, window.scrollY);
    }
    snapToGrid(x, y) {
        const p = typeof x === 'number'
            ? this.clientToLocalPoint(x, y)
            : this.clientToLocalPoint(x.x, x.y);
        return p.snapToGrid(this.graph.getGridSize());
    }
    localToGraphPoint(x, y) {
        const localPoint = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(x, y);
        return _util__WEBPACK_IMPORTED_MODULE_3__.Util.transformPoint(localPoint, this.graph.matrix());
    }
    localToClientPoint(x, y) {
        const localPoint = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(x, y);
        return _util__WEBPACK_IMPORTED_MODULE_3__.Util.transformPoint(localPoint, this.getClientMatrix());
    }
    localToPagePoint(x, y) {
        const p = typeof x === 'number'
            ? this.localToGraphPoint(x, y)
            : this.localToGraphPoint(x);
        return p.translate(this.getPageOffset());
    }
    localToGraphRect(x, y, width, height) {
        const localRect = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.create(x, y, width, height);
        return _util__WEBPACK_IMPORTED_MODULE_3__.Util.transformRectangle(localRect, this.graph.matrix());
    }
    localToClientRect(x, y, width, height) {
        const localRect = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.create(x, y, width, height);
        return _util__WEBPACK_IMPORTED_MODULE_3__.Util.transformRectangle(localRect, this.getClientMatrix());
    }
    localToPageRect(x, y, width, height) {
        const rect = typeof x === 'number'
            ? this.localToGraphRect(x, y, width, height)
            : this.localToGraphRect(x);
        return rect.translate(this.getPageOffset());
    }
    graphToLocalPoint(x, y) {
        const graphPoint = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(x, y);
        return _util__WEBPACK_IMPORTED_MODULE_3__.Util.transformPoint(graphPoint, this.graph.matrix().inverse());
    }
    clientToLocalPoint(x, y) {
        const clientPoint = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(x, y);
        return _util__WEBPACK_IMPORTED_MODULE_3__.Util.transformPoint(clientPoint, this.getClientMatrix().inverse());
    }
    clientToGraphPoint(x, y) {
        const clientPoint = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(x, y);
        return _util__WEBPACK_IMPORTED_MODULE_3__.Util.transformPoint(clientPoint, this.graph.matrix().multiply(this.getClientMatrix().inverse()));
    }
    pageToLocalPoint(x, y) {
        const pagePoint = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(x, y);
        const graphPoint = pagePoint.diff(this.getPageOffset());
        return this.graphToLocalPoint(graphPoint);
    }
    graphToLocalRect(x, y, width, height) {
        const graphRect = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.create(x, y, width, height);
        return _util__WEBPACK_IMPORTED_MODULE_3__.Util.transformRectangle(graphRect, this.graph.matrix().inverse());
    }
    clientToLocalRect(x, y, width, height) {
        const clientRect = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.create(x, y, width, height);
        return _util__WEBPACK_IMPORTED_MODULE_3__.Util.transformRectangle(clientRect, this.getClientMatrix().inverse());
    }
    clientToGraphRect(x, y, width, height) {
        const clientRect = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.create(x, y, width, height);
        return _util__WEBPACK_IMPORTED_MODULE_3__.Util.transformRectangle(clientRect, this.graph.matrix().multiply(this.getClientMatrix().inverse()));
    }
    pageToLocalRect(x, y, width, height) {
        const graphRect = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.create(x, y, width, height);
        const pageOffset = this.getPageOffset();
        graphRect.x -= pageOffset.x;
        graphRect.y -= pageOffset.y;
        return this.graphToLocalRect(graphRect);
    }
}
//# sourceMappingURL=coord.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/graph/css.js":
/*!***********************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/css.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CSSManager: () => (/* binding */ CSSManager)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config */ "./node_modules/@antv/x6/es/config/index.js");
/* harmony import */ var _style_raw__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../style/raw */ "./node_modules/@antv/x6/es/style/raw.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base */ "./node_modules/@antv/x6/es/graph/base.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};




class CSSManager extends _base__WEBPACK_IMPORTED_MODULE_3__.Base {
    init() {
        if (_config__WEBPACK_IMPORTED_MODULE_1__.Config.autoInsertCSS) {
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.CssLoader.ensure('core', _style_raw__WEBPACK_IMPORTED_MODULE_2__.content);
        }
    }
    dispose() {
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.CssLoader.clean('core');
    }
}
__decorate([
    CSSManager.dispose()
], CSSManager.prototype, "dispose", null);
//# sourceMappingURL=css.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/graph/defs.js":
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/defs.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefsManager: () => (/* binding */ DefsManager)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../registry */ "./node_modules/@antv/x6/es/registry/index.js");
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../view */ "./node_modules/@antv/x6/es/view/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base */ "./node_modules/@antv/x6/es/graph/base.js");
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};




class DefsManager extends _base__WEBPACK_IMPORTED_MODULE_3__.Base {
    get cid() {
        return this.graph.view.cid;
    }
    get svg() {
        return this.view.svg;
    }
    get defs() {
        return this.view.defs;
    }
    isDefined(id) {
        return this.svg.getElementById(id) != null;
    }
    filter(options) {
        let filterId = options.id;
        const name = options.name;
        if (!filterId) {
            filterId = `filter-${name}-${this.cid}-${_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.StringExt.hashcode(JSON.stringify(options))}`;
        }
        if (!this.isDefined(filterId)) {
            const fn = _registry__WEBPACK_IMPORTED_MODULE_1__.Filter.registry.get(name);
            if (fn == null) {
                return _registry__WEBPACK_IMPORTED_MODULE_1__.Filter.registry.onNotFound(name);
            }
            const markup = fn(options.args || {});
            // Set the filter area to be 3x the bounding box of the cell
            // and center the filter around the cell.
            const attrs = Object.assign(Object.assign({ x: -1, y: -1, width: 3, height: 3, filterUnits: 'objectBoundingBox' }, options.attrs), { id: filterId });
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Vector.create(_view__WEBPACK_IMPORTED_MODULE_2__.Markup.sanitize(markup), attrs).appendTo(this.defs);
        }
        return filterId;
    }
    gradient(options) {
        let id = options.id;
        const type = options.type;
        if (!id) {
            id = `gradient-${type}-${this.cid}-${_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.StringExt.hashcode(JSON.stringify(options))}`;
        }
        if (!this.isDefined(id)) {
            const stops = options.stops;
            const arr = stops.map((stop) => {
                const opacity = stop.opacity != null && Number.isFinite(stop.opacity)
                    ? stop.opacity
                    : 1;
                return `<stop offset="${stop.offset}" stop-color="${stop.color}" stop-opacity="${opacity}"/>`;
            });
            const markup = `<${type}>${arr.join('')}</${type}>`;
            const attrs = Object.assign({ id }, options.attrs);
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Vector.create(markup, attrs).appendTo(this.defs);
        }
        return id;
    }
    marker(options) {
        const { id, refX, refY, markerUnits, markerOrient, tagName, children } = options, attrs = __rest(options, ["id", "refX", "refY", "markerUnits", "markerOrient", "tagName", "children"]);
        let markerId = id;
        if (!markerId) {
            markerId = `marker-${this.cid}-${_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.StringExt.hashcode(JSON.stringify(options))}`;
        }
        if (!this.isDefined(markerId)) {
            if (tagName !== 'path') {
                // remove unnecessary d attribute inherit from standard edge.
                delete attrs.d;
            }
            const pathMarker = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Vector.create('marker', {
                refX,
                refY,
                id: markerId,
                overflow: 'visible',
                orient: markerOrient != null ? markerOrient : 'auto',
                markerUnits: markerUnits || 'userSpaceOnUse',
            }, children
                ? children.map((_a) => {
                    var { tagName } = _a, other = __rest(_a, ["tagName"]);
                    return _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Vector.create(`${tagName}` || 'path', _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.kebablizeAttrs(Object.assign(Object.assign({}, attrs), other)));
                })
                : [_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Vector.create(tagName || 'path', _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.kebablizeAttrs(attrs))]);
            this.defs.appendChild(pathMarker.node);
        }
        return markerId;
    }
    remove(id) {
        const elem = this.svg.getElementById(id);
        if (elem && elem.parentNode) {
            elem.parentNode.removeChild(elem);
        }
    }
}
//# sourceMappingURL=defs.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/graph/events.js":
/*!**************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/events.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);

//# sourceMappingURL=events.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/graph/graph.js":
/*!*************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/graph.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Graph: () => (/* binding */ Graph)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model */ "./node_modules/@antv/x6/es/model/index.js");
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../view */ "./node_modules/@antv/x6/es/view/index.js");
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../registry */ "./node_modules/@antv/x6/es/registry/index.js");
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./view */ "./node_modules/@antv/x6/es/graph/view.js");
/* harmony import */ var _css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./css */ "./node_modules/@antv/x6/es/graph/css.js");
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./options */ "./node_modules/@antv/x6/es/graph/options.js");
/* harmony import */ var _grid__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./grid */ "./node_modules/@antv/x6/es/graph/grid.js");
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./transform */ "./node_modules/@antv/x6/es/graph/transform.js");
/* harmony import */ var _background__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./background */ "./node_modules/@antv/x6/es/graph/background.js");
/* harmony import */ var _panning__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./panning */ "./node_modules/@antv/x6/es/graph/panning.js");
/* harmony import */ var _mousewheel__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./mousewheel */ "./node_modules/@antv/x6/es/graph/mousewheel.js");
/* harmony import */ var _virtual_render__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./virtual-render */ "./node_modules/@antv/x6/es/graph/virtual-render.js");
/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../renderer */ "./node_modules/@antv/x6/es/renderer/index.js");
/* harmony import */ var _defs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./defs */ "./node_modules/@antv/x6/es/graph/defs.js");
/* harmony import */ var _coord__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./coord */ "./node_modules/@antv/x6/es/graph/coord.js");
/* harmony import */ var _highlight__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./highlight */ "./node_modules/@antv/x6/es/graph/highlight.js");
/* harmony import */ var _size__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./size */ "./node_modules/@antv/x6/es/graph/size.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};



















class Graph extends _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Basecoat {
    get container() {
        return this.options.container;
    }
    get [Symbol.toStringTag]() {
        return Graph.toStringTag;
    }
    constructor(options) {
        super();
        this.installedPlugins = new Set();
        this.options = _options__WEBPACK_IMPORTED_MODULE_7__.Options.get(options);
        this.css = new _css__WEBPACK_IMPORTED_MODULE_6__.CSSManager(this);
        this.view = new _view__WEBPACK_IMPORTED_MODULE_5__.GraphView(this);
        this.defs = new _defs__WEBPACK_IMPORTED_MODULE_15__.DefsManager(this);
        this.coord = new _coord__WEBPACK_IMPORTED_MODULE_16__.CoordManager(this);
        this.transform = new _transform__WEBPACK_IMPORTED_MODULE_9__.TransformManager(this);
        this.highlight = new _highlight__WEBPACK_IMPORTED_MODULE_17__.HighlightManager(this);
        this.grid = new _grid__WEBPACK_IMPORTED_MODULE_8__.GridManager(this);
        this.background = new _background__WEBPACK_IMPORTED_MODULE_10__.BackgroundManager(this);
        if (this.options.model) {
            this.model = this.options.model;
        }
        else {
            this.model = new _model__WEBPACK_IMPORTED_MODULE_2__.Model();
            this.model.graph = this;
        }
        this.renderer = new _renderer__WEBPACK_IMPORTED_MODULE_14__.Renderer(this);
        this.panning = new _panning__WEBPACK_IMPORTED_MODULE_11__.PanningManager(this);
        this.mousewheel = new _mousewheel__WEBPACK_IMPORTED_MODULE_12__.MouseWheel(this);
        this.virtualRender = new _virtual_render__WEBPACK_IMPORTED_MODULE_13__.VirtualRenderManager(this);
        this.size = new _size__WEBPACK_IMPORTED_MODULE_18__.SizeManager(this);
    }
    // #region model
    isNode(cell) {
        return cell.isNode();
    }
    isEdge(cell) {
        return cell.isEdge();
    }
    resetCells(cells, options = {}) {
        this.model.resetCells(cells, options);
        return this;
    }
    clearCells(options = {}) {
        this.model.clear(options);
        return this;
    }
    toJSON(options = {}) {
        return this.model.toJSON(options);
    }
    parseJSON(data) {
        return this.model.parseJSON(data);
    }
    fromJSON(data, options = {}) {
        this.model.fromJSON(data, options);
        return this;
    }
    getCellById(id) {
        return this.model.getCell(id);
    }
    addNode(node, options = {}) {
        return this.model.addNode(node, options);
    }
    addNodes(nodes, options = {}) {
        return this.addCell(nodes.map((node) => (_model__WEBPACK_IMPORTED_MODULE_2__.Node.isNode(node) ? node : this.createNode(node))), options);
    }
    createNode(metadata) {
        return this.model.createNode(metadata);
    }
    removeNode(node, options = {}) {
        return this.model.removeCell(node, options);
    }
    addEdge(edge, options = {}) {
        return this.model.addEdge(edge, options);
    }
    addEdges(edges, options = {}) {
        return this.addCell(edges.map((edge) => (_model__WEBPACK_IMPORTED_MODULE_2__.Edge.isEdge(edge) ? edge : this.createEdge(edge))), options);
    }
    removeEdge(edge, options = {}) {
        return this.model.removeCell(edge, options);
    }
    createEdge(metadata) {
        return this.model.createEdge(metadata);
    }
    addCell(cell, options = {}) {
        this.model.addCell(cell, options);
        return this;
    }
    removeCell(cell, options = {}) {
        return this.model.removeCell(cell, options);
    }
    removeCells(cells, options = {}) {
        return this.model.removeCells(cells, options);
    }
    removeConnectedEdges(cell, options = {}) {
        return this.model.removeConnectedEdges(cell, options);
    }
    disconnectConnectedEdges(cell, options = {}) {
        this.model.disconnectConnectedEdges(cell, options);
        return this;
    }
    hasCell(cell) {
        return this.model.has(cell);
    }
    getCells() {
        return this.model.getCells();
    }
    getCellCount() {
        return this.model.total();
    }
    /**
     * Returns all the nodes in the graph.
     */
    getNodes() {
        return this.model.getNodes();
    }
    /**
     * Returns all the edges in the graph.
     */
    getEdges() {
        return this.model.getEdges();
    }
    /**
     * Returns all outgoing edges for the node.
     */
    getOutgoingEdges(cell) {
        return this.model.getOutgoingEdges(cell);
    }
    /**
     * Returns all incoming edges for the node.
     */
    getIncomingEdges(cell) {
        return this.model.getIncomingEdges(cell);
    }
    /**
     * Returns edges connected with cell.
     */
    getConnectedEdges(cell, options = {}) {
        return this.model.getConnectedEdges(cell, options);
    }
    /**
     * Returns an array of all the roots of the graph.
     */
    getRootNodes() {
        return this.model.getRoots();
    }
    /**
     * Returns an array of all the leafs of the graph.
     */
    getLeafNodes() {
        return this.model.getLeafs();
    }
    /**
     * Returns `true` if the node is a root node, i.e.
     * there is no  edges coming to the node.
     */
    isRootNode(cell) {
        return this.model.isRoot(cell);
    }
    /**
     * Returns `true` if the node is a leaf node, i.e.
     * there is no edges going out from the node.
     */
    isLeafNode(cell) {
        return this.model.isLeaf(cell);
    }
    /**
     * Returns all the neighbors of node in the graph. Neighbors are all
     * the nodes connected to node via either incoming or outgoing edge.
     */
    getNeighbors(cell, options = {}) {
        return this.model.getNeighbors(cell, options);
    }
    /**
     * Returns `true` if `cell2` is a neighbor of `cell1`.
     */
    isNeighbor(cell1, cell2, options = {}) {
        return this.model.isNeighbor(cell1, cell2, options);
    }
    getSuccessors(cell, options = {}) {
        return this.model.getSuccessors(cell, options);
    }
    /**
     * Returns `true` if `cell2` is a successor of `cell1`.
     */
    isSuccessor(cell1, cell2, options = {}) {
        return this.model.isSuccessor(cell1, cell2, options);
    }
    getPredecessors(cell, options = {}) {
        return this.model.getPredecessors(cell, options);
    }
    /**
     * Returns `true` if `cell2` is a predecessor of `cell1`.
     */
    isPredecessor(cell1, cell2, options = {}) {
        return this.model.isPredecessor(cell1, cell2, options);
    }
    getCommonAncestor(...cells) {
        return this.model.getCommonAncestor(...cells);
    }
    /**
     * Returns an array of cells that result from finding nodes/edges that
     * are connected to any of the cells in the cells array. This function
     * loops over cells and if the current cell is a edge, it collects its
     * source/target nodes; if it is an node, it collects its incoming and
     * outgoing edges if both the edge terminal (source/target) are in the
     * cells array.
     */
    getSubGraph(cells, options = {}) {
        return this.model.getSubGraph(cells, options);
    }
    /**
     * Clones the whole subgraph (including all the connected links whose
     * source/target is in the subgraph). If `options.deep` is `true`, also
     * take into account all the embedded cells of all the subgraph cells.
     *
     * Returns a map of the form: { [original cell ID]: [clone] }.
     */
    cloneSubGraph(cells, options = {}) {
        return this.model.cloneSubGraph(cells, options);
    }
    cloneCells(cells) {
        return this.model.cloneCells(cells);
    }
    getNodesFromPoint(x, y) {
        return this.model.getNodesFromPoint(x, y);
    }
    getNodesInArea(x, y, w, h, options) {
        return this.model.getNodesInArea(x, y, w, h, options);
    }
    getNodesUnderNode(node, options = {}) {
        return this.model.getNodesUnderNode(node, options);
    }
    searchCell(cell, iterator, options = {}) {
        this.model.search(cell, iterator, options);
        return this;
    }
    /** *
     * Returns an array of IDs of nodes on the shortest
     * path between source and target.
     */
    getShortestPath(source, target, options = {}) {
        return this.model.getShortestPath(source, target, options);
    }
    /**
     * Returns the bounding box that surrounds all cells in the graph.
     */
    getAllCellsBBox() {
        return this.model.getAllCellsBBox();
    }
    /**
     * Returns the bounding box that surrounds all the given cells.
     */
    getCellsBBox(cells, options = {}) {
        return this.model.getCellsBBox(cells, options);
    }
    startBatch(name, data = {}) {
        this.model.startBatch(name, data);
    }
    stopBatch(name, data = {}) {
        this.model.stopBatch(name, data);
    }
    batchUpdate(arg1, arg2, arg3) {
        const name = typeof arg1 === 'string' ? arg1 : 'update';
        const execute = typeof arg1 === 'string' ? arg2 : arg1;
        const data = typeof arg2 === 'function' ? arg3 : arg2;
        this.startBatch(name, data);
        const result = execute();
        this.stopBatch(name, data);
        return result;
    }
    updateCellId(cell, newId) {
        return this.model.updateCellId(cell, newId);
    }
    // #endregion
    // #region view
    findView(ref) {
        if (_model__WEBPACK_IMPORTED_MODULE_2__.Cell.isCell(ref)) {
            return this.findViewByCell(ref);
        }
        return this.findViewByElem(ref);
    }
    findViews(ref) {
        if (_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.isRectangleLike(ref)) {
            return this.findViewsInArea(ref);
        }
        if (_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.isPointLike(ref)) {
            return this.findViewsFromPoint(ref);
        }
        return [];
    }
    findViewByCell(cell) {
        return this.renderer.findViewByCell(cell);
    }
    findViewByElem(elem) {
        return this.renderer.findViewByElem(elem);
    }
    findViewsFromPoint(x, y) {
        const p = typeof x === 'number' ? { x, y: y } : x;
        return this.renderer.findViewsFromPoint(p);
    }
    findViewsInArea(x, y, width, height, options) {
        const rect = typeof x === 'number'
            ? {
                x,
                y: y,
                width: width,
                height: height,
            }
            : x;
        const localOptions = typeof x === 'number'
            ? options
            : y;
        return this.renderer.findViewsInArea(rect, localOptions);
    }
    matrix(mat) {
        if (typeof mat === 'undefined') {
            return this.transform.getMatrix();
        }
        this.transform.setMatrix(mat);
        return this;
    }
    resize(width, height) {
        const scroller = this.getPlugin('scroller');
        if (scroller) {
            scroller.resize(width, height);
        }
        else {
            this.transform.resize(width, height);
        }
        return this;
    }
    scale(sx, sy = sx, cx = 0, cy = 0) {
        if (typeof sx === 'undefined') {
            return this.transform.getScale();
        }
        this.transform.scale(sx, sy, cx, cy);
        return this;
    }
    zoom(factor, options) {
        const scroller = this.getPlugin('scroller');
        if (scroller) {
            if (typeof factor === 'undefined') {
                return scroller.zoom();
            }
            scroller.zoom(factor, options);
        }
        else {
            if (typeof factor === 'undefined') {
                return this.transform.getZoom();
            }
            this.transform.zoom(factor, options);
        }
        return this;
    }
    zoomTo(factor, options = {}) {
        const scroller = this.getPlugin('scroller');
        if (scroller) {
            scroller.zoom(factor, Object.assign(Object.assign({}, options), { absolute: true }));
        }
        else {
            this.transform.zoom(factor, Object.assign(Object.assign({}, options), { absolute: true }));
        }
        return this;
    }
    zoomToRect(rect, options = {}) {
        const scroller = this.getPlugin('scroller');
        if (scroller) {
            scroller.zoomToRect(rect, options);
        }
        else {
            this.transform.zoomToRect(rect, options);
        }
        return this;
    }
    zoomToFit(options = {}) {
        const scroller = this.getPlugin('scroller');
        if (scroller) {
            scroller.zoomToFit(options);
        }
        else {
            this.transform.zoomToFit(options);
        }
        return this;
    }
    rotate(angle, cx, cy) {
        if (typeof angle === 'undefined') {
            return this.transform.getRotation();
        }
        this.transform.rotate(angle, cx, cy);
        return this;
    }
    translate(tx, ty) {
        if (typeof tx === 'undefined') {
            return this.transform.getTranslation();
        }
        this.transform.translate(tx, ty);
        return this;
    }
    translateBy(dx, dy) {
        const ts = this.translate();
        const tx = ts.tx + dx;
        const ty = ts.ty + dy;
        return this.translate(tx, ty);
    }
    getGraphArea() {
        return this.transform.getGraphArea();
    }
    getContentArea(options = {}) {
        return this.transform.getContentArea(options);
    }
    getContentBBox(options = {}) {
        return this.transform.getContentBBox(options);
    }
    fitToContent(gridWidth, gridHeight, padding, options) {
        return this.transform.fitToContent(gridWidth, gridHeight, padding, options);
    }
    scaleContentToFit(options = {}) {
        this.transform.scaleContentToFit(options);
        return this;
    }
    /**
     * Position the center of graph to the center of the viewport.
     */
    center(options) {
        return this.centerPoint(options);
    }
    centerPoint(x, y, options) {
        const scroller = this.getPlugin('scroller');
        if (scroller) {
            scroller.centerPoint(x, y, options);
        }
        else {
            this.transform.centerPoint(x, y);
        }
        return this;
    }
    centerContent(options) {
        const scroller = this.getPlugin('scroller');
        if (scroller) {
            scroller.centerContent(options);
        }
        else {
            this.transform.centerContent(options);
        }
        return this;
    }
    centerCell(cell, options) {
        const scroller = this.getPlugin('scroller');
        if (scroller) {
            scroller.centerCell(cell, options);
        }
        else {
            this.transform.centerCell(cell);
        }
        return this;
    }
    positionPoint(point, x, y, options = {}) {
        const scroller = this.getPlugin('scroller');
        if (scroller) {
            scroller.positionPoint(point, x, y, options);
        }
        else {
            this.transform.positionPoint(point, x, y);
        }
        return this;
    }
    positionRect(rect, direction, options) {
        const scroller = this.getPlugin('scroller');
        if (scroller) {
            scroller.positionRect(rect, direction, options);
        }
        else {
            this.transform.positionRect(rect, direction);
        }
        return this;
    }
    positionCell(cell, direction, options) {
        const scroller = this.getPlugin('scroller');
        if (scroller) {
            scroller.positionCell(cell, direction, options);
        }
        else {
            this.transform.positionCell(cell, direction);
        }
        return this;
    }
    positionContent(pos, options) {
        const scroller = this.getPlugin('scroller');
        if (scroller) {
            scroller.positionContent(pos, options);
        }
        else {
            this.transform.positionContent(pos, options);
        }
        return this;
    }
    snapToGrid(x, y) {
        return this.coord.snapToGrid(x, y);
    }
    pageToLocal(x, y, width, height) {
        if (_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.isRectangleLike(x)) {
            return this.coord.pageToLocalRect(x);
        }
        if (typeof x === 'number' &&
            typeof y === 'number' &&
            typeof width === 'number' &&
            typeof height === 'number') {
            return this.coord.pageToLocalRect(x, y, width, height);
        }
        return this.coord.pageToLocalPoint(x, y);
    }
    localToPage(x, y, width, height) {
        if (_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.isRectangleLike(x)) {
            return this.coord.localToPageRect(x);
        }
        if (typeof x === 'number' &&
            typeof y === 'number' &&
            typeof width === 'number' &&
            typeof height === 'number') {
            return this.coord.localToPageRect(x, y, width, height);
        }
        return this.coord.localToPagePoint(x, y);
    }
    clientToLocal(x, y, width, height) {
        if (_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.isRectangleLike(x)) {
            return this.coord.clientToLocalRect(x);
        }
        if (typeof x === 'number' &&
            typeof y === 'number' &&
            typeof width === 'number' &&
            typeof height === 'number') {
            return this.coord.clientToLocalRect(x, y, width, height);
        }
        return this.coord.clientToLocalPoint(x, y);
    }
    localToClient(x, y, width, height) {
        if (_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.isRectangleLike(x)) {
            return this.coord.localToClientRect(x);
        }
        if (typeof x === 'number' &&
            typeof y === 'number' &&
            typeof width === 'number' &&
            typeof height === 'number') {
            return this.coord.localToClientRect(x, y, width, height);
        }
        return this.coord.localToClientPoint(x, y);
    }
    localToGraph(x, y, width, height) {
        if (_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.isRectangleLike(x)) {
            return this.coord.localToGraphRect(x);
        }
        if (typeof x === 'number' &&
            typeof y === 'number' &&
            typeof width === 'number' &&
            typeof height === 'number') {
            return this.coord.localToGraphRect(x, y, width, height);
        }
        return this.coord.localToGraphPoint(x, y);
    }
    graphToLocal(x, y, width, height) {
        if (_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.isRectangleLike(x)) {
            return this.coord.graphToLocalRect(x);
        }
        if (typeof x === 'number' &&
            typeof y === 'number' &&
            typeof width === 'number' &&
            typeof height === 'number') {
            return this.coord.graphToLocalRect(x, y, width, height);
        }
        return this.coord.graphToLocalPoint(x, y);
    }
    clientToGraph(x, y, width, height) {
        if (_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.isRectangleLike(x)) {
            return this.coord.clientToGraphRect(x);
        }
        if (typeof x === 'number' &&
            typeof y === 'number' &&
            typeof width === 'number' &&
            typeof height === 'number') {
            return this.coord.clientToGraphRect(x, y, width, height);
        }
        return this.coord.clientToGraphPoint(x, y);
    }
    // #endregion
    // #region defs
    defineFilter(options) {
        return this.defs.filter(options);
    }
    defineGradient(options) {
        return this.defs.gradient(options);
    }
    defineMarker(options) {
        return this.defs.marker(options);
    }
    // #endregion
    // #region grid
    getGridSize() {
        return this.grid.getGridSize();
    }
    setGridSize(gridSize) {
        this.grid.setGridSize(gridSize);
        return this;
    }
    showGrid() {
        this.grid.show();
        return this;
    }
    hideGrid() {
        this.grid.hide();
        return this;
    }
    clearGrid() {
        this.grid.clear();
        return this;
    }
    drawGrid(options) {
        this.grid.draw(options);
        return this;
    }
    // #endregion
    // #region background
    updateBackground() {
        this.background.update();
        return this;
    }
    drawBackground(options, onGraph) {
        const scroller = this.getPlugin('scroller');
        if (scroller != null && (this.options.background == null || !onGraph)) {
            scroller.drawBackground(options, onGraph);
        }
        else {
            this.background.draw(options);
        }
        return this;
    }
    clearBackground(onGraph) {
        const scroller = this.getPlugin('scroller');
        if (scroller != null && (this.options.background == null || !onGraph)) {
            scroller.clearBackground(onGraph);
        }
        else {
            this.background.clear();
        }
        return this;
    }
    // #endregion
    // #region virtual-render
    enableVirtualRender() {
        this.virtualRender.enableVirtualRender();
        return this;
    }
    disableVirtualRender() {
        this.virtualRender.disableVirtualRender();
        return this;
    }
    // #endregion
    // #region mousewheel
    isMouseWheelEnabled() {
        return !this.mousewheel.disabled;
    }
    enableMouseWheel() {
        this.mousewheel.enable();
        return this;
    }
    disableMouseWheel() {
        this.mousewheel.disable();
        return this;
    }
    toggleMouseWheel(enabled) {
        if (enabled == null) {
            if (this.isMouseWheelEnabled()) {
                this.disableMouseWheel();
            }
            else {
                this.enableMouseWheel();
            }
        }
        else if (enabled) {
            this.enableMouseWheel();
        }
        else {
            this.disableMouseWheel();
        }
        return this;
    }
    // #endregion
    // #region panning
    isPannable() {
        const scroller = this.getPlugin('scroller');
        if (scroller) {
            return scroller.isPannable();
        }
        return this.panning.pannable;
    }
    enablePanning() {
        const scroller = this.getPlugin('scroller');
        if (scroller) {
            scroller.enablePanning();
        }
        else {
            this.panning.enablePanning();
        }
        return this;
    }
    disablePanning() {
        const scroller = this.getPlugin('scroller');
        if (scroller) {
            scroller.disablePanning();
        }
        else {
            this.panning.disablePanning();
        }
        return this;
    }
    togglePanning(pannable) {
        if (pannable == null) {
            if (this.isPannable()) {
                this.disablePanning();
            }
            else {
                this.enablePanning();
            }
        }
        else if (pannable !== this.isPannable()) {
            if (pannable) {
                this.enablePanning();
            }
            else {
                this.disablePanning();
            }
        }
        return this;
    }
    // #endregion
    // #region plugin
    use(plugin, ...options) {
        if (!this.installedPlugins.has(plugin)) {
            this.installedPlugins.add(plugin);
            plugin.init(this, ...options);
        }
        return this;
    }
    getPlugin(pluginName) {
        return Array.from(this.installedPlugins).find((plugin) => plugin.name === pluginName);
    }
    getPlugins(pluginName) {
        return Array.from(this.installedPlugins).filter((plugin) => pluginName.includes(plugin.name));
    }
    enablePlugins(plugins) {
        let postPlugins = plugins;
        if (!Array.isArray(postPlugins)) {
            postPlugins = [postPlugins];
        }
        const aboutToChangePlugins = this.getPlugins(postPlugins);
        aboutToChangePlugins === null || aboutToChangePlugins === void 0 ? void 0 : aboutToChangePlugins.forEach((plugin) => {
            var _a;
            (_a = plugin === null || plugin === void 0 ? void 0 : plugin.enable) === null || _a === void 0 ? void 0 : _a.call(plugin);
        });
        return this;
    }
    disablePlugins(plugins) {
        let postPlugins = plugins;
        if (!Array.isArray(postPlugins)) {
            postPlugins = [postPlugins];
        }
        const aboutToChangePlugins = this.getPlugins(postPlugins);
        aboutToChangePlugins === null || aboutToChangePlugins === void 0 ? void 0 : aboutToChangePlugins.forEach((plugin) => {
            var _a;
            (_a = plugin === null || plugin === void 0 ? void 0 : plugin.disable) === null || _a === void 0 ? void 0 : _a.call(plugin);
        });
        return this;
    }
    isPluginEnabled(pluginName) {
        var _a;
        const pluginIns = this.getPlugin(pluginName);
        return (_a = pluginIns === null || pluginIns === void 0 ? void 0 : pluginIns.isEnabled) === null || _a === void 0 ? void 0 : _a.call(pluginIns);
    }
    disposePlugins(plugins) {
        let postPlugins = plugins;
        if (!Array.isArray(postPlugins)) {
            postPlugins = [postPlugins];
        }
        const aboutToChangePlugins = this.getPlugins(postPlugins);
        aboutToChangePlugins === null || aboutToChangePlugins === void 0 ? void 0 : aboutToChangePlugins.forEach((plugin) => {
            plugin.dispose();
            this.installedPlugins.delete(plugin);
        });
        return this;
    }
    // #endregion
    // #region dispose
    dispose(clean = true) {
        if (clean) {
            this.model.dispose();
        }
        this.css.dispose();
        this.defs.dispose();
        this.grid.dispose();
        this.coord.dispose();
        this.transform.dispose();
        this.highlight.dispose();
        this.background.dispose();
        this.mousewheel.dispose();
        this.panning.dispose();
        this.view.dispose();
        this.renderer.dispose();
        this.installedPlugins.forEach((plugin) => {
            plugin.dispose();
        });
    }
}
__decorate([
    _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Basecoat.dispose()
], Graph.prototype, "dispose", null);
(function (Graph) {
    /* eslint-disable @typescript-eslint/no-unused-vars */
    Graph.View = _view__WEBPACK_IMPORTED_MODULE_5__.GraphView;
    Graph.Renderer = _renderer__WEBPACK_IMPORTED_MODULE_14__.Renderer;
    Graph.MouseWheel = _mousewheel__WEBPACK_IMPORTED_MODULE_12__.MouseWheel;
    Graph.DefsManager = _defs__WEBPACK_IMPORTED_MODULE_15__.DefsManager;
    Graph.GridManager = _grid__WEBPACK_IMPORTED_MODULE_8__.GridManager;
    Graph.CoordManager = _coord__WEBPACK_IMPORTED_MODULE_16__.CoordManager;
    Graph.TransformManager = _transform__WEBPACK_IMPORTED_MODULE_9__.TransformManager;
    Graph.HighlightManager = _highlight__WEBPACK_IMPORTED_MODULE_17__.HighlightManager;
    Graph.BackgroundManager = _background__WEBPACK_IMPORTED_MODULE_10__.BackgroundManager;
    Graph.PanningManager = _panning__WEBPACK_IMPORTED_MODULE_11__.PanningManager;
})(Graph || (Graph = {}));
(function (Graph) {
    Graph.toStringTag = `X6.${Graph.name}`;
    function isGraph(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof Graph) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        if (tag == null || tag === Graph.toStringTag) {
            return true;
        }
        return false;
    }
    Graph.isGraph = isGraph;
})(Graph || (Graph = {}));
(function (Graph) {
    function render(options, data) {
        const graph = options instanceof HTMLElement
            ? new Graph({ container: options })
            : new Graph(options);
        if (data != null) {
            graph.fromJSON(data);
        }
        return graph;
    }
    Graph.render = render;
})(Graph || (Graph = {}));
(function (Graph) {
    Graph.registerNode = _model__WEBPACK_IMPORTED_MODULE_2__.Node.registry.register;
    Graph.registerEdge = _model__WEBPACK_IMPORTED_MODULE_2__.Edge.registry.register;
    Graph.registerView = _view__WEBPACK_IMPORTED_MODULE_3__.CellView.registry.register;
    Graph.registerAttr = _registry__WEBPACK_IMPORTED_MODULE_4__.Attr.registry.register;
    Graph.registerGrid = _registry__WEBPACK_IMPORTED_MODULE_4__.Grid.registry.register;
    Graph.registerFilter = _registry__WEBPACK_IMPORTED_MODULE_4__.Filter.registry.register;
    Graph.registerNodeTool = _registry__WEBPACK_IMPORTED_MODULE_4__.NodeTool.registry.register;
    Graph.registerEdgeTool = _registry__WEBPACK_IMPORTED_MODULE_4__.EdgeTool.registry.register;
    Graph.registerBackground = _registry__WEBPACK_IMPORTED_MODULE_4__.Background.registry.register;
    Graph.registerHighlighter = _registry__WEBPACK_IMPORTED_MODULE_4__.Highlighter.registry.register;
    Graph.registerPortLayout = _registry__WEBPACK_IMPORTED_MODULE_4__.PortLayout.registry.register;
    Graph.registerPortLabelLayout = _registry__WEBPACK_IMPORTED_MODULE_4__.PortLabelLayout.registry.register;
    Graph.registerMarker = _registry__WEBPACK_IMPORTED_MODULE_4__.Marker.registry.register;
    Graph.registerRouter = _registry__WEBPACK_IMPORTED_MODULE_4__.Router.registry.register;
    Graph.registerConnector = _registry__WEBPACK_IMPORTED_MODULE_4__.Connector.registry.register;
    Graph.registerAnchor = _registry__WEBPACK_IMPORTED_MODULE_4__.NodeAnchor.registry.register;
    Graph.registerEdgeAnchor = _registry__WEBPACK_IMPORTED_MODULE_4__.EdgeAnchor.registry.register;
    Graph.registerConnectionPoint = _registry__WEBPACK_IMPORTED_MODULE_4__.ConnectionPoint.registry.register;
})(Graph || (Graph = {}));
(function (Graph) {
    Graph.unregisterNode = _model__WEBPACK_IMPORTED_MODULE_2__.Node.registry.unregister;
    Graph.unregisterEdge = _model__WEBPACK_IMPORTED_MODULE_2__.Edge.registry.unregister;
    Graph.unregisterView = _view__WEBPACK_IMPORTED_MODULE_3__.CellView.registry.unregister;
    Graph.unregisterAttr = _registry__WEBPACK_IMPORTED_MODULE_4__.Attr.registry.unregister;
    Graph.unregisterGrid = _registry__WEBPACK_IMPORTED_MODULE_4__.Grid.registry.unregister;
    Graph.unregisterFilter = _registry__WEBPACK_IMPORTED_MODULE_4__.Filter.registry.unregister;
    Graph.unregisterNodeTool = _registry__WEBPACK_IMPORTED_MODULE_4__.NodeTool.registry.unregister;
    Graph.unregisterEdgeTool = _registry__WEBPACK_IMPORTED_MODULE_4__.EdgeTool.registry.unregister;
    Graph.unregisterBackground = _registry__WEBPACK_IMPORTED_MODULE_4__.Background.registry.unregister;
    Graph.unregisterHighlighter = _registry__WEBPACK_IMPORTED_MODULE_4__.Highlighter.registry.unregister;
    Graph.unregisterPortLayout = _registry__WEBPACK_IMPORTED_MODULE_4__.PortLayout.registry.unregister;
    Graph.unregisterPortLabelLayout = _registry__WEBPACK_IMPORTED_MODULE_4__.PortLabelLayout.registry.unregister;
    Graph.unregisterMarker = _registry__WEBPACK_IMPORTED_MODULE_4__.Marker.registry.unregister;
    Graph.unregisterRouter = _registry__WEBPACK_IMPORTED_MODULE_4__.Router.registry.unregister;
    Graph.unregisterConnector = _registry__WEBPACK_IMPORTED_MODULE_4__.Connector.registry.unregister;
    Graph.unregisterAnchor = _registry__WEBPACK_IMPORTED_MODULE_4__.NodeAnchor.registry.unregister;
    Graph.unregisterEdgeAnchor = _registry__WEBPACK_IMPORTED_MODULE_4__.EdgeAnchor.registry.unregister;
    Graph.unregisterConnectionPoint = _registry__WEBPACK_IMPORTED_MODULE_4__.ConnectionPoint.registry.unregister;
})(Graph || (Graph = {}));
//# sourceMappingURL=graph.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/graph/grid.js":
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/grid.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GridManager: () => (/* binding */ GridManager)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../registry */ "./node_modules/@antv/x6/es/registry/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base */ "./node_modules/@antv/x6/es/graph/base.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};



class GridManager extends _base__WEBPACK_IMPORTED_MODULE_2__.Base {
    get elem() {
        return this.view.grid;
    }
    get grid() {
        return this.options.grid;
    }
    init() {
        this.startListening();
        this.draw(this.grid);
    }
    startListening() {
        this.graph.on('scale', this.update, this);
        this.graph.on('translate', this.update, this);
    }
    stopListening() {
        this.graph.off('scale', this.update, this);
        this.graph.off('translate', this.update, this);
    }
    setVisible(visible) {
        if (this.grid.visible !== visible) {
            this.grid.visible = visible;
            this.update();
        }
    }
    getGridSize() {
        return this.grid.size;
    }
    setGridSize(size) {
        this.grid.size = Math.max(size, 1);
        this.update();
    }
    show() {
        this.setVisible(true);
        this.update();
    }
    hide() {
        this.setVisible(false);
        this.update();
    }
    clear() {
        this.elem.style.backgroundImage = '';
    }
    draw(options) {
        this.clear();
        this.instance = null;
        Object.assign(this.grid, options);
        this.patterns = this.resolveGrid(options);
        this.update();
    }
    update(options = {}) {
        const gridSize = this.grid.size;
        if (gridSize <= 1 || !this.grid.visible) {
            return this.clear();
        }
        const ctm = this.graph.matrix();
        const grid = this.getInstance();
        const items = Array.isArray(options) ? options : [options];
        this.patterns.forEach((settings, index) => {
            const id = `pattern_${index}`;
            const sx = ctm.a || 1;
            const sy = ctm.d || 1;
            const { update, markup } = settings, others = __rest(settings, ["update", "markup"]);
            const options = Object.assign(Object.assign(Object.assign({}, others), items[index]), { sx,
                sy, ox: ctm.e || 0, oy: ctm.f || 0, width: gridSize * sx, height: gridSize * sy });
            if (!grid.has(id)) {
                grid.add(id, _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Vector.create('pattern', { id, patternUnits: 'userSpaceOnUse' }, _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Vector.createVectors(markup)).node);
            }
            const patternElem = grid.get(id);
            if (typeof update === 'function') {
                update(patternElem.childNodes[0], options);
            }
            let x = options.ox % options.width;
            if (x < 0) {
                x += options.width;
            }
            let y = options.oy % options.height;
            if (y < 0) {
                y += options.height;
            }
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.attr(patternElem, {
                x,
                y,
                width: options.width,
                height: options.height,
            });
        });
        const base64 = new XMLSerializer().serializeToString(grid.root);
        const url = `url(data:image/svg+xml;base64,${btoa(base64)})`;
        this.elem.style.backgroundImage = url;
    }
    getInstance() {
        if (!this.instance) {
            this.instance = new _registry__WEBPACK_IMPORTED_MODULE_1__.Grid();
        }
        return this.instance;
    }
    resolveGrid(options) {
        if (!options) {
            return [];
        }
        const type = options.type;
        if (type == null) {
            return [
                Object.assign(Object.assign({}, _registry__WEBPACK_IMPORTED_MODULE_1__.Grid.presets.dot), options.args),
            ];
        }
        const items = _registry__WEBPACK_IMPORTED_MODULE_1__.Grid.registry.get(type);
        if (items) {
            let args = options.args || [];
            if (!Array.isArray(args)) {
                args = [args];
            }
            return Array.isArray(items)
                ? items.map((item, index) => (Object.assign(Object.assign({}, item), args[index])))
                : [Object.assign(Object.assign({}, items), args[0])];
        }
        return _registry__WEBPACK_IMPORTED_MODULE_1__.Grid.registry.onNotFound(type);
    }
    dispose() {
        this.stopListening();
        this.clear();
    }
}
__decorate([
    _base__WEBPACK_IMPORTED_MODULE_2__.Base.dispose()
], GridManager.prototype, "dispose", null);
//# sourceMappingURL=grid.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/graph/highlight.js":
/*!*****************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/highlight.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HighlightManager: () => (/* binding */ HighlightManager)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../registry */ "./node_modules/@antv/x6/es/registry/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base */ "./node_modules/@antv/x6/es/graph/base.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};



class HighlightManager extends _base__WEBPACK_IMPORTED_MODULE_2__.Base {
    constructor() {
        super(...arguments);
        this.highlights = {};
    }
    init() {
        this.startListening();
    }
    startListening() {
        this.graph.on('cell:highlight', this.onCellHighlight, this);
        this.graph.on('cell:unhighlight', this.onCellUnhighlight, this);
    }
    stopListening() {
        this.graph.off('cell:highlight', this.onCellHighlight, this);
        this.graph.off('cell:unhighlight', this.onCellUnhighlight, this);
    }
    onCellHighlight({ view: cellView, magnet, options = {}, }) {
        const resolved = this.resolveHighlighter(options);
        if (!resolved) {
            return;
        }
        const key = this.getHighlighterId(magnet, resolved);
        if (!this.highlights[key]) {
            const highlighter = resolved.highlighter;
            highlighter.highlight(cellView, magnet, Object.assign({}, resolved.args));
            this.highlights[key] = {
                cellView,
                magnet,
                highlighter,
                args: resolved.args,
            };
        }
    }
    onCellUnhighlight({ magnet, options = {}, }) {
        const resolved = this.resolveHighlighter(options);
        if (!resolved) {
            return;
        }
        const id = this.getHighlighterId(magnet, resolved);
        this.unhighlight(id);
    }
    resolveHighlighter(options) {
        const graphOptions = this.options;
        let highlighterDef = options.highlighter;
        if (highlighterDef == null) {
            // check for built-in types
            const type = options.type;
            highlighterDef =
                (type && graphOptions.highlighting[type]) ||
                    graphOptions.highlighting.default;
        }
        if (highlighterDef == null) {
            return null;
        }
        const def = typeof highlighterDef === 'string'
            ? {
                name: highlighterDef,
            }
            : highlighterDef;
        const name = def.name;
        const highlighter = _registry__WEBPACK_IMPORTED_MODULE_1__.Highlighter.registry.get(name);
        if (highlighter == null) {
            return _registry__WEBPACK_IMPORTED_MODULE_1__.Highlighter.registry.onNotFound(name);
        }
        _registry__WEBPACK_IMPORTED_MODULE_1__.Highlighter.check(name, highlighter);
        return {
            name,
            highlighter,
            args: def.args || {},
        };
    }
    getHighlighterId(magnet, options) {
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.ensureId(magnet);
        return options.name + magnet.id + JSON.stringify(options.args);
    }
    unhighlight(id) {
        const highlight = this.highlights[id];
        if (highlight) {
            highlight.highlighter.unhighlight(highlight.cellView, highlight.magnet, highlight.args);
            delete this.highlights[id];
        }
    }
    dispose() {
        Object.keys(this.highlights).forEach((id) => this.unhighlight(id));
        this.stopListening();
    }
}
__decorate([
    HighlightManager.dispose()
], HighlightManager.prototype, "dispose", null);
//# sourceMappingURL=highlight.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/graph/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BackgroundManager: () => (/* reexport safe */ _background__WEBPACK_IMPORTED_MODULE_4__.BackgroundManager),
/* harmony export */   Graph: () => (/* reexport safe */ _graph__WEBPACK_IMPORTED_MODULE_0__.Graph),
/* harmony export */   GraphView: () => (/* reexport safe */ _view__WEBPACK_IMPORTED_MODULE_1__.GraphView),
/* harmony export */   Options: () => (/* reexport safe */ _options__WEBPACK_IMPORTED_MODULE_5__.Options),
/* harmony export */   TransformManager: () => (/* reexport safe */ _transform__WEBPACK_IMPORTED_MODULE_3__.TransformManager)
/* harmony export */ });
/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graph */ "./node_modules/@antv/x6/es/graph/graph.js");
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./view */ "./node_modules/@antv/x6/es/graph/view.js");
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events */ "./node_modules/@antv/x6/es/graph/events.js");
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./transform */ "./node_modules/@antv/x6/es/graph/transform.js");
/* harmony import */ var _background__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./background */ "./node_modules/@antv/x6/es/graph/background.js");
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./options */ "./node_modules/@antv/x6/es/graph/options.js");






//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/graph/mousewheel.js":
/*!******************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/mousewheel.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MouseWheel: () => (/* binding */ MouseWheel)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./node_modules/@antv/x6/es/graph/base.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


class MouseWheel extends _base__WEBPACK_IMPORTED_MODULE_1__.Base {
    constructor() {
        super(...arguments);
        this.cumulatedFactor = 1;
    }
    get widgetOptions() {
        return this.options.mousewheel;
    }
    init() {
        this.container = this.graph.container;
        this.target = this.widgetOptions.global ? document : this.container;
        this.mousewheelHandle = new _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.MouseWheelHandle(this.target, this.onMouseWheel.bind(this), this.allowMouseWheel.bind(this));
        if (this.widgetOptions.enabled) {
            this.enable(true);
        }
    }
    get disabled() {
        return this.widgetOptions.enabled !== true;
    }
    enable(force) {
        if (this.disabled || force) {
            this.widgetOptions.enabled = true;
            this.mousewheelHandle.enable();
        }
    }
    disable() {
        if (!this.disabled) {
            this.widgetOptions.enabled = false;
            this.mousewheelHandle.disable();
        }
    }
    allowMouseWheel(e) {
        const guard = this.widgetOptions.guard;
        return ((guard == null || guard(e)) &&
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ModifierKey.isMatch(e, this.widgetOptions.modifiers));
    }
    onMouseWheel(e) {
        const guard = this.widgetOptions.guard;
        if ((guard == null || guard(e)) &&
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ModifierKey.isMatch(e, this.widgetOptions.modifiers)) {
            const factor = this.widgetOptions.factor || 1.2;
            if (this.currentScale == null) {
                this.startPos = { x: e.clientX, y: e.clientY };
                this.currentScale = this.graph.transform.getScale().sx;
            }
            const delta = e.deltaY;
            if (delta < 0) {
                // zoomin
                // ------
                // Switches to 1% zoom steps below 15%
                if (this.currentScale < 0.15) {
                    this.cumulatedFactor = (this.currentScale + 0.01) / this.currentScale;
                }
                else {
                    // Uses to 5% zoom steps for better grid rendering in
                    // webkit and to avoid rounding errors for zoom steps
                    this.cumulatedFactor =
                        Math.round(this.currentScale * factor * 20) / 20 / this.currentScale;
                    if (this.cumulatedFactor === 1) {
                        this.cumulatedFactor = 1.05;
                    }
                }
            }
            else {
                // zoomout
                // -------
                // Switches to 1% zoom steps below 15%
                if (this.currentScale <= 0.15) {
                    this.cumulatedFactor = (this.currentScale - 0.01) / this.currentScale;
                }
                else {
                    // Uses to 5% zoom steps for better grid rendering in
                    // webkit and to avoid rounding errors for zoom steps
                    this.cumulatedFactor =
                        Math.round(this.currentScale * (1 / factor) * 20) /
                            20 /
                            this.currentScale;
                    if (this.cumulatedFactor === 1) {
                        this.cumulatedFactor = 0.95;
                    }
                }
            }
            this.cumulatedFactor = Math.max(0.01, Math.min(this.currentScale * this.cumulatedFactor, 160) /
                this.currentScale);
            const currentScale = this.currentScale;
            let targetScale = this.graph.transform.clampScale(currentScale * this.cumulatedFactor);
            const minScale = this.widgetOptions.minScale || Number.MIN_SAFE_INTEGER;
            const maxScale = this.widgetOptions.maxScale || Number.MAX_SAFE_INTEGER;
            targetScale = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.NumberExt.clamp(targetScale, minScale, maxScale);
            if (targetScale !== currentScale) {
                if (this.widgetOptions.zoomAtMousePosition) {
                    const hasScroller = !!this.graph.getPlugin('scroller');
                    const origin = hasScroller
                        ? this.graph.clientToLocal(this.startPos)
                        : this.graph.clientToGraph(this.startPos);
                    this.graph.zoom(targetScale, {
                        absolute: true,
                        center: origin.clone(),
                    });
                }
                else {
                    this.graph.zoom(targetScale, { absolute: true });
                }
            }
            this.currentScale = null;
            this.cumulatedFactor = 1;
        }
    }
    dispose() {
        this.disable();
    }
}
__decorate([
    _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Disposable.dispose()
], MouseWheel.prototype, "dispose", null);
//# sourceMappingURL=mousewheel.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/graph/options.js":
/*!***************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/options.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Options: () => (/* binding */ Options)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config */ "./node_modules/@antv/x6/es/config/index.js");
/* harmony import */ var _shape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shape */ "./node_modules/@antv/x6/es/shape/index.js");
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};



var Options;
(function (Options) {
    function get(options) {
        const { grid, panning, mousewheel, embedding } = options, others = __rest(options
        // size
        // ----
        , ["grid", "panning", "mousewheel", "embedding"]);
        // size
        // ----
        const container = options.container;
        if (container != null) {
            if (others.width == null) {
                others.width = container.clientWidth;
            }
            if (others.height == null) {
                others.height = container.clientHeight;
            }
        }
        else {
            throw new Error(`Ensure the container of the graph is specified and valid`);
        }
        const result = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.merge({}, Options.defaults, others);
        // grid
        // ----
        const defaultGrid = { size: 10, visible: false };
        if (typeof grid === 'number') {
            result.grid = { size: grid, visible: false };
        }
        else if (typeof grid === 'boolean') {
            result.grid = Object.assign(Object.assign({}, defaultGrid), { visible: grid });
        }
        else {
            result.grid = Object.assign(Object.assign({}, defaultGrid), grid);
        }
        // booleas
        // -------
        const booleas = [
            'panning',
            'mousewheel',
            'embedding',
        ];
        booleas.forEach((key) => {
            const val = options[key];
            if (typeof val === 'boolean') {
                result[key].enabled = val;
            }
            else {
                result[key] = Object.assign(Object.assign({}, result[key]), val);
            }
        });
        return result;
    }
    Options.get = get;
})(Options || (Options = {}));
(function (Options) {
    Options.defaults = {
        x: 0,
        y: 0,
        scaling: {
            min: 0.01,
            max: 16,
        },
        grid: {
            size: 10,
            visible: false,
        },
        background: false,
        panning: {
            enabled: false,
            eventTypes: ['leftMouseDown'],
        },
        mousewheel: {
            enabled: false,
            factor: 1.2,
            zoomAtMousePosition: true,
        },
        highlighting: {
            default: {
                name: 'stroke',
                args: {
                    padding: 3,
                },
            },
            nodeAvailable: {
                name: 'className',
                args: {
                    className: _config__WEBPACK_IMPORTED_MODULE_1__.Config.prefix('available-node'),
                },
            },
            magnetAvailable: {
                name: 'className',
                args: {
                    className: _config__WEBPACK_IMPORTED_MODULE_1__.Config.prefix('available-magnet'),
                },
            },
        },
        connecting: {
            snap: false,
            allowLoop: true,
            allowNode: true,
            allowEdge: false,
            allowPort: true,
            allowBlank: true,
            allowMulti: true,
            highlight: false,
            anchor: 'center',
            edgeAnchor: 'ratio',
            connectionPoint: 'boundary',
            router: 'normal',
            connector: 'normal',
            validateConnection({ type, sourceView, targetView }) {
                const view = type === 'target' ? targetView : sourceView;
                return view != null;
            },
            createEdge() {
                return new _shape__WEBPACK_IMPORTED_MODULE_2__.Edge();
            },
        },
        translating: {
            restrict: false,
        },
        embedding: {
            enabled: false,
            findParent: 'bbox',
            frontOnly: true,
            validate: () => true,
        },
        moveThreshold: 0,
        clickThreshold: 0,
        magnetThreshold: 0,
        preventDefaultDblClick: true,
        preventDefaultMouseDown: false,
        preventDefaultContextMenu: true,
        preventDefaultBlankAction: true,
        interacting: {
            edgeLabelMovable: false,
        },
        async: true,
        virtual: false,
        guard: () => false,
    };
})(Options || (Options = {}));
//# sourceMappingURL=options.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/graph/panning.js":
/*!***************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/panning.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PanningManager: () => (/* binding */ PanningManager)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./node_modules/@antv/x6/es/graph/base.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


class PanningManager extends _base__WEBPACK_IMPORTED_MODULE_1__.Base {
    get widgetOptions() {
        return this.options.panning;
    }
    get pannable() {
        return this.widgetOptions && this.widgetOptions.enabled === true;
    }
    init() {
        this.onRightMouseDown = this.onRightMouseDown.bind(this);
        this.onSpaceKeyDown = this.onSpaceKeyDown.bind(this);
        this.onSpaceKeyUp = this.onSpaceKeyUp.bind(this);
        this.startListening();
        this.updateClassName();
    }
    startListening() {
        this.graph.on('blank:mousedown', this.onMouseDown, this);
        this.graph.on('node:unhandled:mousedown', this.onMouseDown, this);
        this.graph.on('edge:unhandled:mousedown', this.onMouseDown, this);
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.Event.on(this.graph.container, 'mousedown', this.onRightMouseDown);
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.Event.on(document.body, {
            keydown: this.onSpaceKeyDown,
            keyup: this.onSpaceKeyUp,
        });
        this.mousewheelHandle = new _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.MouseWheelHandle(this.graph.container, this.onMouseWheel.bind(this), this.allowMouseWheel.bind(this));
        this.mousewheelHandle.enable();
    }
    stopListening() {
        this.graph.off('blank:mousedown', this.onMouseDown, this);
        this.graph.off('node:unhandled:mousedown', this.onMouseDown, this);
        this.graph.off('edge:unhandled:mousedown', this.onMouseDown, this);
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.Event.off(this.graph.container, 'mousedown', this.onRightMouseDown);
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.Event.off(document.body, {
            keydown: this.onSpaceKeyDown,
            keyup: this.onSpaceKeyUp,
        });
        if (this.mousewheelHandle) {
            this.mousewheelHandle.disable();
        }
    }
    allowPanning(e, strict) {
        ;
        e.spaceKey = this.isSpaceKeyPressed;
        return (this.pannable &&
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ModifierKey.isMatch(e, this.widgetOptions.modifiers, strict));
    }
    startPanning(evt) {
        const e = this.view.normalizeEvent(evt);
        this.clientX = e.clientX;
        this.clientY = e.clientY;
        this.panning = true;
        this.updateClassName();
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.Event.on(document.body, {
            'mousemove.panning touchmove.panning': this.pan.bind(this),
            'mouseup.panning touchend.panning': this.stopPanning.bind(this),
            'mouseleave.panning': this.stopPanning.bind(this),
        });
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.Event.on(window, 'mouseup.panning', this.stopPanning.bind(this));
    }
    pan(evt) {
        const e = this.view.normalizeEvent(evt);
        const dx = e.clientX - this.clientX;
        const dy = e.clientY - this.clientY;
        this.clientX = e.clientX;
        this.clientY = e.clientY;
        this.graph.translateBy(dx, dy);
    }
    // eslint-disable-next-line
    stopPanning(e) {
        this.panning = false;
        this.updateClassName();
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.Event.off(document.body, '.panning');
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.Event.off(window, '.panning');
    }
    updateClassName() {
        const container = this.view.container;
        const panning = this.view.prefixClassName('graph-panning');
        const pannable = this.view.prefixClassName('graph-pannable');
        if (this.pannable) {
            if (this.panning) {
                _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(container, panning);
                _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.removeClass(container, pannable);
            }
            else {
                _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.removeClass(container, panning);
                _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(container, pannable);
            }
        }
        else {
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.removeClass(container, panning);
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.removeClass(container, pannable);
        }
    }
    onMouseDown({ e }) {
        if (!this.allowBlankMouseDown(e)) {
            return;
        }
        const selection = this.graph.getPlugin('selection');
        const allowRubberband = selection && selection.allowRubberband(e, true);
        if (this.allowPanning(e, true) ||
            (this.allowPanning(e) && !allowRubberband)) {
            this.startPanning(e);
        }
    }
    onRightMouseDown(e) {
        const eventTypes = this.widgetOptions.eventTypes;
        if (!((eventTypes === null || eventTypes === void 0 ? void 0 : eventTypes.includes('rightMouseDown')) && e.button === 2)) {
            return;
        }
        if (this.allowPanning(e, true)) {
            this.startPanning(e);
        }
    }
    onMouseWheel(e, deltaX, deltaY) {
        this.graph.translateBy(-deltaX, -deltaY);
    }
    onSpaceKeyDown(e) {
        if (e.which === 32) {
            this.isSpaceKeyPressed = true;
        }
    }
    onSpaceKeyUp(e) {
        if (e.which === 32) {
            this.isSpaceKeyPressed = false;
        }
    }
    allowBlankMouseDown(e) {
        const eventTypes = this.widgetOptions.eventTypes;
        return (((eventTypes === null || eventTypes === void 0 ? void 0 : eventTypes.includes('leftMouseDown')) && e.button === 0) ||
            ((eventTypes === null || eventTypes === void 0 ? void 0 : eventTypes.includes('mouseWheelDown')) && e.button === 1));
    }
    allowMouseWheel(e) {
        var _a;
        return (this.pannable &&
            !e.ctrlKey &&
            ((_a = this.widgetOptions.eventTypes) === null || _a === void 0 ? void 0 : _a.includes('mouseWheel')));
    }
    autoPanning(x, y) {
        const buffer = 10;
        const graphArea = this.graph.getGraphArea();
        let dx = 0;
        let dy = 0;
        if (x <= graphArea.left + buffer) {
            dx = -buffer;
        }
        if (y <= graphArea.top + buffer) {
            dy = -buffer;
        }
        if (x >= graphArea.right - buffer) {
            dx = buffer;
        }
        if (y >= graphArea.bottom - buffer) {
            dy = buffer;
        }
        if (dx !== 0 || dy !== 0) {
            this.graph.translateBy(-dx, -dy);
        }
    }
    enablePanning() {
        if (!this.pannable) {
            this.widgetOptions.enabled = true;
            this.updateClassName();
        }
    }
    disablePanning() {
        if (this.pannable) {
            this.widgetOptions.enabled = false;
            this.updateClassName();
        }
    }
    dispose() {
        this.stopListening();
    }
}
__decorate([
    _base__WEBPACK_IMPORTED_MODULE_1__.Base.dispose()
], PanningManager.prototype, "dispose", null);
//# sourceMappingURL=panning.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/graph/size.js":
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/size.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SizeManager: () => (/* binding */ SizeManager)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./node_modules/@antv/x6/es/graph/base.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


class SizeManager extends _base__WEBPACK_IMPORTED_MODULE_1__.Base {
    getScroller() {
        const scroller = this.graph.getPlugin('scroller');
        if (scroller && scroller.options.enabled) {
            return scroller;
        }
        return null;
    }
    getContainer() {
        const scroller = this.getScroller();
        if (scroller) {
            return scroller.container.parentElement;
        }
        return this.graph.container.parentElement;
    }
    getSensorTarget() {
        const autoResize = this.options.autoResize;
        if (autoResize) {
            if (typeof autoResize === 'boolean') {
                return this.getContainer();
            }
            return autoResize;
        }
    }
    init() {
        const autoResize = this.options.autoResize;
        if (autoResize) {
            const target = this.getSensorTarget();
            if (target) {
                _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.SizeSensor.bind(target, () => {
                    const width = target.offsetWidth;
                    const height = target.offsetHeight;
                    this.resize(width, height);
                });
            }
        }
    }
    resize(width, height) {
        const scroller = this.getScroller();
        if (scroller) {
            scroller.resize(width, height);
        }
        else {
            this.graph.transform.resize(width, height);
        }
    }
    dispose() {
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.SizeSensor.clear(this.graph.container);
    }
}
__decorate([
    _base__WEBPACK_IMPORTED_MODULE_1__.Base.dispose()
], SizeManager.prototype, "dispose", null);
//# sourceMappingURL=size.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/graph/transform.js":
/*!*****************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/transform.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TransformManager: () => (/* binding */ TransformManager)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base */ "./node_modules/@antv/x6/es/graph/base.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/x6/es/util/index.js");




class TransformManager extends _base__WEBPACK_IMPORTED_MODULE_2__.Base {
    get container() {
        return this.graph.view.container;
    }
    get viewport() {
        return this.graph.view.viewport;
    }
    get stage() {
        return this.graph.view.stage;
    }
    init() {
        this.resize();
    }
    /**
     * Returns the current transformation matrix of the graph.
     */
    getMatrix() {
        const transform = this.viewport.getAttribute('transform');
        if (transform !== this.viewportTransformString) {
            // `getCTM`: top-left relative to the SVG element
            // `getScreenCTM`: top-left relative to the document
            this.viewportMatrix = this.viewport.getCTM();
            this.viewportTransformString = transform;
        }
        // Clone the cached current transformation matrix.
        // If no matrix previously stored the identity matrix is returned.
        return _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.createSVGMatrix(this.viewportMatrix);
    }
    /**
     * Sets new transformation with the given `matrix`
     */
    setMatrix(matrix) {
        const ctm = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.createSVGMatrix(matrix);
        const transform = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.matrixToTransformString(ctm);
        this.viewport.setAttribute('transform', transform);
        this.viewportMatrix = ctm;
        this.viewportTransformString = transform;
    }
    resize(width, height) {
        let w = width === undefined ? this.options.width : width;
        let h = height === undefined ? this.options.height : height;
        this.options.width = w;
        this.options.height = h;
        if (typeof w === 'number') {
            w = Math.round(w);
        }
        if (typeof h === 'number') {
            h = Math.round(h);
        }
        this.container.style.width = w == null ? '' : `${w}px`;
        this.container.style.height = h == null ? '' : `${h}px`;
        const size = this.getComputedSize();
        this.graph.trigger('resize', Object.assign({}, size));
        return this;
    }
    getComputedSize() {
        let w = this.options.width;
        let h = this.options.height;
        if (!_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.NumberExt.isNumber(w)) {
            w = this.container.clientWidth;
        }
        if (!_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.NumberExt.isNumber(h)) {
            h = this.container.clientHeight;
        }
        return { width: w, height: h };
    }
    getScale() {
        return _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.matrixToScale(this.getMatrix());
    }
    scale(sx, sy = sx, ox = 0, oy = 0) {
        sx = this.clampScale(sx); // eslint-disable-line
        sy = this.clampScale(sy); // eslint-disable-line
        if (ox || oy) {
            const ts = this.getTranslation();
            const tx = ts.tx - ox * (sx - 1);
            const ty = ts.ty - oy * (sy - 1);
            if (tx !== ts.tx || ty !== ts.ty) {
                this.translate(tx, ty);
            }
        }
        const matrix = this.getMatrix();
        matrix.a = sx;
        matrix.d = sy;
        this.setMatrix(matrix);
        this.graph.trigger('scale', { sx, sy, ox, oy });
        return this;
    }
    clampScale(scale) {
        const range = this.graph.options.scaling;
        return _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.NumberExt.clamp(scale, range.min || 0.01, range.max || 16);
    }
    getZoom() {
        return this.getScale().sx;
    }
    zoom(factor, options) {
        options = options || {}; // eslint-disable-line
        let sx = factor;
        let sy = factor;
        const scale = this.getScale();
        const clientSize = this.getComputedSize();
        let cx = clientSize.width / 2;
        let cy = clientSize.height / 2;
        if (!options.absolute) {
            sx += scale.sx;
            sy += scale.sy;
        }
        if (options.scaleGrid) {
            sx = Math.round(sx / options.scaleGrid) * options.scaleGrid;
            sy = Math.round(sy / options.scaleGrid) * options.scaleGrid;
        }
        if (options.maxScale) {
            sx = Math.min(options.maxScale, sx);
            sy = Math.min(options.maxScale, sy);
        }
        if (options.minScale) {
            sx = Math.max(options.minScale, sx);
            sy = Math.max(options.minScale, sy);
        }
        if (options.center) {
            cx = options.center.x;
            cy = options.center.y;
        }
        sx = this.clampScale(sx);
        sy = this.clampScale(sy);
        if (cx || cy) {
            const ts = this.getTranslation();
            const tx = cx - (cx - ts.tx) * (sx / scale.sx);
            const ty = cy - (cy - ts.ty) * (sy / scale.sy);
            if (tx !== ts.tx || ty !== ts.ty) {
                this.translate(tx, ty);
            }
        }
        this.scale(sx, sy);
        return this;
    }
    getRotation() {
        return _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.matrixToRotation(this.getMatrix());
    }
    rotate(angle, cx, cy) {
        if (cx == null || cy == null) {
            const bbox = _util__WEBPACK_IMPORTED_MODULE_3__.Util.getBBox(this.stage);
            cx = bbox.width / 2; // eslint-disable-line
            cy = bbox.height / 2; // eslint-disable-line
        }
        const ctm = this.getMatrix()
            .translate(cx, cy)
            .rotate(angle)
            .translate(-cx, -cy);
        this.setMatrix(ctm);
        return this;
    }
    getTranslation() {
        return _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.matrixToTranslation(this.getMatrix());
    }
    translate(tx, ty) {
        const matrix = this.getMatrix();
        matrix.e = tx || 0;
        matrix.f = ty || 0;
        this.setMatrix(matrix);
        const ts = this.getTranslation();
        this.options.x = ts.tx;
        this.options.y = ts.ty;
        this.graph.trigger('translate', Object.assign({}, ts));
        return this;
    }
    setOrigin(ox, oy) {
        return this.translate(ox || 0, oy || 0);
    }
    fitToContent(gridWidth, gridHeight, padding, options) {
        if (typeof gridWidth === 'object') {
            const opts = gridWidth;
            gridWidth = opts.gridWidth || 1; // eslint-disable-line
            gridHeight = opts.gridHeight || 1; // eslint-disable-line
            padding = opts.padding || 0; // eslint-disable-line
            options = opts; // eslint-disable-line
        }
        else {
            gridWidth = gridWidth || 1; // eslint-disable-line
            gridHeight = gridHeight || 1; // eslint-disable-line
            padding = padding || 0; // eslint-disable-line
            if (options == null) {
                options = {}; // eslint-disable-line
            }
        }
        const paddings = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.NumberExt.normalizeSides(padding);
        const border = options.border || 0;
        const contentArea = options.contentArea
            ? _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.create(options.contentArea)
            : this.getContentArea(options);
        if (border > 0) {
            contentArea.inflate(border);
        }
        const scale = this.getScale();
        const translate = this.getTranslation();
        const sx = scale.sx;
        const sy = scale.sy;
        contentArea.x *= sx;
        contentArea.y *= sy;
        contentArea.width *= sx;
        contentArea.height *= sy;
        let width = Math.max(Math.ceil((contentArea.width + contentArea.x) / gridWidth), 1) *
            gridWidth;
        let height = Math.max(Math.ceil((contentArea.height + contentArea.y) / gridHeight), 1) * gridHeight;
        let tx = 0;
        let ty = 0;
        if ((options.allowNewOrigin === 'negative' && contentArea.x < 0) ||
            (options.allowNewOrigin === 'positive' && contentArea.x >= 0) ||
            options.allowNewOrigin === 'any') {
            tx = Math.ceil(-contentArea.x / gridWidth) * gridWidth;
            tx += paddings.left;
            width += tx;
        }
        if ((options.allowNewOrigin === 'negative' && contentArea.y < 0) ||
            (options.allowNewOrigin === 'positive' && contentArea.y >= 0) ||
            options.allowNewOrigin === 'any') {
            ty = Math.ceil(-contentArea.y / gridHeight) * gridHeight;
            ty += paddings.top;
            height += ty;
        }
        width += paddings.right;
        height += paddings.bottom;
        // Make sure the resulting width and height are greater than minimum.
        width = Math.max(width, options.minWidth || 0);
        height = Math.max(height, options.minHeight || 0);
        // Make sure the resulting width and height are lesser than maximum.
        width = Math.min(width, options.maxWidth || Number.MAX_SAFE_INTEGER);
        height = Math.min(height, options.maxHeight || Number.MAX_SAFE_INTEGER);
        const size = this.getComputedSize();
        const sizeChanged = width !== size.width || height !== size.height;
        const originChanged = tx !== translate.tx || ty !== translate.ty;
        // Change the dimensions only if there is a size discrepency or an origin change
        if (originChanged) {
            this.translate(tx, ty);
        }
        if (sizeChanged) {
            this.resize(width, height);
        }
        return new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle(-tx / sx, -ty / sy, width / sx, height / sy);
    }
    scaleContentToFit(options = {}) {
        this.scaleContentToFitImpl(options);
    }
    scaleContentToFitImpl(options = {}, translate = true) {
        let contentBBox;
        let contentLocalOrigin;
        if (options.contentArea) {
            const contentArea = options.contentArea;
            contentBBox = this.graph.localToGraph(contentArea);
            contentLocalOrigin = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(contentArea);
        }
        else {
            contentBBox = this.getContentBBox(options);
            contentLocalOrigin = this.graph.graphToLocal(contentBBox);
        }
        if (!contentBBox.width || !contentBBox.height) {
            return;
        }
        const padding = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.NumberExt.normalizeSides(options.padding);
        const minScale = options.minScale || 0;
        const maxScale = options.maxScale || Number.MAX_SAFE_INTEGER;
        const minScaleX = options.minScaleX || minScale;
        const maxScaleX = options.maxScaleX || maxScale;
        const minScaleY = options.minScaleY || minScale;
        const maxScaleY = options.maxScaleY || maxScale;
        let fittingBox;
        if (options.viewportArea) {
            fittingBox = options.viewportArea;
        }
        else {
            const computedSize = this.getComputedSize();
            const currentTranslate = this.getTranslation();
            fittingBox = {
                x: currentTranslate.tx,
                y: currentTranslate.ty,
                width: computedSize.width,
                height: computedSize.height,
            };
        }
        fittingBox = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.create(fittingBox).moveAndExpand({
            x: padding.left,
            y: padding.top,
            width: -padding.left - padding.right,
            height: -padding.top - padding.bottom,
        });
        const currentScale = this.getScale();
        let newSX = (fittingBox.width / contentBBox.width) * currentScale.sx;
        let newSY = (fittingBox.height / contentBBox.height) * currentScale.sy;
        if (options.preserveAspectRatio !== false) {
            newSX = newSY = Math.min(newSX, newSY);
        }
        // snap scale to a grid
        const gridSize = options.scaleGrid;
        if (gridSize) {
            newSX = gridSize * Math.floor(newSX / gridSize);
            newSY = gridSize * Math.floor(newSY / gridSize);
        }
        // scale min/max boundaries
        newSX = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.NumberExt.clamp(newSX, minScaleX, maxScaleX);
        newSY = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.NumberExt.clamp(newSY, minScaleY, maxScaleY);
        this.scale(newSX, newSY);
        if (translate) {
            const origin = this.options;
            const newOX = fittingBox.x - contentLocalOrigin.x * newSX - origin.x;
            const newOY = fittingBox.y - contentLocalOrigin.y * newSY - origin.y;
            this.translate(newOX, newOY);
        }
    }
    getContentArea(options = {}) {
        // use geometry calc default
        if (options.useCellGeometry !== false) {
            return this.model.getAllCellsBBox() || new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle();
        }
        return _util__WEBPACK_IMPORTED_MODULE_3__.Util.getBBox(this.stage);
    }
    getContentBBox(options = {}) {
        return this.graph.localToGraph(this.getContentArea(options));
    }
    getGraphArea() {
        const rect = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.fromSize(this.getComputedSize());
        return this.graph.graphToLocal(rect);
    }
    zoomToRect(rect, options = {}) {
        const area = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.create(rect);
        const graph = this.graph;
        options.contentArea = area;
        if (options.viewportArea == null) {
            options.viewportArea = {
                x: graph.options.x,
                y: graph.options.y,
                width: this.options.width,
                height: this.options.height,
            };
        }
        this.scaleContentToFitImpl(options, false);
        const center = area.getCenter();
        this.centerPoint(center.x, center.y);
        return this;
    }
    zoomToFit(options = {}) {
        return this.zoomToRect(this.getContentArea(options), options);
    }
    centerPoint(x, y) {
        const clientSize = this.getComputedSize();
        const scale = this.getScale();
        const ts = this.getTranslation();
        const cx = clientSize.width / 2;
        const cy = clientSize.height / 2;
        x = typeof x === 'number' ? x : cx; // eslint-disable-line
        y = typeof y === 'number' ? y : cy; // eslint-disable-line
        x = cx - x * scale.sx; // eslint-disable-line
        y = cy - y * scale.sy; // eslint-disable-line
        if (ts.tx !== x || ts.ty !== y) {
            this.translate(x, y);
        }
    }
    centerContent(options) {
        const rect = this.graph.getContentArea(options);
        const center = rect.getCenter();
        this.centerPoint(center.x, center.y);
    }
    centerCell(cell) {
        return this.positionCell(cell, 'center');
    }
    positionPoint(point, x, y) {
        const clientSize = this.getComputedSize();
        // eslint-disable-next-line
        x = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.NumberExt.normalizePercentage(x, Math.max(0, clientSize.width));
        if (x < 0) {
            x = clientSize.width + x; // eslint-disable-line
        }
        // eslint-disable-next-line
        y = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.NumberExt.normalizePercentage(y, Math.max(0, clientSize.height));
        if (y < 0) {
            y = clientSize.height + y; // eslint-disable-line
        }
        const ts = this.getTranslation();
        const scale = this.getScale();
        const dx = x - point.x * scale.sx;
        const dy = y - point.y * scale.sy;
        if (ts.tx !== dx || ts.ty !== dy) {
            this.translate(dx, dy);
        }
    }
    positionRect(rect, pos) {
        const bbox = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.create(rect);
        switch (pos) {
            case 'center':
                return this.positionPoint(bbox.getCenter(), '50%', '50%');
            case 'top':
                return this.positionPoint(bbox.getTopCenter(), '50%', 0);
            case 'top-right':
                return this.positionPoint(bbox.getTopRight(), '100%', 0);
            case 'right':
                return this.positionPoint(bbox.getRightMiddle(), '100%', '50%');
            case 'bottom-right':
                return this.positionPoint(bbox.getBottomRight(), '100%', '100%');
            case 'bottom':
                return this.positionPoint(bbox.getBottomCenter(), '50%', '100%');
            case 'bottom-left':
                return this.positionPoint(bbox.getBottomLeft(), 0, '100%');
            case 'left':
                return this.positionPoint(bbox.getLeftMiddle(), 0, '50%');
            case 'top-left':
                return this.positionPoint(bbox.getTopLeft(), 0, 0);
            default:
                return this;
        }
    }
    positionCell(cell, pos) {
        const bbox = cell.getBBox();
        return this.positionRect(bbox, pos);
    }
    positionContent(pos, options) {
        const rect = this.graph.getContentArea(options);
        return this.positionRect(rect, pos);
    }
}
//# sourceMappingURL=transform.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/graph/view.js":
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/view.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GraphView: () => (/* binding */ GraphView)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model */ "./node_modules/@antv/x6/es/model/index.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../config */ "./node_modules/@antv/x6/es/config/index.js");
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../view */ "./node_modules/@antv/x6/es/view/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};




class GraphView extends _view__WEBPACK_IMPORTED_MODULE_3__.View {
    /** Graph's `this.container` is from outer, should not dispose */
    get disposeContainer() {
        return false;
    }
    get options() {
        return this.graph.options;
    }
    constructor(graph) {
        super();
        this.graph = graph;
        const { selectors, fragment } = _view__WEBPACK_IMPORTED_MODULE_3__.Markup.parseJSONMarkup(GraphView.markup);
        this.background = selectors.background;
        this.grid = selectors.grid;
        this.svg = selectors.svg;
        this.defs = selectors.defs;
        this.viewport = selectors.viewport;
        this.primer = selectors.primer;
        this.stage = selectors.stage;
        this.decorator = selectors.decorator;
        this.overlay = selectors.overlay;
        this.container = this.options.container;
        this.restore = GraphView.snapshoot(this.container);
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.container, this.prefixClassName('graph'));
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.append(this.container, fragment);
        this.delegateEvents();
    }
    delegateEvents() {
        const ctor = this.constructor;
        super.delegateEvents(ctor.events);
        return this;
    }
    /**
     * Guard the specified event. If the event is not interesting, it
     * returns `true`, otherwise returns `false`.
     */
    guard(e, view) {
        // handled as `contextmenu` type
        if (e.type === 'mousedown' && e.button === 2) {
            return true;
        }
        if (this.options.guard && this.options.guard(e, view)) {
            return true;
        }
        if (e.data && e.data.guarded !== undefined) {
            return e.data.guarded;
        }
        if (view && view.cell && _model__WEBPACK_IMPORTED_MODULE_1__.Cell.isCell(view.cell)) {
            return false;
        }
        if (this.svg === e.target ||
            this.container === e.target ||
            this.svg.contains(e.target)) {
            return false;
        }
        return true;
    }
    findView(elem) {
        return this.graph.findViewByElem(elem);
    }
    onDblClick(evt) {
        if (this.options.preventDefaultDblClick) {
            evt.preventDefault();
        }
        const e = this.normalizeEvent(evt);
        const view = this.findView(e.target);
        if (this.guard(e, view)) {
            return;
        }
        const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
        if (view) {
            view.onDblClick(e, localPoint.x, localPoint.y);
        }
        else {
            this.graph.trigger('blank:dblclick', {
                e,
                x: localPoint.x,
                y: localPoint.y,
            });
        }
    }
    onClick(evt) {
        if (this.getMouseMovedCount(evt) <= this.options.clickThreshold) {
            const e = this.normalizeEvent(evt);
            const view = this.findView(e.target);
            if (this.guard(e, view)) {
                return;
            }
            const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
            if (view) {
                view.onClick(e, localPoint.x, localPoint.y);
            }
            else {
                this.graph.trigger('blank:click', {
                    e,
                    x: localPoint.x,
                    y: localPoint.y,
                });
            }
        }
    }
    isPreventDefaultContextMenu(view) {
        let preventDefaultContextMenu = this.options.preventDefaultContextMenu;
        if (typeof preventDefaultContextMenu === 'function') {
            preventDefaultContextMenu = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(preventDefaultContextMenu, this.graph, { view });
        }
        return preventDefaultContextMenu;
    }
    onContextMenu(evt) {
        const e = this.normalizeEvent(evt);
        const view = this.findView(e.target);
        if (this.isPreventDefaultContextMenu(view)) {
            evt.preventDefault();
        }
        if (this.guard(e, view)) {
            return;
        }
        const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
        if (view) {
            view.onContextMenu(e, localPoint.x, localPoint.y);
        }
        else {
            this.graph.trigger('blank:contextmenu', {
                e,
                x: localPoint.x,
                y: localPoint.y,
            });
        }
    }
    delegateDragEvents(e, view) {
        if (e.data == null) {
            e.data = {};
        }
        this.setEventData(e, {
            currentView: view || null,
            mouseMovedCount: 0,
            startPosition: {
                x: e.clientX,
                y: e.clientY,
            },
        });
        const ctor = this.constructor;
        this.delegateDocumentEvents(ctor.documentEvents, e.data);
        this.undelegateEvents();
    }
    getMouseMovedCount(e) {
        const data = this.getEventData(e);
        return data.mouseMovedCount || 0;
    }
    onMouseDown(evt) {
        const e = this.normalizeEvent(evt);
        const view = this.findView(e.target);
        if (this.guard(e, view)) {
            return;
        }
        if (this.options.preventDefaultMouseDown) {
            evt.preventDefault();
        }
        const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
        if (view) {
            view.onMouseDown(e, localPoint.x, localPoint.y);
        }
        else {
            if (this.options.preventDefaultBlankAction &&
                ['touchstart'].includes(e.type)) {
                evt.preventDefault();
            }
            this.graph.trigger('blank:mousedown', {
                e,
                x: localPoint.x,
                y: localPoint.y,
            });
        }
        this.delegateDragEvents(e, view);
    }
    onMouseMove(evt) {
        const data = this.getEventData(evt);
        const startPosition = data.startPosition;
        if (startPosition &&
            startPosition.x === evt.clientX &&
            startPosition.y === evt.clientY) {
            return;
        }
        if (data.mouseMovedCount == null) {
            data.mouseMovedCount = 0;
        }
        data.mouseMovedCount += 1;
        const mouseMovedCount = data.mouseMovedCount;
        if (mouseMovedCount <= this.options.moveThreshold) {
            return;
        }
        const e = this.normalizeEvent(evt);
        const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
        const view = data.currentView;
        if (view) {
            view.onMouseMove(e, localPoint.x, localPoint.y);
        }
        else {
            this.graph.trigger('blank:mousemove', {
                e,
                x: localPoint.x,
                y: localPoint.y,
            });
        }
        this.setEventData(e, data);
    }
    onMouseUp(e) {
        this.undelegateDocumentEvents();
        const normalized = this.normalizeEvent(e);
        const localPoint = this.graph.snapToGrid(normalized.clientX, normalized.clientY);
        const data = this.getEventData(e);
        const view = data.currentView;
        if (view) {
            view.onMouseUp(normalized, localPoint.x, localPoint.y);
        }
        else {
            this.graph.trigger('blank:mouseup', {
                e: normalized,
                x: localPoint.x,
                y: localPoint.y,
            });
        }
        if (!e.isPropagationStopped()) {
            const ev = new _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.EventObject(e, {
                type: 'click',
                data: e.data,
            });
            this.onClick(ev);
        }
        e.stopImmediatePropagation();
        this.delegateEvents();
    }
    onMouseOver(evt) {
        const e = this.normalizeEvent(evt);
        const view = this.findView(e.target);
        if (this.guard(e, view)) {
            return;
        }
        if (view) {
            view.onMouseOver(e);
        }
        else {
            // prevent border of paper from triggering this
            if (this.container === e.target) {
                return;
            }
            this.graph.trigger('blank:mouseover', { e });
        }
    }
    onMouseOut(evt) {
        const e = this.normalizeEvent(evt);
        const view = this.findView(e.target);
        if (this.guard(e, view)) {
            return;
        }
        if (view) {
            view.onMouseOut(e);
        }
        else {
            if (this.container === e.target) {
                return;
            }
            this.graph.trigger('blank:mouseout', { e });
        }
    }
    onMouseEnter(evt) {
        const e = this.normalizeEvent(evt);
        const view = this.findView(e.target);
        if (this.guard(e, view)) {
            return;
        }
        const relatedView = this.graph.findViewByElem(e.relatedTarget);
        if (view) {
            if (relatedView === view) {
                // mouse moved from tool to view
                return;
            }
            view.onMouseEnter(e);
        }
        else {
            if (relatedView) {
                return;
            }
            this.graph.trigger('graph:mouseenter', { e });
        }
    }
    onMouseLeave(evt) {
        const e = this.normalizeEvent(evt);
        const view = this.findView(e.target);
        if (this.guard(e, view)) {
            return;
        }
        const relatedView = this.graph.findViewByElem(e.relatedTarget);
        if (view) {
            if (relatedView === view) {
                // mouse moved from view to tool
                return;
            }
            view.onMouseLeave(e);
        }
        else {
            if (relatedView) {
                return;
            }
            this.graph.trigger('graph:mouseleave', { e });
        }
    }
    onMouseWheel(evt) {
        const e = this.normalizeEvent(evt);
        const view = this.findView(e.target);
        if (this.guard(e, view)) {
            return;
        }
        const originalEvent = e.originalEvent;
        const localPoint = this.graph.snapToGrid(originalEvent.clientX, originalEvent.clientY);
        const delta = Math.max(-1, Math.min(1, originalEvent.wheelDelta || -originalEvent.detail));
        if (view) {
            view.onMouseWheel(e, localPoint.x, localPoint.y, delta);
        }
        else {
            this.graph.trigger('blank:mousewheel', {
                e,
                delta,
                x: localPoint.x,
                y: localPoint.y,
            });
        }
    }
    onCustomEvent(evt) {
        const elem = evt.currentTarget;
        const event = elem.getAttribute('event') || elem.getAttribute('data-event');
        if (event) {
            const view = this.findView(elem);
            if (view) {
                const e = this.normalizeEvent(evt);
                if (this.guard(e, view)) {
                    return;
                }
                const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
                view.onCustomEvent(e, event, localPoint.x, localPoint.y);
            }
        }
    }
    handleMagnetEvent(evt, handler) {
        const magnetElem = evt.currentTarget;
        const magnetValue = magnetElem.getAttribute('magnet');
        if (magnetValue && magnetValue.toLowerCase() !== 'false') {
            const view = this.findView(magnetElem);
            if (view) {
                const e = this.normalizeEvent(evt);
                if (this.guard(e, view)) {
                    return;
                }
                const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
                _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(handler, this.graph, view, e, magnetElem, localPoint.x, localPoint.y);
            }
        }
    }
    onMagnetMouseDown(e) {
        this.handleMagnetEvent(e, (view, e, magnet, x, y) => {
            view.onMagnetMouseDown(e, magnet, x, y);
        });
    }
    onMagnetDblClick(e) {
        this.handleMagnetEvent(e, (view, e, magnet, x, y) => {
            view.onMagnetDblClick(e, magnet, x, y);
        });
    }
    onMagnetContextMenu(e) {
        const view = this.findView(e.target);
        if (this.isPreventDefaultContextMenu(view)) {
            e.preventDefault();
        }
        this.handleMagnetEvent(e, (view, e, magnet, x, y) => {
            view.onMagnetContextMenu(e, magnet, x, y);
        });
    }
    onLabelMouseDown(evt) {
        const labelNode = evt.currentTarget;
        const view = this.findView(labelNode);
        if (view) {
            const e = this.normalizeEvent(evt);
            if (this.guard(e, view)) {
                return;
            }
            const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);
            view.onLabelMouseDown(e, localPoint.x, localPoint.y);
        }
    }
    onImageDragStart() {
        // This is the only way to prevent image dragging in Firefox that works.
        // Setting -moz-user-select: none, draggable="false" attribute or
        // user-drag: none didn't help.
        return false;
    }
    dispose() {
        this.undelegateEvents();
        this.undelegateDocumentEvents();
        this.restore();
        this.restore = () => { };
    }
}
__decorate([
    _view__WEBPACK_IMPORTED_MODULE_3__.View.dispose()
], GraphView.prototype, "dispose", null);
(function (GraphView) {
    const prefixCls = `${_config__WEBPACK_IMPORTED_MODULE_2__.Config.prefixCls}-graph`;
    GraphView.markup = [
        {
            ns: _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.ns.xhtml,
            tagName: 'div',
            selector: 'background',
            className: `${prefixCls}-background`,
        },
        {
            ns: _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.ns.xhtml,
            tagName: 'div',
            selector: 'grid',
            className: `${prefixCls}-grid`,
        },
        {
            ns: _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.ns.svg,
            tagName: 'svg',
            selector: 'svg',
            className: `${prefixCls}-svg`,
            attrs: {
                width: '100%',
                height: '100%',
                'xmlns:xlink': _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.ns.xlink,
            },
            children: [
                {
                    tagName: 'defs',
                    selector: 'defs',
                },
                {
                    tagName: 'g',
                    selector: 'viewport',
                    className: `${prefixCls}-svg-viewport`,
                    children: [
                        {
                            tagName: 'g',
                            selector: 'primer',
                            className: `${prefixCls}-svg-primer`,
                        },
                        {
                            tagName: 'g',
                            selector: 'stage',
                            className: `${prefixCls}-svg-stage`,
                        },
                        {
                            tagName: 'g',
                            selector: 'decorator',
                            className: `${prefixCls}-svg-decorator`,
                        },
                        {
                            tagName: 'g',
                            selector: 'overlay',
                            className: `${prefixCls}-svg-overlay`,
                        },
                    ],
                },
            ],
        },
    ];
    function snapshoot(elem) {
        const cloned = elem.cloneNode();
        elem.childNodes.forEach((child) => cloned.appendChild(child));
        return () => {
            // remove all children
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.empty(elem);
            // remove all attributes
            while (elem.attributes.length > 0) {
                elem.removeAttribute(elem.attributes[0].name);
            }
            // restore attributes
            for (let i = 0, l = cloned.attributes.length; i < l; i += 1) {
                const attr = cloned.attributes[i];
                elem.setAttribute(attr.name, attr.value);
            }
            // restore children
            cloned.childNodes.forEach((child) => elem.appendChild(child));
        };
    }
    GraphView.snapshoot = snapshoot;
})(GraphView || (GraphView = {}));
(function (GraphView) {
    const prefixCls = _config__WEBPACK_IMPORTED_MODULE_2__.Config.prefixCls;
    GraphView.events = {
        dblclick: 'onDblClick',
        contextmenu: 'onContextMenu',
        touchstart: 'onMouseDown',
        mousedown: 'onMouseDown',
        mouseover: 'onMouseOver',
        mouseout: 'onMouseOut',
        mouseenter: 'onMouseEnter',
        mouseleave: 'onMouseLeave',
        mousewheel: 'onMouseWheel',
        DOMMouseScroll: 'onMouseWheel',
        [`mouseenter  .${prefixCls}-cell`]: 'onMouseEnter',
        [`mouseleave  .${prefixCls}-cell`]: 'onMouseLeave',
        [`mouseenter  .${prefixCls}-cell-tools`]: 'onMouseEnter',
        [`mouseleave  .${prefixCls}-cell-tools`]: 'onMouseLeave',
        [`mousedown   .${prefixCls}-cell [event]`]: 'onCustomEvent',
        [`touchstart  .${prefixCls}-cell [event]`]: 'onCustomEvent',
        [`mousedown   .${prefixCls}-cell [data-event]`]: 'onCustomEvent',
        [`touchstart  .${prefixCls}-cell [data-event]`]: 'onCustomEvent',
        [`dblclick    .${prefixCls}-cell [magnet]`]: 'onMagnetDblClick',
        [`contextmenu .${prefixCls}-cell [magnet]`]: 'onMagnetContextMenu',
        [`mousedown   .${prefixCls}-cell [magnet]`]: 'onMagnetMouseDown',
        [`touchstart  .${prefixCls}-cell [magnet]`]: 'onMagnetMouseDown',
        [`dblclick    .${prefixCls}-cell [data-magnet]`]: 'onMagnetDblClick',
        [`contextmenu .${prefixCls}-cell [data-magnet]`]: 'onMagnetContextMenu',
        [`mousedown   .${prefixCls}-cell [data-magnet]`]: 'onMagnetMouseDown',
        [`touchstart  .${prefixCls}-cell [data-magnet]`]: 'onMagnetMouseDown',
        [`dragstart   .${prefixCls}-cell image`]: 'onImageDragStart',
        [`mousedown   .${prefixCls}-edge .${prefixCls}-edge-label`]: 'onLabelMouseDown',
        [`touchstart  .${prefixCls}-edge .${prefixCls}-edge-label`]: 'onLabelMouseDown',
    };
    GraphView.documentEvents = {
        mousemove: 'onMouseMove',
        touchmove: 'onMouseMove',
        mouseup: 'onMouseUp',
        touchend: 'onMouseUp',
        touchcancel: 'onMouseUp',
    };
})(GraphView || (GraphView = {}));
//# sourceMappingURL=view.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/graph/virtual-render.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/graph/virtual-render.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VirtualRenderManager: () => (/* binding */ VirtualRenderManager)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./node_modules/@antv/x6/es/graph/base.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


class VirtualRenderManager extends _base__WEBPACK_IMPORTED_MODULE_1__.Base {
    init() {
        this.resetRenderArea = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.throttle(this.resetRenderArea, 200, {
            leading: true,
        });
        this.resetRenderArea();
        this.startListening();
    }
    startListening() {
        this.graph.on('translate', this.resetRenderArea, this);
        this.graph.on('scale', this.resetRenderArea, this);
        this.graph.on('resize', this.resetRenderArea, this);
    }
    stopListening() {
        this.graph.off('translate', this.resetRenderArea, this);
        this.graph.off('scale', this.resetRenderArea, this);
        this.graph.off('resize', this.resetRenderArea, this);
    }
    enableVirtualRender() {
        this.options.virtual = true;
        this.resetRenderArea();
    }
    disableVirtualRender() {
        this.options.virtual = false;
        this.graph.renderer.setRenderArea(undefined);
    }
    resetRenderArea() {
        if (this.options.virtual) {
            const renderArea = this.graph.getGraphArea();
            this.graph.renderer.setRenderArea(renderArea);
        }
    }
    dispose() {
        this.stopListening();
    }
}
__decorate([
    _base__WEBPACK_IMPORTED_MODULE_1__.Base.dispose()
], VirtualRenderManager.prototype, "dispose", null);
//# sourceMappingURL=virtual-render.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/index.js":
/*!*******************************************!*\
  !*** ./node_modules/@antv/x6/es/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Angle: () => (/* reexport safe */ _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_8__.Angle),
/* harmony export */   ArrayExt: () => (/* reexport safe */ _antv_x6_common__WEBPACK_IMPORTED_MODULE_7__.ArrayExt),
/* harmony export */   BackgroundManager: () => (/* reexport safe */ _graph__WEBPACK_IMPORTED_MODULE_4__.BackgroundManager),
/* harmony export */   Basecoat: () => (/* reexport safe */ _antv_x6_common__WEBPACK_IMPORTED_MODULE_7__.Basecoat),
/* harmony export */   Cell: () => (/* reexport safe */ _model__WEBPACK_IMPORTED_MODULE_2__.Cell),
/* harmony export */   CellView: () => (/* reexport safe */ _view__WEBPACK_IMPORTED_MODULE_3__.CellView),
/* harmony export */   Collection: () => (/* reexport safe */ _model__WEBPACK_IMPORTED_MODULE_2__.Collection),
/* harmony export */   Color: () => (/* reexport safe */ _antv_x6_common__WEBPACK_IMPORTED_MODULE_7__.Color),
/* harmony export */   Config: () => (/* reexport safe */ _config__WEBPACK_IMPORTED_MODULE_5__.Config),
/* harmony export */   CssLoader: () => (/* reexport safe */ _antv_x6_common__WEBPACK_IMPORTED_MODULE_7__.CssLoader),
/* harmony export */   Curve: () => (/* reexport safe */ _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_8__.Curve),
/* harmony export */   DataUri: () => (/* reexport safe */ _antv_x6_common__WEBPACK_IMPORTED_MODULE_7__.DataUri),
/* harmony export */   Dictionary: () => (/* reexport safe */ _antv_x6_common__WEBPACK_IMPORTED_MODULE_7__.Dictionary),
/* harmony export */   Dijkstra: () => (/* reexport safe */ _antv_x6_common__WEBPACK_IMPORTED_MODULE_7__.Dijkstra),
/* harmony export */   Disablable: () => (/* reexport safe */ _antv_x6_common__WEBPACK_IMPORTED_MODULE_7__.Disablable),
/* harmony export */   Disposable: () => (/* reexport safe */ _antv_x6_common__WEBPACK_IMPORTED_MODULE_7__.Disposable),
/* harmony export */   DisposableDelegate: () => (/* reexport safe */ _antv_x6_common__WEBPACK_IMPORTED_MODULE_7__.DisposableDelegate),
/* harmony export */   DisposableSet: () => (/* reexport safe */ _antv_x6_common__WEBPACK_IMPORTED_MODULE_7__.DisposableSet),
/* harmony export */   Dom: () => (/* reexport safe */ _antv_x6_common__WEBPACK_IMPORTED_MODULE_7__.Dom),
/* harmony export */   Edge: () => (/* reexport safe */ _model__WEBPACK_IMPORTED_MODULE_2__.Edge),
/* harmony export */   EdgeView: () => (/* reexport safe */ _view__WEBPACK_IMPORTED_MODULE_3__.EdgeView),
/* harmony export */   Ellipse: () => (/* reexport safe */ _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_8__.Ellipse),
/* harmony export */   Events: () => (/* reexport safe */ _antv_x6_common__WEBPACK_IMPORTED_MODULE_7__.Events),
/* harmony export */   FunctionExt: () => (/* reexport safe */ _antv_x6_common__WEBPACK_IMPORTED_MODULE_7__.FunctionExt),
/* harmony export */   GeometryUtil: () => (/* reexport safe */ _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_8__.GeometryUtil),
/* harmony export */   Graph: () => (/* reexport safe */ _graph__WEBPACK_IMPORTED_MODULE_4__.Graph),
/* harmony export */   GraphView: () => (/* reexport safe */ _graph__WEBPACK_IMPORTED_MODULE_4__.GraphView),
/* harmony export */   Interp: () => (/* reexport safe */ _antv_x6_common__WEBPACK_IMPORTED_MODULE_7__.Interp),
/* harmony export */   Line: () => (/* reexport safe */ _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_8__.Line),
/* harmony export */   Markup: () => (/* reexport safe */ _view__WEBPACK_IMPORTED_MODULE_3__.Markup),
/* harmony export */   Model: () => (/* reexport safe */ _model__WEBPACK_IMPORTED_MODULE_2__.Model),
/* harmony export */   ModifierKey: () => (/* reexport safe */ _antv_x6_common__WEBPACK_IMPORTED_MODULE_7__.ModifierKey),
/* harmony export */   Node: () => (/* reexport safe */ _model__WEBPACK_IMPORTED_MODULE_2__.Node),
/* harmony export */   NodeView: () => (/* reexport safe */ _view__WEBPACK_IMPORTED_MODULE_3__.NodeView),
/* harmony export */   NumberExt: () => (/* reexport safe */ _antv_x6_common__WEBPACK_IMPORTED_MODULE_7__.NumberExt),
/* harmony export */   ObjectExt: () => (/* reexport safe */ _antv_x6_common__WEBPACK_IMPORTED_MODULE_7__.ObjectExt),
/* harmony export */   Options: () => (/* reexport safe */ _graph__WEBPACK_IMPORTED_MODULE_4__.Options),
/* harmony export */   Path: () => (/* reexport safe */ _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_8__.Path),
/* harmony export */   Platform: () => (/* reexport safe */ _antv_x6_common__WEBPACK_IMPORTED_MODULE_7__.Platform),
/* harmony export */   Point: () => (/* reexport safe */ _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_8__.Point),
/* harmony export */   Polyline: () => (/* reexport safe */ _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_8__.Polyline),
/* harmony export */   PriorityQueue: () => (/* reexport safe */ _antv_x6_common__WEBPACK_IMPORTED_MODULE_7__.PriorityQueue),
/* harmony export */   Rectangle: () => (/* reexport safe */ _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_8__.Rectangle),
/* harmony export */   Registry: () => (/* reexport module object */ _registry__WEBPACK_IMPORTED_MODULE_1__),
/* harmony export */   Segment: () => (/* reexport safe */ _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_8__.Segment),
/* harmony export */   Shape: () => (/* reexport module object */ _shape__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   SizeSensor: () => (/* reexport safe */ _antv_x6_common__WEBPACK_IMPORTED_MODULE_7__.SizeSensor),
/* harmony export */   StringExt: () => (/* reexport safe */ _antv_x6_common__WEBPACK_IMPORTED_MODULE_7__.StringExt),
/* harmony export */   Text: () => (/* reexport safe */ _antv_x6_common__WEBPACK_IMPORTED_MODULE_7__.Text),
/* harmony export */   Timing: () => (/* reexport safe */ _antv_x6_common__WEBPACK_IMPORTED_MODULE_7__.Timing),
/* harmony export */   ToolsView: () => (/* reexport safe */ _view__WEBPACK_IMPORTED_MODULE_3__.ToolsView),
/* harmony export */   TransformManager: () => (/* reexport safe */ _graph__WEBPACK_IMPORTED_MODULE_4__.TransformManager),
/* harmony export */   Unit: () => (/* reexport safe */ _antv_x6_common__WEBPACK_IMPORTED_MODULE_7__.Unit),
/* harmony export */   Util: () => (/* reexport safe */ _util__WEBPACK_IMPORTED_MODULE_6__.Util),
/* harmony export */   Vector: () => (/* reexport safe */ _antv_x6_common__WEBPACK_IMPORTED_MODULE_7__.Vector),
/* harmony export */   View: () => (/* reexport safe */ _view__WEBPACK_IMPORTED_MODULE_3__.View),
/* harmony export */   normalizePathData: () => (/* reexport safe */ _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_8__.normalizePathData)
/* harmony export */ });
/* harmony import */ var _shape__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shape */ "./node_modules/@antv/x6/es/shape/index.js");
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./registry */ "./node_modules/@antv/x6/es/registry/index.js");
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./model */ "./node_modules/@antv/x6/es/model/index.js");
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./view */ "./node_modules/@antv/x6/es/view/index.js");
/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./graph */ "./node_modules/@antv/x6/es/graph/index.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./config */ "./node_modules/@antv/x6/es/config/index.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/util/index.js");
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");










//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/model/animation.js":
/*!*****************************************************!*\
  !*** ./node_modules/@antv/x6/es/model/animation.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Animation: () => (/* binding */ Animation)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");

class Animation {
    constructor(cell) {
        this.cell = cell;
        this.ids = {};
        this.cache = {};
    }
    get() {
        return Object.keys(this.ids);
    }
    start(path, targetValue, options = {}, delim = '/') {
        const startValue = this.cell.getPropByPath(path);
        const localOptions = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.defaults(options, Animation.defaultOptions);
        const timing = this.getTiming(localOptions.timing);
        const interpolate = this.getInterp(localOptions.interp, startValue, targetValue);
        let startTime = 0;
        const key = Array.isArray(path) ? path.join(delim) : path;
        const paths = Array.isArray(path) ? path : path.split(delim);
        const iterate = () => {
            const now = new Date().getTime();
            if (startTime === 0) {
                startTime = now;
            }
            const elaspe = now - startTime;
            let progress = elaspe / localOptions.duration;
            if (progress < 1) {
                this.ids[key] = requestAnimationFrame(iterate);
            }
            else {
                progress = 1;
            }
            const currentValue = interpolate(timing(progress));
            this.cell.setPropByPath(paths, currentValue);
            if (options.progress) {
                options.progress(Object.assign({ progress, currentValue }, this.getArgs(key)));
            }
            if (progress === 1) {
                this.cell.notify('transition:complete', this.getArgs(key));
                options.complete && options.complete(this.getArgs(key));
                this.cell.notify('transition:finish', this.getArgs(key));
                options.finish && options.finish(this.getArgs(key));
                this.clean(key);
            }
        };
        setTimeout(() => {
            this.stop(path, undefined, delim);
            this.cache[key] = { startValue, targetValue, options: localOptions };
            this.ids[key] = requestAnimationFrame(iterate);
            this.cell.notify('transition:start', this.getArgs(key));
            options.start && options.start(this.getArgs(key));
        }, options.delay);
        return this.stop.bind(this, path, delim, options);
    }
    stop(path, options = {}, delim = '/') {
        const paths = Array.isArray(path) ? path : path.split(delim);
        Object.keys(this.ids)
            .filter((key) => _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isEqual(paths, key.split(delim).slice(0, paths.length)))
            .forEach((key) => {
            cancelAnimationFrame(this.ids[key]);
            const data = this.cache[key];
            const commonArgs = this.getArgs(key);
            const localOptions = Object.assign(Object.assign({}, data.options), options);
            const jumpedToEnd = localOptions.jumpedToEnd;
            if (jumpedToEnd && data.targetValue != null) {
                this.cell.setPropByPath(key, data.targetValue);
                this.cell.notify('transition:end', Object.assign({}, commonArgs));
                this.cell.notify('transition:complete', Object.assign({}, commonArgs));
                localOptions.complete && localOptions.complete(Object.assign({}, commonArgs));
            }
            const stopArgs = Object.assign({ jumpedToEnd }, commonArgs);
            this.cell.notify('transition:stop', Object.assign({}, stopArgs));
            localOptions.stop && localOptions.stop(Object.assign({}, stopArgs));
            this.cell.notify('transition:finish', Object.assign({}, commonArgs));
            localOptions.finish && localOptions.finish(Object.assign({}, commonArgs));
            this.clean(key);
        });
        return this;
    }
    clean(key) {
        delete this.ids[key];
        delete this.cache[key];
    }
    getTiming(timing) {
        return typeof timing === 'string' ? _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Timing[timing] : timing;
    }
    getInterp(interp, startValue, targetValue) {
        if (interp) {
            return interp(startValue, targetValue);
        }
        if (typeof targetValue === 'number') {
            return _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Interp.number(startValue, targetValue);
        }
        if (typeof targetValue === 'string') {
            if (targetValue[0] === '#') {
                return _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Interp.color(startValue, targetValue);
            }
            return _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Interp.unit(startValue, targetValue);
        }
        return _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Interp.object(startValue, targetValue);
    }
    getArgs(key) {
        const data = this.cache[key];
        return {
            path: key,
            startValue: data.startValue,
            targetValue: data.targetValue,
            cell: this.cell,
        };
    }
}
(function (Animation) {
    Animation.defaultOptions = {
        delay: 10,
        duration: 100,
        timing: 'linear',
    };
})(Animation || (Animation = {}));
//# sourceMappingURL=animation.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/model/cell.js":
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/model/cell.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Cell: () => (/* binding */ Cell)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../registry */ "./node_modules/@antv/x6/es/registry/index.js");
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./store */ "./node_modules/@antv/x6/es/model/store.js");
/* harmony import */ var _animation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./animation */ "./node_modules/@antv/x6/es/model/animation.js");
/* eslint-disable no-underscore-dangle */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};





class Cell extends _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Basecoat {
    static config(presets) {
        const { markup, propHooks, attrHooks } = presets, others = __rest(presets, ["markup", "propHooks", "attrHooks"]);
        if (markup != null) {
            this.markup = markup;
        }
        if (propHooks) {
            this.propHooks = this.propHooks.slice();
            if (Array.isArray(propHooks)) {
                this.propHooks.push(...propHooks);
            }
            else if (typeof propHooks === 'function') {
                this.propHooks.push(propHooks);
            }
            else {
                Object.values(propHooks).forEach((hook) => {
                    if (typeof hook === 'function') {
                        this.propHooks.push(hook);
                    }
                });
            }
        }
        if (attrHooks) {
            this.attrHooks = Object.assign(Object.assign({}, this.attrHooks), attrHooks);
        }
        this.defaults = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.merge({}, this.defaults, others);
    }
    static getMarkup() {
        return this.markup;
    }
    static getDefaults(raw) {
        return (raw ? this.defaults : _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(this.defaults));
    }
    static getAttrHooks() {
        return this.attrHooks;
    }
    static applyPropHooks(cell, metadata) {
        return this.propHooks.reduce((memo, hook) => {
            return hook ? _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(hook, cell, memo) : memo;
        }, metadata);
    }
    // #endregion
    get [Symbol.toStringTag]() {
        return Cell.toStringTag;
    }
    constructor(metadata = {}) {
        super();
        const ctor = this.constructor;
        const defaults = ctor.getDefaults(true);
        const props = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.merge({}, this.preprocess(defaults), this.preprocess(metadata));
        this.id = props.id || _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.StringExt.uuid();
        this.store = new _store__WEBPACK_IMPORTED_MODULE_3__.Store(props);
        this.animation = new _animation__WEBPACK_IMPORTED_MODULE_4__.Animation(this);
        this.setup();
        this.init();
        this.postprocess(metadata);
    }
    init() { }
    // #region model
    get model() {
        return this._model;
    }
    set model(model) {
        if (this._model !== model) {
            this._model = model;
        }
    }
    // #endregion
    preprocess(metadata, ignoreIdCheck) {
        const id = metadata.id;
        const ctor = this.constructor;
        const props = ctor.applyPropHooks(this, metadata);
        if (id == null && ignoreIdCheck !== true) {
            props.id = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.StringExt.uuid();
        }
        return props;
    }
    postprocess(metadata) { } // eslint-disable-line
    setup() {
        this.store.on('change:*', (metadata) => {
            const { key, current, previous, options } = metadata;
            this.notify('change:*', {
                key,
                options,
                current,
                previous,
                cell: this,
            });
            this.notify(`change:${key}`, {
                options,
                current,
                previous,
                cell: this,
            });
            const type = key;
            if (type === 'source' || type === 'target') {
                this.notify(`change:terminal`, {
                    type,
                    current,
                    previous,
                    options,
                    cell: this,
                });
            }
        });
        this.store.on('changed', ({ options }) => this.notify('changed', { options, cell: this }));
    }
    notify(name, args) {
        this.trigger(name, args);
        const model = this.model;
        if (model) {
            model.notify(`cell:${name}`, args);
            if (this.isNode()) {
                model.notify(`node:${name}`, Object.assign(Object.assign({}, args), { node: this }));
            }
            else if (this.isEdge()) {
                model.notify(`edge:${name}`, Object.assign(Object.assign({}, args), { edge: this }));
            }
        }
        return this;
    }
    isNode() {
        return false;
    }
    isEdge() {
        return false;
    }
    isSameStore(cell) {
        return this.store === cell.store;
    }
    get view() {
        return this.store.get('view');
    }
    get shape() {
        return this.store.get('shape', '');
    }
    getProp(key, defaultValue) {
        if (key == null) {
            return this.store.get();
        }
        return this.store.get(key, defaultValue);
    }
    setProp(key, value, options) {
        if (typeof key === 'string') {
            this.store.set(key, value, options);
        }
        else {
            const props = this.preprocess(key, true);
            this.store.set(_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.merge({}, this.getProp(), props), value);
            this.postprocess(key);
        }
        return this;
    }
    removeProp(key, options) {
        if (typeof key === 'string' || Array.isArray(key)) {
            this.store.removeByPath(key, options);
        }
        else {
            this.store.remove(options);
        }
        return this;
    }
    hasChanged(key) {
        return key == null ? this.store.hasChanged() : this.store.hasChanged(key);
    }
    getPropByPath(path) {
        return this.store.getByPath(path);
    }
    setPropByPath(path, value, options = {}) {
        if (this.model) {
            // update inner reference
            if (path === 'children') {
                this._children = value
                    ? value
                        .map((id) => this.model.getCell(id))
                        .filter((child) => child != null)
                    : null;
            }
            else if (path === 'parent') {
                this._parent = value ? this.model.getCell(value) : null;
            }
        }
        this.store.setByPath(path, value, options);
        return this;
    }
    removePropByPath(path, options = {}) {
        const paths = Array.isArray(path) ? path : path.split('/');
        // Once a property is removed from the `attrs` the CellView will
        // recognize a `dirty` flag and re-render itself in order to remove
        // the attribute from SVGElement.
        if (paths[0] === 'attrs') {
            options.dirty = true;
        }
        this.store.removeByPath(paths, options);
        return this;
    }
    prop(key, value, options) {
        if (key == null) {
            return this.getProp();
        }
        if (typeof key === 'string' || Array.isArray(key)) {
            if (arguments.length === 1) {
                return this.getPropByPath(key);
            }
            if (value == null) {
                return this.removePropByPath(key, options || {});
            }
            return this.setPropByPath(key, value, options || {});
        }
        return this.setProp(key, value || {});
    }
    previous(name) {
        return this.store.getPrevious(name);
    }
    // #endregion
    // #region zIndex
    get zIndex() {
        return this.getZIndex();
    }
    set zIndex(z) {
        if (z == null) {
            this.removeZIndex();
        }
        else {
            this.setZIndex(z);
        }
    }
    getZIndex() {
        return this.store.get('zIndex');
    }
    setZIndex(z, options = {}) {
        this.store.set('zIndex', z, options);
        return this;
    }
    removeZIndex(options = {}) {
        this.store.remove('zIndex', options);
        return this;
    }
    toFront(options = {}) {
        const model = this.model;
        if (model) {
            let z = model.getMaxZIndex();
            let cells;
            if (options.deep) {
                cells = this.getDescendants({ deep: true, breadthFirst: true });
                cells.unshift(this);
            }
            else {
                cells = [this];
            }
            z = z - cells.length + 1;
            const count = model.total();
            let changed = model.indexOf(this) !== count - cells.length;
            if (!changed) {
                changed = cells.some((cell, index) => cell.getZIndex() !== z + index);
            }
            if (changed) {
                this.batchUpdate('to-front', () => {
                    z += cells.length;
                    cells.forEach((cell, index) => {
                        cell.setZIndex(z + index, options);
                    });
                });
            }
        }
        return this;
    }
    toBack(options = {}) {
        const model = this.model;
        if (model) {
            let z = model.getMinZIndex();
            let cells;
            if (options.deep) {
                cells = this.getDescendants({ deep: true, breadthFirst: true });
                cells.unshift(this);
            }
            else {
                cells = [this];
            }
            let changed = model.indexOf(this) !== 0;
            if (!changed) {
                changed = cells.some((cell, index) => cell.getZIndex() !== z + index);
            }
            if (changed) {
                this.batchUpdate('to-back', () => {
                    z -= cells.length;
                    cells.forEach((cell, index) => {
                        cell.setZIndex(z + index, options);
                    });
                });
            }
        }
        return this;
    }
    // #endregion
    // #region markup
    get markup() {
        return this.getMarkup();
    }
    set markup(value) {
        if (value == null) {
            this.removeMarkup();
        }
        else {
            this.setMarkup(value);
        }
    }
    getMarkup() {
        let markup = this.store.get('markup');
        if (markup == null) {
            const ctor = this.constructor;
            markup = ctor.getMarkup();
        }
        return markup;
    }
    setMarkup(markup, options = {}) {
        this.store.set('markup', markup, options);
        return this;
    }
    removeMarkup(options = {}) {
        this.store.remove('markup', options);
        return this;
    }
    // #endregion
    // #region attrs
    get attrs() {
        return this.getAttrs();
    }
    set attrs(value) {
        if (value == null) {
            this.removeAttrs();
        }
        else {
            this.setAttrs(value);
        }
    }
    getAttrs() {
        const result = this.store.get('attrs');
        return result ? Object.assign({}, result) : {};
    }
    setAttrs(attrs, options = {}) {
        if (attrs == null) {
            this.removeAttrs(options);
        }
        else {
            const set = (attrs) => this.store.set('attrs', attrs, options);
            if (options.overwrite === true) {
                set(attrs);
            }
            else {
                const prev = this.getAttrs();
                if (options.deep === false) {
                    set(Object.assign(Object.assign({}, prev), attrs));
                }
                else {
                    set(_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.merge({}, prev, attrs));
                }
            }
        }
        return this;
    }
    replaceAttrs(attrs, options = {}) {
        return this.setAttrs(attrs, Object.assign(Object.assign({}, options), { overwrite: true }));
    }
    updateAttrs(attrs, options = {}) {
        return this.setAttrs(attrs, Object.assign(Object.assign({}, options), { deep: false }));
    }
    removeAttrs(options = {}) {
        this.store.remove('attrs', options);
        return this;
    }
    getAttrDefinition(attrName) {
        if (!attrName) {
            return null;
        }
        const ctor = this.constructor;
        const hooks = ctor.getAttrHooks() || {};
        let definition = hooks[attrName] || _registry__WEBPACK_IMPORTED_MODULE_2__.Attr.registry.get(attrName);
        if (!definition) {
            const name = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.StringExt.camelCase(attrName);
            definition = hooks[name] || _registry__WEBPACK_IMPORTED_MODULE_2__.Attr.registry.get(name);
        }
        return definition || null;
    }
    getAttrByPath(path) {
        if (path == null || path === '') {
            return this.getAttrs();
        }
        return this.getPropByPath(this.prefixAttrPath(path));
    }
    setAttrByPath(path, value, options = {}) {
        this.setPropByPath(this.prefixAttrPath(path), value, options);
        return this;
    }
    removeAttrByPath(path, options = {}) {
        this.removePropByPath(this.prefixAttrPath(path), options);
        return this;
    }
    prefixAttrPath(path) {
        return Array.isArray(path) ? ['attrs'].concat(path) : `attrs/${path}`;
    }
    attr(path, value, options) {
        if (path == null) {
            return this.getAttrByPath();
        }
        if (typeof path === 'string' || Array.isArray(path)) {
            if (arguments.length === 1) {
                return this.getAttrByPath(path);
            }
            if (value == null) {
                return this.removeAttrByPath(path, options || {});
            }
            return this.setAttrByPath(path, value, options || {});
        }
        return this.setAttrs(path, (value || {}));
    }
    // #endregion
    // #region visible
    get visible() {
        return this.isVisible();
    }
    set visible(value) {
        this.setVisible(value);
    }
    setVisible(visible, options = {}) {
        this.store.set('visible', visible, options);
        return this;
    }
    isVisible() {
        return this.store.get('visible') !== false;
    }
    show(options = {}) {
        if (!this.isVisible()) {
            this.setVisible(true, options);
        }
        return this;
    }
    hide(options = {}) {
        if (this.isVisible()) {
            this.setVisible(false, options);
        }
        return this;
    }
    toggleVisible(isVisible, options = {}) {
        const visible = typeof isVisible === 'boolean' ? isVisible : !this.isVisible();
        const localOptions = typeof isVisible === 'boolean' ? options : isVisible;
        if (visible) {
            this.show(localOptions);
        }
        else {
            this.hide(localOptions);
        }
        return this;
    }
    // #endregion
    // #region data
    get data() {
        return this.getData();
    }
    set data(val) {
        this.setData(val);
    }
    getData() {
        return this.store.get('data');
    }
    setData(data, options = {}) {
        if (data == null) {
            this.removeData(options);
        }
        else {
            const set = (data) => this.store.set('data', data, options);
            if (options.overwrite === true) {
                set(data);
            }
            else {
                const prev = this.getData();
                if (options.deep === false) {
                    set(typeof data === 'object' ? Object.assign(Object.assign({}, prev), data) : data);
                }
                else {
                    set(_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.merge({}, prev, data));
                }
            }
        }
        return this;
    }
    replaceData(data, options = {}) {
        return this.setData(data, Object.assign(Object.assign({}, options), { overwrite: true }));
    }
    updateData(data, options = {}) {
        return this.setData(data, Object.assign(Object.assign({}, options), { deep: false }));
    }
    removeData(options = {}) {
        this.store.remove('data', options);
        return this;
    }
    // #endregion
    // #region parent children
    get parent() {
        return this.getParent();
    }
    get children() {
        return this.getChildren();
    }
    getParentId() {
        return this.store.get('parent');
    }
    getParent() {
        const parentId = this.getParentId();
        if (parentId && this.model) {
            const parent = this.model.getCell(parentId);
            this._parent = parent;
            return parent;
        }
        return null;
    }
    getChildren() {
        const childrenIds = this.store.get('children');
        if (childrenIds && childrenIds.length && this.model) {
            const children = childrenIds
                .map((id) => { var _a; return (_a = this.model) === null || _a === void 0 ? void 0 : _a.getCell(id); })
                .filter((cell) => cell != null);
            this._children = children;
            return [...children];
        }
        return null;
    }
    hasParent() {
        return this.parent != null;
    }
    isParentOf(child) {
        return child != null && child.getParent() === this;
    }
    isChildOf(parent) {
        return parent != null && this.getParent() === parent;
    }
    eachChild(iterator, context) {
        if (this.children) {
            this.children.forEach(iterator, context);
        }
        return this;
    }
    filterChild(filter, context) {
        return this.children ? this.children.filter(filter, context) : [];
    }
    getChildCount() {
        return this.children == null ? 0 : this.children.length;
    }
    getChildIndex(child) {
        return this.children == null ? -1 : this.children.indexOf(child);
    }
    getChildAt(index) {
        return this.children != null && index >= 0 ? this.children[index] : null;
    }
    getAncestors(options = {}) {
        const ancestors = [];
        let parent = this.getParent();
        while (parent) {
            ancestors.push(parent);
            parent = options.deep !== false ? parent.getParent() : null;
        }
        return ancestors;
    }
    getDescendants(options = {}) {
        if (options.deep !== false) {
            // breadth first
            if (options.breadthFirst) {
                const cells = [];
                const queue = this.getChildren() || [];
                while (queue.length > 0) {
                    const parent = queue.shift();
                    const children = parent.getChildren();
                    cells.push(parent);
                    if (children) {
                        queue.push(...children);
                    }
                }
                return cells;
            }
            // depth first
            {
                const cells = this.getChildren() || [];
                cells.forEach((cell) => {
                    cells.push(...cell.getDescendants(options));
                });
                return cells;
            }
        }
        return this.getChildren() || [];
    }
    isDescendantOf(ancestor, options = {}) {
        if (ancestor == null) {
            return false;
        }
        if (options.deep !== false) {
            let current = this.getParent();
            while (current) {
                if (current === ancestor) {
                    return true;
                }
                current = current.getParent();
            }
            return false;
        }
        return this.isChildOf(ancestor);
    }
    isAncestorOf(descendant, options = {}) {
        if (descendant == null) {
            return false;
        }
        return descendant.isDescendantOf(this, options);
    }
    contains(cell) {
        return this.isAncestorOf(cell);
    }
    getCommonAncestor(...cells) {
        return Cell.getCommonAncestor(this, ...cells);
    }
    setParent(parent, options = {}) {
        this._parent = parent;
        if (parent) {
            this.store.set('parent', parent.id, options);
        }
        else {
            this.store.remove('parent', options);
        }
        return this;
    }
    setChildren(children, options = {}) {
        this._children = children;
        if (children != null) {
            this.store.set('children', children.map((child) => child.id), options);
        }
        else {
            this.store.remove('children', options);
        }
        return this;
    }
    unembed(child, options = {}) {
        const children = this.children;
        if (children != null && child != null) {
            const index = this.getChildIndex(child);
            if (index !== -1) {
                children.splice(index, 1);
                child.setParent(null, options);
                this.setChildren(children, options);
            }
        }
        return this;
    }
    embed(child, options = {}) {
        child.addTo(this, options);
        return this;
    }
    addTo(target, options = {}) {
        if (Cell.isCell(target)) {
            target.addChild(this, options);
        }
        else {
            target.addCell(this, options);
        }
        return this;
    }
    insertTo(parent, index, options = {}) {
        parent.insertChild(this, index, options);
        return this;
    }
    addChild(child, options = {}) {
        return this.insertChild(child, undefined, options);
    }
    insertChild(child, index, options = {}) {
        if (child != null && child !== this) {
            const oldParent = child.getParent();
            const changed = this !== oldParent;
            let pos = index;
            if (pos == null) {
                pos = this.getChildCount();
                if (!changed) {
                    pos -= 1;
                }
            }
            // remove from old parent
            if (oldParent) {
                const children = oldParent.getChildren();
                if (children) {
                    const index = children.indexOf(child);
                    if (index >= 0) {
                        child.setParent(null, options);
                        children.splice(index, 1);
                        oldParent.setChildren(children, options);
                    }
                }
            }
            let children = this.children;
            if (children == null) {
                children = [];
                children.push(child);
            }
            else {
                children.splice(pos, 0, child);
            }
            child.setParent(this, options);
            this.setChildren(children, options);
            if (changed && this.model) {
                const incomings = this.model.getIncomingEdges(this);
                const outgoings = this.model.getOutgoingEdges(this);
                if (incomings) {
                    incomings.forEach((edge) => edge.updateParent(options));
                }
                if (outgoings) {
                    outgoings.forEach((edge) => edge.updateParent(options));
                }
            }
            if (this.model) {
                this.model.addCell(child, options);
            }
        }
        return this;
    }
    removeFromParent(options = {}) {
        const parent = this.getParent();
        if (parent != null) {
            const index = parent.getChildIndex(this);
            parent.removeChildAt(index, options);
        }
        return this;
    }
    removeChild(child, options = {}) {
        const index = this.getChildIndex(child);
        return this.removeChildAt(index, options);
    }
    removeChildAt(index, options = {}) {
        const child = this.getChildAt(index);
        const children = this.children;
        if (children != null && child != null) {
            this.unembed(child, options);
            child.remove(options);
        }
        return child;
    }
    remove(options = {}) {
        this.batchUpdate('remove', () => {
            const parent = this.getParent();
            if (parent) {
                parent.removeChild(this, options);
            }
            if (options.deep !== false) {
                this.eachChild((child) => child.remove(options));
            }
            if (this.model) {
                this.model.removeCell(this, options);
            }
        });
        return this;
    }
    transition(path, target, options = {}, delim = '/') {
        return this.animation.start(path, target, options, delim);
    }
    stopTransition(path, options, delim = '/') {
        this.animation.stop(path, options, delim);
        return this;
    }
    getTransitions() {
        return this.animation.get();
    }
    // #endregion
    // #region transform
    // eslint-disable-next-line
    translate(tx, ty, options) {
        return this;
    }
    scale(sx, // eslint-disable-line
    sy, // eslint-disable-line
    origin, // eslint-disable-line
    options) {
        return this;
    }
    addTools(items, obj, options) {
        const toolItems = Array.isArray(items) ? items : [items];
        const name = typeof obj === 'string' ? obj : null;
        const config = typeof obj === 'object' ? obj : typeof options === 'object' ? options : {};
        if (config.reset) {
            return this.setTools({ name, items: toolItems, local: config.local }, config);
        }
        let tools = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(this.getTools());
        if (tools == null || name == null || tools.name === name) {
            if (tools == null) {
                tools = {};
            }
            if (!tools.items) {
                tools.items = [];
            }
            tools.name = name;
            tools.items = [...tools.items, ...toolItems];
            return this.setTools(Object.assign({}, tools), config);
        }
    }
    setTools(tools, options = {}) {
        if (tools == null) {
            this.removeTools();
        }
        else {
            this.store.set('tools', Cell.normalizeTools(tools), options);
        }
        return this;
    }
    getTools() {
        return this.store.get('tools');
    }
    removeTools(options = {}) {
        this.store.remove('tools', options);
        return this;
    }
    hasTools(name) {
        const tools = this.getTools();
        if (tools == null) {
            return false;
        }
        if (name == null) {
            return true;
        }
        return tools.name === name;
    }
    hasTool(name) {
        const tools = this.getTools();
        if (tools == null) {
            return false;
        }
        return tools.items.some((item) => typeof item === 'string' ? item === name : item.name === name);
    }
    removeTool(nameOrIndex, options = {}) {
        const tools = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(this.getTools());
        if (tools) {
            let updated = false;
            const items = tools.items.slice();
            const remove = (index) => {
                items.splice(index, 1);
                updated = true;
            };
            if (typeof nameOrIndex === 'number') {
                remove(nameOrIndex);
            }
            else {
                for (let i = items.length - 1; i >= 0; i -= 1) {
                    const item = items[i];
                    const exist = typeof item === 'string'
                        ? item === nameOrIndex
                        : item.name === nameOrIndex;
                    if (exist) {
                        remove(i);
                    }
                }
            }
            if (updated) {
                tools.items = items;
                this.setTools(tools, options);
            }
        }
        return this;
    }
    // #endregion
    // #region common
    // eslint-disable-next-line
    getBBox(options) {
        return new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle();
    }
    // eslint-disable-next-line
    getConnectionPoint(edge, type) {
        return new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point();
    }
    toJSON(options = {}) {
        const props = Object.assign({}, this.store.get());
        const toString = Object.prototype.toString;
        const cellType = this.isNode() ? 'node' : this.isEdge() ? 'edge' : 'cell';
        if (!props.shape) {
            const ctor = this.constructor;
            throw new Error(`Unable to serialize ${cellType} missing "shape" prop, check the ${cellType} "${ctor.name || toString.call(ctor)}"`);
        }
        const ctor = this.constructor;
        const diff = options.diff === true;
        const attrs = props.attrs || {};
        const presets = ctor.getDefaults(true);
        // When `options.diff` is `true`, we should process the custom options,
        // such as `width`, `height` etc. to ensure the comparing work correctly.
        const defaults = diff ? this.preprocess(presets, true) : presets;
        const defaultAttrs = defaults.attrs || {};
        const finalAttrs = {};
        Object.entries(props).forEach(([key, val]) => {
            if (val != null &&
                !Array.isArray(val) &&
                typeof val === 'object' &&
                !_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isPlainObject(val)) {
                throw new Error(`Can only serialize ${cellType} with plain-object props, but got a "${toString.call(val)}" type of key "${key}" on ${cellType} "${this.id}"`);
            }
            if (key !== 'attrs' && key !== 'shape' && diff) {
                const preset = defaults[key];
                if (_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isEqual(val, preset)) {
                    delete props[key];
                }
            }
        });
        Object.keys(attrs).forEach((key) => {
            const attr = attrs[key];
            const defaultAttr = defaultAttrs[key];
            Object.keys(attr).forEach((name) => {
                const value = attr[name];
                const defaultValue = defaultAttr ? defaultAttr[name] : null;
                if (value != null &&
                    typeof value === 'object' &&
                    !Array.isArray(value)) {
                    Object.keys(value).forEach((subName) => {
                        const subValue = value[subName];
                        if (defaultAttr == null ||
                            defaultValue == null ||
                            !_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isObject(defaultValue) ||
                            !_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isEqual(defaultValue[subName], subValue)) {
                            if (finalAttrs[key] == null) {
                                finalAttrs[key] = {};
                            }
                            if (finalAttrs[key][name] == null) {
                                finalAttrs[key][name] = {};
                            }
                            const tmp = finalAttrs[key][name];
                            tmp[subName] = subValue;
                        }
                    });
                }
                else if (defaultAttr == null ||
                    !_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isEqual(defaultValue, value)) {
                    // `value` is not an object, default attribute with `key` does not
                    // exist or it is different than the attribute value set on the cell.
                    if (finalAttrs[key] == null) {
                        finalAttrs[key] = {};
                    }
                    finalAttrs[key][name] = value;
                }
            });
        });
        const finalProps = Object.assign(Object.assign({}, props), { attrs: _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isEmpty(finalAttrs) ? undefined : finalAttrs });
        if (finalProps.attrs == null) {
            delete finalProps.attrs;
        }
        const ret = finalProps;
        if (ret.angle === 0) {
            delete ret.angle;
        }
        return _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(ret);
    }
    clone(options = {}) {
        if (!options.deep) {
            const data = Object.assign({}, this.store.get());
            if (!options.keepId) {
                delete data.id;
            }
            delete data.parent;
            delete data.children;
            const ctor = this.constructor;
            return new ctor(data); // eslint-disable-line new-cap
        }
        // Deep cloning. Clone the cell itself and all its children.
        const map = Cell.deepClone(this);
        return map[this.id];
    }
    findView(graph) {
        return graph.findViewByCell(this);
    }
    // #endregion
    // #region batch
    startBatch(name, data = {}, model = this.model) {
        this.notify('batch:start', { name, data, cell: this });
        if (model) {
            model.startBatch(name, Object.assign(Object.assign({}, data), { cell: this }));
        }
        return this;
    }
    stopBatch(name, data = {}, model = this.model) {
        if (model) {
            model.stopBatch(name, Object.assign(Object.assign({}, data), { cell: this }));
        }
        this.notify('batch:stop', { name, data, cell: this });
        return this;
    }
    batchUpdate(name, execute, data) {
        // The model is null after cell was removed(remove batch).
        // So we should temp save model to trigger pairing batch event.
        const model = this.model;
        this.startBatch(name, data, model);
        const result = execute();
        this.stopBatch(name, data, model);
        return result;
    }
    // #endregion
    // #region IDisposable
    dispose() {
        this.removeFromParent();
        this.store.dispose();
    }
}
Cell.defaults = {};
Cell.attrHooks = {};
Cell.propHooks = [];
__decorate([
    _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Basecoat.dispose()
], Cell.prototype, "dispose", null);
(function (Cell) {
    function normalizeTools(raw) {
        if (typeof raw === 'string') {
            return { items: [raw] };
        }
        if (Array.isArray(raw)) {
            return { items: raw };
        }
        if (raw.items) {
            return raw;
        }
        return {
            items: [raw],
        };
    }
    Cell.normalizeTools = normalizeTools;
})(Cell || (Cell = {}));
(function (Cell) {
    Cell.toStringTag = `X6.${Cell.name}`;
    function isCell(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof Cell) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const cell = instance;
        if ((tag == null || tag === Cell.toStringTag) &&
            typeof cell.isNode === 'function' &&
            typeof cell.isEdge === 'function' &&
            typeof cell.prop === 'function' &&
            typeof cell.attr === 'function') {
            return true;
        }
        return false;
    }
    Cell.isCell = isCell;
})(Cell || (Cell = {}));
(function (Cell) {
    function getCommonAncestor(...cells) {
        const ancestors = cells
            .filter((cell) => cell != null)
            .map((cell) => cell.getAncestors())
            .sort((a, b) => {
            return a.length - b.length;
        });
        const first = ancestors.shift();
        return (first.find((cell) => ancestors.every((item) => item.includes(cell))) ||
            null);
    }
    Cell.getCommonAncestor = getCommonAncestor;
    function getCellsBBox(cells, options = {}) {
        let bbox = null;
        for (let i = 0, ii = cells.length; i < ii; i += 1) {
            const cell = cells[i];
            let rect = cell.getBBox(options);
            if (rect) {
                if (cell.isNode()) {
                    const angle = cell.getAngle();
                    if (angle != null && angle !== 0) {
                        rect = rect.bbox(angle);
                    }
                }
                bbox = bbox == null ? rect : bbox.union(rect);
            }
        }
        return bbox;
    }
    Cell.getCellsBBox = getCellsBBox;
    function deepClone(cell) {
        const cells = [cell, ...cell.getDescendants({ deep: true })];
        return Cell.cloneCells(cells);
    }
    Cell.deepClone = deepClone;
    function cloneCells(cells) {
        const inputs = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.uniq(cells);
        const cloneMap = inputs.reduce((map, cell) => {
            map[cell.id] = cell.clone();
            return map;
        }, {});
        inputs.forEach((cell) => {
            const clone = cloneMap[cell.id];
            if (clone.isEdge()) {
                const sourceId = clone.getSourceCellId();
                const targetId = clone.getTargetCellId();
                if (sourceId && cloneMap[sourceId]) {
                    // Source is a node and the node is among the clones.
                    // Then update the source of the cloned edge.
                    clone.setSource(Object.assign(Object.assign({}, clone.getSource()), { cell: cloneMap[sourceId].id }));
                }
                if (targetId && cloneMap[targetId]) {
                    // Target is a node and the node is among the clones.
                    // Then update the target of the cloned edge.
                    clone.setTarget(Object.assign(Object.assign({}, clone.getTarget()), { cell: cloneMap[targetId].id }));
                }
            }
            // Find the parent of the original cell
            const parent = cell.getParent();
            if (parent && cloneMap[parent.id]) {
                clone.setParent(cloneMap[parent.id]);
            }
            // Find the children of the original cell
            const children = cell.getChildren();
            if (children && children.length) {
                const embeds = children.reduce((memo, child) => {
                    // Embedded cells that are not being cloned can not be carried
                    // over with other embedded cells.
                    if (cloneMap[child.id]) {
                        memo.push(cloneMap[child.id]);
                    }
                    return memo;
                }, []);
                if (embeds.length > 0) {
                    clone.setChildren(embeds);
                }
            }
        });
        return cloneMap;
    }
    Cell.cloneCells = cloneCells;
})(Cell || (Cell = {}));
(function (Cell) {
    Cell.config({
        propHooks(_a) {
            var { tools } = _a, metadata = __rest(_a, ["tools"]);
            if (tools) {
                metadata.tools = Cell.normalizeTools(tools);
            }
            return metadata;
        },
    });
})(Cell || (Cell = {}));
//# sourceMappingURL=cell.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/model/collection.js":
/*!******************************************************!*\
  !*** ./node_modules/@antv/x6/es/model/collection.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Collection: () => (/* binding */ Collection)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

class Collection extends _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Basecoat {
    constructor(cells, options = {}) {
        super();
        this.length = 0;
        this.comparator = options.comparator || 'zIndex';
        this.clean();
        if (cells) {
            this.reset(cells, { silent: true });
        }
    }
    toJSON() {
        return this.cells.map((cell) => cell.toJSON());
    }
    add(cells, index, options) {
        let localIndex;
        let localOptions;
        if (typeof index === 'number') {
            localIndex = index;
            localOptions = Object.assign({ merge: false }, options);
        }
        else {
            localIndex = this.length;
            localOptions = Object.assign({ merge: false }, index);
        }
        if (localIndex > this.length) {
            localIndex = this.length;
        }
        if (localIndex < 0) {
            localIndex += this.length + 1;
        }
        const entities = Array.isArray(cells) ? cells : [cells];
        const sortable = this.comparator &&
            typeof index !== 'number' &&
            localOptions.sort !== false;
        const sortAttr = this.comparator || null;
        let sort = false;
        const added = [];
        const merged = [];
        entities.forEach((cell) => {
            const existing = this.get(cell);
            if (existing) {
                if (localOptions.merge && !cell.isSameStore(existing)) {
                    existing.setProp(cell.getProp(), options); // merge
                    merged.push(existing);
                    if (sortable && !sort) {
                        if (sortAttr == null || typeof sortAttr === 'function') {
                            sort = existing.hasChanged();
                        }
                        else if (typeof sortAttr === 'string') {
                            sort = existing.hasChanged(sortAttr);
                        }
                        else {
                            sort = sortAttr.some((key) => existing.hasChanged(key));
                        }
                    }
                }
            }
            else {
                added.push(cell);
                this.reference(cell);
            }
        });
        if (added.length) {
            if (sortable) {
                sort = true;
            }
            this.cells.splice(localIndex, 0, ...added);
            this.length = this.cells.length;
        }
        if (sort) {
            this.sort({ silent: true });
        }
        if (!localOptions.silent) {
            added.forEach((cell, i) => {
                const args = {
                    cell,
                    index: localIndex + i,
                    options: localOptions,
                };
                this.trigger('added', args);
                if (!localOptions.dryrun) {
                    cell.notify('added', Object.assign({}, args));
                }
            });
            if (sort) {
                this.trigger('sorted');
            }
            if (added.length || merged.length) {
                this.trigger('updated', {
                    added,
                    merged,
                    removed: [],
                    options: localOptions,
                });
            }
        }
        return this;
    }
    remove(cells, options = {}) {
        const arr = Array.isArray(cells) ? cells : [cells];
        const removed = this.removeCells(arr, options);
        if (!options.silent && removed.length > 0) {
            this.trigger('updated', {
                options,
                removed,
                added: [],
                merged: [],
            });
        }
        return Array.isArray(cells) ? removed : removed[0];
    }
    removeCells(cells, options) {
        const removed = [];
        for (let i = 0; i < cells.length; i += 1) {
            const cell = this.get(cells[i]);
            if (cell == null) {
                continue;
            }
            const index = this.cells.indexOf(cell);
            this.cells.splice(index, 1);
            this.length -= 1;
            delete this.map[cell.id];
            removed.push(cell);
            this.unreference(cell);
            if (!options.dryrun) {
                cell.remove();
            }
            if (!options.silent) {
                this.trigger('removed', { cell, index, options });
                if (!options.dryrun) {
                    cell.notify('removed', { cell, index, options });
                }
            }
        }
        return removed;
    }
    reset(cells, options = {}) {
        const previous = this.cells.slice();
        previous.forEach((cell) => this.unreference(cell));
        this.clean();
        this.add(cells, Object.assign({ silent: true }, options));
        if (!options.silent) {
            const current = this.cells.slice();
            this.trigger('reseted', {
                options,
                previous,
                current,
            });
            const added = [];
            const removed = [];
            current.forEach((a) => {
                const exist = previous.some((b) => b.id === a.id);
                if (!exist) {
                    added.push(a);
                }
            });
            previous.forEach((a) => {
                const exist = current.some((b) => b.id === a.id);
                if (!exist) {
                    removed.push(a);
                }
            });
            this.trigger('updated', { options, added, removed, merged: [] });
        }
        return this;
    }
    push(cell, options) {
        return this.add(cell, this.length, options);
    }
    pop(options) {
        const cell = this.at(this.length - 1);
        return this.remove(cell, options);
    }
    unshift(cell, options) {
        return this.add(cell, 0, options);
    }
    shift(options) {
        const cell = this.at(0);
        return this.remove(cell, options);
    }
    get(cell) {
        if (cell == null) {
            return null;
        }
        const id = typeof cell === 'string' || typeof cell === 'number' ? cell : cell.id;
        return this.map[id] || null;
    }
    has(cell) {
        return this.get(cell) != null;
    }
    at(index) {
        if (index < 0) {
            index += this.length; // eslint-disable-line
        }
        return this.cells[index] || null;
    }
    first() {
        return this.at(0);
    }
    last() {
        return this.at(-1);
    }
    indexOf(cell) {
        return this.cells.indexOf(cell);
    }
    toArray() {
        return this.cells.slice();
    }
    sort(options = {}) {
        if (this.comparator != null) {
            this.cells = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.sortBy(this.cells, this.comparator);
            if (!options.silent) {
                this.trigger('sorted');
            }
        }
        return this;
    }
    clone() {
        const constructor = this.constructor;
        return new constructor(this.cells.slice(), {
            comparator: this.comparator,
        });
    }
    reference(cell) {
        this.map[cell.id] = cell;
        cell.on('*', this.notifyCellEvent, this);
    }
    unreference(cell) {
        cell.off('*', this.notifyCellEvent, this);
        delete this.map[cell.id];
    }
    notifyCellEvent(name, args) {
        const cell = args.cell;
        this.trigger(`cell:${name}`, args);
        if (cell) {
            if (cell.isNode()) {
                this.trigger(`node:${name}`, Object.assign(Object.assign({}, args), { node: cell }));
            }
            else if (cell.isEdge()) {
                this.trigger(`edge:${name}`, Object.assign(Object.assign({}, args), { edge: cell }));
            }
        }
    }
    clean() {
        this.length = 0;
        this.cells = [];
        this.map = {};
    }
    dispose() {
        this.reset([]);
    }
}
__decorate([
    Collection.dispose()
], Collection.prototype, "dispose", null);
//# sourceMappingURL=collection.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/model/edge.js":
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/model/edge.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Edge: () => (/* binding */ Edge)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _registry_registry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../registry/registry */ "./node_modules/@antv/x6/es/registry/registry.js");
/* harmony import */ var _view_markup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../view/markup */ "./node_modules/@antv/x6/es/view/markup.js");
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./registry */ "./node_modules/@antv/x6/es/model/registry.js");
/* harmony import */ var _cell__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cell */ "./node_modules/@antv/x6/es/model/cell.js");
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};






class Edge extends _cell__WEBPACK_IMPORTED_MODULE_5__.Cell {
    get [Symbol.toStringTag]() {
        return Edge.toStringTag;
    }
    constructor(metadata = {}) {
        super(metadata);
    }
    preprocess(metadata, ignoreIdCheck) {
        const { source, sourceCell, sourcePort, sourcePoint, target, targetCell, targetPort, targetPoint } = metadata, others = __rest(metadata, ["source", "sourceCell", "sourcePort", "sourcePoint", "target", "targetCell", "targetPort", "targetPoint"]);
        const data = others;
        const isValidId = (val) => typeof val === 'string' || typeof val === 'number';
        if (source != null) {
            if (_cell__WEBPACK_IMPORTED_MODULE_5__.Cell.isCell(source)) {
                data.source = { cell: source.id };
            }
            else if (isValidId(source)) {
                data.source = { cell: source };
            }
            else if (_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.isPoint(source)) {
                data.source = source.toJSON();
            }
            else if (Array.isArray(source)) {
                data.source = { x: source[0], y: source[1] };
            }
            else {
                const cell = source.cell;
                if (_cell__WEBPACK_IMPORTED_MODULE_5__.Cell.isCell(cell)) {
                    data.source = Object.assign(Object.assign({}, source), { cell: cell.id });
                }
                else {
                    data.source = source;
                }
            }
        }
        if (sourceCell != null || sourcePort != null) {
            let terminal = data.source;
            if (sourceCell != null) {
                const id = isValidId(sourceCell) ? sourceCell : sourceCell.id;
                if (terminal) {
                    terminal.cell = id;
                }
                else {
                    terminal = data.source = { cell: id };
                }
            }
            if (sourcePort != null && terminal) {
                terminal.port = sourcePort;
            }
        }
        else if (sourcePoint != null) {
            data.source = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(sourcePoint).toJSON();
        }
        if (target != null) {
            if (_cell__WEBPACK_IMPORTED_MODULE_5__.Cell.isCell(target)) {
                data.target = { cell: target.id };
            }
            else if (isValidId(target)) {
                data.target = { cell: target };
            }
            else if (_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.isPoint(target)) {
                data.target = target.toJSON();
            }
            else if (Array.isArray(target)) {
                data.target = { x: target[0], y: target[1] };
            }
            else {
                const cell = target.cell;
                if (_cell__WEBPACK_IMPORTED_MODULE_5__.Cell.isCell(cell)) {
                    data.target = Object.assign(Object.assign({}, target), { cell: cell.id });
                }
                else {
                    data.target = target;
                }
            }
        }
        if (targetCell != null || targetPort != null) {
            let terminal = data.target;
            if (targetCell != null) {
                const id = isValidId(targetCell) ? targetCell : targetCell.id;
                if (terminal) {
                    terminal.cell = id;
                }
                else {
                    terminal = data.target = { cell: id };
                }
            }
            if (targetPort != null && terminal) {
                terminal.port = targetPort;
            }
        }
        else if (targetPoint != null) {
            data.target = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(targetPoint).toJSON();
        }
        return super.preprocess(data, ignoreIdCheck);
    }
    setup() {
        super.setup();
        this.on('change:labels', (args) => this.onLabelsChanged(args));
        this.on('change:vertices', (args) => this.onVertexsChanged(args));
    }
    isEdge() {
        return true;
    }
    // #region terminal
    disconnect(options = {}) {
        this.store.set({
            source: { x: 0, y: 0 },
            target: { x: 0, y: 0 },
        }, options);
        return this;
    }
    get source() {
        return this.getSource();
    }
    set source(data) {
        this.setSource(data);
    }
    getSource() {
        return this.getTerminal('source');
    }
    getSourceCellId() {
        return this.source.cell;
    }
    getSourcePortId() {
        return this.source.port;
    }
    setSource(source, args, options = {}) {
        return this.setTerminal('source', source, args, options);
    }
    get target() {
        return this.getTarget();
    }
    set target(data) {
        this.setTarget(data);
    }
    getTarget() {
        return this.getTerminal('target');
    }
    getTargetCellId() {
        return this.target.cell;
    }
    getTargetPortId() {
        return this.target.port;
    }
    setTarget(target, args, options = {}) {
        return this.setTerminal('target', target, args, options);
    }
    getTerminal(type) {
        return Object.assign({}, this.store.get(type));
    }
    setTerminal(type, terminal, args, options = {}) {
        // `terminal` is a cell
        if (_cell__WEBPACK_IMPORTED_MODULE_5__.Cell.isCell(terminal)) {
            this.store.set(type, _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.merge({}, args, { cell: terminal.id }), options);
            return this;
        }
        // `terminal` is a point-like object
        const p = terminal;
        if (_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.isPoint(terminal) || (p.x != null && p.y != null)) {
            this.store.set(type, _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.merge({}, args, { x: p.x, y: p.y }), options);
            return this;
        }
        // `terminal` is an object
        this.store.set(type, _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(terminal), options);
        return this;
    }
    getSourcePoint() {
        return this.getTerminalPoint('source');
    }
    getTargetPoint() {
        return this.getTerminalPoint('target');
    }
    getTerminalPoint(type) {
        const terminal = this[type];
        if (_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.isPointLike(terminal)) {
            return _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(terminal);
        }
        const cell = this.getTerminalCell(type);
        if (cell) {
            return cell.getConnectionPoint(this, type);
        }
        return new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point();
    }
    getSourceCell() {
        return this.getTerminalCell('source');
    }
    getTargetCell() {
        return this.getTerminalCell('target');
    }
    getTerminalCell(type) {
        if (this.model) {
            const cellId = type === 'source' ? this.getSourceCellId() : this.getTargetCellId();
            if (cellId) {
                return this.model.getCell(cellId);
            }
        }
        return null;
    }
    getSourceNode() {
        return this.getTerminalNode('source');
    }
    getTargetNode() {
        return this.getTerminalNode('target');
    }
    getTerminalNode(type) {
        let cell = this; // eslint-disable-line
        const visited = {};
        while (cell && cell.isEdge()) {
            if (visited[cell.id]) {
                return null;
            }
            visited[cell.id] = true;
            cell = cell.getTerminalCell(type);
        }
        return cell && cell.isNode() ? cell : null;
    }
    // #endregion
    // #region router
    get router() {
        return this.getRouter();
    }
    set router(data) {
        if (data == null) {
            this.removeRouter();
        }
        else {
            this.setRouter(data);
        }
    }
    getRouter() {
        return this.store.get('router');
    }
    setRouter(name, args, options) {
        if (typeof name === 'object') {
            this.store.set('router', name, args);
        }
        else {
            this.store.set('router', { name, args }, options);
        }
        return this;
    }
    removeRouter(options = {}) {
        this.store.remove('router', options);
        return this;
    }
    // #endregion
    // #region connector
    get connector() {
        return this.getConnector();
    }
    set connector(data) {
        if (data == null) {
            this.removeConnector();
        }
        else {
            this.setConnector(data);
        }
    }
    getConnector() {
        return this.store.get('connector');
    }
    setConnector(name, args, options) {
        if (typeof name === 'object') {
            this.store.set('connector', name, args);
        }
        else {
            this.store.set('connector', { name, args }, options);
        }
        return this;
    }
    removeConnector(options = {}) {
        return this.store.remove('connector', options);
    }
    // #endregion
    // #region labels
    getDefaultLabel() {
        const ctor = this.constructor;
        const defaults = this.store.get('defaultLabel') || ctor.defaultLabel || {};
        return _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(defaults);
    }
    get labels() {
        return this.getLabels();
    }
    set labels(labels) {
        this.setLabels(labels);
    }
    getLabels() {
        return [...this.store.get('labels', [])].map((item) => this.parseLabel(item));
    }
    setLabels(labels, options = {}) {
        this.store.set('labels', Array.isArray(labels) ? labels : [labels], options);
        return this;
    }
    insertLabel(label, index, options = {}) {
        const labels = this.getLabels();
        const len = labels.length;
        let idx = index != null && Number.isFinite(index) ? index : len;
        if (idx < 0) {
            idx = len + idx + 1;
        }
        labels.splice(idx, 0, this.parseLabel(label));
        return this.setLabels(labels, options);
    }
    appendLabel(label, options = {}) {
        return this.insertLabel(label, -1, options);
    }
    getLabelAt(index) {
        const labels = this.getLabels();
        if (index != null && Number.isFinite(index)) {
            return this.parseLabel(labels[index]);
        }
        return null;
    }
    setLabelAt(index, label, options = {}) {
        if (index != null && Number.isFinite(index)) {
            const labels = this.getLabels();
            labels[index] = this.parseLabel(label);
            this.setLabels(labels, options);
        }
        return this;
    }
    removeLabelAt(index, options = {}) {
        const labels = this.getLabels();
        const idx = index != null && Number.isFinite(index) ? index : -1;
        const removed = labels.splice(idx, 1);
        this.setLabels(labels, options);
        return removed.length ? removed[0] : null;
    }
    parseLabel(label) {
        if (typeof label === 'string') {
            const ctor = this.constructor;
            return ctor.parseStringLabel(label);
        }
        return label;
    }
    onLabelsChanged({ previous, current, }) {
        const added = previous && current
            ? current.filter((label1) => {
                if (!previous.find((label2) => label1 === label2 || _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isEqual(label1, label2))) {
                    return label1;
                }
                return null;
            })
            : current
                ? [...current]
                : [];
        const removed = previous && current
            ? previous.filter((label1) => {
                if (!current.find((label2) => label1 === label2 || _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isEqual(label1, label2))) {
                    return label1;
                }
                return null;
            })
            : previous
                ? [...previous]
                : [];
        if (added.length > 0) {
            this.notify('labels:added', { added, cell: this, edge: this });
        }
        if (removed.length > 0) {
            this.notify('labels:removed', { removed, cell: this, edge: this });
        }
    }
    // #endregion
    // #region vertices
    get vertices() {
        return this.getVertices();
    }
    set vertices(vertices) {
        this.setVertices(vertices);
    }
    getVertices() {
        return [...this.store.get('vertices', [])];
    }
    setVertices(vertices, options = {}) {
        const points = Array.isArray(vertices) ? vertices : [vertices];
        this.store.set('vertices', points.map((p) => _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.toJSON(p)), options);
        return this;
    }
    insertVertex(vertice, index, options = {}) {
        const vertices = this.getVertices();
        const len = vertices.length;
        let idx = index != null && Number.isFinite(index) ? index : len;
        if (idx < 0) {
            idx = len + idx + 1;
        }
        vertices.splice(idx, 0, _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.toJSON(vertice));
        return this.setVertices(vertices, options);
    }
    appendVertex(vertex, options = {}) {
        return this.insertVertex(vertex, -1, options);
    }
    getVertexAt(index) {
        if (index != null && Number.isFinite(index)) {
            const vertices = this.getVertices();
            return vertices[index];
        }
        return null;
    }
    setVertexAt(index, vertice, options = {}) {
        if (index != null && Number.isFinite(index)) {
            const vertices = this.getVertices();
            vertices[index] = vertice;
            this.setVertices(vertices, options);
        }
        return this;
    }
    removeVertexAt(index, options = {}) {
        const vertices = this.getVertices();
        const idx = index != null && Number.isFinite(index) ? index : -1;
        vertices.splice(idx, 1);
        return this.setVertices(vertices, options);
    }
    onVertexsChanged({ previous, current, }) {
        const added = previous && current
            ? current.filter((p1) => {
                if (!previous.find((p2) => _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.equals(p1, p2))) {
                    return p1;
                }
                return null;
            })
            : current
                ? [...current]
                : [];
        const removed = previous && current
            ? previous.filter((p1) => {
                if (!current.find((p2) => _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.equals(p1, p2))) {
                    return p1;
                }
                return null;
            })
            : previous
                ? [...previous]
                : [];
        if (added.length > 0) {
            this.notify('vertexs:added', { added, cell: this, edge: this });
        }
        if (removed.length > 0) {
            this.notify('vertexs:removed', { removed, cell: this, edge: this });
        }
    }
    // #endregion
    // #region markup
    getDefaultMarkup() {
        return this.store.get('defaultMarkup') || _view_markup__WEBPACK_IMPORTED_MODULE_3__.Markup.getEdgeMarkup();
    }
    getMarkup() {
        return super.getMarkup() || this.getDefaultMarkup();
    }
    // #endregion
    // #region transform
    /**
     * Translate the edge vertices (and source and target if they are points)
     * by `tx` pixels in the x-axis and `ty` pixels in the y-axis.
     */
    translate(tx, ty, options = {}) {
        options.translateBy = options.translateBy || this.id;
        options.tx = tx;
        options.ty = ty;
        return this.applyToPoints((p) => ({
            x: (p.x || 0) + tx,
            y: (p.y || 0) + ty,
        }), options);
    }
    /**
     * Scales the edge's points (vertices) relative to the given origin.
     */
    scale(sx, sy, origin, options = {}) {
        return this.applyToPoints((p) => {
            return _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(p).scale(sx, sy, origin).toJSON();
        }, options);
    }
    applyToPoints(worker, options = {}) {
        const attrs = {};
        const source = this.getSource();
        const target = this.getTarget();
        if (_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.isPointLike(source)) {
            attrs.source = worker(source);
        }
        if (_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.isPointLike(target)) {
            attrs.target = worker(target);
        }
        const vertices = this.getVertices();
        if (vertices.length > 0) {
            attrs.vertices = vertices.map(worker);
        }
        this.store.set(attrs, options);
        return this;
    }
    // #endregion
    // #region common
    getBBox() {
        return this.getPolyline().bbox();
    }
    getConnectionPoint() {
        return this.getPolyline().pointAt(0.5);
    }
    getPolyline() {
        const points = [
            this.getSourcePoint(),
            ...this.getVertices().map((vertice) => _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(vertice)),
            this.getTargetPoint(),
        ];
        return new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Polyline(points);
    }
    updateParent(options) {
        let newParent = null;
        const source = this.getSourceCell();
        const target = this.getTargetCell();
        const prevParent = this.getParent();
        if (source && target) {
            if (source === target || source.isDescendantOf(target)) {
                newParent = target;
            }
            else if (target.isDescendantOf(source)) {
                newParent = source;
            }
            else {
                newParent = _cell__WEBPACK_IMPORTED_MODULE_5__.Cell.getCommonAncestor(source, target);
            }
        }
        // Unembeds the edge if source and target has no common
        // ancestor or common ancestor changed
        if (prevParent && newParent && newParent.id !== prevParent.id) {
            prevParent.unembed(this, options);
        }
        // Embeds the edge if source and target are not same
        if (newParent && (!prevParent || prevParent.id !== newParent.id)) {
            newParent.embed(this, options);
        }
        return newParent;
    }
    hasLoop(options = {}) {
        const source = this.getSource();
        const target = this.getTarget();
        const sourceId = source.cell;
        const targetId = target.cell;
        if (!sourceId || !targetId) {
            return false;
        }
        let loop = sourceId === targetId;
        // Note that there in the deep mode a edge can have a loop,
        // even if it connects only a parent and its embed.
        // A loop "target equals source" is valid in both shallow and deep mode.
        // eslint-disable-next-line
        if (!loop && options.deep && this._model) {
            const sourceCell = this.getSourceCell();
            const targetCell = this.getTargetCell();
            if (sourceCell && targetCell) {
                loop =
                    sourceCell.isAncestorOf(targetCell, options) ||
                        targetCell.isAncestorOf(sourceCell, options);
            }
        }
        return loop;
    }
    getFragmentAncestor() {
        const cells = [this, this.getSourceNode(), this.getTargetNode()].filter((item) => item != null);
        return this.getCommonAncestor(...cells);
    }
    isFragmentDescendantOf(cell) {
        const ancestor = this.getFragmentAncestor();
        return (!!ancestor && (ancestor.id === cell.id || ancestor.isDescendantOf(cell)));
    }
}
Edge.defaults = {};
(function (Edge) {
    function equalTerminals(a, b) {
        const a1 = a;
        const b1 = b;
        if (a1.cell === b1.cell) {
            return a1.port === b1.port || (a1.port == null && b1.port == null);
        }
        return false;
    }
    Edge.equalTerminals = equalTerminals;
})(Edge || (Edge = {}));
(function (Edge) {
    Edge.defaultLabel = {
        markup: [
            {
                tagName: 'rect',
                selector: 'body',
            },
            {
                tagName: 'text',
                selector: 'label',
            },
        ],
        attrs: {
            text: {
                fill: '#000',
                fontSize: 14,
                textAnchor: 'middle',
                textVerticalAnchor: 'middle',
                pointerEvents: 'none',
            },
            rect: {
                ref: 'label',
                fill: '#fff',
                rx: 3,
                ry: 3,
                refWidth: 1,
                refHeight: 1,
                refX: 0,
                refY: 0,
            },
        },
        position: {
            distance: 0.5,
        },
    };
    function parseStringLabel(text) {
        return {
            attrs: { label: { text } },
        };
    }
    Edge.parseStringLabel = parseStringLabel;
})(Edge || (Edge = {}));
(function (Edge) {
    Edge.toStringTag = `X6.${Edge.name}`;
    function isEdge(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof Edge) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const edge = instance;
        if ((tag == null || tag === Edge.toStringTag) &&
            typeof edge.isNode === 'function' &&
            typeof edge.isEdge === 'function' &&
            typeof edge.prop === 'function' &&
            typeof edge.attr === 'function' &&
            typeof edge.disconnect === 'function' &&
            typeof edge.getSource === 'function' &&
            typeof edge.getTarget === 'function') {
            return true;
        }
        return false;
    }
    Edge.isEdge = isEdge;
})(Edge || (Edge = {}));
(function (Edge) {
    Edge.registry = _registry_registry__WEBPACK_IMPORTED_MODULE_2__.Registry.create({
        type: 'edge',
        process(shape, options) {
            if (_registry__WEBPACK_IMPORTED_MODULE_4__.ShareRegistry.exist(shape, false)) {
                throw new Error(`Edge with name '${shape}' was registered by anthor Node`);
            }
            if (typeof options === 'function') {
                options.config({ shape });
                return options;
            }
            let parent = Edge;
            // default inherit from 'dege'
            const { inherit = 'edge' } = options, others = __rest(options, ["inherit"]);
            if (typeof inherit === 'string') {
                const base = this.get(inherit || 'edge');
                if (base == null && inherit) {
                    this.onNotFound(inherit, 'inherited');
                }
                else {
                    parent = base;
                }
            }
            else {
                parent = inherit;
            }
            if (others.constructorName == null) {
                others.constructorName = shape;
            }
            const ctor = parent.define.call(parent, others);
            ctor.config({ shape });
            return ctor;
        },
    });
    _registry__WEBPACK_IMPORTED_MODULE_4__.ShareRegistry.setEdgeRegistry(Edge.registry);
})(Edge || (Edge = {}));
(function (Edge) {
    let counter = 0;
    function getClassName(name) {
        if (name) {
            return _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.StringExt.pascalCase(name);
        }
        counter += 1;
        return `CustomEdge${counter}`;
    }
    function define(config) {
        const { constructorName, overwrite } = config, others = __rest(config, ["constructorName", "overwrite"]);
        const ctor = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.createClass(getClassName(constructorName || others.shape), this);
        ctor.config(others);
        if (others.shape) {
            Edge.registry.register(others.shape, ctor, overwrite);
        }
        return ctor;
    }
    Edge.define = define;
    function create(options) {
        const shape = options.shape || 'edge';
        const Ctor = Edge.registry.get(shape);
        if (Ctor) {
            return new Ctor(options);
        }
        return Edge.registry.onNotFound(shape);
    }
    Edge.create = create;
})(Edge || (Edge = {}));
(function (Edge) {
    const shape = 'basic.edge';
    Edge.config({
        shape,
        propHooks(metadata) {
            const { label, vertices } = metadata, others = __rest(metadata, ["label", "vertices"]);
            if (label) {
                if (others.labels == null) {
                    others.labels = [];
                }
                const formated = typeof label === 'string' ? Edge.parseStringLabel(label) : label;
                others.labels.push(formated);
            }
            if (vertices) {
                if (Array.isArray(vertices)) {
                    others.vertices = vertices.map((item) => _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(item).toJSON());
                }
            }
            return others;
        },
    });
    Edge.registry.register(shape, Edge);
})(Edge || (Edge = {}));
//# sourceMappingURL=edge.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/model/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@antv/x6/es/model/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Cell: () => (/* reexport safe */ _cell__WEBPACK_IMPORTED_MODULE_0__.Cell),
/* harmony export */   Collection: () => (/* reexport safe */ _collection__WEBPACK_IMPORTED_MODULE_4__.Collection),
/* harmony export */   Edge: () => (/* reexport safe */ _edge__WEBPACK_IMPORTED_MODULE_2__.Edge),
/* harmony export */   Model: () => (/* reexport safe */ _model__WEBPACK_IMPORTED_MODULE_3__.Model),
/* harmony export */   Node: () => (/* reexport safe */ _node__WEBPACK_IMPORTED_MODULE_1__.Node)
/* harmony export */ });
/* harmony import */ var _cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cell */ "./node_modules/@antv/x6/es/model/cell.js");
/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node */ "./node_modules/@antv/x6/es/model/node.js");
/* harmony import */ var _edge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./edge */ "./node_modules/@antv/x6/es/model/edge.js");
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./model */ "./node_modules/@antv/x6/es/model/model.js");
/* harmony import */ var _collection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./collection */ "./node_modules/@antv/x6/es/model/collection.js");





//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/model/model.js":
/*!*************************************************!*\
  !*** ./node_modules/@antv/x6/es/model/model.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Model: () => (/* binding */ Model)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _cell__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cell */ "./node_modules/@antv/x6/es/model/cell.js");
/* harmony import */ var _edge__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./edge */ "./node_modules/@antv/x6/es/model/edge.js");
/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./node */ "./node_modules/@antv/x6/es/model/node.js");
/* harmony import */ var _collection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./collection */ "./node_modules/@antv/x6/es/model/collection.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};






class Model extends _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Basecoat {
    get [Symbol.toStringTag]() {
        return Model.toStringTag;
    }
    constructor(cells = []) {
        super();
        this.batches = {};
        this.addings = new WeakMap();
        this.nodes = {};
        this.edges = {};
        this.outgoings = {};
        this.incomings = {};
        this.collection = new _collection__WEBPACK_IMPORTED_MODULE_5__.Collection(cells);
        this.setup();
    }
    notify(name, args) {
        this.trigger(name, args);
        const graph = this.graph;
        if (graph) {
            if (name === 'sorted' || name === 'reseted' || name === 'updated') {
                graph.trigger(`model:${name}`, args);
            }
            else {
                graph.trigger(name, args);
            }
        }
        return this;
    }
    setup() {
        const collection = this.collection;
        collection.on('sorted', () => this.notify('sorted', null));
        collection.on('updated', (args) => this.notify('updated', args));
        collection.on('cell:change:zIndex', () => this.sortOnChangeZ());
        collection.on('added', ({ cell }) => {
            this.onCellAdded(cell);
        });
        collection.on('removed', (args) => {
            const cell = args.cell;
            this.onCellRemoved(cell, args.options);
            // Should trigger remove-event manually after cell was removed.
            this.notify('cell:removed', args);
            if (cell.isNode()) {
                this.notify('node:removed', Object.assign(Object.assign({}, args), { node: cell }));
            }
            else if (cell.isEdge()) {
                this.notify('edge:removed', Object.assign(Object.assign({}, args), { edge: cell }));
            }
        });
        collection.on('reseted', (args) => {
            this.onReset(args.current);
            this.notify('reseted', args);
        });
        collection.on('edge:change:source', ({ edge }) => this.onEdgeTerminalChanged(edge, 'source'));
        collection.on('edge:change:target', ({ edge }) => {
            this.onEdgeTerminalChanged(edge, 'target');
        });
    }
    sortOnChangeZ() {
        this.collection.sort();
    }
    onCellAdded(cell) {
        const cellId = cell.id;
        if (cell.isEdge()) {
            // Auto update edge's parent
            cell.updateParent();
            this.edges[cellId] = true;
            this.onEdgeTerminalChanged(cell, 'source');
            this.onEdgeTerminalChanged(cell, 'target');
        }
        else {
            this.nodes[cellId] = true;
        }
    }
    onCellRemoved(cell, options) {
        const cellId = cell.id;
        if (cell.isEdge()) {
            delete this.edges[cellId];
            const source = cell.getSource();
            const target = cell.getTarget();
            if (source && source.cell) {
                const cache = this.outgoings[source.cell];
                const index = cache ? cache.indexOf(cellId) : -1;
                if (index >= 0) {
                    cache.splice(index, 1);
                    if (cache.length === 0) {
                        delete this.outgoings[source.cell];
                    }
                }
            }
            if (target && target.cell) {
                const cache = this.incomings[target.cell];
                const index = cache ? cache.indexOf(cellId) : -1;
                if (index >= 0) {
                    cache.splice(index, 1);
                    if (cache.length === 0) {
                        delete this.incomings[target.cell];
                    }
                }
            }
        }
        else {
            delete this.nodes[cellId];
        }
        if (!options.clear) {
            if (options.disconnectEdges) {
                this.disconnectConnectedEdges(cell, options);
            }
            else {
                this.removeConnectedEdges(cell, options);
            }
        }
        if (cell.model === this) {
            cell.model = null;
        }
    }
    onReset(cells) {
        this.nodes = {};
        this.edges = {};
        this.outgoings = {};
        this.incomings = {};
        cells.forEach((cell) => this.onCellAdded(cell));
    }
    onEdgeTerminalChanged(edge, type) {
        const ref = type === 'source' ? this.outgoings : this.incomings;
        const prev = edge.previous(type);
        if (prev && prev.cell) {
            const cellId = _cell__WEBPACK_IMPORTED_MODULE_2__.Cell.isCell(prev.cell) ? prev.cell.id : prev.cell;
            const cache = ref[cellId];
            const index = cache ? cache.indexOf(edge.id) : -1;
            if (index >= 0) {
                cache.splice(index, 1);
                if (cache.length === 0) {
                    delete ref[cellId];
                }
            }
        }
        const terminal = edge.getTerminal(type);
        if (terminal && terminal.cell) {
            const terminalId = _cell__WEBPACK_IMPORTED_MODULE_2__.Cell.isCell(terminal.cell)
                ? terminal.cell.id
                : terminal.cell;
            const cache = ref[terminalId] || [];
            const index = cache.indexOf(edge.id);
            if (index === -1) {
                cache.push(edge.id);
            }
            ref[terminalId] = cache;
        }
    }
    prepareCell(cell, options) {
        if (!cell.model && (!options || !options.dryrun)) {
            cell.model = this;
        }
        if (cell.zIndex == null) {
            cell.setZIndex(this.getMaxZIndex() + 1, { silent: true });
        }
        return cell;
    }
    resetCells(cells, options = {}) {
        // Do not update model at this time. Because if we just update the graph
        // with the same json-data, the edge will reference to the old nodes.
        cells.map((cell) => this.prepareCell(cell, Object.assign(Object.assign({}, options), { dryrun: true })));
        this.collection.reset(cells, options);
        // Update model and trigger edge update it's references
        cells.map((cell) => this.prepareCell(cell, { options }));
        return this;
    }
    clear(options = {}) {
        const raw = this.getCells();
        if (raw.length === 0) {
            return this;
        }
        const localOptions = Object.assign(Object.assign({}, options), { clear: true });
        this.batchUpdate('clear', () => {
            // The nodes come after the edges.
            const cells = raw.sort((a, b) => {
                const v1 = a.isEdge() ? 1 : 2;
                const v2 = b.isEdge() ? 1 : 2;
                return v1 - v2;
            });
            while (cells.length > 0) {
                // Note that all the edges are removed first, so it's safe to
                // remove the nodes without removing the connected edges first.
                const cell = cells.shift();
                if (cell) {
                    cell.remove(localOptions);
                }
            }
        }, localOptions);
        return this;
    }
    addNode(metadata, options = {}) {
        const node = _node__WEBPACK_IMPORTED_MODULE_4__.Node.isNode(metadata) ? metadata : this.createNode(metadata);
        this.addCell(node, options);
        return node;
    }
    updateNode(metadata, options = {}) {
        const node = this.createNode(metadata);
        const prop = node.getProp();
        node.dispose();
        return this.updateCell(prop, options);
    }
    createNode(metadata) {
        return _node__WEBPACK_IMPORTED_MODULE_4__.Node.create(metadata);
    }
    addEdge(metadata, options = {}) {
        const edge = _edge__WEBPACK_IMPORTED_MODULE_3__.Edge.isEdge(metadata) ? metadata : this.createEdge(metadata);
        this.addCell(edge, options);
        return edge;
    }
    createEdge(metadata) {
        return _edge__WEBPACK_IMPORTED_MODULE_3__.Edge.create(metadata);
    }
    updateEdge(metadata, options = {}) {
        const edge = this.createEdge(metadata);
        const prop = edge.getProp();
        edge.dispose();
        return this.updateCell(prop, options);
    }
    addCell(cell, options = {}) {
        if (Array.isArray(cell)) {
            return this.addCells(cell, options);
        }
        if (!this.collection.has(cell) && !this.addings.has(cell)) {
            this.addings.set(cell, true);
            this.collection.add(this.prepareCell(cell, options), options);
            cell.eachChild((child) => this.addCell(child, options));
            this.addings.delete(cell);
        }
        return this;
    }
    addCells(cells, options = {}) {
        const count = cells.length;
        if (count === 0) {
            return this;
        }
        const localOptions = Object.assign(Object.assign({}, options), { position: count - 1, maxPosition: count - 1 });
        this.startBatch('add', Object.assign(Object.assign({}, localOptions), { cells }));
        cells.forEach((cell) => {
            this.addCell(cell, localOptions);
            localOptions.position -= 1;
        });
        this.stopBatch('add', Object.assign(Object.assign({}, localOptions), { cells }));
        return this;
    }
    updateCell(prop, options = {}) {
        const existing = prop.id && this.getCell(prop.id);
        if (existing) {
            return this.batchUpdate('update', () => {
                Object.entries(prop).forEach(([key, val]) => existing.setProp(key, val, options));
                return true;
            }, prop);
        }
        return false;
    }
    removeCell(obj, options = {}) {
        const cell = typeof obj === 'string' ? this.getCell(obj) : obj;
        if (cell && this.has(cell)) {
            return this.collection.remove(cell, options);
        }
        return null;
    }
    updateCellId(cell, newId) {
        if (cell.id === newId)
            return;
        this.startBatch('update', { id: newId });
        cell.prop('id', newId);
        const newCell = cell.clone({ keepId: true });
        this.addCell(newCell);
        // update connected edge terminal
        const edges = this.getConnectedEdges(cell);
        edges.forEach((edge) => {
            const sourceCell = edge.getSourceCell();
            const targetCell = edge.getTargetCell();
            if (sourceCell === cell) {
                edge.setSource(Object.assign(Object.assign({}, edge.getSource()), { cell: newId }));
            }
            if (targetCell === cell) {
                edge.setTarget(Object.assign(Object.assign({}, edge.getTarget()), { cell: newId }));
            }
        });
        this.removeCell(cell);
        this.stopBatch('update', { id: newId });
        return newCell;
    }
    removeCells(cells, options = {}) {
        if (cells.length) {
            return this.batchUpdate('remove', () => {
                return cells.map((cell) => this.removeCell(cell, options));
            });
        }
        return [];
    }
    removeConnectedEdges(cell, options = {}) {
        const edges = this.getConnectedEdges(cell);
        edges.forEach((edge) => {
            edge.remove(options);
        });
        return edges;
    }
    disconnectConnectedEdges(cell, options = {}) {
        const cellId = typeof cell === 'string' ? cell : cell.id;
        this.getConnectedEdges(cell).forEach((edge) => {
            const sourceCellId = edge.getSourceCellId();
            const targetCellId = edge.getTargetCellId();
            if (sourceCellId === cellId) {
                edge.setSource({ x: 0, y: 0 }, options);
            }
            if (targetCellId === cellId) {
                edge.setTarget({ x: 0, y: 0 }, options);
            }
        });
    }
    has(obj) {
        return this.collection.has(obj);
    }
    total() {
        return this.collection.length;
    }
    indexOf(cell) {
        return this.collection.indexOf(cell);
    }
    /**
     * Returns a cell from the graph by its id.
     */
    getCell(id) {
        return this.collection.get(id);
    }
    /**
     * Returns all the nodes and edges in the graph.
     */
    getCells() {
        return this.collection.toArray();
    }
    /**
     * Returns the first cell (node or edge) in the graph. The first cell is
     * defined as the cell with the lowest `zIndex`.
     */
    getFirstCell() {
        return this.collection.first();
    }
    /**
     * Returns the last cell (node or edge) in the graph. The last cell is
     * defined as the cell with the highest `zIndex`.
     */
    getLastCell() {
        return this.collection.last();
    }
    /**
     * Returns the lowest `zIndex` value in the graph.
     */
    getMinZIndex() {
        const first = this.collection.first();
        return first ? first.getZIndex() || 0 : 0;
    }
    /**
     * Returns the highest `zIndex` value in the graph.
     */
    getMaxZIndex() {
        const last = this.collection.last();
        return last ? last.getZIndex() || 0 : 0;
    }
    getCellsFromCache(cache) {
        return cache
            ? Object.keys(cache)
                .map((id) => this.getCell(id))
                .filter((cell) => cell != null)
            : [];
    }
    /**
     * Returns all the nodes in the graph.
     */
    getNodes() {
        return this.getCellsFromCache(this.nodes);
    }
    /**
     * Returns all the edges in the graph.
     */
    getEdges() {
        return this.getCellsFromCache(this.edges);
    }
    /**
     * Returns all outgoing edges for the node.
     */
    getOutgoingEdges(cell) {
        const cellId = typeof cell === 'string' ? cell : cell.id;
        const cellIds = this.outgoings[cellId];
        return cellIds
            ? cellIds
                .map((id) => this.getCell(id))
                .filter((cell) => cell && cell.isEdge())
            : null;
    }
    /**
     * Returns all incoming edges for the node.
     */
    getIncomingEdges(cell) {
        const cellId = typeof cell === 'string' ? cell : cell.id;
        const cellIds = this.incomings[cellId];
        return cellIds
            ? cellIds
                .map((id) => this.getCell(id))
                .filter((cell) => cell && cell.isEdge())
            : null;
    }
    /**
     * Returns edges connected with cell.
     */
    getConnectedEdges(cell, options = {}) {
        const result = [];
        const node = typeof cell === 'string' ? this.getCell(cell) : cell;
        if (node == null) {
            return result;
        }
        const cache = {};
        const indirect = options.indirect;
        let incoming = options.incoming;
        let outgoing = options.outgoing;
        if (incoming == null && outgoing == null) {
            incoming = outgoing = true;
        }
        const collect = (cell, isOutgoing) => {
            const edges = isOutgoing
                ? this.getOutgoingEdges(cell)
                : this.getIncomingEdges(cell);
            if (edges != null) {
                edges.forEach((edge) => {
                    if (cache[edge.id]) {
                        return;
                    }
                    result.push(edge);
                    cache[edge.id] = true;
                    if (indirect) {
                        if (incoming) {
                            collect(edge, false);
                        }
                        if (outgoing) {
                            collect(edge, true);
                        }
                    }
                });
            }
            if (indirect && cell.isEdge()) {
                const terminal = isOutgoing
                    ? cell.getTargetCell()
                    : cell.getSourceCell();
                if (terminal && terminal.isEdge()) {
                    if (!cache[terminal.id]) {
                        result.push(terminal);
                        collect(terminal, isOutgoing);
                    }
                }
            }
        };
        if (outgoing) {
            collect(node, true);
        }
        if (incoming) {
            collect(node, false);
        }
        if (options.deep) {
            const descendants = node.getDescendants({ deep: true });
            const embedsCache = {};
            descendants.forEach((cell) => {
                if (cell.isNode()) {
                    embedsCache[cell.id] = true;
                }
            });
            const collectSub = (cell, isOutgoing) => {
                const edges = isOutgoing
                    ? this.getOutgoingEdges(cell.id)
                    : this.getIncomingEdges(cell.id);
                if (edges != null) {
                    edges.forEach((edge) => {
                        if (!cache[edge.id]) {
                            const sourceCell = edge.getSourceCell();
                            const targetCell = edge.getTargetCell();
                            if (!options.enclosed &&
                                sourceCell &&
                                embedsCache[sourceCell.id] &&
                                targetCell &&
                                embedsCache[targetCell.id]) {
                                return;
                            }
                            result.push(edge);
                            cache[edge.id] = true;
                        }
                    });
                }
            };
            descendants.forEach((cell) => {
                if (cell.isEdge()) {
                    return;
                }
                if (outgoing) {
                    collectSub(cell, true);
                }
                if (incoming) {
                    collectSub(cell, false);
                }
            });
        }
        return result;
    }
    isBoundary(cell, isOrigin) {
        const node = typeof cell === 'string' ? this.getCell(cell) : cell;
        const arr = isOrigin
            ? this.getIncomingEdges(node)
            : this.getOutgoingEdges(node);
        return arr == null || arr.length === 0;
    }
    getBoundaryNodes(isOrigin) {
        const result = [];
        Object.keys(this.nodes).forEach((nodeId) => {
            if (this.isBoundary(nodeId, isOrigin)) {
                const node = this.getCell(nodeId);
                if (node) {
                    result.push(node);
                }
            }
        });
        return result;
    }
    /**
     * Returns an array of all the roots of the graph.
     */
    getRoots() {
        return this.getBoundaryNodes(true);
    }
    /**
     * Returns an array of all the leafs of the graph.
     */
    getLeafs() {
        return this.getBoundaryNodes(false);
    }
    /**
     * Returns `true` if the node is a root node, i.e. there is no edges
     * coming to the node.
     */
    isRoot(cell) {
        return this.isBoundary(cell, true);
    }
    /**
     * Returns `true` if the node is a leaf node, i.e. there is no edges
     * going out from the node.
     */
    isLeaf(cell) {
        return this.isBoundary(cell, false);
    }
    /**
     * Returns all the neighbors of node in the graph. Neighbors are all
     * the nodes connected to node via either incoming or outgoing edge.
     */
    getNeighbors(cell, options = {}) {
        let incoming = options.incoming;
        let outgoing = options.outgoing;
        if (incoming == null && outgoing == null) {
            incoming = outgoing = true;
        }
        const edges = this.getConnectedEdges(cell, options);
        const map = edges.reduce((memo, edge) => {
            const hasLoop = edge.hasLoop(options);
            const sourceCell = edge.getSourceCell();
            const targetCell = edge.getTargetCell();
            if (incoming &&
                sourceCell &&
                sourceCell.isNode() &&
                !memo[sourceCell.id]) {
                if (hasLoop ||
                    (sourceCell !== cell &&
                        (!options.deep || !sourceCell.isDescendantOf(cell)))) {
                    memo[sourceCell.id] = sourceCell;
                }
            }
            if (outgoing &&
                targetCell &&
                targetCell.isNode() &&
                !memo[targetCell.id]) {
                if (hasLoop ||
                    (targetCell !== cell &&
                        (!options.deep || !targetCell.isDescendantOf(cell)))) {
                    memo[targetCell.id] = targetCell;
                }
            }
            return memo;
        }, {});
        if (cell.isEdge()) {
            if (incoming) {
                const sourceCell = cell.getSourceCell();
                if (sourceCell && sourceCell.isNode() && !map[sourceCell.id]) {
                    map[sourceCell.id] = sourceCell;
                }
            }
            if (outgoing) {
                const targetCell = cell.getTargetCell();
                if (targetCell && targetCell.isNode() && !map[targetCell.id]) {
                    map[targetCell.id] = targetCell;
                }
            }
        }
        return Object.keys(map).map((id) => map[id]);
    }
    /**
     * Returns `true` if `cell2` is a neighbor of `cell1`.
     */
    isNeighbor(cell1, cell2, options = {}) {
        let incoming = options.incoming;
        let outgoing = options.outgoing;
        if (incoming == null && outgoing == null) {
            incoming = outgoing = true;
        }
        return this.getConnectedEdges(cell1, options).some((edge) => {
            const sourceCell = edge.getSourceCell();
            const targetCell = edge.getTargetCell();
            if (incoming && sourceCell && sourceCell.id === cell2.id) {
                return true;
            }
            if (outgoing && targetCell && targetCell.id === cell2.id) {
                return true;
            }
            return false;
        });
    }
    getSuccessors(cell, options = {}) {
        const successors = [];
        this.search(cell, (curr, distance) => {
            if (curr !== cell && this.matchDistance(distance, options.distance)) {
                successors.push(curr);
            }
        }, Object.assign(Object.assign({}, options), { outgoing: true }));
        return successors;
    }
    /**
     * Returns `true` if `cell2` is a successor of `cell1`.
     */
    isSuccessor(cell1, cell2, options = {}) {
        let result = false;
        this.search(cell1, (curr, distance) => {
            if (curr === cell2 &&
                curr !== cell1 &&
                this.matchDistance(distance, options.distance)) {
                result = true;
                return false;
            }
        }, Object.assign(Object.assign({}, options), { outgoing: true }));
        return result;
    }
    getPredecessors(cell, options = {}) {
        const predecessors = [];
        this.search(cell, (curr, distance) => {
            if (curr !== cell && this.matchDistance(distance, options.distance)) {
                predecessors.push(curr);
            }
        }, Object.assign(Object.assign({}, options), { incoming: true }));
        return predecessors;
    }
    /**
     * Returns `true` if `cell2` is a predecessor of `cell1`.
     */
    isPredecessor(cell1, cell2, options = {}) {
        let result = false;
        this.search(cell1, (curr, distance) => {
            if (curr === cell2 &&
                curr !== cell1 &&
                this.matchDistance(distance, options.distance)) {
                result = true;
                return false;
            }
        }, Object.assign(Object.assign({}, options), { incoming: true }));
        return result;
    }
    matchDistance(distance, preset) {
        if (preset == null) {
            return true;
        }
        if (typeof preset === 'function') {
            return preset(distance);
        }
        if (Array.isArray(preset) && preset.includes(distance)) {
            return true;
        }
        return distance === preset;
    }
    /**
     * Returns the common ancestor of the passed cells.
     */
    getCommonAncestor(...cells) {
        const arr = [];
        cells.forEach((item) => {
            if (item) {
                if (Array.isArray(item)) {
                    arr.push(...item);
                }
                else {
                    arr.push(item);
                }
            }
        });
        return _cell__WEBPACK_IMPORTED_MODULE_2__.Cell.getCommonAncestor(...arr);
    }
    /**
     * Returns an array of cells that result from finding nodes/edges that
     * are connected to any of the cells in the cells array. This function
     * loops over cells and if the current cell is a edge, it collects its
     * source/target nodes; if it is an node, it collects its incoming and
     * outgoing edges if both the edge terminal (source/target) are in the
     * cells array.
     */
    getSubGraph(cells, options = {}) {
        const subgraph = [];
        const cache = {};
        const nodes = [];
        const edges = [];
        const collect = (cell) => {
            if (!cache[cell.id]) {
                subgraph.push(cell);
                cache[cell.id] = cell;
                if (cell.isEdge()) {
                    edges.push(cell);
                }
                if (cell.isNode()) {
                    nodes.push(cell);
                }
            }
        };
        cells.forEach((cell) => {
            collect(cell);
            if (options.deep) {
                const descendants = cell.getDescendants({ deep: true });
                descendants.forEach((descendant) => collect(descendant));
            }
        });
        edges.forEach((edge) => {
            // For edges, include their source & target
            const sourceCell = edge.getSourceCell();
            const targetCell = edge.getTargetCell();
            if (sourceCell && !cache[sourceCell.id]) {
                subgraph.push(sourceCell);
                cache[sourceCell.id] = sourceCell;
                if (sourceCell.isNode()) {
                    nodes.push(sourceCell);
                }
            }
            if (targetCell && !cache[targetCell.id]) {
                subgraph.push(targetCell);
                cache[targetCell.id] = targetCell;
                if (targetCell.isNode()) {
                    nodes.push(targetCell);
                }
            }
        });
        nodes.forEach((node) => {
            // For nodes, include their connected edges if their source/target
            // is in the subgraph.
            const edges = this.getConnectedEdges(node, options);
            edges.forEach((edge) => {
                const sourceCell = edge.getSourceCell();
                const targetCell = edge.getTargetCell();
                if (!cache[edge.id] &&
                    sourceCell &&
                    cache[sourceCell.id] &&
                    targetCell &&
                    cache[targetCell.id]) {
                    subgraph.push(edge);
                    cache[edge.id] = edge;
                }
            });
        });
        return subgraph;
    }
    /**
     * Clones the whole subgraph (including all the connected links whose
     * source/target is in the subgraph). If `options.deep` is `true`, also
     * take into account all the embedded cells of all the subgraph cells.
     *
     * Returns a map of the form: { [original cell ID]: [clone] }.
     */
    cloneSubGraph(cells, options = {}) {
        const subgraph = this.getSubGraph(cells, options);
        return this.cloneCells(subgraph);
    }
    cloneCells(cells) {
        return _cell__WEBPACK_IMPORTED_MODULE_2__.Cell.cloneCells(cells);
    }
    getNodesFromPoint(x, y) {
        const p = typeof x === 'number' ? { x, y: y || 0 } : x;
        return this.getNodes().filter((node) => {
            return node.getBBox().containsPoint(p);
        });
    }
    getNodesInArea(x, y, w, h, options) {
        const rect = typeof x === 'number'
            ? new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle(x, y, w, h)
            : _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.create(x);
        const opts = typeof x === 'number' ? options : y;
        const strict = opts && opts.strict;
        return this.getNodes().filter((node) => {
            const bbox = node.getBBox();
            return strict ? rect.containsRect(bbox) : rect.isIntersectWithRect(bbox);
        });
    }
    getEdgesInArea(x, y, w, h, options) {
        const rect = typeof x === 'number'
            ? new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle(x, y, w, h)
            : _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.create(x);
        const opts = typeof x === 'number' ? options : y;
        const strict = opts && opts.strict;
        return this.getEdges().filter((edge) => {
            const bbox = edge.getBBox();
            if (bbox.width === 0) {
                bbox.inflate(1, 0);
            }
            else if (bbox.height === 0) {
                bbox.inflate(0, 1);
            }
            return strict ? rect.containsRect(bbox) : rect.isIntersectWithRect(bbox);
        });
    }
    getNodesUnderNode(node, options = {}) {
        const bbox = node.getBBox();
        const nodes = options.by == null || options.by === 'bbox'
            ? this.getNodesInArea(bbox)
            : this.getNodesFromPoint(bbox[options.by]);
        return nodes.filter((curr) => node.id !== curr.id && !curr.isDescendantOf(node));
    }
    /**
     * Returns the bounding box that surrounds all cells in the graph.
     */
    getAllCellsBBox() {
        return this.getCellsBBox(this.getCells());
    }
    /**
     * Returns the bounding box that surrounds all the given cells.
     */
    getCellsBBox(cells, options = {}) {
        return _cell__WEBPACK_IMPORTED_MODULE_2__.Cell.getCellsBBox(cells, options);
    }
    // #region search
    search(cell, iterator, options = {}) {
        if (options.breadthFirst) {
            this.breadthFirstSearch(cell, iterator, options);
        }
        else {
            this.depthFirstSearch(cell, iterator, options);
        }
    }
    breadthFirstSearch(cell, iterator, options = {}) {
        const queue = [];
        const visited = {};
        const distance = {};
        queue.push(cell);
        distance[cell.id] = 0;
        while (queue.length > 0) {
            const next = queue.shift();
            if (next == null || visited[next.id]) {
                continue;
            }
            visited[next.id] = true;
            if (_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(iterator, this, next, distance[next.id]) === false) {
                continue;
            }
            const neighbors = this.getNeighbors(next, options);
            neighbors.forEach((neighbor) => {
                distance[neighbor.id] = distance[next.id] + 1;
                queue.push(neighbor);
            });
        }
    }
    depthFirstSearch(cell, iterator, options = {}) {
        const queue = [];
        const visited = {};
        const distance = {};
        queue.push(cell);
        distance[cell.id] = 0;
        while (queue.length > 0) {
            const next = queue.pop();
            if (next == null || visited[next.id]) {
                continue;
            }
            visited[next.id] = true;
            if (_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(iterator, this, next, distance[next.id]) === false) {
                continue;
            }
            const neighbors = this.getNeighbors(next, options);
            const lastIndex = queue.length;
            neighbors.forEach((neighbor) => {
                distance[neighbor.id] = distance[next.id] + 1;
                queue.splice(lastIndex, 0, neighbor);
            });
        }
    }
    // #endregion
    // #region shortest path
    /** *
     * Returns an array of IDs of nodes on the shortest
     * path between source and target.
     */
    getShortestPath(source, target, options = {}) {
        const adjacencyList = {};
        this.getEdges().forEach((edge) => {
            const sourceId = edge.getSourceCellId();
            const targetId = edge.getTargetCellId();
            if (sourceId && targetId) {
                if (!adjacencyList[sourceId]) {
                    adjacencyList[sourceId] = [];
                }
                if (!adjacencyList[targetId]) {
                    adjacencyList[targetId] = [];
                }
                adjacencyList[sourceId].push(targetId);
                if (!options.directed) {
                    adjacencyList[targetId].push(sourceId);
                }
            }
        });
        const sourceId = typeof source === 'string' ? source : source.id;
        const previous = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dijkstra.run(adjacencyList, sourceId, options.weight);
        const path = [];
        let targetId = typeof target === 'string' ? target : target.id;
        if (previous[targetId]) {
            path.push(targetId);
        }
        while ((targetId = previous[targetId])) {
            path.unshift(targetId);
        }
        return path;
    }
    // #endregion
    // #region transform
    /**
     * Translate all cells in the graph by `tx` and `ty` pixels.
     */
    translate(tx, ty, options) {
        this.getCells()
            .filter((cell) => !cell.hasParent())
            .forEach((cell) => cell.translate(tx, ty, options));
        return this;
    }
    resize(width, height, options) {
        return this.resizeCells(width, height, this.getCells(), options);
    }
    resizeCells(width, height, cells, options = {}) {
        const bbox = this.getCellsBBox(cells);
        if (bbox) {
            const sx = Math.max(width / bbox.width, 0);
            const sy = Math.max(height / bbox.height, 0);
            const origin = bbox.getOrigin();
            cells.forEach((cell) => cell.scale(sx, sy, origin, options));
        }
        return this;
    }
    // #endregion
    // #region serialize/deserialize
    toJSON(options = {}) {
        return Model.toJSON(this.getCells(), options);
    }
    parseJSON(data) {
        return Model.fromJSON(data);
    }
    fromJSON(data, options = {}) {
        const cells = this.parseJSON(data);
        this.resetCells(cells, options);
        return this;
    }
    // #endregion
    // #region batch
    startBatch(name, data = {}) {
        this.batches[name] = (this.batches[name] || 0) + 1;
        this.notify('batch:start', { name, data });
        return this;
    }
    stopBatch(name, data = {}) {
        this.batches[name] = (this.batches[name] || 0) - 1;
        this.notify('batch:stop', { name, data });
        return this;
    }
    batchUpdate(name, execute, data = {}) {
        this.startBatch(name, data);
        const result = execute();
        this.stopBatch(name, data);
        return result;
    }
    hasActiveBatch(name = Object.keys(this.batches)) {
        const names = Array.isArray(name) ? name : [name];
        return names.some((batch) => this.batches[batch] > 0);
    }
    // #endregion
    dispose() {
        this.collection.dispose();
    }
}
__decorate([
    Model.dispose()
], Model.prototype, "dispose", null);
(function (Model) {
    Model.toStringTag = `X6.${Model.name}`;
    function isModel(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof Model) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const model = instance;
        if ((tag == null || tag === Model.toStringTag) &&
            typeof model.addNode === 'function' &&
            typeof model.addEdge === 'function' &&
            model.collection != null) {
            return true;
        }
        return false;
    }
    Model.isModel = isModel;
})(Model || (Model = {}));
(function (Model) {
    function toJSON(cells, options = {}) {
        return {
            cells: cells.map((cell) => cell.toJSON(options)),
        };
    }
    Model.toJSON = toJSON;
    function fromJSON(data) {
        const cells = [];
        if (Array.isArray(data)) {
            cells.push(...data);
        }
        else {
            if (data.cells) {
                cells.push(...data.cells);
            }
            if (data.nodes) {
                data.nodes.forEach((node) => {
                    if (node.shape == null) {
                        node.shape = 'rect';
                    }
                    cells.push(node);
                });
            }
            if (data.edges) {
                data.edges.forEach((edge) => {
                    if (edge.shape == null) {
                        edge.shape = 'edge';
                    }
                    cells.push(edge);
                });
            }
        }
        return cells.map((cell) => {
            const type = cell.shape;
            if (type) {
                if (_node__WEBPACK_IMPORTED_MODULE_4__.Node.registry.exist(type)) {
                    return _node__WEBPACK_IMPORTED_MODULE_4__.Node.create(cell);
                }
                if (_edge__WEBPACK_IMPORTED_MODULE_3__.Edge.registry.exist(type)) {
                    return _edge__WEBPACK_IMPORTED_MODULE_3__.Edge.create(cell);
                }
            }
            throw new Error('The `shape` should be specified when creating a node/edge instance');
        });
    }
    Model.fromJSON = fromJSON;
})(Model || (Model = {}));
//# sourceMappingURL=model.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/model/node.js":
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/model/node.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Node: () => (/* binding */ Node)
/* harmony export */ });
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _registry_registry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../registry/registry */ "./node_modules/@antv/x6/es/registry/registry.js");
/* harmony import */ var _view_markup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../view/markup */ "./node_modules/@antv/x6/es/view/markup.js");
/* harmony import */ var _cell__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cell */ "./node_modules/@antv/x6/es/model/cell.js");
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./registry */ "./node_modules/@antv/x6/es/model/registry.js");
/* harmony import */ var _port__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./port */ "./node_modules/@antv/x6/es/model/port.js");
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};







class Node extends _cell__WEBPACK_IMPORTED_MODULE_4__.Cell {
    get [Symbol.toStringTag]() {
        return Node.toStringTag;
    }
    constructor(metadata = {}) {
        super(metadata);
        this.initPorts();
    }
    preprocess(metadata, ignoreIdCheck) {
        const { x, y, width, height } = metadata, others = __rest(metadata, ["x", "y", "width", "height"]);
        if (x != null || y != null) {
            const position = others.position;
            others.position = Object.assign(Object.assign({}, position), { x: x != null ? x : position ? position.x : 0, y: y != null ? y : position ? position.y : 0 });
        }
        if (width != null || height != null) {
            const size = others.size;
            others.size = Object.assign(Object.assign({}, size), { width: width != null ? width : size ? size.width : 0, height: height != null ? height : size ? size.height : 0 });
        }
        return super.preprocess(others, ignoreIdCheck);
    }
    isNode() {
        return true;
    }
    size(width, height, options) {
        if (width === undefined) {
            return this.getSize();
        }
        if (typeof width === 'number') {
            return this.setSize(width, height, options);
        }
        return this.setSize(width, height);
    }
    getSize() {
        const size = this.store.get('size');
        return size ? Object.assign({}, size) : { width: 1, height: 1 };
    }
    setSize(width, height, options) {
        if (typeof width === 'object') {
            this.resize(width.width, width.height, height);
        }
        else {
            this.resize(width, height, options);
        }
        return this;
    }
    resize(width, height, options = {}) {
        this.startBatch('resize', options);
        const direction = options.direction;
        if (direction) {
            const currentSize = this.getSize();
            switch (direction) {
                case 'left':
                case 'right':
                    // Don't change height when resizing horizontally.
                    height = currentSize.height; // eslint-disable-line
                    break;
                case 'top':
                case 'bottom':
                    // Don't change width when resizing vertically.
                    width = currentSize.width; // eslint-disable-line
                    break;
                default:
                    break;
            }
            const map = {
                right: 0,
                'top-right': 0,
                top: 1,
                'top-left': 1,
                left: 2,
                'bottom-left': 2,
                bottom: 3,
                'bottom-right': 3,
            };
            let quadrant = map[direction];
            const angle = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Angle.normalize(this.getAngle() || 0);
            if (options.absolute) {
                // We are taking the node's rotation into account
                quadrant += Math.floor((angle + 45) / 90);
                quadrant %= 4;
            }
            // This is a rectangle in size of the un-rotated node.
            const bbox = this.getBBox();
            // Pick the corner point on the node, which meant to stay on its
            // place before and after the rotation.
            let fixedPoint;
            if (quadrant === 0) {
                fixedPoint = bbox.getBottomLeft();
            }
            else if (quadrant === 1) {
                fixedPoint = bbox.getCorner();
            }
            else if (quadrant === 2) {
                fixedPoint = bbox.getTopRight();
            }
            else {
                fixedPoint = bbox.getOrigin();
            }
            // Find an image of the previous indent point. This is the position,
            // where is the point actually located on the screen.
            const imageFixedPoint = fixedPoint
                .clone()
                .rotate(-angle, bbox.getCenter());
            // Every point on the element rotates around a circle with the centre of
            // rotation in the middle of the element while the whole element is being
            // rotated. That means that the distance from a point in the corner of
            // the element (supposed its always rect) to the center of the element
            // doesn't change during the rotation and therefore it equals to a
            // distance on un-rotated element.
            // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.
            const radius = Math.sqrt(width * width + height * height) / 2;
            // Now we are looking for an angle between x-axis and the line starting
            // at image of fixed point and ending at the center of the element.
            // We call this angle `alpha`.
            // The image of a fixed point is located in n-th quadrant. For each
            // quadrant passed going anti-clockwise we have to add 90 degrees.
            // Note that the first quadrant has index 0.
            //
            // 3 | 2
            // --c-- Quadrant positions around the element's center `c`
            // 0 | 1
            //
            let alpha = (quadrant * Math.PI) / 2;
            // Add an angle between the beginning of the current quadrant (line
            // parallel with x-axis or y-axis going through the center of the
            // element) and line crossing the indent of the fixed point and the
            // center of the element. This is the angle we need but on the
            // un-rotated element.
            alpha += Math.atan(quadrant % 2 === 0 ? height / width : width / height);
            // Lastly we have to deduct the original angle the element was rotated
            // by and that's it.
            alpha -= _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Angle.toRad(angle);
            // With this angle and distance we can easily calculate the centre of
            // the un-rotated element.
            // Note that fromPolar constructor accepts an angle in radians.
            const center = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.fromPolar(radius, alpha, imageFixedPoint);
            // The top left corner on the un-rotated element has to be half a width
            // on the left and half a height to the top from the center. This will
            // be the origin of rectangle we were looking for.
            const origin = center.clone().translate(width / -2, height / -2);
            this.store.set('size', { width, height }, options);
            this.setPosition(origin.x, origin.y, options);
        }
        else {
            this.store.set('size', { width, height }, options);
        }
        this.stopBatch('resize', options);
        return this;
    }
    scale(sx, sy, origin, options = {}) {
        const scaledBBox = this.getBBox().scale(sx, sy, origin == null ? undefined : origin);
        this.startBatch('scale', options);
        this.setPosition(scaledBBox.x, scaledBBox.y, options);
        this.resize(scaledBBox.width, scaledBBox.height, options);
        this.stopBatch('scale');
        return this;
    }
    position(arg0, arg1, arg2) {
        if (typeof arg0 === 'number') {
            return this.setPosition(arg0, arg1, arg2);
        }
        return this.getPosition(arg0);
    }
    getPosition(options = {}) {
        if (options.relative) {
            const parent = this.getParent();
            if (parent != null && parent.isNode()) {
                const currentPosition = this.getPosition();
                const parentPosition = parent.getPosition();
                return {
                    x: currentPosition.x - parentPosition.x,
                    y: currentPosition.y - parentPosition.y,
                };
            }
        }
        const pos = this.store.get('position');
        return pos ? Object.assign({}, pos) : { x: 0, y: 0 };
    }
    setPosition(arg0, arg1, arg2 = {}) {
        let x;
        let y;
        let options;
        if (typeof arg0 === 'object') {
            x = arg0.x;
            y = arg0.y;
            options = arg1 || {};
        }
        else {
            x = arg0;
            y = arg1;
            options = arg2 || {};
        }
        if (options.relative) {
            const parent = this.getParent();
            if (parent != null && parent.isNode()) {
                const parentPosition = parent.getPosition();
                x += parentPosition.x;
                y += parentPosition.y;
            }
        }
        if (options.deep) {
            const currentPosition = this.getPosition();
            this.translate(x - currentPosition.x, y - currentPosition.y, options);
        }
        else {
            this.store.set('position', { x, y }, options);
        }
        return this;
    }
    translate(tx = 0, ty = 0, options = {}) {
        if (tx === 0 && ty === 0) {
            return this;
        }
        // Pass the initiator of the translation.
        options.translateBy = options.translateBy || this.id;
        const position = this.getPosition();
        if (options.restrict != null && options.translateBy === this.id) {
            // We are restricting the translation for the element itself only. We get
            // the bounding box of the element including all its embeds.
            // All embeds have to be translated the exact same way as the element.
            const bbox = this.getBBox({ deep: true });
            const ra = options.restrict;
            // - - - - - - - - - - - - -> ra.x + ra.width
            // - - - -> position.x      |
            // -> bbox.x
            //                ▓▓▓▓▓▓▓   |
            //         ░░░░░░░▓▓▓▓▓▓▓
            //         ░░░░░░░░░        |
            //   ▓▓▓▓▓▓▓▓░░░░░░░
            //   ▓▓▓▓▓▓▓▓               |
            //   <-dx->                     | restricted area right border
            //         <-width->        |   ░ translated element
            //   <- - bbox.width - ->       ▓ embedded element
            const dx = position.x - bbox.x;
            const dy = position.y - bbox.y;
            // Find the maximal/minimal coordinates that the element can be translated
            // while complies the restrictions.
            const x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx));
            const y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty));
            // recalculate the translation taking the restrictions into account.
            tx = x - position.x; // eslint-disable-line
            ty = y - position.y; // eslint-disable-line
        }
        const translatedPosition = {
            x: position.x + tx,
            y: position.y + ty,
        };
        // To find out by how much an element was translated in event
        // 'change:position' handlers.
        options.tx = tx;
        options.ty = ty;
        if (options.transition) {
            if (typeof options.transition !== 'object') {
                options.transition = {};
            }
            this.transition('position', translatedPosition, Object.assign(Object.assign({}, options.transition), { interp: _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Interp.object }));
            this.eachChild((child) => {
                var _a;
                const excluded = (_a = options.exclude) === null || _a === void 0 ? void 0 : _a.includes(child);
                if (!excluded) {
                    child.translate(tx, ty, options);
                }
            });
        }
        else {
            this.startBatch('translate', options);
            this.store.set('position', translatedPosition, options);
            this.eachChild((child) => {
                var _a;
                const excluded = (_a = options.exclude) === null || _a === void 0 ? void 0 : _a.includes(child);
                if (!excluded) {
                    child.translate(tx, ty, options);
                }
            });
            this.stopBatch('translate', options);
        }
        return this;
    }
    angle(val, options) {
        if (val == null) {
            return this.getAngle();
        }
        return this.rotate(val, options);
    }
    getAngle() {
        return this.store.get('angle', 0);
    }
    rotate(angle, options = {}) {
        const currentAngle = this.getAngle();
        if (options.center) {
            const size = this.getSize();
            const position = this.getPosition();
            const center = this.getBBox().getCenter();
            center.rotate(currentAngle - angle, options.center);
            const dx = center.x - size.width / 2 - position.x;
            const dy = center.y - size.height / 2 - position.y;
            this.startBatch('rotate', { angle, options });
            this.setPosition(position.x + dx, position.y + dy, options);
            this.rotate(angle, Object.assign(Object.assign({}, options), { center: null }));
            this.stopBatch('rotate');
        }
        else {
            this.store.set('angle', options.absolute ? angle : (currentAngle + angle) % 360, options);
        }
        return this;
    }
    // #endregion
    // #region common
    getBBox(options = {}) {
        if (options.deep) {
            const cells = this.getDescendants({ deep: true, breadthFirst: true });
            cells.push(this);
            return _cell__WEBPACK_IMPORTED_MODULE_4__.Cell.getCellsBBox(cells);
        }
        return _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle.fromPositionAndSize(this.getPosition(), this.getSize());
    }
    getConnectionPoint(edge, type) {
        const bbox = this.getBBox();
        const center = bbox.getCenter();
        const terminal = edge.getTerminal(type);
        if (terminal == null) {
            return center;
        }
        const portId = terminal.port;
        if (!portId || !this.hasPort(portId)) {
            return center;
        }
        const port = this.getPort(portId);
        if (!port || !port.group) {
            return center;
        }
        const layouts = this.getPortsPosition(port.group);
        const position = layouts[portId].position;
        const portCenter = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(position).translate(bbox.getOrigin());
        const angle = this.getAngle();
        if (angle) {
            portCenter.rotate(-angle, center);
        }
        return portCenter;
    }
    /**
     * Sets cell's size and position based on the children bbox and given padding.
     */
    fit(options = {}) {
        const children = this.getChildren() || [];
        const embeds = children.filter((cell) => cell.isNode());
        if (embeds.length === 0) {
            return this;
        }
        this.startBatch('fit-embeds', options);
        if (options.deep) {
            embeds.forEach((cell) => cell.fit(options));
        }
        let { x, y, width, height } = _cell__WEBPACK_IMPORTED_MODULE_4__.Cell.getCellsBBox(embeds);
        const padding = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.NumberExt.normalizeSides(options.padding);
        x -= padding.left;
        y -= padding.top;
        width += padding.left + padding.right;
        height += padding.bottom + padding.top;
        this.store.set({
            position: { x, y },
            size: { width, height },
        }, options);
        this.stopBatch('fit-embeds');
        return this;
    }
    // #endregion
    // #region ports
    get portContainerMarkup() {
        return this.getPortContainerMarkup();
    }
    set portContainerMarkup(markup) {
        this.setPortContainerMarkup(markup);
    }
    getDefaultPortContainerMarkup() {
        return (this.store.get('defaultPortContainerMarkup') ||
            _view_markup__WEBPACK_IMPORTED_MODULE_3__.Markup.getPortContainerMarkup());
    }
    getPortContainerMarkup() {
        return (this.store.get('portContainerMarkup') ||
            this.getDefaultPortContainerMarkup());
    }
    setPortContainerMarkup(markup, options = {}) {
        this.store.set('portContainerMarkup', _view_markup__WEBPACK_IMPORTED_MODULE_3__.Markup.clone(markup), options);
        return this;
    }
    get portMarkup() {
        return this.getPortMarkup();
    }
    set portMarkup(markup) {
        this.setPortMarkup(markup);
    }
    getDefaultPortMarkup() {
        return this.store.get('defaultPortMarkup') || _view_markup__WEBPACK_IMPORTED_MODULE_3__.Markup.getPortMarkup();
    }
    getPortMarkup() {
        return this.store.get('portMarkup') || this.getDefaultPortMarkup();
    }
    setPortMarkup(markup, options = {}) {
        this.store.set('portMarkup', _view_markup__WEBPACK_IMPORTED_MODULE_3__.Markup.clone(markup), options);
        return this;
    }
    get portLabelMarkup() {
        return this.getPortLabelMarkup();
    }
    set portLabelMarkup(markup) {
        this.setPortLabelMarkup(markup);
    }
    getDefaultPortLabelMarkup() {
        return (this.store.get('defaultPortLabelMarkup') || _view_markup__WEBPACK_IMPORTED_MODULE_3__.Markup.getPortLabelMarkup());
    }
    getPortLabelMarkup() {
        return this.store.get('portLabelMarkup') || this.getDefaultPortLabelMarkup();
    }
    setPortLabelMarkup(markup, options = {}) {
        this.store.set('portLabelMarkup', _view_markup__WEBPACK_IMPORTED_MODULE_3__.Markup.clone(markup), options);
        return this;
    }
    get ports() {
        const res = this.store.get('ports', { items: [] });
        if (res.items == null) {
            res.items = [];
        }
        return res;
    }
    getPorts() {
        return _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.cloneDeep(this.ports.items);
    }
    getPortsByGroup(groupName) {
        return this.getPorts().filter((port) => port.group === groupName);
    }
    getPort(portId) {
        return _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.cloneDeep(this.ports.items.find((port) => port.id && port.id === portId));
    }
    getPortAt(index) {
        return this.ports.items[index] || null;
    }
    hasPorts() {
        return this.ports.items.length > 0;
    }
    hasPort(portId) {
        return this.getPortIndex(portId) !== -1;
    }
    getPortIndex(port) {
        const portId = typeof port === 'string' ? port : port.id;
        return portId != null
            ? this.ports.items.findIndex((item) => item.id === portId)
            : -1;
    }
    getPortsPosition(groupName) {
        const size = this.getSize();
        const layouts = this.port.getPortsLayoutByGroup(groupName, new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle(0, 0, size.width, size.height));
        return layouts.reduce((memo, item) => {
            const layout = item.portLayout;
            memo[item.portId] = {
                position: Object.assign({}, layout.position),
                angle: layout.angle || 0,
            };
            return memo;
        }, {});
    }
    getPortProp(portId, path) {
        return this.getPropByPath(this.prefixPortPath(portId, path));
    }
    setPortProp(portId, arg1, arg2, arg3) {
        if (typeof arg1 === 'string' || Array.isArray(arg1)) {
            const path = this.prefixPortPath(portId, arg1);
            const value = arg2;
            return this.setPropByPath(path, value, arg3);
        }
        const path = this.prefixPortPath(portId);
        const value = arg1;
        return this.setPropByPath(path, value, arg2);
    }
    removePortProp(portId, path, options) {
        if (typeof path === 'string' || Array.isArray(path)) {
            return this.removePropByPath(this.prefixPortPath(portId, path), options);
        }
        return this.removePropByPath(this.prefixPortPath(portId), path);
    }
    portProp(portId, path, value, options) {
        if (path == null) {
            return this.getPortProp(portId);
        }
        if (typeof path === 'string' || Array.isArray(path)) {
            if (arguments.length === 2) {
                return this.getPortProp(portId, path);
            }
            if (value == null) {
                return this.removePortProp(portId, path, options);
            }
            return this.setPortProp(portId, path, value, options);
        }
        return this.setPortProp(portId, path, value);
    }
    prefixPortPath(portId, path) {
        const index = this.getPortIndex(portId);
        if (index === -1) {
            throw new Error(`Unable to find port with id: "${portId}"`);
        }
        if (path == null || path === '') {
            return ['ports', 'items', `${index}`];
        }
        if (Array.isArray(path)) {
            return ['ports', 'items', `${index}`, ...path];
        }
        return `ports/items/${index}/${path}`;
    }
    addPort(port, options) {
        const ports = [...this.ports.items];
        ports.push(port);
        this.setPropByPath('ports/items', ports, options);
        return this;
    }
    addPorts(ports, options) {
        this.setPropByPath('ports/items', [...this.ports.items, ...ports], options);
        return this;
    }
    insertPort(index, port, options) {
        const ports = [...this.ports.items];
        ports.splice(index, 0, port);
        this.setPropByPath('ports/items', ports, options);
        return this;
    }
    removePort(port, options = {}) {
        return this.removePortAt(this.getPortIndex(port), options);
    }
    removePortAt(index, options = {}) {
        if (index >= 0) {
            const ports = [...this.ports.items];
            ports.splice(index, 1);
            options.rewrite = true;
            this.setPropByPath('ports/items', ports, options);
        }
        return this;
    }
    removePorts(portsForRemoval, opt) {
        let options;
        if (Array.isArray(portsForRemoval)) {
            options = opt || {};
            if (portsForRemoval.length) {
                options.rewrite = true;
                const currentPorts = [...this.ports.items];
                const remainingPorts = currentPorts.filter((cp) => !portsForRemoval.some((p) => {
                    const id = typeof p === 'string' ? p : p.id;
                    return cp.id === id;
                }));
                this.setPropByPath('ports/items', remainingPorts, options);
            }
        }
        else {
            options = portsForRemoval || {};
            options.rewrite = true;
            this.setPropByPath('ports/items', [], options);
        }
        return this;
    }
    getParsedPorts() {
        return this.port.getPorts();
    }
    getParsedGroups() {
        return this.port.groups;
    }
    getPortsLayoutByGroup(groupName, bbox) {
        return this.port.getPortsLayoutByGroup(groupName, bbox);
    }
    initPorts() {
        this.updatePortData();
        this.on('change:ports', () => {
            this.processRemovedPort();
            this.updatePortData();
        });
    }
    processRemovedPort() {
        const current = this.ports;
        const currentItemsMap = {};
        current.items.forEach((item) => {
            if (item.id) {
                currentItemsMap[item.id] = true;
            }
        });
        const removed = {};
        const previous = this.store.getPrevious('ports') || {
            items: [],
        };
        previous.items.forEach((item) => {
            if (item.id && !currentItemsMap[item.id]) {
                removed[item.id] = true;
            }
        });
        const model = this.model;
        if (model && !_antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.isEmpty(removed)) {
            const incomings = model.getConnectedEdges(this, { incoming: true });
            incomings.forEach((edge) => {
                const portId = edge.getTargetPortId();
                if (portId && removed[portId]) {
                    edge.remove();
                }
            });
            const outgoings = model.getConnectedEdges(this, { outgoing: true });
            outgoings.forEach((edge) => {
                const portId = edge.getSourcePortId();
                if (portId && removed[portId]) {
                    edge.remove();
                }
            });
        }
    }
    validatePorts() {
        const ids = {};
        const errors = [];
        this.ports.items.forEach((p) => {
            if (typeof p !== 'object') {
                errors.push(`Invalid port ${p}.`);
            }
            if (p.id == null) {
                p.id = this.generatePortId();
            }
            if (ids[p.id]) {
                errors.push('Duplicitied port id.');
            }
            ids[p.id] = true;
        });
        return errors;
    }
    generatePortId() {
        return _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.StringExt.uuid();
    }
    updatePortData() {
        const err = this.validatePorts();
        if (err.length > 0) {
            this.store.set('ports', this.store.getPrevious('ports'));
            throw new Error(err.join(' '));
        }
        const prev = this.port ? this.port.getPorts() : null;
        this.port = new _port__WEBPACK_IMPORTED_MODULE_6__.PortManager(this.ports);
        const curr = this.port.getPorts();
        const added = prev
            ? curr.filter((item) => {
                if (!prev.find((prevPort) => prevPort.id === item.id)) {
                    return item;
                }
                return null;
            })
            : [...curr];
        const removed = prev
            ? prev.filter((item) => {
                if (!curr.find((curPort) => curPort.id === item.id)) {
                    return item;
                }
                return null;
            })
            : [];
        if (added.length > 0) {
            this.notify('ports:added', { added, cell: this, node: this });
        }
        if (removed.length > 0) {
            this.notify('ports:removed', { removed, cell: this, node: this });
        }
    }
}
Node.defaults = {
    angle: 0,
    position: { x: 0, y: 0 },
    size: { width: 1, height: 1 },
};
(function (Node) {
    Node.toStringTag = `X6.${Node.name}`;
    function isNode(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof Node) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const node = instance;
        if ((tag == null || tag === Node.toStringTag) &&
            typeof node.isNode === 'function' &&
            typeof node.isEdge === 'function' &&
            typeof node.prop === 'function' &&
            typeof node.attr === 'function' &&
            typeof node.size === 'function' &&
            typeof node.position === 'function') {
            return true;
        }
        return false;
    }
    Node.isNode = isNode;
})(Node || (Node = {}));
(function (Node) {
    Node.config({
        propHooks(_a) {
            var { ports } = _a, metadata = __rest(_a, ["ports"]);
            if (ports) {
                metadata.ports = Array.isArray(ports) ? { items: ports } : ports;
            }
            return metadata;
        },
    });
})(Node || (Node = {}));
(function (Node) {
    Node.registry = _registry_registry__WEBPACK_IMPORTED_MODULE_2__.Registry.create({
        type: 'node',
        process(shape, options) {
            if (_registry__WEBPACK_IMPORTED_MODULE_5__.ShareRegistry.exist(shape, true)) {
                throw new Error(`Node with name '${shape}' was registered by anthor Edge`);
            }
            if (typeof options === 'function') {
                options.config({ shape });
                return options;
            }
            let parent = Node;
            const { inherit } = options, config = __rest(options, ["inherit"]);
            if (inherit) {
                if (typeof inherit === 'string') {
                    const base = this.get(inherit);
                    if (base == null) {
                        this.onNotFound(inherit, 'inherited');
                    }
                    else {
                        parent = base;
                    }
                }
                else {
                    parent = inherit;
                }
            }
            if (config.constructorName == null) {
                config.constructorName = shape;
            }
            const ctor = parent.define.call(parent, config);
            ctor.config({ shape });
            return ctor;
        },
    });
    _registry__WEBPACK_IMPORTED_MODULE_5__.ShareRegistry.setNodeRegistry(Node.registry);
})(Node || (Node = {}));
(function (Node) {
    let counter = 0;
    function getClassName(name) {
        if (name) {
            return _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.StringExt.pascalCase(name);
        }
        counter += 1;
        return `CustomNode${counter}`;
    }
    function define(config) {
        const { constructorName, overwrite } = config, others = __rest(config, ["constructorName", "overwrite"]);
        const ctor = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.createClass(getClassName(constructorName || others.shape), this);
        ctor.config(others);
        if (others.shape) {
            Node.registry.register(others.shape, ctor, overwrite);
        }
        return ctor;
    }
    Node.define = define;
    function create(options) {
        const shape = options.shape || 'rect';
        const Ctor = Node.registry.get(shape);
        if (Ctor) {
            return new Ctor(options);
        }
        return Node.registry.onNotFound(shape);
    }
    Node.create = create;
})(Node || (Node = {}));
//# sourceMappingURL=node.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/model/port.js":
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/model/port.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PortManager: () => (/* binding */ PortManager)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../registry */ "./node_modules/@antv/x6/es/registry/index.js");



class PortManager {
    constructor(data) {
        this.ports = [];
        this.groups = {};
        this.init(_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(data));
    }
    getPorts() {
        return this.ports;
    }
    getGroup(groupName) {
        return groupName != null ? this.groups[groupName] : null;
    }
    getPortsByGroup(groupName) {
        return this.ports.filter((p) => p.group === groupName || (p.group == null && groupName == null));
    }
    getPortsLayoutByGroup(groupName, elemBBox) {
        const ports = this.getPortsByGroup(groupName);
        const group = groupName ? this.getGroup(groupName) : null;
        const groupPosition = group ? group.position : null;
        const groupPositionName = groupPosition ? groupPosition.name : null;
        let layoutFn;
        if (groupPositionName != null) {
            const fn = _registry__WEBPACK_IMPORTED_MODULE_2__.PortLayout.registry.get(groupPositionName);
            if (fn == null) {
                return _registry__WEBPACK_IMPORTED_MODULE_2__.PortLayout.registry.onNotFound(groupPositionName);
            }
            layoutFn = fn;
        }
        else {
            layoutFn = _registry__WEBPACK_IMPORTED_MODULE_2__.PortLayout.presets.left;
        }
        const portsArgs = ports.map((port) => (port && port.position && port.position.args) || {});
        const groupArgs = (groupPosition && groupPosition.args) || {};
        const layouts = layoutFn(portsArgs, elemBBox, groupArgs);
        return layouts.map((portLayout, index) => {
            const port = ports[index];
            return {
                portLayout,
                portId: port.id,
                portSize: port.size,
                portAttrs: port.attrs,
                labelSize: port.label.size,
                labelLayout: this.getPortLabelLayout(port, _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(portLayout.position), elemBBox),
            };
        });
    }
    init(data) {
        const { groups, items } = data;
        if (groups != null) {
            Object.keys(groups).forEach((key) => {
                this.groups[key] = this.parseGroup(groups[key]);
            });
        }
        if (Array.isArray(items)) {
            items.forEach((item) => {
                this.ports.push(this.parsePort(item));
            });
        }
    }
    parseGroup(group) {
        return Object.assign(Object.assign({}, group), { label: this.getLabel(group, true), position: this.getPortPosition(group.position, true) });
    }
    parsePort(port) {
        const result = Object.assign({}, port);
        const group = this.getGroup(port.group) || {};
        result.markup = result.markup || group.markup;
        result.attrs = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.merge({}, group.attrs, result.attrs);
        result.position = this.createPosition(group, result);
        result.label = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.merge({}, group.label, this.getLabel(result));
        result.zIndex = this.getZIndex(group, result);
        result.size = Object.assign(Object.assign({}, group.size), result.size);
        return result;
    }
    getZIndex(group, port) {
        if (typeof port.zIndex === 'number') {
            return port.zIndex;
        }
        if (typeof group.zIndex === 'number' || group.zIndex === 'auto') {
            return group.zIndex;
        }
        return 'auto';
    }
    createPosition(group, port) {
        return _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.merge({
            name: 'left',
            args: {},
        }, group.position, { args: port.args });
    }
    getPortPosition(position, setDefault = false) {
        if (position == null) {
            if (setDefault) {
                return { name: 'left', args: {} };
            }
        }
        else {
            if (typeof position === 'string') {
                return {
                    name: position,
                    args: {},
                };
            }
            if (Array.isArray(position)) {
                return {
                    name: 'absolute',
                    args: { x: position[0], y: position[1] },
                };
            }
            if (typeof position === 'object') {
                return position;
            }
        }
        return { args: {} };
    }
    getPortLabelPosition(position, setDefault = false) {
        if (position == null) {
            if (setDefault) {
                return { name: 'left', args: {} };
            }
        }
        else {
            if (typeof position === 'string') {
                return {
                    name: position,
                    args: {},
                };
            }
            if (typeof position === 'object') {
                return position;
            }
        }
        return { args: {} };
    }
    getLabel(item, setDefaults = false) {
        const label = item.label || {};
        label.position = this.getPortLabelPosition(label.position, setDefaults);
        return label;
    }
    getPortLabelLayout(port, portPosition, elemBBox) {
        const name = port.label.position.name || 'left';
        const args = port.label.position.args || {};
        const layoutFn = _registry__WEBPACK_IMPORTED_MODULE_2__.PortLabelLayout.registry.get(name) || _registry__WEBPACK_IMPORTED_MODULE_2__.PortLabelLayout.presets.left;
        if (layoutFn) {
            return layoutFn(portPosition, elemBBox, args);
        }
        return null;
    }
}
//# sourceMappingURL=port.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/model/registry.js":
/*!****************************************************!*\
  !*** ./node_modules/@antv/x6/es/model/registry.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ShareRegistry: () => (/* binding */ ShareRegistry)
/* harmony export */ });
var ShareRegistry;
(function (ShareRegistry) {
    let edgeRegistry;
    let nodeRegistry;
    function exist(name, isNode) {
        return isNode
            ? edgeRegistry != null && edgeRegistry.exist(name)
            : nodeRegistry != null && nodeRegistry.exist(name);
    }
    ShareRegistry.exist = exist;
    function setEdgeRegistry(registry) {
        edgeRegistry = registry;
    }
    ShareRegistry.setEdgeRegistry = setEdgeRegistry;
    function setNodeRegistry(registry) {
        nodeRegistry = registry;
    }
    ShareRegistry.setNodeRegistry = setNodeRegistry;
})(ShareRegistry || (ShareRegistry = {}));
//# sourceMappingURL=registry.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/model/store.js":
/*!*************************************************!*\
  !*** ./node_modules/@antv/x6/es/model/store.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Store: () => (/* binding */ Store)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

class Store extends _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Basecoat {
    constructor(data = {}) {
        super();
        this.pending = false;
        this.changing = false;
        this.data = {};
        this.mutate(_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(data));
        this.changed = {};
    }
    mutate(data, options = {}) {
        const unset = options.unset === true;
        const silent = options.silent === true;
        const changes = [];
        const changing = this.changing;
        this.changing = true;
        if (!changing) {
            this.previous = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(this.data);
            this.changed = {};
        }
        const current = this.data;
        const previous = this.previous;
        const changed = this.changed;
        Object.keys(data).forEach((k) => {
            const key = k;
            const newValue = data[key];
            if (!_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isEqual(current[key], newValue)) {
                changes.push(key);
            }
            if (!_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isEqual(previous[key], newValue)) {
                changed[key] = newValue;
            }
            else {
                delete changed[key];
            }
            if (unset) {
                delete current[key];
            }
            else {
                current[key] = newValue;
            }
        });
        if (!silent && changes.length > 0) {
            this.pending = true;
            this.pendingOptions = options;
            changes.forEach((key) => {
                this.emit('change:*', {
                    key,
                    options,
                    store: this,
                    current: current[key],
                    previous: previous[key],
                });
            });
        }
        if (changing) {
            return this;
        }
        if (!silent) {
            // Changes can be recursively nested within `"change"` events.
            while (this.pending) {
                this.pending = false;
                this.emit('changed', {
                    current,
                    previous,
                    store: this,
                    options: this.pendingOptions,
                });
            }
        }
        this.pending = false;
        this.changing = false;
        this.pendingOptions = null;
        return this;
    }
    get(key, defaultValue) {
        if (key == null) {
            return this.data;
        }
        const ret = this.data[key];
        return ret == null ? defaultValue : ret;
    }
    getPrevious(key) {
        if (this.previous) {
            const ret = this.previous[key];
            return ret == null ? undefined : ret;
        }
        return undefined;
    }
    set(key, value, options) {
        if (key != null) {
            if (typeof key === 'object') {
                this.mutate(key, value);
            }
            else {
                this.mutate({ [key]: value }, options);
            }
        }
        return this;
    }
    remove(key, options) {
        const empty = undefined;
        const subset = {};
        let opts;
        if (typeof key === 'string') {
            subset[key] = empty;
            opts = options;
        }
        else if (Array.isArray(key)) {
            key.forEach((k) => (subset[k] = empty));
            opts = options;
        }
        else {
            // eslint-disable-next-line
            for (const key in this.data) {
                subset[key] = empty;
            }
            opts = key;
        }
        this.mutate(subset, Object.assign(Object.assign({}, opts), { unset: true }));
        return this;
    }
    getByPath(path) {
        return _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.getByPath(this.data, path, '/');
    }
    setByPath(path, value, options = {}) {
        const delim = '/';
        const pathArray = Array.isArray(path) ? [...path] : path.split(delim);
        const pathString = Array.isArray(path) ? path.join(delim) : path;
        const property = pathArray[0];
        const pathArrayLength = pathArray.length;
        options.propertyPath = pathString;
        options.propertyValue = value;
        options.propertyPathArray = pathArray;
        if (pathArrayLength === 1) {
            this.set(property, value, options);
        }
        else {
            const update = {};
            let diver = update;
            let nextKey = property;
            // Initialize the nested object. Subobjects are either arrays or objects.
            // An empty array is created if the sub-key is an integer. Otherwise, an
            // empty object is created.
            for (let i = 1; i < pathArrayLength; i += 1) {
                const key = pathArray[i];
                const isArrayIndex = Number.isFinite(Number(key));
                diver = diver[nextKey] = isArrayIndex ? [] : {};
                nextKey = key;
            }
            // Fills update with the `value` on `path`.
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.setByPath(update, pathArray, value, delim);
            const data = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(this.data);
            // If rewrite mode enabled, we replace value referenced by path with the
            // new one (we don't merge).
            if (options.rewrite) {
                _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.unsetByPath(data, path, delim);
            }
            const merged = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.merge(data, update);
            this.set(property, merged[property], options);
        }
        return this;
    }
    removeByPath(path, options) {
        const keys = Array.isArray(path) ? path : path.split('/');
        const key = keys[0];
        if (keys.length === 1) {
            this.remove(key, options);
        }
        else {
            const paths = keys.slice(1);
            const prop = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(this.get(key));
            if (prop) {
                _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.unsetByPath(prop, paths);
            }
            this.set(key, prop, options);
        }
        return this;
    }
    hasChanged(key) {
        if (key == null) {
            return Object.keys(this.changed).length > 0;
        }
        return key in this.changed;
    }
    /**
     * Returns an object containing all the data that have changed,
     * or `null` if there are no changes. Useful for determining what
     * parts of a view need to be updated.
     */
    getChanges(diff) {
        if (diff == null) {
            return this.hasChanged() ? _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(this.changed) : null;
        }
        const old = this.changing ? this.previous : this.data;
        const changed = {};
        let hasChanged;
        // eslint-disable-next-line
        for (const key in diff) {
            const val = diff[key];
            if (!_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isEqual(old[key], val)) {
                changed[key] = val;
                hasChanged = true;
            }
        }
        return hasChanged ? _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(changed) : null;
    }
    /**
     * Returns a copy of the store's `data` object.
     */
    toJSON() {
        return _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(this.data);
    }
    clone() {
        const constructor = this.constructor;
        return new constructor(this.data);
    }
    dispose() {
        this.off();
        this.data = {};
        this.previous = {};
        this.changed = {};
        this.pending = false;
        this.changing = false;
        this.pendingOptions = null;
        this.trigger('disposed', { store: this });
    }
}
__decorate([
    _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Basecoat.dispose()
], Store.prototype, "dispose", null);
//# sourceMappingURL=store.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/attr/align.js":
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/attr/align.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   resetOffset: () => (/* binding */ resetOffset),
/* harmony export */   xAlign: () => (/* binding */ xAlign),
/* harmony export */   yAlign: () => (/* binding */ yAlign)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");


// `x-align` when set to `middle` causes centering of the subelement around its new x coordinate.
// `x-align` when set to `right` uses the x coordinate as referenced to the right of the bbox.
const xAlign = {
    offset: offsetWrapper('x', 'width', 'right'),
};
// `y-align` when set to `middle` causes centering of the subelement around its new y coordinate.
// `y-align` when set to `bottom` uses the y coordinate as referenced to the bottom of the bbox.
const yAlign = {
    offset: offsetWrapper('y', 'height', 'bottom'),
};
const resetOffset = {
    offset(val, { refBBox }) {
        return val ? { x: -refBBox.x, y: -refBBox.y } : { x: 0, y: 0 };
    },
};
function offsetWrapper(axis, dimension, corner) {
    return (value, { refBBox }) => {
        const point = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point();
        let delta;
        if (value === 'middle') {
            delta = refBBox[dimension] / 2;
        }
        else if (value === corner) {
            delta = refBBox[dimension];
        }
        else if (typeof value === 'number' && Number.isFinite(value)) {
            delta = value > -1 && value < 1 ? -refBBox[dimension] * value : -value;
        }
        else if (_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.NumberExt.isPercentage(value)) {
            delta = (refBBox[dimension] * parseFloat(value)) / 100;
        }
        else {
            delta = 0;
        }
        point[axis] = -(refBBox[axis] + delta);
        return point;
    };
}
//# sourceMappingURL=align.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/attr/connection.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/attr/connection.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   atConnectionLength: () => (/* binding */ atConnectionLength),
/* harmony export */   atConnectionLengthIgnoreGradient: () => (/* binding */ atConnectionLengthIgnoreGradient),
/* harmony export */   atConnectionLengthKeepGradient: () => (/* binding */ atConnectionLengthKeepGradient),
/* harmony export */   atConnectionRatio: () => (/* binding */ atConnectionRatio),
/* harmony export */   atConnectionRatioIgnoreGradient: () => (/* binding */ atConnectionRatioIgnoreGradient),
/* harmony export */   atConnectionRatioKeepGradient: () => (/* binding */ atConnectionRatioKeepGradient),
/* harmony export */   connection: () => (/* binding */ connection)
/* harmony export */ });
const isEdgeView = (val, { view }) => {
    return view.cell.isEdge();
};
const connection = {
    qualify: isEdgeView,
    set(val, args) {
        var _a, _b, _c, _d;
        const view = args.view;
        const reverse = (val.reverse || false);
        const stubs = (val.stubs || 0);
        let d;
        if (Number.isFinite(stubs) && stubs !== 0) {
            if (!reverse) {
                let offset;
                if (stubs < 0) {
                    const len = view.getConnectionLength() || 0;
                    offset = (len + stubs) / 2;
                }
                else {
                    offset = stubs;
                }
                const path = view.getConnection();
                if (path) {
                    const sourceParts = path.divideAtLength(offset);
                    const targetParts = path.divideAtLength(-offset);
                    if (sourceParts && targetParts) {
                        d = `${sourceParts[0].serialize()} ${targetParts[1].serialize()}`;
                    }
                }
            }
            else {
                let offset;
                let length;
                const len = view.getConnectionLength() || 0;
                if (stubs < 0) {
                    offset = (len + stubs) / 2;
                    length = -stubs;
                }
                else {
                    offset = stubs;
                    length = len - stubs * 2;
                }
                const path = view.getConnection();
                d = (_d = (_c = (_b = (_a = path === null || path === void 0 ? void 0 : path.divideAtLength(offset)) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.divideAtLength(length)) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.serialize();
            }
        }
        return { d: d || view.getConnectionPathData() };
    },
};
const atConnectionLengthKeepGradient = {
    qualify: isEdgeView,
    set: atConnectionWrapper('getTangentAtLength', { rotate: true }),
};
const atConnectionLengthIgnoreGradient = {
    qualify: isEdgeView,
    set: atConnectionWrapper('getTangentAtLength', { rotate: false }),
};
const atConnectionRatioKeepGradient = {
    qualify: isEdgeView,
    set: atConnectionWrapper('getTangentAtRatio', { rotate: true }),
};
const atConnectionRatioIgnoreGradient = {
    qualify: isEdgeView,
    set: atConnectionWrapper('getTangentAtRatio', { rotate: false }),
};
// aliases
// -------
const atConnectionLength = atConnectionLengthKeepGradient;
const atConnectionRatio = atConnectionRatioKeepGradient;
// utils
// -----
function atConnectionWrapper(method, options) {
    const zeroVector = { x: 1, y: 0 };
    return (value, args) => {
        let p;
        let angle;
        const view = args.view;
        const tangent = view[method](Number(value));
        if (tangent) {
            angle = options.rotate ? tangent.vector().vectorAngle(zeroVector) : 0;
            p = tangent.start;
        }
        else {
            p = view.path.start;
            angle = 0;
        }
        if (angle === 0) {
            return { transform: `translate(${p.x},${p.y}')` };
        }
        return {
            transform: `translate(${p.x},${p.y}') rotate(${angle})`,
        };
    };
}
//# sourceMappingURL=connection.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/attr/fill.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/attr/fill.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fill: () => (/* binding */ fill)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");

const fill = {
    qualify: _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isPlainObject,
    set(fill, { view }) {
        return `url(#${view.graph.defineGradient(fill)})`;
    },
};
//# sourceMappingURL=fill.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/attr/filter.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/attr/filter.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   filter: () => (/* binding */ filter)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");

const filter = {
    qualify: _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isPlainObject,
    set(filter, { view }) {
        return `url(#${view.graph.defineFilter(filter)})`;
    },
};
//# sourceMappingURL=filter.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/attr/html.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/attr/html.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   html: () => (/* binding */ html)
/* harmony export */ });
const html = {
    set(html, { elem }) {
        elem.innerHTML = `${html}`;
    },
};
//# sourceMappingURL=html.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/attr/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/attr/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Attr: () => (/* binding */ Attr)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../registry */ "./node_modules/@antv/x6/es/registry/registry.js");
/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./raw */ "./node_modules/@antv/x6/es/registry/attr/raw.js");
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./main */ "./node_modules/@antv/x6/es/registry/attr/main.js");




var Attr;
(function (Attr) {
    function isValidDefinition(def, val, options) {
        if (def != null) {
            if (typeof def === 'string') {
                return true;
            }
            if (typeof def.qualify !== 'function' ||
                _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(def.qualify, this, val, options)) {
                return true;
            }
        }
        return false;
    }
    Attr.isValidDefinition = isValidDefinition;
})(Attr || (Attr = {}));
(function (Attr) {
    Attr.presets = Object.assign(Object.assign({}, _raw__WEBPACK_IMPORTED_MODULE_2__.raw), _main__WEBPACK_IMPORTED_MODULE_3__);
    Attr.registry = _registry__WEBPACK_IMPORTED_MODULE_1__.Registry.create({
        type: 'attribute definition',
    });
    Attr.registry.register(Attr.presets, true);
})(Attr || (Attr = {}));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/attr/main.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/attr/main.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   annotations: () => (/* reexport safe */ _text__WEBPACK_IMPORTED_MODULE_3__.annotations),
/* harmony export */   atConnectionLength: () => (/* reexport safe */ _connection__WEBPACK_IMPORTED_MODULE_11__.atConnectionLength),
/* harmony export */   atConnectionLengthIgnoreGradient: () => (/* reexport safe */ _connection__WEBPACK_IMPORTED_MODULE_11__.atConnectionLengthIgnoreGradient),
/* harmony export */   atConnectionLengthKeepGradient: () => (/* reexport safe */ _connection__WEBPACK_IMPORTED_MODULE_11__.atConnectionLengthKeepGradient),
/* harmony export */   atConnectionRatio: () => (/* reexport safe */ _connection__WEBPACK_IMPORTED_MODULE_11__.atConnectionRatio),
/* harmony export */   atConnectionRatioIgnoreGradient: () => (/* reexport safe */ _connection__WEBPACK_IMPORTED_MODULE_11__.atConnectionRatioIgnoreGradient),
/* harmony export */   atConnectionRatioKeepGradient: () => (/* reexport safe */ _connection__WEBPACK_IMPORTED_MODULE_11__.atConnectionRatioKeepGradient),
/* harmony export */   connection: () => (/* reexport safe */ _connection__WEBPACK_IMPORTED_MODULE_11__.connection),
/* harmony export */   displayEmpty: () => (/* reexport safe */ _text__WEBPACK_IMPORTED_MODULE_3__.displayEmpty),
/* harmony export */   eol: () => (/* reexport safe */ _text__WEBPACK_IMPORTED_MODULE_3__.eol),
/* harmony export */   fill: () => (/* reexport safe */ _fill__WEBPACK_IMPORTED_MODULE_1__.fill),
/* harmony export */   filter: () => (/* reexport safe */ _filter__WEBPACK_IMPORTED_MODULE_8__.filter),
/* harmony export */   html: () => (/* reexport safe */ _html__WEBPACK_IMPORTED_MODULE_7__.html),
/* harmony export */   lineHeight: () => (/* reexport safe */ _text__WEBPACK_IMPORTED_MODULE_3__.lineHeight),
/* harmony export */   port: () => (/* reexport safe */ _port__WEBPACK_IMPORTED_MODULE_9__.port),
/* harmony export */   ref: () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.ref),
/* harmony export */   refCx: () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refCx),
/* harmony export */   refCy: () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refCy),
/* harmony export */   refD: () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refD),
/* harmony export */   refDKeepOffset: () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refDKeepOffset),
/* harmony export */   refDResetOffset: () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refDResetOffset),
/* harmony export */   refDx: () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refDx),
/* harmony export */   refDy: () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refDy),
/* harmony export */   refHeight: () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refHeight),
/* harmony export */   refHeight2: () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refHeight2),
/* harmony export */   refPoints: () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refPoints),
/* harmony export */   refPointsKeepOffset: () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refPointsKeepOffset),
/* harmony export */   refPointsResetOffset: () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refPointsResetOffset),
/* harmony export */   refR: () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refR),
/* harmony export */   refRCircumscribed: () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refRCircumscribed),
/* harmony export */   refRInscribed: () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refRInscribed),
/* harmony export */   refRx: () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refRx),
/* harmony export */   refRy: () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refRy),
/* harmony export */   refWidth: () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refWidth),
/* harmony export */   refWidth2: () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refWidth2),
/* harmony export */   refX: () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refX),
/* harmony export */   refX2: () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refX2),
/* harmony export */   refY: () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refY),
/* harmony export */   refY2: () => (/* reexport safe */ _ref__WEBPACK_IMPORTED_MODULE_0__.refY2),
/* harmony export */   resetOffset: () => (/* reexport safe */ _align__WEBPACK_IMPORTED_MODULE_5__.resetOffset),
/* harmony export */   sourceMarker: () => (/* reexport safe */ _marker__WEBPACK_IMPORTED_MODULE_10__.sourceMarker),
/* harmony export */   stroke: () => (/* reexport safe */ _stroke__WEBPACK_IMPORTED_MODULE_2__.stroke),
/* harmony export */   style: () => (/* reexport safe */ _style__WEBPACK_IMPORTED_MODULE_6__.style),
/* harmony export */   targetMarker: () => (/* reexport safe */ _marker__WEBPACK_IMPORTED_MODULE_10__.targetMarker),
/* harmony export */   text: () => (/* reexport safe */ _text__WEBPACK_IMPORTED_MODULE_3__.text),
/* harmony export */   textPath: () => (/* reexport safe */ _text__WEBPACK_IMPORTED_MODULE_3__.textPath),
/* harmony export */   textVerticalAnchor: () => (/* reexport safe */ _text__WEBPACK_IMPORTED_MODULE_3__.textVerticalAnchor),
/* harmony export */   textWrap: () => (/* reexport safe */ _text__WEBPACK_IMPORTED_MODULE_3__.textWrap),
/* harmony export */   title: () => (/* reexport safe */ _title__WEBPACK_IMPORTED_MODULE_4__.title),
/* harmony export */   vertexMarker: () => (/* reexport safe */ _marker__WEBPACK_IMPORTED_MODULE_10__.vertexMarker),
/* harmony export */   xAlign: () => (/* reexport safe */ _align__WEBPACK_IMPORTED_MODULE_5__.xAlign),
/* harmony export */   yAlign: () => (/* reexport safe */ _align__WEBPACK_IMPORTED_MODULE_5__.yAlign)
/* harmony export */ });
/* harmony import */ var _ref__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ref */ "./node_modules/@antv/x6/es/registry/attr/ref.js");
/* harmony import */ var _fill__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fill */ "./node_modules/@antv/x6/es/registry/attr/fill.js");
/* harmony import */ var _stroke__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stroke */ "./node_modules/@antv/x6/es/registry/attr/stroke.js");
/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./text */ "./node_modules/@antv/x6/es/registry/attr/text.js");
/* harmony import */ var _title__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./title */ "./node_modules/@antv/x6/es/registry/attr/title.js");
/* harmony import */ var _align__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./align */ "./node_modules/@antv/x6/es/registry/attr/align.js");
/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./style */ "./node_modules/@antv/x6/es/registry/attr/style.js");
/* harmony import */ var _html__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./html */ "./node_modules/@antv/x6/es/registry/attr/html.js");
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./filter */ "./node_modules/@antv/x6/es/registry/attr/filter.js");
/* harmony import */ var _port__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./port */ "./node_modules/@antv/x6/es/registry/attr/port.js");
/* harmony import */ var _marker__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./marker */ "./node_modules/@antv/x6/es/registry/attr/marker.js");
/* harmony import */ var _connection__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./connection */ "./node_modules/@antv/x6/es/registry/attr/connection.js");












//# sourceMappingURL=main.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/attr/marker.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/attr/marker.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   sourceMarker: () => (/* binding */ sourceMarker),
/* harmony export */   targetMarker: () => (/* binding */ targetMarker),
/* harmony export */   vertexMarker: () => (/* binding */ vertexMarker)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _marker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../marker */ "./node_modules/@antv/x6/es/registry/marker/index.js");
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};


function qualify(value) {
    return typeof value === 'string' || _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isPlainObject(value);
}
const sourceMarker = {
    qualify,
    set(marker, { view, attrs }) {
        return createMarker('marker-start', marker, view, attrs);
    },
};
const targetMarker = {
    qualify,
    set(marker, { view, attrs }) {
        return createMarker('marker-end', marker, view, attrs, {
            transform: 'rotate(180)',
        });
    },
};
const vertexMarker = {
    qualify,
    set(marker, { view, attrs }) {
        return createMarker('marker-mid', marker, view, attrs);
    },
};
function createMarker(type, marker, view, attrs, manual = {}) {
    const def = typeof marker === 'string' ? { name: marker } : marker;
    const { name, args } = def, others = __rest(def, ["name", "args"]);
    let preset = others;
    if (name && typeof name === 'string') {
        const fn = _marker__WEBPACK_IMPORTED_MODULE_1__.Marker.registry.get(name);
        if (fn) {
            preset = fn(Object.assign(Object.assign({}, others), args));
        }
        else {
            return _marker__WEBPACK_IMPORTED_MODULE_1__.Marker.registry.onNotFound(name);
        }
    }
    const options = Object.assign(Object.assign(Object.assign({}, normalizeAttr(attrs, type)), manual), preset);
    return {
        [type]: `url(#${view.graph.defineMarker(options)})`,
    };
}
function normalizeAttr(attr, type) {
    const result = {};
    // The context 'fill' is disregared here. The usual case is to use the
    // marker with a connection(for which 'fill' attribute is set to 'none').
    const stroke = attr.stroke;
    if (typeof stroke === 'string') {
        result.stroke = stroke;
        result.fill = stroke;
    }
    // Again the context 'fill-opacity' is ignored.
    let strokeOpacity = attr.strokeOpacity;
    if (strokeOpacity == null) {
        strokeOpacity = attr['stroke-opacity'];
    }
    if (strokeOpacity == null) {
        strokeOpacity = attr.opacity;
    }
    if (strokeOpacity != null) {
        result['stroke-opacity'] = strokeOpacity;
        result['fill-opacity'] = strokeOpacity;
    }
    if (type !== 'marker-mid') {
        const strokeWidth = parseFloat((attr.strokeWidth || attr['stroke-width']));
        if (Number.isFinite(strokeWidth) && strokeWidth > 1) {
            const offset = Math.ceil(strokeWidth / 2);
            result.refX = type === 'marker-start' ? offset : -offset;
        }
    }
    return result;
}
//# sourceMappingURL=marker.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/attr/port.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/attr/port.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   port: () => (/* binding */ port)
/* harmony export */ });
const port = {
    set(port) {
        if (port != null && typeof port === 'object' && port.id) {
            return port.id;
        }
        return port;
    },
};
//# sourceMappingURL=port.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/attr/raw.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/attr/raw.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   raw: () => (/* binding */ raw)
/* harmony export */ });
const raw = {
    xlinkHref: 'xlink:href',
    xlinkShow: 'xlink:show',
    xlinkRole: 'xlink:role',
    xlinkType: 'xlink:type',
    xlinkArcrole: 'xlink:arcrole',
    xlinkTitle: 'xlink:title',
    xlinkActuate: 'xlink:actuate',
    xmlSpace: 'xml:space',
    xmlBase: 'xml:base',
    xmlLang: 'xml:lang',
    preserveAspectRatio: 'preserveAspectRatio',
    requiredExtension: 'requiredExtension',
    requiredFeatures: 'requiredFeatures',
    systemLanguage: 'systemLanguage',
    externalResourcesRequired: 'externalResourceRequired',
};
//# sourceMappingURL=raw.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/attr/ref.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/attr/ref.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ref: () => (/* binding */ ref),
/* harmony export */   refCx: () => (/* binding */ refCx),
/* harmony export */   refCy: () => (/* binding */ refCy),
/* harmony export */   refD: () => (/* binding */ refD),
/* harmony export */   refDKeepOffset: () => (/* binding */ refDKeepOffset),
/* harmony export */   refDResetOffset: () => (/* binding */ refDResetOffset),
/* harmony export */   refDx: () => (/* binding */ refDx),
/* harmony export */   refDy: () => (/* binding */ refDy),
/* harmony export */   refHeight: () => (/* binding */ refHeight),
/* harmony export */   refHeight2: () => (/* binding */ refHeight2),
/* harmony export */   refPoints: () => (/* binding */ refPoints),
/* harmony export */   refPointsKeepOffset: () => (/* binding */ refPointsKeepOffset),
/* harmony export */   refPointsResetOffset: () => (/* binding */ refPointsResetOffset),
/* harmony export */   refR: () => (/* binding */ refR),
/* harmony export */   refRCircumscribed: () => (/* binding */ refRCircumscribed),
/* harmony export */   refRInscribed: () => (/* binding */ refRInscribed),
/* harmony export */   refRx: () => (/* binding */ refRx),
/* harmony export */   refRy: () => (/* binding */ refRy),
/* harmony export */   refWidth: () => (/* binding */ refWidth),
/* harmony export */   refWidth2: () => (/* binding */ refWidth2),
/* harmony export */   refX: () => (/* binding */ refX),
/* harmony export */   refX2: () => (/* binding */ refX2),
/* harmony export */   refY: () => (/* binding */ refY),
/* harmony export */   refY2: () => (/* binding */ refY2)
/* harmony export */ });
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");


const ref = {
// We do not set `ref` attribute directly on an element.
// The attribute itself does not qualify for relative positioning.
};
// if `refX` is in [0, 1] then `refX` is a fraction of bounding box width
// if `refX` is < 0 then `refX`'s absolute values is the right coordinate of the bounding box
// otherwise, `refX` is the left coordinate of the bounding box
const refX = {
    position: positionWrapper('x', 'width', 'origin'),
};
const refY = {
    position: positionWrapper('y', 'height', 'origin'),
};
// `ref-dx` and `ref-dy` define the offset of the subelement relative to the right and/or bottom
// coordinate of the reference element.
const refDx = {
    position: positionWrapper('x', 'width', 'corner'),
};
const refDy = {
    position: positionWrapper('y', 'height', 'corner'),
};
// 'ref-width'/'ref-height' defines the width/height of the subelement relatively to
// the reference element size
// val in 0..1         ref-width = 0.75 sets the width to 75% of the ref. el. width
// val < 0 || val > 1  ref-height = -20 sets the height to the ref. el. height shorter by 20
const refWidth = {
    set: setWrapper('width', 'width'),
};
const refHeight = {
    set: setWrapper('height', 'height'),
};
const refRx = {
    set: setWrapper('rx', 'width'),
};
const refRy = {
    set: setWrapper('ry', 'height'),
};
const refRInscribed = {
    set: ((attrName) => {
        const widthFn = setWrapper(attrName, 'width');
        const heightFn = setWrapper(attrName, 'height');
        return function (value, options) {
            const refBBox = options.refBBox;
            const fn = refBBox.height > refBBox.width ? widthFn : heightFn;
            return _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(fn, this, value, options);
        };
    })('r'),
};
const refRCircumscribed = {
    set(val, { refBBox }) {
        let value = parseFloat(val);
        const percentage = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.NumberExt.isPercentage(val);
        if (percentage) {
            value /= 100;
        }
        const diagonalLength = Math.sqrt(refBBox.height * refBBox.height + refBBox.width * refBBox.width);
        let rValue;
        if (Number.isFinite(value)) {
            if (percentage || (value >= 0 && value <= 1)) {
                rValue = value * diagonalLength;
            }
            else {
                rValue = Math.max(value + diagonalLength, 0);
            }
        }
        return { r: rValue };
    },
};
const refCx = {
    set: setWrapper('cx', 'width'),
};
const refCy = {
    set: setWrapper('cy', 'height'),
};
const refDResetOffset = {
    set: dWrapper({ resetOffset: true }),
};
const refDKeepOffset = {
    set: dWrapper({ resetOffset: false }),
};
const refPointsResetOffset = {
    set: pointsWrapper({ resetOffset: true }),
};
const refPointsKeepOffset = {
    set: pointsWrapper({ resetOffset: false }),
};
// aliases
// -------
const refR = refRInscribed;
const refD = refDResetOffset;
const refPoints = refPointsResetOffset;
// Allows to combine both absolute and relative positioning
// refX: 50%, refX2: 20
const refX2 = refX;
const refY2 = refY;
const refWidth2 = refWidth;
const refHeight2 = refHeight;
// utils
// -----
function positionWrapper(axis, dimension, origin) {
    return (val, { refBBox }) => {
        if (val == null) {
            return null;
        }
        let value = parseFloat(val);
        const percentage = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.NumberExt.isPercentage(val);
        if (percentage) {
            value /= 100;
        }
        let delta;
        if (Number.isFinite(value)) {
            const refOrigin = refBBox[origin];
            if (percentage || (value > 0 && value < 1)) {
                delta = refOrigin[axis] + refBBox[dimension] * value;
            }
            else {
                delta = refOrigin[axis] + value;
            }
        }
        const point = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point();
        point[axis] = delta || 0;
        return point;
    };
}
function setWrapper(attrName, dimension) {
    return function (val, { refBBox }) {
        let value = parseFloat(val);
        const percentage = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.NumberExt.isPercentage(val);
        if (percentage) {
            value /= 100;
        }
        const attrs = {};
        if (Number.isFinite(value)) {
            const attrValue = percentage || (value >= 0 && value <= 1)
                ? value * refBBox[dimension]
                : Math.max(value + refBBox[dimension], 0);
            attrs[attrName] = attrValue;
        }
        return attrs;
    };
}
function shapeWrapper(shapeConstructor, options) {
    const cacheName = 'x6-shape';
    const resetOffset = options && options.resetOffset;
    return function (value, { elem, refBBox }) {
        let cache = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.data(elem, cacheName);
        if (!cache || cache.value !== value) {
            // only recalculate if value has changed
            const cachedShape = shapeConstructor(value);
            cache = {
                value,
                shape: cachedShape,
                shapeBBox: cachedShape.bbox(),
            };
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.data(elem, cacheName, cache);
        }
        const shape = cache.shape.clone();
        const shapeBBox = cache.shapeBBox.clone();
        const shapeOrigin = shapeBBox.getOrigin();
        const refOrigin = refBBox.getOrigin();
        shapeBBox.x = refOrigin.x;
        shapeBBox.y = refOrigin.y;
        const fitScale = refBBox.getMaxScaleToFit(shapeBBox, refOrigin);
        // `maxRectScaleToFit` can give Infinity if width or height is 0
        const sx = shapeBBox.width === 0 || refBBox.width === 0 ? 1 : fitScale.sx;
        const sy = shapeBBox.height === 0 || refBBox.height === 0 ? 1 : fitScale.sy;
        shape.scale(sx, sy, shapeOrigin);
        if (resetOffset) {
            shape.translate(-shapeOrigin.x, -shapeOrigin.y);
        }
        return shape;
    };
}
// `d` attribute for SVGPaths
function dWrapper(options) {
    function pathConstructor(value) {
        return _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Path.parse(value);
    }
    const shape = shapeWrapper(pathConstructor, options);
    return (value, args) => {
        const path = shape(value, args);
        return {
            d: path.serialize(),
        };
    };
}
// `points` attribute for SVGPolylines and SVGPolygons
function pointsWrapper(options) {
    const shape = shapeWrapper((points) => new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Polyline(points), options);
    return (value, args) => {
        const polyline = shape(value, args);
        return {
            points: polyline.serialize(),
        };
    };
}
//# sourceMappingURL=ref.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/attr/stroke.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/attr/stroke.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   stroke: () => (/* binding */ stroke)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");

const stroke = {
    qualify: _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isPlainObject,
    set(stroke, { view }) {
        const cell = view.cell;
        const options = Object.assign({}, stroke);
        if (cell.isEdge() && options.type === 'linearGradient') {
            const edgeView = view;
            const source = edgeView.sourcePoint;
            const target = edgeView.targetPoint;
            options.id = `gradient-${options.type}-${cell.id}`;
            options.attrs = Object.assign(Object.assign({}, options.attrs), { x1: source.x, y1: source.y, x2: target.x, y2: target.y, gradientUnits: 'userSpaceOnUse' });
            view.graph.defs.remove(options.id);
        }
        return `url(#${view.graph.defineGradient(options)})`;
    },
};
//# sourceMappingURL=stroke.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/attr/style.js":
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/attr/style.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   style: () => (/* binding */ style)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");

const style = {
    qualify: _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isPlainObject,
    set(styles, { elem }) {
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.css(elem, styles);
    },
};
//# sourceMappingURL=style.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/attr/text.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/attr/text.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   annotations: () => (/* binding */ annotations),
/* harmony export */   displayEmpty: () => (/* binding */ displayEmpty),
/* harmony export */   eol: () => (/* binding */ eol),
/* harmony export */   lineHeight: () => (/* binding */ lineHeight),
/* harmony export */   text: () => (/* binding */ text),
/* harmony export */   textPath: () => (/* binding */ textPath),
/* harmony export */   textVerticalAnchor: () => (/* binding */ textVerticalAnchor),
/* harmony export */   textWrap: () => (/* binding */ textWrap)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");

const text = {
    qualify(text, { attrs }) {
        return attrs.textWrap == null || !_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isPlainObject(attrs.textWrap);
    },
    set(text, { view, elem, attrs }) {
        const cacheName = 'x6-text';
        const cache = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.data(elem, cacheName);
        const json = (str) => {
            try {
                return JSON.parse(str);
            }
            catch (error) {
                return str;
            }
        };
        const options = {
            x: attrs.x,
            eol: attrs.eol,
            annotations: json(attrs.annotations),
            textPath: json(attrs['text-path'] || attrs.textPath),
            textVerticalAnchor: (attrs['text-vertical-anchor'] ||
                attrs.textVerticalAnchor),
            displayEmpty: (attrs['display-empty'] || attrs.displayEmpty) === 'true',
            lineHeight: (attrs['line-height'] || attrs.lineHeight),
        };
        const fontSize = (attrs['font-size'] || attrs.fontSize);
        const textHash = JSON.stringify([text, options]);
        if (fontSize) {
            elem.setAttribute('font-size', fontSize);
        }
        // Updates the text only if there was a change in the string
        // or any of its attributes.
        if (cache == null || cache !== textHash) {
            // Text Along Path Selector
            const textPath = options.textPath;
            if (textPath != null && typeof textPath === 'object') {
                const selector = textPath.selector;
                if (typeof selector === 'string') {
                    const pathNode = view.find(selector)[0];
                    if (pathNode instanceof SVGPathElement) {
                        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.ensureId(pathNode);
                        options.textPath = Object.assign({ 'xlink:href': `#${pathNode.id}` }, textPath);
                    }
                }
            }
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.text(elem, `${text}`, options);
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.data(elem, cacheName, textHash);
        }
    },
};
const textWrap = {
    qualify: _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isPlainObject,
    set(val, { view, elem, attrs, refBBox }) {
        const info = val;
        // option `width`
        const width = info.width || 0;
        if (_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.NumberExt.isPercentage(width)) {
            refBBox.width *= parseFloat(width) / 100;
        }
        else if (width <= 0) {
            refBBox.width += width;
        }
        else {
            refBBox.width = width;
        }
        // option `height`
        const height = info.height || 0;
        if (_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.NumberExt.isPercentage(height)) {
            refBBox.height *= parseFloat(height) / 100;
        }
        else if (height <= 0) {
            refBBox.height += height;
        }
        else {
            refBBox.height = height;
        }
        // option `text`
        let wrappedText;
        let txt = info.text;
        if (txt == null) {
            // the edge of the label is assigned to txt
            txt = attrs.text || (elem === null || elem === void 0 ? void 0 : elem.textContent);
        }
        if (txt != null) {
            wrappedText = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.breakText(`${txt}`, refBBox, {
                'font-weight': attrs['font-weight'] || attrs.fontWeight,
                'font-size': attrs['font-size'] || attrs.fontSize,
                'font-family': attrs['font-family'] || attrs.fontFamily,
                lineHeight: attrs.lineHeight,
            }, {
                // svgDocument: view.graph.view.svg,
                ellipsis: info.ellipsis,
                // hyphen: info.hyphen as string,
                // breakWord: info.breakWord as boolean,
            });
        }
        else {
            wrappedText = '';
        }
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(text.set, this, wrappedText, {
            view,
            elem,
            attrs,
            refBBox,
            cell: view.cell,
        });
    },
};
const isTextInUse = (val, { attrs }) => {
    return attrs.text !== undefined;
};
const lineHeight = {
    qualify: isTextInUse,
};
const textVerticalAnchor = {
    qualify: isTextInUse,
};
const textPath = {
    qualify: isTextInUse,
};
const annotations = {
    qualify: isTextInUse,
};
const eol = {
    qualify: isTextInUse,
};
const displayEmpty = {
    qualify: isTextInUse,
};
//# sourceMappingURL=text.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/attr/title.js":
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/attr/title.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   title: () => (/* binding */ title)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");

const title = {
    qualify(title, { elem }) {
        // HTMLElement title is specified via an attribute (i.e. not an element)
        return elem instanceof SVGElement;
    },
    set(val, { elem }) {
        const cacheName = 'x6-title';
        const title = `${val}`;
        const cache = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.data(elem, cacheName);
        if (cache == null || cache !== title) {
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.data(elem, cacheName, title);
            // Generally SVGTitleElement should be the first child
            // element of its parent.
            const firstChild = elem.firstChild;
            if (firstChild && firstChild.tagName.toUpperCase() === 'TITLE') {
                // Update an existing title
                const titleElem = firstChild;
                titleElem.textContent = title;
            }
            else {
                // Create a new title
                const titleNode = document.createElementNS(elem.namespaceURI, 'title');
                titleNode.textContent = title;
                elem.insertBefore(titleNode, firstChild);
            }
        }
    },
};
//# sourceMappingURL=title.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/background/flip-x.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/background/flip-x.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   flipX: () => (/* binding */ flipX)
/* harmony export */ });
const flipX = function (img) {
    // d b
    // d b
    const canvas = document.createElement('canvas');
    const width = img.width;
    const height = img.height;
    canvas.width = width * 2;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    // left image
    ctx.drawImage(img, 0, 0, width, height);
    // flipped right image
    ctx.translate(2 * width, 0);
    ctx.scale(-1, 1);
    ctx.drawImage(img, 0, 0, width, height);
    return canvas;
};
//# sourceMappingURL=flip-x.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/background/flip-xy.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/background/flip-xy.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   flipXY: () => (/* binding */ flipXY)
/* harmony export */ });
const flipXY = function (img) {
    // d b
    // q p
    const canvas = document.createElement('canvas');
    const width = img.width;
    const height = img.height;
    canvas.width = 2 * width;
    canvas.height = 2 * height;
    const ctx = canvas.getContext('2d');
    // top-left image
    ctx.drawImage(img, 0, 0, width, height);
    // xy-flipped bottom-right image
    ctx.setTransform(-1, 0, 0, -1, canvas.width, canvas.height);
    ctx.drawImage(img, 0, 0, width, height);
    // x-flipped top-right image
    ctx.setTransform(-1, 0, 0, 1, canvas.width, 0);
    ctx.drawImage(img, 0, 0, width, height);
    // y-flipped bottom-left image
    ctx.setTransform(1, 0, 0, -1, 0, canvas.height);
    ctx.drawImage(img, 0, 0, width, height);
    return canvas;
};
//# sourceMappingURL=flip-xy.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/background/flip-y.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/background/flip-y.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   flipY: () => (/* binding */ flipY)
/* harmony export */ });
const flipY = function (img) {
    // d d
    // q q
    const canvas = document.createElement('canvas');
    const width = img.width;
    const height = img.height;
    canvas.width = width;
    canvas.height = height * 2;
    const ctx = canvas.getContext('2d');
    // top image
    ctx.drawImage(img, 0, 0, width, height);
    // flipped bottom image
    ctx.translate(0, 2 * height);
    ctx.scale(1, -1);
    ctx.drawImage(img, 0, 0, width, height);
    return canvas;
};
//# sourceMappingURL=flip-y.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/background/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/background/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Background: () => (/* binding */ Background)
/* harmony export */ });
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry */ "./node_modules/@antv/x6/es/registry/registry.js");
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./main */ "./node_modules/@antv/x6/es/registry/background/main.js");
/* eslint-disable @typescript-eslint/ban-types */


var Background;
(function (Background) {
    Background.presets = Object.assign({}, _main__WEBPACK_IMPORTED_MODULE_1__);
    Background.presets['flip-x'] = _main__WEBPACK_IMPORTED_MODULE_1__.flipX;
    Background.presets['flip-y'] = _main__WEBPACK_IMPORTED_MODULE_1__.flipY;
    Background.presets['flip-xy'] = _main__WEBPACK_IMPORTED_MODULE_1__.flipXY;
    Background.registry = _registry__WEBPACK_IMPORTED_MODULE_0__.Registry.create({
        type: 'background pattern',
    });
    Background.registry.register(Background.presets, true);
})(Background || (Background = {}));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/background/main.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/background/main.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   flipX: () => (/* reexport safe */ _flip_x__WEBPACK_IMPORTED_MODULE_0__.flipX),
/* harmony export */   flipXY: () => (/* reexport safe */ _flip_xy__WEBPACK_IMPORTED_MODULE_2__.flipXY),
/* harmony export */   flipY: () => (/* reexport safe */ _flip_y__WEBPACK_IMPORTED_MODULE_1__.flipY),
/* harmony export */   watermark: () => (/* reexport safe */ _watermark__WEBPACK_IMPORTED_MODULE_3__.watermark)
/* harmony export */ });
/* harmony import */ var _flip_x__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./flip-x */ "./node_modules/@antv/x6/es/registry/background/flip-x.js");
/* harmony import */ var _flip_y__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./flip-y */ "./node_modules/@antv/x6/es/registry/background/flip-y.js");
/* harmony import */ var _flip_xy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./flip-xy */ "./node_modules/@antv/x6/es/registry/background/flip-xy.js");
/* harmony import */ var _watermark__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./watermark */ "./node_modules/@antv/x6/es/registry/background/watermark.js");




//# sourceMappingURL=main.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/background/watermark.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/background/watermark.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   watermark: () => (/* binding */ watermark)
/* harmony export */ });
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");

const watermark = function (img, options) {
    const width = img.width;
    const height = img.height;
    const canvas = document.createElement('canvas');
    canvas.width = width * 3;
    canvas.height = height * 3;
    const ctx = canvas.getContext('2d');
    const angle = options.angle != null ? -options.angle : -20;
    const radians = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Angle.toRad(angle);
    const stepX = canvas.width / 4;
    const stepY = canvas.height / 4;
    for (let i = 0; i < 4; i += 1) {
        for (let j = 0; j < 4; j += 1) {
            if ((i + j) % 2 > 0) {
                ctx.setTransform(1, 0, 0, 1, (2 * i - 1) * stepX, (2 * j - 1) * stepY);
                ctx.rotate(radians);
                ctx.drawImage(img, -width / 2, -height / 2, width, height);
            }
        }
    }
    return canvas;
};
//# sourceMappingURL=watermark.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/connection-point/anchor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connection-point/anchor.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   anchor: () => (/* binding */ anchor)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/connection-point/util.js");

function alignLine(line, type, offset = 0) {
    const { start, end } = line;
    let a;
    let b;
    let direction;
    let coordinate;
    switch (type) {
        case 'left':
            coordinate = 'x';
            a = end;
            b = start;
            direction = -1;
            break;
        case 'right':
            coordinate = 'x';
            a = start;
            b = end;
            direction = 1;
            break;
        case 'top':
            coordinate = 'y';
            a = end;
            b = start;
            direction = -1;
            break;
        case 'bottom':
            coordinate = 'y';
            a = start;
            b = end;
            direction = 1;
            break;
        default:
            return;
    }
    if (start[coordinate] < end[coordinate]) {
        a[coordinate] = b[coordinate];
    }
    else {
        b[coordinate] = a[coordinate];
    }
    if (Number.isFinite(offset)) {
        a[coordinate] += direction * offset;
        b[coordinate] += direction * offset;
    }
}
/**
 * Places the connection point at the edge's endpoint.
 */
const anchor = function (line, view, magnet, options) {
    const { alignOffset, align } = options;
    if (align) {
        alignLine(line, align, alignOffset);
    }
    return (0,_util__WEBPACK_IMPORTED_MODULE_0__.offset)(line.end, line.start, options.offset);
};
//# sourceMappingURL=anchor.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/connection-point/bbox.js":
/*!********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connection-point/bbox.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bbox: () => (/* binding */ bbox)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/connection-point/util.js");

/**
 * Places the connection point at the intersection between the edge
 * path end segment and the target node bbox.
 */
const bbox = function (line, view, magnet, options) {
    const bbox = view.getBBoxOfElement(magnet);
    if (options.stroked) {
        bbox.inflate((0,_util__WEBPACK_IMPORTED_MODULE_0__.getStrokeWidth)(magnet) / 2);
    }
    const intersections = line.intersect(bbox);
    const p = intersections && intersections.length
        ? line.start.closest(intersections)
        : line.end;
    return (0,_util__WEBPACK_IMPORTED_MODULE_0__.offset)(p, line.start, options.offset);
};
//# sourceMappingURL=bbox.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/connection-point/boundary.js":
/*!************************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connection-point/boundary.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   boundary: () => (/* binding */ boundary)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/connection-point/util.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util */ "./node_modules/@antv/x6/es/util/index.js");




/**
 * Places the connection point at the intersection between the
 * edge path end segment and the actual shape of the target magnet.
 */
const boundary = function (line, view, magnet, options) {
    let node;
    let intersection;
    const anchor = line.end;
    const selector = options.selector;
    if (typeof selector === 'string') {
        node = view.findOne(selector);
    }
    else if (Array.isArray(selector)) {
        node = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.getByPath(magnet, selector);
    }
    else {
        node = (0,_util__WEBPACK_IMPORTED_MODULE_2__.findShapeNode)(magnet);
    }
    if (!_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.isSVGGraphicsElement(node)) {
        if (node === magnet || !_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.isSVGGraphicsElement(magnet)) {
            return anchor;
        }
        node = magnet;
    }
    const localShape = view.getShapeOfElement(node);
    const magnetMatrix = view.getMatrixOfElement(node);
    const translateMatrix = view.getRootTranslatedMatrix();
    const rotateMatrix = view.getRootRotatedMatrix();
    const targetMatrix = translateMatrix
        .multiply(rotateMatrix)
        .multiply(magnetMatrix);
    const localMatrix = targetMatrix.inverse();
    const localLine = _util__WEBPACK_IMPORTED_MODULE_3__.Util.transformLine(line, localMatrix);
    const localRef = localLine.start.clone();
    const data = view.getDataOfElement(node);
    if (options.insideout === false) {
        if (data.shapeBBox == null) {
            data.shapeBBox = localShape.bbox();
        }
        const localBBox = data.shapeBBox;
        if (localBBox != null && localBBox.containsPoint(localRef)) {
            return anchor;
        }
    }
    if (options.extrapolate === true) {
        localLine.setLength(1e6);
    }
    // Caching segment subdivisions for paths
    let pathOptions;
    if (_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Path.isPath(localShape)) {
        const precision = options.precision || 2;
        if (data.segmentSubdivisions == null) {
            data.segmentSubdivisions = localShape.getSegmentSubdivisions({
                precision,
            });
        }
        pathOptions = {
            precision,
            segmentSubdivisions: data.segmentSubdivisions,
        };
        intersection = localLine.intersect(localShape, pathOptions);
    }
    else {
        intersection = localLine.intersect(localShape);
    }
    if (intersection) {
        if (Array.isArray(intersection)) {
            intersection = localRef.closest(intersection);
        }
    }
    else if (options.sticky === true) {
        // No intersection, find the closest point instead
        if (_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.isRectangle(localShape)) {
            intersection = localShape.getNearestPointToPoint(localRef);
        }
        else if (_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Ellipse.isEllipse(localShape)) {
            intersection = localShape.intersectsWithLineFromCenterToPoint(localRef);
        }
        else {
            intersection = localShape.closestPoint(localRef, pathOptions);
        }
    }
    const cp = intersection
        ? _util__WEBPACK_IMPORTED_MODULE_3__.Util.transformPoint(intersection, targetMatrix)
        : anchor;
    let cpOffset = options.offset || 0;
    if (options.stroked !== false) {
        if (typeof cpOffset === 'object') {
            cpOffset = Object.assign({}, cpOffset);
            if (cpOffset.x == null) {
                cpOffset.x = 0;
            }
            cpOffset.x += (0,_util__WEBPACK_IMPORTED_MODULE_2__.getStrokeWidth)(node) / 2;
        }
        else {
            cpOffset += (0,_util__WEBPACK_IMPORTED_MODULE_2__.getStrokeWidth)(node) / 2;
        }
    }
    return (0,_util__WEBPACK_IMPORTED_MODULE_2__.offset)(cp, line.start, cpOffset);
};
//# sourceMappingURL=boundary.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/connection-point/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connection-point/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConnectionPoint: () => (/* binding */ ConnectionPoint)
/* harmony export */ });
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry */ "./node_modules/@antv/x6/es/registry/registry.js");
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./main */ "./node_modules/@antv/x6/es/registry/connection-point/main.js");


var ConnectionPoint;
(function (ConnectionPoint) {
    ConnectionPoint.presets = _main__WEBPACK_IMPORTED_MODULE_1__;
    ConnectionPoint.registry = _registry__WEBPACK_IMPORTED_MODULE_0__.Registry.create({
        type: 'connection point',
    });
    ConnectionPoint.registry.register(ConnectionPoint.presets, true);
})(ConnectionPoint || (ConnectionPoint = {}));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/connection-point/main.js":
/*!********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connection-point/main.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   anchor: () => (/* reexport safe */ _anchor__WEBPACK_IMPORTED_MODULE_3__.anchor),
/* harmony export */   bbox: () => (/* reexport safe */ _bbox__WEBPACK_IMPORTED_MODULE_0__.bbox),
/* harmony export */   boundary: () => (/* reexport safe */ _boundary__WEBPACK_IMPORTED_MODULE_2__.boundary),
/* harmony export */   rect: () => (/* reexport safe */ _rect__WEBPACK_IMPORTED_MODULE_1__.rect)
/* harmony export */ });
/* harmony import */ var _bbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bbox */ "./node_modules/@antv/x6/es/registry/connection-point/bbox.js");
/* harmony import */ var _rect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rect */ "./node_modules/@antv/x6/es/registry/connection-point/rect.js");
/* harmony import */ var _boundary__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./boundary */ "./node_modules/@antv/x6/es/registry/connection-point/boundary.js");
/* harmony import */ var _anchor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./anchor */ "./node_modules/@antv/x6/es/registry/connection-point/anchor.js");




//# sourceMappingURL=main.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/connection-point/rect.js":
/*!********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connection-point/rect.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   rect: () => (/* binding */ rect)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _bbox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bbox */ "./node_modules/@antv/x6/es/registry/connection-point/bbox.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/connection-point/util.js");



/**
 * Places the connection point at the intersection between the
 * link path end segment and the element's unrotated bbox.
 */
const rect = function (line, view, magnet, options, type) {
    const cell = view.cell;
    const angle = cell.isNode() ? cell.getAngle() : 0;
    if (angle === 0) {
        return _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(_bbox__WEBPACK_IMPORTED_MODULE_1__.bbox, this, line, view, magnet, options, type);
    }
    const bboxRaw = view.getUnrotatedBBoxOfElement(magnet);
    if (options.stroked) {
        bboxRaw.inflate((0,_util__WEBPACK_IMPORTED_MODULE_2__.getStrokeWidth)(magnet) / 2);
    }
    const center = bboxRaw.getCenter();
    const lineRaw = line.clone().rotate(angle, center);
    const intersections = lineRaw.setLength(1e6).intersect(bboxRaw);
    const p = intersections && intersections.length
        ? lineRaw.start.closest(intersections).rotate(-angle, center)
        : line.end;
    return (0,_util__WEBPACK_IMPORTED_MODULE_2__.offset)(p, line.start, options.offset);
};
//# sourceMappingURL=rect.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/connection-point/util.js":
/*!********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connection-point/util.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   findShapeNode: () => (/* binding */ findShapeNode),
/* harmony export */   getStrokeWidth: () => (/* binding */ getStrokeWidth),
/* harmony export */   offset: () => (/* binding */ offset)
/* harmony export */ });
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");

function offset(p1, p2, offset) {
    let tx;
    if (typeof offset === 'object') {
        if (Number.isFinite(offset.y)) {
            const line = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Line(p2, p1);
            const { start, end } = line.parallel(offset.y);
            p2 = start; // eslint-disable-line
            p1 = end; // eslint-disable-line
        }
        tx = offset.x;
    }
    else {
        tx = offset;
    }
    if (tx == null || !Number.isFinite(tx)) {
        return p1;
    }
    const length = p1.distance(p2);
    if (tx === 0 && length > 0) {
        return p1;
    }
    return p1.move(p2, -Math.min(tx, length - 1));
}
function getStrokeWidth(magnet) {
    const stroke = magnet.getAttribute('stroke-width');
    if (stroke === null) {
        return 0;
    }
    return parseFloat(stroke) || 0;
}
function findShapeNode(magnet) {
    if (magnet == null) {
        return null;
    }
    let node = magnet;
    do {
        let tagName = node.tagName;
        if (typeof tagName !== 'string')
            return null;
        tagName = tagName.toUpperCase();
        if (tagName === 'G') {
            node = node.firstElementChild;
        }
        else if (tagName === 'TITLE') {
            node = node.nextElementSibling;
        }
        else
            break;
    } while (node);
    return node;
}
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/connection-strategy/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connection-strategy/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConnectionStrategy: () => (/* binding */ ConnectionStrategy)
/* harmony export */ });
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry */ "./node_modules/@antv/x6/es/registry/registry.js");
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./main */ "./node_modules/@antv/x6/es/registry/connection-strategy/main.js");


var ConnectionStrategy;
(function (ConnectionStrategy) {
    ConnectionStrategy.presets = _main__WEBPACK_IMPORTED_MODULE_1__;
    ConnectionStrategy.registry = _registry__WEBPACK_IMPORTED_MODULE_0__.Registry.create({
        type: 'connection strategy',
    });
    ConnectionStrategy.registry.register(ConnectionStrategy.presets, true);
})(ConnectionStrategy || (ConnectionStrategy = {}));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/connection-strategy/main.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connection-strategy/main.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   noop: () => (/* reexport safe */ _noop__WEBPACK_IMPORTED_MODULE_0__.noop),
/* harmony export */   pinAbsolute: () => (/* reexport safe */ _pin__WEBPACK_IMPORTED_MODULE_1__.pinAbsolute),
/* harmony export */   pinRelative: () => (/* reexport safe */ _pin__WEBPACK_IMPORTED_MODULE_1__.pinRelative)
/* harmony export */ });
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./noop */ "./node_modules/@antv/x6/es/registry/connection-strategy/noop.js");
/* harmony import */ var _pin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pin */ "./node_modules/@antv/x6/es/registry/connection-strategy/pin.js");


//# sourceMappingURL=main.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/connection-strategy/noop.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connection-strategy/noop.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   noop: () => (/* binding */ noop)
/* harmony export */ });
const noop = (terminal) => terminal;
//# sourceMappingURL=noop.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/connection-strategy/pin.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connection-strategy/pin.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   pinAbsolute: () => (/* binding */ pinAbsolute),
/* harmony export */   pinRelative: () => (/* binding */ pinRelative)
/* harmony export */ });
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");

function toPercentage(value, max) {
    if (max === 0) {
        return '0%';
    }
    return `${Math.round((value / max) * 100)}%`;
}
function pin(relative) {
    const strategy = (terminal, view, magnet, coords) => {
        return view.isEdgeElement(magnet)
            ? pinEdgeTerminal(relative, terminal, view, magnet, coords)
            : pinNodeTerminal(relative, terminal, view, magnet, coords);
    };
    return strategy;
}
function pinNodeTerminal(relative, data, view, magnet, coords) {
    const node = view.cell;
    const angle = node.getAngle();
    const bbox = view.getUnrotatedBBoxOfElement(magnet);
    const center = node.getBBox().getCenter();
    const pos = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(coords).rotate(angle, center);
    let dx = pos.x - bbox.x;
    let dy = pos.y - bbox.y;
    if (relative) {
        dx = toPercentage(dx, bbox.width);
        dy = toPercentage(dy, bbox.height);
    }
    data.anchor = {
        name: 'topLeft',
        args: {
            dx,
            dy,
            rotate: true,
        },
    };
    return data;
}
function pinEdgeTerminal(relative, end, view, magnet, coords) {
    const connection = view.getConnection();
    if (!connection) {
        return end;
    }
    const length = connection.closestPointLength(coords);
    if (relative) {
        const totalLength = connection.length();
        end.anchor = {
            name: 'ratio',
            args: {
                ratio: length / totalLength,
            },
        };
    }
    else {
        end.anchor = {
            name: 'length',
            args: {
                length,
            },
        };
    }
    return end;
}
const pinRelative = pin(true);
const pinAbsolute = pin(false);
//# sourceMappingURL=pin.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/connector/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connector/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Connector: () => (/* binding */ Connector)
/* harmony export */ });
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry */ "./node_modules/@antv/x6/es/registry/registry.js");
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./main */ "./node_modules/@antv/x6/es/registry/connector/main.js");


var Connector;
(function (Connector) {
    Connector.presets = _main__WEBPACK_IMPORTED_MODULE_1__;
    Connector.registry = _registry__WEBPACK_IMPORTED_MODULE_0__.Registry.create({
        type: 'connector',
    });
    Connector.registry.register(Connector.presets, true);
})(Connector || (Connector = {}));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/connector/jumpover.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connector/jumpover.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   jumpover: () => (/* binding */ jumpover)
/* harmony export */ });
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* eslint-disable no-underscore-dangle */

// takes care of math. error for case when jump is too close to end of line
const CLOSE_PROXIMITY_PADDING = 1;
const F13 = 1 / 3;
const F23 = 2 / 3;
function setupUpdating(view) {
    let updateList = view.graph._jumpOverUpdateList;
    // first time setup for this paper
    if (updateList == null) {
        updateList = view.graph._jumpOverUpdateList = [];
        view.graph.on('cell:mouseup', () => {
            const list = view.graph._jumpOverUpdateList;
            // add timeout to wait for the target node to be connected
            // fix https://github.com/antvis/X6/issues/3387
            setTimeout(() => {
                for (let i = 0; i < list.length; i += 1) {
                    list[i].update();
                }
            });
        });
        view.graph.on('model:reseted', () => {
            updateList = view.graph._jumpOverUpdateList = [];
        });
    }
    // add this link to a list so it can be updated when some other link is updated
    if (updateList.indexOf(view) < 0) {
        updateList.push(view);
        // watch for change of connector type or removal of link itself
        // to remove the link from a list of jump over connectors
        const clean = () => updateList.splice(updateList.indexOf(view), 1);
        view.cell.once('change:connector', clean);
        view.cell.once('removed', clean);
    }
}
function createLines(sourcePoint, targetPoint, route = []) {
    const points = [sourcePoint, ...route, targetPoint];
    const lines = [];
    points.forEach((point, idx) => {
        const next = points[idx + 1];
        if (next != null) {
            lines.push(new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Line(point, next));
        }
    });
    return lines;
}
function findLineIntersections(line, crossCheckLines) {
    const intersections = [];
    crossCheckLines.forEach((crossCheckLine) => {
        const intersection = line.intersectsWithLine(crossCheckLine);
        if (intersection) {
            intersections.push(intersection);
        }
    });
    return intersections;
}
function getDistence(p1, p2) {
    return new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Line(p1, p2).squaredLength();
}
/**
 * Split input line into multiple based on intersection points.
 */
function createJumps(line, intersections, jumpSize) {
    return intersections.reduce((memo, point, idx) => {
        // skipping points that were merged with the previous line
        // to make bigger arc over multiple lines that are close to each other
        if (skippedPoints.includes(point)) {
            return memo;
        }
        // always grab the last line from buffer and modify it
        const lastLine = memo.pop() || line;
        // calculate start and end of jump by moving by a given size of jump
        const jumpStart = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(point).move(lastLine.start, -jumpSize);
        let jumpEnd = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(point).move(lastLine.start, +jumpSize);
        // now try to look at the next intersection point
        const nextPoint = intersections[idx + 1];
        if (nextPoint != null) {
            const distance = jumpEnd.distance(nextPoint);
            if (distance <= jumpSize) {
                // next point is close enough, move the jump end by this
                // difference and mark the next point to be skipped
                jumpEnd = nextPoint.move(lastLine.start, distance);
                skippedPoints.push(nextPoint);
            }
        }
        else {
            // this block is inside of `else` as an optimization so the distance is
            // not calculated when we know there are no other intersection points
            const endDistance = jumpStart.distance(lastLine.end);
            // if the end is too close to possible jump, draw remaining line instead of a jump
            if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {
                memo.push(lastLine);
                return memo;
            }
        }
        const startDistance = jumpEnd.distance(lastLine.start);
        if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {
            // if the start of line is too close to jump, draw that line instead of a jump
            memo.push(lastLine);
            return memo;
        }
        // finally create a jump line
        const jumpLine = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Line(jumpStart, jumpEnd);
        // it's just simple line but with a `isJump` property
        jumppedLines.push(jumpLine);
        memo.push(new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Line(lastLine.start, jumpStart), jumpLine, new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Line(jumpEnd, lastLine.end));
        return memo;
    }, []);
}
function buildPath(lines, jumpSize, jumpType, radius) {
    const path = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Path();
    let segment;
    // first move to the start of a first line
    segment = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Path.createSegment('M', lines[0].start);
    path.appendSegment(segment);
    lines.forEach((line, index) => {
        if (jumppedLines.includes(line)) {
            let angle;
            let diff;
            let control1;
            let control2;
            if (jumpType === 'arc') {
                // approximates semicircle with 2 curves
                angle = -90;
                // determine rotation of arc based on difference between points
                diff = line.start.diff(line.end);
                // make sure the arc always points up (or right)
                const xAxisRotate = diff.x < 0 || (diff.x === 0 && diff.y < 0);
                if (xAxisRotate) {
                    angle += 180;
                }
                const center = line.getCenter();
                const centerLine = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Line(center, line.end).rotate(angle, center);
                let halfLine;
                // first half
                halfLine = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Line(line.start, center);
                control1 = halfLine.pointAt(2 / 3).rotate(angle, line.start);
                control2 = centerLine.pointAt(1 / 3).rotate(-angle, centerLine.end);
                segment = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Path.createSegment('C', control1, control2, centerLine.end);
                path.appendSegment(segment);
                // second half
                halfLine = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Line(center, line.end);
                control1 = centerLine.pointAt(1 / 3).rotate(angle, centerLine.end);
                control2 = halfLine.pointAt(1 / 3).rotate(-angle, line.end);
                segment = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Path.createSegment('C', control1, control2, line.end);
                path.appendSegment(segment);
            }
            else if (jumpType === 'gap') {
                segment = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Path.createSegment('M', line.end);
                path.appendSegment(segment);
            }
            else if (jumpType === 'cubic') {
                // approximates semicircle with 1 curve
                angle = line.start.theta(line.end);
                const xOffset = jumpSize * 0.6;
                let yOffset = jumpSize * 1.35;
                // determine rotation of arc based on difference between points
                diff = line.start.diff(line.end);
                // make sure the arc always points up (or right)
                const xAxisRotate = diff.x < 0 || (diff.x === 0 && diff.y < 0);
                if (xAxisRotate) {
                    yOffset *= -1;
                }
                control1 = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(line.start.x + xOffset, line.start.y + yOffset).rotate(angle, line.start);
                control2 = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(line.end.x - xOffset, line.end.y + yOffset).rotate(angle, line.end);
                segment = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Path.createSegment('C', control1, control2, line.end);
                path.appendSegment(segment);
            }
        }
        else {
            const nextLine = lines[index + 1];
            if (radius === 0 || !nextLine || jumppedLines.includes(nextLine)) {
                segment = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Path.createSegment('L', line.end);
                path.appendSegment(segment);
            }
            else {
                buildRoundedSegment(radius, path, line.end, line.start, nextLine.end);
            }
        }
    });
    return path;
}
function buildRoundedSegment(offset, path, curr, prev, next) {
    const prevDistance = curr.distance(prev) / 2;
    const nextDistance = curr.distance(next) / 2;
    const startMove = -Math.min(offset, prevDistance);
    const endMove = -Math.min(offset, nextDistance);
    const roundedStart = curr.clone().move(prev, startMove).round();
    const roundedEnd = curr.clone().move(next, endMove).round();
    const control1 = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(F13 * roundedStart.x + F23 * curr.x, F23 * curr.y + F13 * roundedStart.y);
    const control2 = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(F13 * roundedEnd.x + F23 * curr.x, F23 * curr.y + F13 * roundedEnd.y);
    let segment;
    segment = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Path.createSegment('L', roundedStart);
    path.appendSegment(segment);
    segment = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Path.createSegment('C', control1, control2, roundedEnd);
    path.appendSegment(segment);
}
let jumppedLines;
let skippedPoints;
const jumpover = function (sourcePoint, targetPoint, routePoints, options = {}) {
    jumppedLines = [];
    skippedPoints = [];
    setupUpdating(this);
    const jumpSize = options.size || 5;
    const jumpType = options.type || 'arc';
    const radius = options.radius || 0;
    // list of connector types not to jump over.
    const ignoreConnectors = options.ignoreConnectors || ['smooth'];
    const graph = this.graph;
    const model = graph.model;
    const allLinks = model.getEdges();
    // there is just one link, draw it directly
    if (allLinks.length === 1) {
        return buildPath(createLines(sourcePoint, targetPoint, routePoints), jumpSize, jumpType, radius);
    }
    const edge = this.cell;
    const thisIndex = allLinks.indexOf(edge);
    const defaultConnector = graph.options.connecting.connector || {};
    // not all links are meant to be jumped over.
    const edges = allLinks.filter((link, idx) => {
        const connector = link.getConnector() || defaultConnector;
        // avoid jumping over links with connector type listed in `ignored connectors`.
        if (ignoreConnectors.includes(connector.name)) {
            return false;
        }
        // filter out links that are above this one and  have the same connector type
        // otherwise there would double hoops for each intersection
        if (idx > thisIndex) {
            return connector.name !== 'jumpover';
        }
        return true;
    });
    // find views for all links
    const linkViews = edges.map((edge) => {
        return graph.findViewByCell(edge);
    });
    // create lines for this link
    const thisLines = createLines(sourcePoint, targetPoint, routePoints);
    // create lines for all other links
    const linkLines = linkViews.map((linkView) => {
        if (linkView == null) {
            return [];
        }
        if (linkView === this) {
            return thisLines;
        }
        return createLines(linkView.sourcePoint, linkView.targetPoint, linkView.routePoints);
    });
    // transform lines for this link by splitting with jump lines at
    // points of intersection with other links
    const jumpingLines = [];
    thisLines.forEach((line) => {
        // iterate all links and grab the intersections with this line
        // these are then sorted by distance so the line can be split more easily
        const intersections = edges
            .reduce((memo, link, i) => {
            // don't intersection with itself
            if (link !== edge) {
                const lineIntersections = findLineIntersections(line, linkLines[i]);
                memo.push(...lineIntersections);
            }
            return memo;
        }, [])
            .sort((a, b) => getDistence(line.start, a) - getDistence(line.start, b));
        if (intersections.length > 0) {
            // split the line based on found intersection points
            jumpingLines.push(...createJumps(line, intersections, jumpSize));
        }
        else {
            // without any intersection the line goes uninterrupted
            jumpingLines.push(line);
        }
    });
    const path = buildPath(jumpingLines, jumpSize, jumpType, radius);
    jumppedLines = [];
    skippedPoints = [];
    return options.raw ? path : path.serialize();
};
//# sourceMappingURL=jumpover.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/connector/loop.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connector/loop.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   loop: () => (/* binding */ loop)
/* harmony export */ });
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");

const loop = function (sourcePoint, targetPoint, routePoints, options = {}) {
    const fix = routePoints.length === 3 ? 0 : 1;
    const p1 = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(routePoints[0 + fix]);
    const p2 = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(routePoints[2 + fix]);
    const center = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(routePoints[1 + fix]);
    if (!_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.equals(sourcePoint, targetPoint)) {
        const middle = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point((sourcePoint.x + targetPoint.x) / 2, (sourcePoint.y + targetPoint.y) / 2);
        const angle = middle.angleBetween(_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(sourcePoint).rotate(90, middle), center);
        if (angle > 1) {
            p1.rotate(180 - angle, middle);
            p2.rotate(180 - angle, middle);
            center.rotate(180 - angle, middle);
        }
    }
    const pathData = `
     M ${sourcePoint.x} ${sourcePoint.y}
     Q ${p1.x} ${p1.y} ${center.x} ${center.y}
     Q ${p2.x} ${p2.y} ${targetPoint.x} ${targetPoint.y}
  `;
    return options.raw ? _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Path.parse(pathData) : pathData;
};
//# sourceMappingURL=loop.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/connector/main.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connector/main.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   jumpover: () => (/* reexport safe */ _jumpover__WEBPACK_IMPORTED_MODULE_4__.jumpover),
/* harmony export */   loop: () => (/* reexport safe */ _loop__WEBPACK_IMPORTED_MODULE_1__.loop),
/* harmony export */   normal: () => (/* reexport safe */ _normal__WEBPACK_IMPORTED_MODULE_0__.normal),
/* harmony export */   rounded: () => (/* reexport safe */ _rounded__WEBPACK_IMPORTED_MODULE_2__.rounded),
/* harmony export */   smooth: () => (/* reexport safe */ _smooth__WEBPACK_IMPORTED_MODULE_3__.smooth)
/* harmony export */ });
/* harmony import */ var _normal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./normal */ "./node_modules/@antv/x6/es/registry/connector/normal.js");
/* harmony import */ var _loop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loop */ "./node_modules/@antv/x6/es/registry/connector/loop.js");
/* harmony import */ var _rounded__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rounded */ "./node_modules/@antv/x6/es/registry/connector/rounded.js");
/* harmony import */ var _smooth__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./smooth */ "./node_modules/@antv/x6/es/registry/connector/smooth.js");
/* harmony import */ var _jumpover__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./jumpover */ "./node_modules/@antv/x6/es/registry/connector/jumpover.js");





//# sourceMappingURL=main.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/connector/normal.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connector/normal.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   normal: () => (/* binding */ normal)
/* harmony export */ });
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");

const normal = function (sourcePoint, targetPoint, routePoints, options = {}) {
    const points = [sourcePoint, ...routePoints, targetPoint];
    const polyline = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Polyline(points);
    const path = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Path(polyline);
    return options.raw ? path : path.serialize();
};
//# sourceMappingURL=normal.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/connector/rounded.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connector/rounded.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   rounded: () => (/* binding */ rounded)
/* harmony export */ });
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");

const rounded = function (sourcePoint, targetPoint, routePoints, options = {}) {
    const path = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Path();
    path.appendSegment(_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Path.createSegment('M', sourcePoint));
    const f13 = 1 / 3;
    const f23 = 2 / 3;
    const radius = options.radius || 10;
    let prevDistance;
    let nextDistance;
    for (let i = 0, ii = routePoints.length; i < ii; i += 1) {
        const curr = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(routePoints[i]);
        const prev = routePoints[i - 1] || sourcePoint;
        const next = routePoints[i + 1] || targetPoint;
        prevDistance = nextDistance || curr.distance(prev) / 2;
        nextDistance = curr.distance(next) / 2;
        const startMove = -Math.min(radius, prevDistance);
        const endMove = -Math.min(radius, nextDistance);
        const roundedStart = curr.clone().move(prev, startMove).round();
        const roundedEnd = curr.clone().move(next, endMove).round();
        const control1 = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(f13 * roundedStart.x + f23 * curr.x, f23 * curr.y + f13 * roundedStart.y);
        const control2 = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(f13 * roundedEnd.x + f23 * curr.x, f23 * curr.y + f13 * roundedEnd.y);
        path.appendSegment(_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Path.createSegment('L', roundedStart));
        path.appendSegment(_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Path.createSegment('C', control1, control2, roundedEnd));
    }
    path.appendSegment(_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Path.createSegment('L', targetPoint));
    return options.raw ? path : path.serialize();
};
//# sourceMappingURL=rounded.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/connector/smooth.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/connector/smooth.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   smooth: () => (/* binding */ smooth)
/* harmony export */ });
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");

const smooth = function (sourcePoint, targetPoint, routePoints, options = {}) {
    let path;
    let direction = options.direction;
    if (routePoints && routePoints.length !== 0) {
        const points = [sourcePoint, ...routePoints, targetPoint];
        const curves = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Curve.throughPoints(points);
        path = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Path(curves);
    }
    else {
        // If we have no route, use a default cubic bezier curve, cubic bezier
        // requires two control points, the control points have `x` midway
        // between source and target. This produces an S-like curve.
        path = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Path();
        path.appendSegment(_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Path.createSegment('M', sourcePoint));
        if (!direction) {
            direction =
                Math.abs(sourcePoint.x - targetPoint.x) >=
                    Math.abs(sourcePoint.y - targetPoint.y)
                    ? 'H'
                    : 'V';
        }
        if (direction === 'H') {
            const controlPointX = (sourcePoint.x + targetPoint.x) / 2;
            path.appendSegment(_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Path.createSegment('C', controlPointX, sourcePoint.y, controlPointX, targetPoint.y, targetPoint.x, targetPoint.y));
        }
        else {
            const controlPointY = (sourcePoint.y + targetPoint.y) / 2;
            path.appendSegment(_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Path.createSegment('C', sourcePoint.x, controlPointY, targetPoint.x, controlPointY, targetPoint.x, targetPoint.y));
        }
    }
    return options.raw ? path : path.serialize();
};
//# sourceMappingURL=smooth.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/edge-anchor/closest.js":
/*!******************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/edge-anchor/closest.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   closest: () => (/* binding */ closest),
/* harmony export */   getClosestPoint: () => (/* binding */ getClosestPoint)
/* harmony export */ });
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _node_anchor_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node-anchor/util */ "./node_modules/@antv/x6/es/registry/node-anchor/util.js");


const getClosestPoint = function (view, magnet, refPoint, options) {
    const closestPoint = view.getClosestPoint(refPoint);
    return closestPoint != null ? closestPoint : new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point();
};
const closest = (0,_node_anchor_util__WEBPACK_IMPORTED_MODULE_1__.resolve)(getClosestPoint);
//# sourceMappingURL=closest.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/edge-anchor/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/edge-anchor/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EdgeAnchor: () => (/* binding */ EdgeAnchor)
/* harmony export */ });
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry */ "./node_modules/@antv/x6/es/registry/registry.js");
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./main */ "./node_modules/@antv/x6/es/registry/edge-anchor/main.js");


var EdgeAnchor;
(function (EdgeAnchor) {
    EdgeAnchor.presets = _main__WEBPACK_IMPORTED_MODULE_1__;
    EdgeAnchor.registry = _registry__WEBPACK_IMPORTED_MODULE_0__.Registry.create({
        type: 'edge endpoint',
    });
    EdgeAnchor.registry.register(EdgeAnchor.presets, true);
})(EdgeAnchor || (EdgeAnchor = {}));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/edge-anchor/length.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/edge-anchor/length.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   length: () => (/* binding */ length)
/* harmony export */ });
const length = function (view, magnet, ref, options) {
    const length = options.length != null ? options.length : 20;
    return view.getPointAtLength(length);
};
//# sourceMappingURL=length.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/edge-anchor/main.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/edge-anchor/main.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   closest: () => (/* reexport safe */ _closest__WEBPACK_IMPORTED_MODULE_3__.closest),
/* harmony export */   length: () => (/* reexport safe */ _length__WEBPACK_IMPORTED_MODULE_1__.length),
/* harmony export */   orth: () => (/* reexport safe */ _orth__WEBPACK_IMPORTED_MODULE_2__.orth),
/* harmony export */   ratio: () => (/* reexport safe */ _ratio__WEBPACK_IMPORTED_MODULE_0__.ratio)
/* harmony export */ });
/* harmony import */ var _ratio__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ratio */ "./node_modules/@antv/x6/es/registry/edge-anchor/ratio.js");
/* harmony import */ var _length__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./length */ "./node_modules/@antv/x6/es/registry/edge-anchor/length.js");
/* harmony import */ var _orth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./orth */ "./node_modules/@antv/x6/es/registry/edge-anchor/orth.js");
/* harmony import */ var _closest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./closest */ "./node_modules/@antv/x6/es/registry/edge-anchor/closest.js");




//# sourceMappingURL=main.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/edge-anchor/orth.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/edge-anchor/orth.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   orth: () => (/* binding */ orth)
/* harmony export */ });
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _node_anchor_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../node-anchor/util */ "./node_modules/@antv/x6/es/registry/node-anchor/util.js");
/* harmony import */ var _closest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./closest */ "./node_modules/@antv/x6/es/registry/edge-anchor/closest.js");




const orthogonal = function (view, magnet, refPoint, options) {
    const OFFSET = 1e6;
    const path = view.getConnection();
    const segmentSubdivisions = view.getConnectionSubdivisions();
    const vLine = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Line(refPoint.clone().translate(0, OFFSET), refPoint.clone().translate(0, -OFFSET));
    const hLine = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Line(refPoint.clone().translate(OFFSET, 0), refPoint.clone().translate(-OFFSET, 0));
    const vIntersections = vLine.intersect(path, {
        segmentSubdivisions,
    });
    const hIntersections = hLine.intersect(path, {
        segmentSubdivisions,
    });
    const intersections = [];
    if (vIntersections) {
        intersections.push(...vIntersections);
    }
    if (hIntersections) {
        intersections.push(...hIntersections);
    }
    if (intersections.length > 0) {
        return refPoint.closest(intersections);
    }
    if (options.fallbackAt != null) {
        return (0,_node_anchor_util__WEBPACK_IMPORTED_MODULE_2__.getPointAtEdge)(view, options.fallbackAt);
    }
    return _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(_closest__WEBPACK_IMPORTED_MODULE_3__.getClosestPoint, this, view, magnet, refPoint, options);
};
const orth = (0,_node_anchor_util__WEBPACK_IMPORTED_MODULE_2__.resolve)(orthogonal);
//# sourceMappingURL=orth.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/edge-anchor/ratio.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/edge-anchor/ratio.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ratio: () => (/* binding */ ratio)
/* harmony export */ });
const ratio = function (view, magnet, ref, options) {
    let ratio = options.ratio != null ? options.ratio : 0.5;
    if (ratio > 1) {
        ratio /= 100;
    }
    return view.getPointAtRatio(ratio);
};
//# sourceMappingURL=ratio.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/filter/blur.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/filter/blur.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   blur: () => (/* binding */ blur)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/filter/util.js");

function blur(args = {}) {
    const x = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.x, 2);
    const stdDeviation = args.y != null && Number.isFinite(args.y) ? [x, args.y] : x;
    return `
    <filter>
      <feGaussianBlur stdDeviation="${stdDeviation}"/>
    </filter>
  `.trim();
}
//# sourceMappingURL=blur.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/filter/brightness.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/filter/brightness.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   brightness: () => (/* binding */ brightness)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/filter/util.js");

function brightness(args = {}) {
    const amount = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.amount, 1);
    return `
    <filter>
      <feComponentTransfer>
        <feFuncR type="linear" slope="${amount}"/>
        <feFuncG type="linear" slope="${amount}"/>
        <feFuncB type="linear" slope="${amount}"/>
      </feComponentTransfer>
    </filter>
  `.trim();
}
//# sourceMappingURL=brightness.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/filter/contrast.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/filter/contrast.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   contrast: () => (/* binding */ contrast)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/filter/util.js");

function contrast(args = {}) {
    const amount = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.amount, 1);
    const amount2 = 0.5 - amount / 2;
    return `
    <filter>
     <feComponentTransfer>
        <feFuncR type="linear" slope="${amount}" intercept="${amount2}"/>
        <feFuncG type="linear" slope="${amount}" intercept="${amount2}"/>
        <feFuncB type="linear" slope="${amount}" intercept="${amount2}"/>
      </feComponentTransfer>
    </filter>
  `.trim();
}
//# sourceMappingURL=contrast.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/filter/drop-shadow.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/filter/drop-shadow.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dropShadow: () => (/* binding */ dropShadow)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/filter/util.js");

function dropShadow(args = {}) {
    const dx = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.dx, 0);
    const dy = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.dy, 0);
    const color = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getString)(args.color, 'black');
    const blur = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.blur, 4);
    const opacity = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.opacity, 1);
    return 'SVGFEDropShadowElement' in window
        ? `<filter>
         <feDropShadow stdDeviation="${blur}" dx="${dx}" dy="${dy}" flood-color="${color}" flood-opacity="${opacity}" />
       </filter>`.trim()
        : `<filter>
         <feGaussianBlur in="SourceAlpha" stdDeviation="${blur}" />
         <feOffset dx="${dx}" dy="${dy}" result="offsetblur" />
         <feFlood flood-color="${color}" />
         <feComposite in2="offsetblur" operator="in" />
         <feComponentTransfer>
           <feFuncA type="linear" slope="${opacity}" />
         </feComponentTransfer>
         <feMerge>
           <feMergeNode/>
           <feMergeNode in="SourceGraphic"/>
         </feMerge>
       </filter>`.trim();
}
//# sourceMappingURL=drop-shadow.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/filter/gray-scale.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/filter/gray-scale.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   grayScale: () => (/* binding */ grayScale)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/filter/util.js");

function grayScale(args = {}) {
    const amount = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.amount, 1);
    const a = 0.2126 + 0.7874 * (1 - amount);
    const b = 0.7152 - 0.7152 * (1 - amount);
    const c = 0.0722 - 0.0722 * (1 - amount);
    const d = 0.2126 - 0.2126 * (1 - amount);
    const e = 0.7152 + 0.2848 * (1 - amount);
    const f = 0.0722 - 0.0722 * (1 - amount);
    const g = 0.2126 - 0.2126 * (1 - amount);
    const h = 0.0722 + 0.9278 * (1 - amount);
    return `
    <filter>
      <feColorMatrix type="matrix" values="${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${b} ${h} 0 0 0 0 0 1 0"/>
    </filter>
  `.trim();
}
//# sourceMappingURL=gray-scale.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/filter/highlight.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/filter/highlight.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   highlight: () => (/* binding */ highlight)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/filter/util.js");

function highlight(args = {}) {
    const color = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getString)(args.color, 'red');
    const blur = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.blur, 0);
    const width = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.width, 1);
    const opacity = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.opacity, 1);
    return `
      <filter>
        <feFlood flood-color="${color}" flood-opacity="${opacity}" result="colored"/>
        <feMorphology result="morphed" in="SourceGraphic" operator="dilate" radius="${width}"/>
        <feComposite result="composed" in="colored" in2="morphed" operator="in"/>
        <feGaussianBlur result="blured" in="composed" stdDeviation="${blur}"/>
        <feBlend in="SourceGraphic" in2="blured" mode="normal"/>
      </filter>
    `.trim();
}
//# sourceMappingURL=highlight.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/filter/hue-rotate.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/filter/hue-rotate.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hueRotate: () => (/* binding */ hueRotate)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/filter/util.js");

function hueRotate(args = {}) {
    const angle = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.angle, 0);
    return `
      <filter>
        <feColorMatrix type="hueRotate" values="${angle}"/>
      </filter>
    `.trim();
}
//# sourceMappingURL=hue-rotate.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/filter/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/filter/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Filter: () => (/* binding */ Filter)
/* harmony export */ });
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry */ "./node_modules/@antv/x6/es/registry/registry.js");
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./main */ "./node_modules/@antv/x6/es/registry/filter/main.js");


var Filter;
(function (Filter) {
    Filter.presets = _main__WEBPACK_IMPORTED_MODULE_1__;
    Filter.registry = _registry__WEBPACK_IMPORTED_MODULE_0__.Registry.create({
        type: 'filter',
    });
    Filter.registry.register(Filter.presets, true);
})(Filter || (Filter = {}));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/filter/invert.js":
/*!************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/filter/invert.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   invert: () => (/* binding */ invert)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/filter/util.js");

function invert(args = {}) {
    const amount = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.amount, 1);
    const amount2 = 1 - amount;
    return `
      <filter>
        <feComponentTransfer>
          <feFuncR type="table" tableValues="${amount} ${amount2}"/>
          <feFuncG type="table" tableValues="${amount} ${amount2}"/>
          <feFuncB type="table" tableValues="${amount} ${amount2}"/>
        </feComponentTransfer>
      </filter>
    `.trim();
}
//# sourceMappingURL=invert.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/filter/main.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/filter/main.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   blur: () => (/* reexport safe */ _blur__WEBPACK_IMPORTED_MODULE_2__.blur),
/* harmony export */   brightness: () => (/* reexport safe */ _brightness__WEBPACK_IMPORTED_MODULE_9__.brightness),
/* harmony export */   contrast: () => (/* reexport safe */ _contrast__WEBPACK_IMPORTED_MODULE_10__.contrast),
/* harmony export */   dropShadow: () => (/* reexport safe */ _drop_shadow__WEBPACK_IMPORTED_MODULE_3__.dropShadow),
/* harmony export */   grayScale: () => (/* reexport safe */ _gray_scale__WEBPACK_IMPORTED_MODULE_4__.grayScale),
/* harmony export */   highlight: () => (/* reexport safe */ _highlight__WEBPACK_IMPORTED_MODULE_1__.highlight),
/* harmony export */   hueRotate: () => (/* reexport safe */ _hue_rotate__WEBPACK_IMPORTED_MODULE_7__.hueRotate),
/* harmony export */   invert: () => (/* reexport safe */ _invert__WEBPACK_IMPORTED_MODULE_8__.invert),
/* harmony export */   outline: () => (/* reexport safe */ _outline__WEBPACK_IMPORTED_MODULE_0__.outline),
/* harmony export */   saturate: () => (/* reexport safe */ _saturate__WEBPACK_IMPORTED_MODULE_6__.saturate),
/* harmony export */   sepia: () => (/* reexport safe */ _sepia__WEBPACK_IMPORTED_MODULE_5__.sepia)
/* harmony export */ });
/* harmony import */ var _outline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./outline */ "./node_modules/@antv/x6/es/registry/filter/outline.js");
/* harmony import */ var _highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./highlight */ "./node_modules/@antv/x6/es/registry/filter/highlight.js");
/* harmony import */ var _blur__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./blur */ "./node_modules/@antv/x6/es/registry/filter/blur.js");
/* harmony import */ var _drop_shadow__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./drop-shadow */ "./node_modules/@antv/x6/es/registry/filter/drop-shadow.js");
/* harmony import */ var _gray_scale__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./gray-scale */ "./node_modules/@antv/x6/es/registry/filter/gray-scale.js");
/* harmony import */ var _sepia__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sepia */ "./node_modules/@antv/x6/es/registry/filter/sepia.js");
/* harmony import */ var _saturate__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./saturate */ "./node_modules/@antv/x6/es/registry/filter/saturate.js");
/* harmony import */ var _hue_rotate__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./hue-rotate */ "./node_modules/@antv/x6/es/registry/filter/hue-rotate.js");
/* harmony import */ var _invert__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./invert */ "./node_modules/@antv/x6/es/registry/filter/invert.js");
/* harmony import */ var _brightness__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./brightness */ "./node_modules/@antv/x6/es/registry/filter/brightness.js");
/* harmony import */ var _contrast__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./contrast */ "./node_modules/@antv/x6/es/registry/filter/contrast.js");











//# sourceMappingURL=main.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/filter/outline.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/filter/outline.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   outline: () => (/* binding */ outline)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/filter/util.js");

function outline(args = {}) {
    const color = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getString)(args.color, 'blue');
    const width = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.width, 1);
    const margin = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.margin, 2);
    const opacity = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.opacity, 1);
    const innerRadius = margin;
    const outerRadius = margin + width;
    return `
    <filter>
      <feFlood flood-color="${color}" flood-opacity="${opacity}" result="colored"/>
      <feMorphology in="SourceAlpha" result="morphedOuter" operator="dilate" radius="${outerRadius}" />
      <feMorphology in="SourceAlpha" result="morphedInner" operator="dilate" radius="${innerRadius}" />
      <feComposite result="morphedOuterColored" in="colored" in2="morphedOuter" operator="in"/>
      <feComposite operator="xor" in="morphedOuterColored" in2="morphedInner" result="outline"/>
      <feMerge>
        <feMergeNode in="outline"/>
        <feMergeNode in="SourceGraphic"/>
      </feMerge>
    </filter>
  `.trim();
}
//# sourceMappingURL=outline.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/filter/saturate.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/filter/saturate.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   saturate: () => (/* binding */ saturate)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/filter/util.js");

function saturate(args = {}) {
    const amount = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.amount, 1);
    return `
      <filter>
        <feColorMatrix type="saturate" values="${1 - amount}"/>
      </filter>
    `.trim();
}
//# sourceMappingURL=saturate.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/filter/sepia.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/filter/sepia.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   sepia: () => (/* binding */ sepia)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/filter/util.js");

function sepia(args = {}) {
    const amount = (0,_util__WEBPACK_IMPORTED_MODULE_0__.getNumber)(args.amount, 1);
    const a = 0.393 + 0.607 * (1 - amount);
    const b = 0.769 - 0.769 * (1 - amount);
    const c = 0.189 - 0.189 * (1 - amount);
    const d = 0.349 - 0.349 * (1 - amount);
    const e = 0.686 + 0.314 * (1 - amount);
    const f = 0.168 - 0.168 * (1 - amount);
    const g = 0.272 - 0.272 * (1 - amount);
    const h = 0.534 - 0.534 * (1 - amount);
    const i = 0.131 + 0.869 * (1 - amount);
    return `
      <filter>
        <feColorMatrix type="matrix" values="${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${h} ${i} 0 0 0 0 0 1 0"/>
      </filter>
    `.trim();
}
//# sourceMappingURL=sepia.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/filter/util.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/filter/util.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getNumber: () => (/* binding */ getNumber),
/* harmony export */   getString: () => (/* binding */ getString)
/* harmony export */ });
function getString(value, defaultValue) {
    return value != null ? value : defaultValue;
}
function getNumber(num, defaultValue) {
    return num != null && Number.isFinite(num) ? num : defaultValue;
}
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/grid/dot.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/grid/dot.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dot: () => (/* binding */ dot)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");

const dot = {
    color: '#aaaaaa',
    thickness: 1,
    markup: 'rect',
    update(elem, options) {
        const width = options.thickness * options.sx;
        const height = options.thickness * options.sy;
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.attr(elem, {
            width,
            height,
            rx: width,
            ry: height,
            fill: options.color,
        });
    },
};
//# sourceMappingURL=dot.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/grid/double-mesh.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/grid/double-mesh.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   doubleMesh: () => (/* binding */ doubleMesh)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");

const doubleMesh = [
    {
        color: 'rgba(224,224,224,1)',
        thickness: 1,
        markup: 'path',
        update(elem, options) {
            let d;
            const width = options.width;
            const height = options.height;
            const thickness = options.thickness;
            if (width - thickness >= 0 && height - thickness >= 0) {
                d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');
            }
            else {
                d = 'M 0 0 0 0';
            }
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.attr(elem, {
                d,
                stroke: options.color,
                'stroke-width': options.thickness,
            });
        },
    },
    {
        color: 'rgba(224,224,224,0.2)',
        thickness: 3,
        factor: 4,
        markup: 'path',
        update(elem, options) {
            let d;
            const factor = options.factor || 1;
            const width = options.width * factor;
            const height = options.height * factor;
            const thickness = options.thickness;
            if (width - thickness >= 0 && height - thickness >= 0) {
                d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');
            }
            else {
                d = 'M 0 0 0 0';
            }
            // update wrapper size
            options.width = width;
            options.height = height;
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.attr(elem, {
                d,
                stroke: options.color,
                'stroke-width': options.thickness,
            });
        },
    },
];
//# sourceMappingURL=double-mesh.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/grid/fixed-dot.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/grid/fixed-dot.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fixedDot: () => (/* binding */ fixedDot)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");

const fixedDot = {
    color: '#aaaaaa',
    thickness: 1,
    markup: 'rect',
    update(elem, options) {
        const size = options.sx <= 1 ? options.thickness * options.sx : options.thickness;
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.attr(elem, {
            width: size,
            height: size,
            rx: size,
            ry: size,
            fill: options.color,
        });
    },
};
//# sourceMappingURL=fixed-dot.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/grid/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/grid/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Grid: () => (/* binding */ Grid)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../registry */ "./node_modules/@antv/x6/es/registry/registry.js");
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./main */ "./node_modules/@antv/x6/es/registry/grid/main.js");



class Grid {
    constructor() {
        this.patterns = {};
        this.root = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Vector.create(_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.createSvgDocument(), {
            width: '100%',
            height: '100%',
        }, [_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.createSvgElement('defs')]).node;
    }
    add(id, elem) {
        const firstChild = this.root.childNodes[0];
        if (firstChild) {
            firstChild.appendChild(elem);
        }
        this.patterns[id] = elem;
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Vector.create('rect', {
            width: '100%',
            height: '100%',
            fill: `url(#${id})`,
        }).appendTo(this.root);
    }
    get(id) {
        return this.patterns[id];
    }
    has(id) {
        return this.patterns[id] != null;
    }
}
(function (Grid) {
    Grid.presets = _main__WEBPACK_IMPORTED_MODULE_2__;
    Grid.registry = _registry__WEBPACK_IMPORTED_MODULE_1__.Registry.create({
        type: 'grid',
    });
    Grid.registry.register(Grid.presets, true);
})(Grid || (Grid = {}));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/grid/main.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/grid/main.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dot: () => (/* reexport safe */ _dot__WEBPACK_IMPORTED_MODULE_0__.dot),
/* harmony export */   doubleMesh: () => (/* reexport safe */ _double_mesh__WEBPACK_IMPORTED_MODULE_3__.doubleMesh),
/* harmony export */   fixedDot: () => (/* reexport safe */ _fixed_dot__WEBPACK_IMPORTED_MODULE_1__.fixedDot),
/* harmony export */   mesh: () => (/* reexport safe */ _mesh__WEBPACK_IMPORTED_MODULE_2__.mesh)
/* harmony export */ });
/* harmony import */ var _dot__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dot */ "./node_modules/@antv/x6/es/registry/grid/dot.js");
/* harmony import */ var _fixed_dot__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fixed-dot */ "./node_modules/@antv/x6/es/registry/grid/fixed-dot.js");
/* harmony import */ var _mesh__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mesh */ "./node_modules/@antv/x6/es/registry/grid/mesh.js");
/* harmony import */ var _double_mesh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./double-mesh */ "./node_modules/@antv/x6/es/registry/grid/double-mesh.js");




//# sourceMappingURL=main.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/grid/mesh.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/grid/mesh.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mesh: () => (/* binding */ mesh)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");

const mesh = {
    color: 'rgba(224,224,224,1)',
    thickness: 1,
    markup: 'path',
    update(elem, options) {
        let d;
        const width = options.width;
        const height = options.height;
        const thickness = options.thickness;
        if (width - thickness >= 0 && height - thickness >= 0) {
            d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');
        }
        else {
            d = 'M 0 0 0 0';
        }
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.attr(elem, {
            d,
            stroke: options.color,
            'stroke-width': options.thickness,
        });
    },
};
//# sourceMappingURL=mesh.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/highlighter/class.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/highlighter/class.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   className: () => (/* binding */ className)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../config */ "./node_modules/@antv/x6/es/config/index.js");


const defaultClassName = _config__WEBPACK_IMPORTED_MODULE_1__.Config.prefix('highlighted');
const className = {
    highlight(cellView, magnet, options) {
        const cls = (options && options.className) || defaultClassName;
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(magnet, cls);
    },
    unhighlight(cellView, magnet, options) {
        const cls = (options && options.className) || defaultClassName;
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.removeClass(magnet, cls);
    },
};
//# sourceMappingURL=class.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/highlighter/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/highlighter/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Highlighter: () => (/* binding */ Highlighter)
/* harmony export */ });
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry */ "./node_modules/@antv/x6/es/registry/registry.js");
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./main */ "./node_modules/@antv/x6/es/registry/highlighter/main.js");


var Highlighter;
(function (Highlighter) {
    function check(name, highlighter) {
        if (typeof highlighter.highlight !== 'function') {
            throw new Error(`Highlighter '${name}' is missing required \`highlight()\` method`);
        }
        if (typeof highlighter.unhighlight !== 'function') {
            throw new Error(`Highlighter '${name}' is missing required \`unhighlight()\` method`);
        }
    }
    Highlighter.check = check;
})(Highlighter || (Highlighter = {}));
(function (Highlighter) {
    Highlighter.presets = _main__WEBPACK_IMPORTED_MODULE_1__;
    Highlighter.registry = _registry__WEBPACK_IMPORTED_MODULE_0__.Registry.create({
        type: 'highlighter',
    });
    Highlighter.registry.register(Highlighter.presets, true);
})(Highlighter || (Highlighter = {}));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/highlighter/main.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/highlighter/main.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   className: () => (/* reexport safe */ _class__WEBPACK_IMPORTED_MODULE_0__.className),
/* harmony export */   opacity: () => (/* reexport safe */ _opacity__WEBPACK_IMPORTED_MODULE_1__.opacity),
/* harmony export */   stroke: () => (/* reexport safe */ _stroke__WEBPACK_IMPORTED_MODULE_2__.stroke)
/* harmony export */ });
/* harmony import */ var _class__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./class */ "./node_modules/@antv/x6/es/registry/highlighter/class.js");
/* harmony import */ var _opacity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./opacity */ "./node_modules/@antv/x6/es/registry/highlighter/opacity.js");
/* harmony import */ var _stroke__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stroke */ "./node_modules/@antv/x6/es/registry/highlighter/stroke.js");



//# sourceMappingURL=main.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/highlighter/opacity.js":
/*!******************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/highlighter/opacity.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   opacity: () => (/* binding */ opacity)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../config */ "./node_modules/@antv/x6/es/config/index.js");


const className = _config__WEBPACK_IMPORTED_MODULE_1__.Config.prefix('highlight-opacity');
const opacity = {
    highlight(cellView, magnet) {
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(magnet, className);
    },
    unhighlight(cellView, magnetEl) {
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.removeClass(magnetEl, className);
    },
};
//# sourceMappingURL=opacity.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/highlighter/stroke.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/highlighter/stroke.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   stroke: () => (/* binding */ stroke)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../config */ "./node_modules/@antv/x6/es/config/index.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util */ "./node_modules/@antv/x6/es/util/index.js");



const defaultOptions = {
    padding: 3,
    rx: 0,
    ry: 0,
    attrs: {
        'stroke-width': 3,
        stroke: '#FEB663',
    },
};
const stroke = {
    highlight(cellView, magnet, options) {
        const id = Private.getHighlighterId(magnet, options);
        if (Private.hasCache(id)) {
            return;
        }
        // eslint-disable-next-line
        options = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.defaultsDeep({}, options, defaultOptions);
        const magnetVel = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Vector.create(magnet);
        let pathData;
        let magnetBBox;
        try {
            pathData = magnetVel.toPathData();
        }
        catch (error) {
            // Failed to get path data from magnet element.
            // Draw a rectangle around the entire cell view instead.
            magnetBBox = _util__WEBPACK_IMPORTED_MODULE_2__.Util.bbox(magnetVel.node, true);
            pathData = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.rectToPathData(Object.assign(Object.assign({}, options), magnetBBox));
        }
        const path = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.createSvgElement('path');
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.attr(path, Object.assign({ d: pathData, 'pointer-events': 'none', 'vector-effect': 'non-scaling-stroke', fill: 'none' }, (options.attrs ? _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.kebablizeAttrs(options.attrs) : null)));
        // const highlightVel = v.create('path').attr()
        if (cellView.isEdgeElement(magnet)) {
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.attr(path, 'd', cellView.getConnectionPathData());
        }
        else {
            let highlightMatrix = magnetVel.getTransformToElement(cellView.container);
            // Add padding to the highlight element.
            const padding = options.padding;
            if (padding) {
                if (magnetBBox == null) {
                    magnetBBox = _util__WEBPACK_IMPORTED_MODULE_2__.Util.bbox(magnetVel.node, true);
                }
                const cx = magnetBBox.x + magnetBBox.width / 2;
                const cy = magnetBBox.y + magnetBBox.height / 2;
                magnetBBox = _util__WEBPACK_IMPORTED_MODULE_2__.Util.transformRectangle(magnetBBox, highlightMatrix);
                const width = Math.max(magnetBBox.width, 1);
                const height = Math.max(magnetBBox.height, 1);
                const sx = (width + padding) / width;
                const sy = (height + padding) / height;
                const paddingMatrix = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.createSVGMatrix({
                    a: sx,
                    b: 0,
                    c: 0,
                    d: sy,
                    e: cx - sx * cx,
                    f: cy - sy * cy,
                });
                highlightMatrix = highlightMatrix.multiply(paddingMatrix);
            }
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.transform(path, highlightMatrix);
        }
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(path, _config__WEBPACK_IMPORTED_MODULE_1__.Config.prefix('highlight-stroke'));
        const cell = cellView.cell;
        const removeHandler = () => Private.removeHighlighter(id);
        cell.on('removed', removeHandler);
        if (cell.model) {
            cell.model.on('reseted', removeHandler);
        }
        cellView.container.appendChild(path);
        Private.setCache(id, path);
    },
    unhighlight(cellView, magnet, opt) {
        Private.removeHighlighter(Private.getHighlighterId(magnet, opt));
    },
};
var Private;
(function (Private) {
    function getHighlighterId(magnet, options) {
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.ensureId(magnet);
        return magnet.id + JSON.stringify(options);
    }
    Private.getHighlighterId = getHighlighterId;
    const cache = {};
    function setCache(id, elem) {
        cache[id] = elem;
    }
    Private.setCache = setCache;
    function hasCache(id) {
        return cache[id] != null;
    }
    Private.hasCache = hasCache;
    function removeHighlighter(id) {
        const elem = cache[id];
        if (elem) {
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.remove(elem);
            delete cache[id];
        }
    }
    Private.removeHighlighter = removeHighlighter;
})(Private || (Private = {}));
//# sourceMappingURL=stroke.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Attr: () => (/* reexport safe */ _attr__WEBPACK_IMPORTED_MODULE_3__.Attr),
/* harmony export */   Background: () => (/* reexport safe */ _background__WEBPACK_IMPORTED_MODULE_1__.Background),
/* harmony export */   ConnectionPoint: () => (/* reexport safe */ _connection_point__WEBPACK_IMPORTED_MODULE_11__.ConnectionPoint),
/* harmony export */   Connector: () => (/* reexport safe */ _connector__WEBPACK_IMPORTED_MODULE_13__.Connector),
/* harmony export */   EdgeAnchor: () => (/* reexport safe */ _edge_anchor__WEBPACK_IMPORTED_MODULE_10__.EdgeAnchor),
/* harmony export */   EdgeTool: () => (/* reexport safe */ _tool__WEBPACK_IMPORTED_MODULE_7__.EdgeTool),
/* harmony export */   Filter: () => (/* reexport safe */ _filter__WEBPACK_IMPORTED_MODULE_2__.Filter),
/* harmony export */   Grid: () => (/* reexport safe */ _grid__WEBPACK_IMPORTED_MODULE_0__.Grid),
/* harmony export */   Highlighter: () => (/* reexport safe */ _highlighter__WEBPACK_IMPORTED_MODULE_4__.Highlighter),
/* harmony export */   Marker: () => (/* reexport safe */ _marker__WEBPACK_IMPORTED_MODULE_8__.Marker),
/* harmony export */   NodeAnchor: () => (/* reexport safe */ _node_anchor__WEBPACK_IMPORTED_MODULE_9__.NodeAnchor),
/* harmony export */   NodeTool: () => (/* reexport safe */ _tool__WEBPACK_IMPORTED_MODULE_7__.NodeTool),
/* harmony export */   PortLabelLayout: () => (/* reexport safe */ _port_label_layout__WEBPACK_IMPORTED_MODULE_6__.PortLabelLayout),
/* harmony export */   PortLayout: () => (/* reexport safe */ _port_layout__WEBPACK_IMPORTED_MODULE_5__.PortLayout),
/* harmony export */   Registry: () => (/* reexport safe */ _registry__WEBPACK_IMPORTED_MODULE_14__.Registry),
/* harmony export */   Router: () => (/* reexport safe */ _router__WEBPACK_IMPORTED_MODULE_12__.Router)
/* harmony export */ });
/* harmony import */ var _grid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./grid */ "./node_modules/@antv/x6/es/registry/grid/index.js");
/* harmony import */ var _background__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./background */ "./node_modules/@antv/x6/es/registry/background/index.js");
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./filter */ "./node_modules/@antv/x6/es/registry/filter/index.js");
/* harmony import */ var _attr__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./attr */ "./node_modules/@antv/x6/es/registry/attr/index.js");
/* harmony import */ var _highlighter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./highlighter */ "./node_modules/@antv/x6/es/registry/highlighter/index.js");
/* harmony import */ var _port_layout__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./port-layout */ "./node_modules/@antv/x6/es/registry/port-layout/index.js");
/* harmony import */ var _port_label_layout__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./port-label-layout */ "./node_modules/@antv/x6/es/registry/port-label-layout/index.js");
/* harmony import */ var _tool__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tool */ "./node_modules/@antv/x6/es/registry/tool/index.js");
/* harmony import */ var _marker__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./marker */ "./node_modules/@antv/x6/es/registry/marker/index.js");
/* harmony import */ var _node_anchor__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./node-anchor */ "./node_modules/@antv/x6/es/registry/node-anchor/index.js");
/* harmony import */ var _edge_anchor__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./edge-anchor */ "./node_modules/@antv/x6/es/registry/edge-anchor/index.js");
/* harmony import */ var _connection_point__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./connection-point */ "./node_modules/@antv/x6/es/registry/connection-point/index.js");
/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./router */ "./node_modules/@antv/x6/es/registry/router/index.js");
/* harmony import */ var _connector__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./connector */ "./node_modules/@antv/x6/es/registry/connector/index.js");
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./registry */ "./node_modules/@antv/x6/es/registry/registry.js");















//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/marker/async.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/marker/async.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   async: () => (/* binding */ async)
/* harmony export */ });
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/marker/util.js");
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};


const async = (_a) => {
    var { width, height, offset, open, flip } = _a, attrs = __rest(_a, ["width", "height", "offset", "open", "flip"]);
    let h = height || 6;
    const w = width || 10;
    const opened = open === true;
    const fliped = flip === true;
    const result = Object.assign(Object.assign({}, attrs), { tagName: 'path' });
    if (fliped) {
        h = -h;
    }
    const path = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Path();
    path.moveTo(0, h).lineTo(w, 0);
    if (!opened) {
        path.lineTo(w, h);
        path.close();
    }
    else {
        result.fill = 'none';
    }
    result.d = (0,_util__WEBPACK_IMPORTED_MODULE_1__.normalize)(path.serialize(), {
        x: offset || -w / 2,
        y: h / 2,
    });
    return result;
};
//# sourceMappingURL=async.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/marker/circle.js":
/*!************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/marker/circle.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   circle: () => (/* binding */ circle),
/* harmony export */   circlePlus: () => (/* binding */ circlePlus)
/* harmony export */ });
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/marker/util.js");
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};


const circle = (_a) => {
    var { r } = _a, attrs = __rest(_a, ["r"]);
    const radius = r || 5;
    return Object.assign(Object.assign({ cx: radius }, attrs), { tagName: 'circle', r: radius });
};
const circlePlus = (_a) => {
    var { r } = _a, attrs = __rest(_a, ["r"]);
    const radius = r || 5;
    const path = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Path();
    path.moveTo(radius, 0).lineTo(radius, radius * 2);
    path.moveTo(0, radius).lineTo(radius * 2, radius);
    return {
        children: [
            Object.assign(Object.assign({}, circle({ r: radius })), { fill: 'none' }),
            Object.assign(Object.assign({}, attrs), { tagName: 'path', d: (0,_util__WEBPACK_IMPORTED_MODULE_1__.normalize)(path.serialize(), -radius) }),
        ],
    };
};
//# sourceMappingURL=circle.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/marker/classic.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/marker/classic.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   block: () => (/* binding */ block),
/* harmony export */   classic: () => (/* binding */ classic)
/* harmony export */ });
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/marker/util.js");
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};



const block = (_a) => {
    var { size, width, height, offset, open } = _a, attrs = __rest(_a, ["size", "width", "height", "offset", "open"]);
    return createClassicMarker({ size, width, height, offset }, open === true, true, undefined, attrs);
};
const classic = (_a) => {
    var { size, width, height, offset, factor } = _a, attrs = __rest(_a, ["size", "width", "height", "offset", "factor"]);
    return createClassicMarker({ size, width, height, offset }, false, false, factor, attrs);
};
function createClassicMarker(options, open, full, factor = 3 / 4, attrs = {}) {
    const size = options.size || 10;
    const width = options.width || size;
    const height = options.height || size;
    const path = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Path();
    const localAttrs = {};
    if (open) {
        path
            .moveTo(width, 0)
            .lineTo(0, height / 2)
            .lineTo(width, height);
        localAttrs.fill = 'none';
    }
    else {
        path.moveTo(0, height / 2);
        path.lineTo(width, 0);
        if (!full) {
            const f = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.NumberExt.clamp(factor, 0, 1);
            path.lineTo(width * f, height / 2);
        }
        path.lineTo(width, height);
        path.close();
    }
    return Object.assign(Object.assign(Object.assign({}, localAttrs), attrs), { tagName: 'path', d: (0,_util__WEBPACK_IMPORTED_MODULE_2__.normalize)(path.serialize(), {
            x: options.offset != null ? options.offset : -width / 2,
        }) });
}
//# sourceMappingURL=classic.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/marker/cross.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/marker/cross.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cross: () => (/* binding */ cross)
/* harmony export */ });
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/marker/util.js");
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};


const cross = (_a) => {
    var { size, width, height, offset } = _a, attrs = __rest(_a, ["size", "width", "height", "offset"]);
    const s = size || 10;
    const w = width || s;
    const h = height || s;
    const path = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Path();
    path.moveTo(0, 0).lineTo(w, h).moveTo(0, h).lineTo(w, 0);
    return Object.assign(Object.assign({}, attrs), { tagName: 'path', fill: 'none', d: (0,_util__WEBPACK_IMPORTED_MODULE_1__.normalize)(path.serialize(), offset || -w / 2) });
};
//# sourceMappingURL=cross.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/marker/diamond.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/marker/diamond.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   diamond: () => (/* binding */ diamond)
/* harmony export */ });
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/marker/util.js");
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};


const diamond = (_a) => {
    var { size, width, height, offset } = _a, attrs = __rest(_a, ["size", "width", "height", "offset"]);
    const s = size || 10;
    const w = width || s;
    const h = height || s;
    const path = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Path();
    path
        .moveTo(0, h / 2)
        .lineTo(w / 2, 0)
        .lineTo(w, h / 2)
        .lineTo(w / 2, h)
        .close();
    return Object.assign(Object.assign({}, attrs), { tagName: 'path', d: (0,_util__WEBPACK_IMPORTED_MODULE_1__.normalize)(path.serialize(), offset == null ? -w / 2 : offset) });
};
//# sourceMappingURL=diamond.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/marker/ellipse.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/marker/ellipse.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ellipse: () => (/* binding */ ellipse)
/* harmony export */ });
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const ellipse = (_a) => {
    var { rx, ry } = _a, attrs = __rest(_a, ["rx", "ry"]);
    const radiusX = rx || 5;
    const radiusy = ry || 5;
    return Object.assign(Object.assign({ cx: radiusX }, attrs), { tagName: 'ellipse', rx: radiusX, ry: radiusy });
};
//# sourceMappingURL=ellipse.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/marker/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/marker/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Marker: () => (/* binding */ Marker)
/* harmony export */ });
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry */ "./node_modules/@antv/x6/es/registry/registry.js");
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./main */ "./node_modules/@antv/x6/es/registry/marker/main.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/marker/util.js");



var Marker;
(function (Marker) {
    Marker.presets = _main__WEBPACK_IMPORTED_MODULE_1__;
    Marker.registry = _registry__WEBPACK_IMPORTED_MODULE_0__.Registry.create({
        type: 'marker',
    });
    Marker.registry.register(Marker.presets, true);
})(Marker || (Marker = {}));
(function (Marker) {
    Marker.normalize = _util__WEBPACK_IMPORTED_MODULE_2__.normalize;
})(Marker || (Marker = {}));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/marker/main.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/marker/main.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   async: () => (/* reexport safe */ _async__WEBPACK_IMPORTED_MODULE_4__.async),
/* harmony export */   block: () => (/* reexport safe */ _classic__WEBPACK_IMPORTED_MODULE_0__.block),
/* harmony export */   circle: () => (/* reexport safe */ _circle__WEBPACK_IMPORTED_MODULE_5__.circle),
/* harmony export */   circlePlus: () => (/* reexport safe */ _circle__WEBPACK_IMPORTED_MODULE_5__.circlePlus),
/* harmony export */   classic: () => (/* reexport safe */ _classic__WEBPACK_IMPORTED_MODULE_0__.classic),
/* harmony export */   cross: () => (/* reexport safe */ _cross__WEBPACK_IMPORTED_MODULE_3__.cross),
/* harmony export */   diamond: () => (/* reexport safe */ _diamond__WEBPACK_IMPORTED_MODULE_1__.diamond),
/* harmony export */   ellipse: () => (/* reexport safe */ _ellipse__WEBPACK_IMPORTED_MODULE_6__.ellipse),
/* harmony export */   path: () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_2__.path)
/* harmony export */ });
/* harmony import */ var _classic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./classic */ "./node_modules/@antv/x6/es/registry/marker/classic.js");
/* harmony import */ var _diamond__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./diamond */ "./node_modules/@antv/x6/es/registry/marker/diamond.js");
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path */ "./node_modules/@antv/x6/es/registry/marker/path.js");
/* harmony import */ var _cross__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cross */ "./node_modules/@antv/x6/es/registry/marker/cross.js");
/* harmony import */ var _async__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./async */ "./node_modules/@antv/x6/es/registry/marker/async.js");
/* harmony import */ var _circle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./circle */ "./node_modules/@antv/x6/es/registry/marker/circle.js");
/* harmony import */ var _ellipse__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ellipse */ "./node_modules/@antv/x6/es/registry/marker/ellipse.js");







//# sourceMappingURL=main.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/marker/path.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/marker/path.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   path: () => (/* binding */ path)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/marker/util.js");
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};

const path = (_a) => {
    var { d, offsetX, offsetY } = _a, attrs = __rest(_a, ["d", "offsetX", "offsetY"]);
    return Object.assign(Object.assign({}, attrs), { tagName: 'path', d: (0,_util__WEBPACK_IMPORTED_MODULE_0__.normalize)(d, offsetX, offsetY) });
};
//# sourceMappingURL=path.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/marker/util.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/marker/util.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   normalize: () => (/* binding */ normalize)
/* harmony export */ });
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");

function normalize(d, offset1, offset2) {
    let offsetX;
    let offsetY;
    if (typeof offset1 === 'object') {
        offsetX = offset1.x;
        offsetY = offset1.y;
    }
    else {
        offsetX = offset1;
        offsetY = offset2;
    }
    const path = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Path.parse(d);
    const bbox = path.bbox();
    if (bbox) {
        let ty = -bbox.height / 2 - bbox.y;
        let tx = -bbox.width / 2 - bbox.x;
        if (typeof offsetX === 'number') {
            tx -= offsetX;
        }
        if (typeof offsetY === 'number') {
            ty -= offsetY;
        }
        path.translate(tx, ty);
    }
    return path.serialize();
}
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/node-anchor/bbox.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/node-anchor/bbox.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bottom: () => (/* binding */ bottom),
/* harmony export */   bottomLeft: () => (/* binding */ bottomLeft),
/* harmony export */   bottomRight: () => (/* binding */ bottomRight),
/* harmony export */   center: () => (/* binding */ center),
/* harmony export */   left: () => (/* binding */ left),
/* harmony export */   right: () => (/* binding */ right),
/* harmony export */   top: () => (/* binding */ top),
/* harmony export */   topLeft: () => (/* binding */ topLeft),
/* harmony export */   topRight: () => (/* binding */ topRight)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");

const center = createBBoxAnchor('center');
const top = createBBoxAnchor('topCenter');
const bottom = createBBoxAnchor('bottomCenter');
const left = createBBoxAnchor('leftMiddle');
const right = createBBoxAnchor('rightMiddle');
const topLeft = createBBoxAnchor('topLeft');
const topRight = createBBoxAnchor('topRight');
const bottomLeft = createBBoxAnchor('bottomLeft');
const bottomRight = createBBoxAnchor('bottomRight');
function createBBoxAnchor(method) {
    return function (view, magnet, ref, options = {}) {
        const bbox = options.rotate
            ? view.getUnrotatedBBoxOfElement(magnet)
            : view.getBBoxOfElement(magnet);
        const result = bbox[method];
        result.x += _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.NumberExt.normalizePercentage(options.dx, bbox.width);
        result.y += _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.NumberExt.normalizePercentage(options.dy, bbox.height);
        const cell = view.cell;
        return options.rotate
            ? result.rotate(-cell.getAngle(), cell.getBBox().getCenter())
            : result;
    };
}
//# sourceMappingURL=bbox.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/node-anchor/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/node-anchor/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NodeAnchor: () => (/* binding */ NodeAnchor)
/* harmony export */ });
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry */ "./node_modules/@antv/x6/es/registry/registry.js");
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./main */ "./node_modules/@antv/x6/es/registry/node-anchor/main.js");


var NodeAnchor;
(function (NodeAnchor) {
    NodeAnchor.presets = _main__WEBPACK_IMPORTED_MODULE_1__;
    NodeAnchor.registry = _registry__WEBPACK_IMPORTED_MODULE_0__.Registry.create({
        type: 'node endpoint',
    });
    NodeAnchor.registry.register(NodeAnchor.presets, true);
})(NodeAnchor || (NodeAnchor = {}));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/node-anchor/main.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/node-anchor/main.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bottom: () => (/* reexport safe */ _bbox__WEBPACK_IMPORTED_MODULE_0__.bottom),
/* harmony export */   bottomLeft: () => (/* reexport safe */ _bbox__WEBPACK_IMPORTED_MODULE_0__.bottomLeft),
/* harmony export */   bottomRight: () => (/* reexport safe */ _bbox__WEBPACK_IMPORTED_MODULE_0__.bottomRight),
/* harmony export */   center: () => (/* reexport safe */ _bbox__WEBPACK_IMPORTED_MODULE_0__.center),
/* harmony export */   left: () => (/* reexport safe */ _bbox__WEBPACK_IMPORTED_MODULE_0__.left),
/* harmony export */   midSide: () => (/* reexport safe */ _middle_side__WEBPACK_IMPORTED_MODULE_3__.midSide),
/* harmony export */   nodeCenter: () => (/* reexport safe */ _node_center__WEBPACK_IMPORTED_MODULE_2__.nodeCenter),
/* harmony export */   orth: () => (/* reexport safe */ _orth__WEBPACK_IMPORTED_MODULE_1__.orth),
/* harmony export */   right: () => (/* reexport safe */ _bbox__WEBPACK_IMPORTED_MODULE_0__.right),
/* harmony export */   top: () => (/* reexport safe */ _bbox__WEBPACK_IMPORTED_MODULE_0__.top),
/* harmony export */   topLeft: () => (/* reexport safe */ _bbox__WEBPACK_IMPORTED_MODULE_0__.topLeft),
/* harmony export */   topRight: () => (/* reexport safe */ _bbox__WEBPACK_IMPORTED_MODULE_0__.topRight)
/* harmony export */ });
/* harmony import */ var _bbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bbox */ "./node_modules/@antv/x6/es/registry/node-anchor/bbox.js");
/* harmony import */ var _orth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./orth */ "./node_modules/@antv/x6/es/registry/node-anchor/orth.js");
/* harmony import */ var _node_center__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node-center */ "./node_modules/@antv/x6/es/registry/node-anchor/node-center.js");
/* harmony import */ var _middle_side__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./middle-side */ "./node_modules/@antv/x6/es/registry/node-anchor/middle-side.js");




//# sourceMappingURL=main.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/node-anchor/middle-side.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/node-anchor/middle-side.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   midSide: () => (/* binding */ midSide)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/node-anchor/util.js");

const middleSide = function (view, magnet, refPoint, options) {
    let bbox;
    let angle = 0;
    let center;
    const node = view.cell;
    if (options.rotate) {
        bbox = view.getUnrotatedBBoxOfElement(magnet);
        center = node.getBBox().getCenter();
        angle = node.getAngle();
    }
    else {
        bbox = view.getBBoxOfElement(magnet);
    }
    const padding = options.padding;
    if (padding != null && Number.isFinite(padding)) {
        bbox.inflate(padding);
    }
    if (options.rotate) {
        refPoint.rotate(angle, center);
    }
    const side = bbox.getNearestSideToPoint(refPoint);
    let result;
    switch (side) {
        case 'left':
            result = bbox.getLeftMiddle();
            break;
        case 'right':
            result = bbox.getRightMiddle();
            break;
        case 'top':
            result = bbox.getTopCenter();
            break;
        case 'bottom':
            result = bbox.getBottomCenter();
            break;
        default:
            break;
    }
    const direction = options.direction;
    if (direction === 'H') {
        if (side === 'top' || side === 'bottom') {
            if (refPoint.x <= bbox.x + bbox.width) {
                result = bbox.getLeftMiddle();
            }
            else {
                result = bbox.getRightMiddle();
            }
        }
    }
    else if (direction === 'V') {
        if (refPoint.y <= bbox.y + bbox.height) {
            result = bbox.getTopCenter();
        }
        else {
            result = bbox.getBottomCenter();
        }
    }
    return options.rotate ? result.rotate(-angle, center) : result;
};
/**
 * Places the anchor of the edge in the middle of the side of view bbox
 * closest to the other endpoint.
 */
const midSide = (0,_util__WEBPACK_IMPORTED_MODULE_0__.resolve)(middleSide);
//# sourceMappingURL=middle-side.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/node-anchor/node-center.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/node-anchor/node-center.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   nodeCenter: () => (/* binding */ nodeCenter)
/* harmony export */ });
/**
 * Places the anchor of the edge at center of the node bbox.
 */
const nodeCenter = function (view, magnet, ref, options, endType) {
    const result = view.cell.getConnectionPoint(this.cell, endType);
    if (options.dx || options.dy) {
        result.translate(options.dx || 0, options.dy || 0);
    }
    return result;
};
//# sourceMappingURL=node-center.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/node-anchor/orth.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/node-anchor/orth.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   orth: () => (/* binding */ orth)
/* harmony export */ });
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/node-anchor/util.js");


const orthogonal = function (view, magnet, refPoint, options) {
    const angle = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Angle.normalize(view.cell.getAngle());
    const bbox = view.getBBoxOfElement(magnet);
    const result = bbox.getCenter();
    const topLeft = bbox.getTopLeft();
    const bottomRight = bbox.getBottomRight();
    let padding = options.padding;
    if (!Number.isFinite(padding)) {
        padding = 0;
    }
    if (topLeft.y + padding <= refPoint.y &&
        refPoint.y <= bottomRight.y - padding) {
        const dy = refPoint.y - result.y;
        result.x +=
            angle === 0 || angle === 180
                ? 0
                : (dy * 1) / Math.tan(_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Angle.toRad(angle));
        result.y += dy;
    }
    else if (topLeft.x + padding <= refPoint.x &&
        refPoint.x <= bottomRight.x - padding) {
        const dx = refPoint.x - result.x;
        result.y +=
            angle === 90 || angle === 270 ? 0 : dx * Math.tan(_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Angle.toRad(angle));
        result.x += dx;
    }
    return result;
};
/**
 * Tries to place the anchor of the edge inside the view bbox so that the
 * edge is made orthogonal. The anchor is placed along two line segments
 * inside the view bbox (between the centers of the top and bottom side and
 * between the centers of the left and right sides). If it is not possible
 * to place the anchor so that the edge would be orthogonal, the anchor is
 * placed at the center of the view bbox instead.
 */
const orth = (0,_util__WEBPACK_IMPORTED_MODULE_1__.resolve)(orthogonal);
//# sourceMappingURL=orth.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/node-anchor/util.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/node-anchor/util.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getPointAtEdge: () => (/* binding */ getPointAtEdge),
/* harmony export */   resolve: () => (/* binding */ resolve)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");


// eslint-disable-next-line
function resolve(fn) {
    return function (view, magnet, ref, options) {
        if (ref instanceof Element) {
            const refView = this.graph.findViewByElem(ref);
            let refPoint;
            if (refView) {
                if (refView.isEdgeElement(ref)) {
                    const distance = options.fixedAt != null ? options.fixedAt : '50%';
                    refPoint = getPointAtEdge(refView, distance);
                }
                else {
                    refPoint = refView.getBBoxOfElement(ref).getCenter();
                }
            }
            else {
                refPoint = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point();
            }
            return fn.call(this, view, magnet, refPoint, options);
        }
        return fn.apply(this, arguments); // eslint-disable-line
    };
}
function getPointAtEdge(edgeView, value) {
    const isPercentage = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.NumberExt.isPercentage(value);
    const num = typeof value === 'string' ? parseFloat(value) : value;
    if (isPercentage) {
        return edgeView.getPointAtRatio(num / 100);
    }
    return edgeView.getPointAtLength(num);
}
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/port-label-layout/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/port-label-layout/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PortLabelLayout: () => (/* binding */ PortLabelLayout)
/* harmony export */ });
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry */ "./node_modules/@antv/x6/es/registry/registry.js");
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./main */ "./node_modules/@antv/x6/es/registry/port-label-layout/main.js");


var PortLabelLayout;
(function (PortLabelLayout) {
    PortLabelLayout.presets = _main__WEBPACK_IMPORTED_MODULE_1__;
    PortLabelLayout.registry = _registry__WEBPACK_IMPORTED_MODULE_0__.Registry.create({
        type: 'port label layout',
    });
    PortLabelLayout.registry.register(PortLabelLayout.presets, true);
})(PortLabelLayout || (PortLabelLayout = {}));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/port-label-layout/inout.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/port-label-layout/inout.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   inside: () => (/* binding */ inside),
/* harmony export */   insideOriented: () => (/* binding */ insideOriented),
/* harmony export */   outside: () => (/* binding */ outside),
/* harmony export */   outsideOriented: () => (/* binding */ outsideOriented)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/port-label-layout/util.js");

const outside = (portPosition, elemBBox, args) => outsideLayout(portPosition, elemBBox, false, args);
const outsideOriented = (portPosition, elemBBox, args) => outsideLayout(portPosition, elemBBox, true, args);
const inside = (portPosition, elemBBox, args) => insideLayout(portPosition, elemBBox, false, args);
const insideOriented = (portPosition, elemBBox, args) => insideLayout(portPosition, elemBBox, true, args);
function outsideLayout(portPosition, elemBBox, autoOrient, args) {
    const offset = args.offset != null ? args.offset : 15;
    const angle = elemBBox.getCenter().theta(portPosition);
    const bboxAngles = getBBoxAngles(elemBBox);
    let y;
    let tx;
    let ty;
    let textAnchor;
    let orientAngle = 0;
    if (angle < bboxAngles[1] || angle > bboxAngles[2]) {
        y = '.3em';
        tx = offset;
        ty = 0;
        textAnchor = 'start';
    }
    else if (angle < bboxAngles[0]) {
        y = '0';
        tx = 0;
        ty = -offset;
        if (autoOrient) {
            orientAngle = -90;
            textAnchor = 'start';
        }
        else {
            textAnchor = 'middle';
        }
    }
    else if (angle < bboxAngles[3]) {
        y = '.3em';
        tx = -offset;
        ty = 0;
        textAnchor = 'end';
    }
    else {
        y = '.6em';
        tx = 0;
        ty = offset;
        if (autoOrient) {
            orientAngle = 90;
            textAnchor = 'start';
        }
        else {
            textAnchor = 'middle';
        }
    }
    return (0,_util__WEBPACK_IMPORTED_MODULE_0__.toResult)({
        position: {
            x: Math.round(tx),
            y: Math.round(ty),
        },
        angle: orientAngle,
        attrs: {
            '.': {
                y,
                'text-anchor': textAnchor,
            },
        },
    }, args);
}
function insideLayout(portPosition, elemBBox, autoOrient, args) {
    const offset = args.offset != null ? args.offset : 15;
    const angle = elemBBox.getCenter().theta(portPosition);
    const bboxAngles = getBBoxAngles(elemBBox);
    let y;
    let tx;
    let ty;
    let textAnchor;
    let orientAngle = 0;
    if (angle < bboxAngles[1] || angle > bboxAngles[2]) {
        y = '.3em';
        tx = -offset;
        ty = 0;
        textAnchor = 'end';
    }
    else if (angle < bboxAngles[0]) {
        y = '.6em';
        tx = 0;
        ty = offset;
        if (autoOrient) {
            orientAngle = 90;
            textAnchor = 'start';
        }
        else {
            textAnchor = 'middle';
        }
    }
    else if (angle < bboxAngles[3]) {
        y = '.3em';
        tx = offset;
        ty = 0;
        textAnchor = 'start';
    }
    else {
        y = '0em';
        tx = 0;
        ty = -offset;
        if (autoOrient) {
            orientAngle = -90;
            textAnchor = 'start';
        }
        else {
            textAnchor = 'middle';
        }
    }
    return (0,_util__WEBPACK_IMPORTED_MODULE_0__.toResult)({
        position: {
            x: Math.round(tx),
            y: Math.round(ty),
        },
        angle: orientAngle,
        attrs: {
            '.': {
                y,
                'text-anchor': textAnchor,
            },
        },
    }, args);
}
function getBBoxAngles(elemBBox) {
    const center = elemBBox.getCenter();
    const tl = center.theta(elemBBox.getTopLeft());
    const bl = center.theta(elemBBox.getBottomLeft());
    const br = center.theta(elemBBox.getBottomRight());
    const tr = center.theta(elemBBox.getTopRight());
    return [tl, tr, br, bl];
}
//# sourceMappingURL=inout.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/port-label-layout/main.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/port-label-layout/main.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bottom: () => (/* reexport safe */ _side__WEBPACK_IMPORTED_MODULE_0__.bottom),
/* harmony export */   inside: () => (/* reexport safe */ _inout__WEBPACK_IMPORTED_MODULE_1__.inside),
/* harmony export */   insideOriented: () => (/* reexport safe */ _inout__WEBPACK_IMPORTED_MODULE_1__.insideOriented),
/* harmony export */   left: () => (/* reexport safe */ _side__WEBPACK_IMPORTED_MODULE_0__.left),
/* harmony export */   manual: () => (/* reexport safe */ _side__WEBPACK_IMPORTED_MODULE_0__.manual),
/* harmony export */   outside: () => (/* reexport safe */ _inout__WEBPACK_IMPORTED_MODULE_1__.outside),
/* harmony export */   outsideOriented: () => (/* reexport safe */ _inout__WEBPACK_IMPORTED_MODULE_1__.outsideOriented),
/* harmony export */   radial: () => (/* reexport safe */ _radial__WEBPACK_IMPORTED_MODULE_2__.radial),
/* harmony export */   radialOriented: () => (/* reexport safe */ _radial__WEBPACK_IMPORTED_MODULE_2__.radialOriented),
/* harmony export */   right: () => (/* reexport safe */ _side__WEBPACK_IMPORTED_MODULE_0__.right),
/* harmony export */   top: () => (/* reexport safe */ _side__WEBPACK_IMPORTED_MODULE_0__.top)
/* harmony export */ });
/* harmony import */ var _side__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./side */ "./node_modules/@antv/x6/es/registry/port-label-layout/side.js");
/* harmony import */ var _inout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./inout */ "./node_modules/@antv/x6/es/registry/port-label-layout/inout.js");
/* harmony import */ var _radial__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./radial */ "./node_modules/@antv/x6/es/registry/port-label-layout/radial.js");



//# sourceMappingURL=main.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/port-label-layout/radial.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/port-label-layout/radial.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   radial: () => (/* binding */ radial),
/* harmony export */   radialOriented: () => (/* binding */ radialOriented)
/* harmony export */ });
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/port-label-layout/util.js");


const radial = (portPosition, elemBBox, args) => radialLayout(portPosition.diff(elemBBox.getCenter()), false, args);
const radialOriented = (portPosition, elemBBox, args) => radialLayout(portPosition.diff(elemBBox.getCenter()), true, args);
function radialLayout(portCenterOffset, autoOrient, args) {
    const offset = args.offset != null ? args.offset : 20;
    const origin = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(0, 0);
    const angle = -portCenterOffset.theta(origin);
    const pos = portCenterOffset
        .clone()
        .move(origin, offset)
        .diff(portCenterOffset)
        .round();
    let y = '.3em';
    let textAnchor;
    let orientAngle = angle;
    if ((angle + 90) % 180 === 0) {
        textAnchor = autoOrient ? 'end' : 'middle';
        if (!autoOrient && angle === -270) {
            y = '0em';
        }
    }
    else if (angle > -270 && angle < -90) {
        textAnchor = 'start';
        orientAngle = angle - 180;
    }
    else {
        textAnchor = 'end';
    }
    return (0,_util__WEBPACK_IMPORTED_MODULE_1__.toResult)({
        position: pos.round().toJSON(),
        angle: autoOrient ? orientAngle : 0,
        attrs: {
            '.': {
                y,
                'text-anchor': textAnchor,
            },
        },
    }, args);
}
//# sourceMappingURL=radial.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/port-label-layout/side.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/port-label-layout/side.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bottom: () => (/* binding */ bottom),
/* harmony export */   left: () => (/* binding */ left),
/* harmony export */   manual: () => (/* binding */ manual),
/* harmony export */   right: () => (/* binding */ right),
/* harmony export */   top: () => (/* binding */ top)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/port-label-layout/util.js");

const manual = (portPosition, elemBBox, args) => (0,_util__WEBPACK_IMPORTED_MODULE_0__.toResult)({ position: elemBBox.getTopLeft() }, args);
const left = (portPosition, elemBBox, args) => (0,_util__WEBPACK_IMPORTED_MODULE_0__.toResult)({
    position: { x: -15, y: 0 },
    attrs: { '.': { y: '.3em', 'text-anchor': 'end' } },
}, args);
const right = (portPosition, elemBBox, args) => (0,_util__WEBPACK_IMPORTED_MODULE_0__.toResult)({
    position: { x: 15, y: 0 },
    attrs: { '.': { y: '.3em', 'text-anchor': 'start' } },
}, args);
const top = (portPosition, elemBBox, args) => (0,_util__WEBPACK_IMPORTED_MODULE_0__.toResult)({
    position: { x: 0, y: -15 },
    attrs: { '.': { 'text-anchor': 'middle' } },
}, args);
const bottom = (portPosition, elemBBox, args) => (0,_util__WEBPACK_IMPORTED_MODULE_0__.toResult)({
    position: { x: 0, y: 15 },
    attrs: { '.': { y: '.6em', 'text-anchor': 'middle' } },
}, args);
//# sourceMappingURL=side.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/port-label-layout/util.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/port-label-layout/util.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   toResult: () => (/* binding */ toResult)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");

const defaults = {
    position: { x: 0, y: 0 },
    angle: 0,
    attrs: {
        '.': {
            y: '0',
            'text-anchor': 'start',
        },
    },
};
function toResult(preset, args) {
    const { x, y, angle, attrs } = args || {};
    return _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.defaultsDeep({}, { angle, attrs, position: { x, y } }, preset, defaults);
}
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/port-layout/absolute.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/port-layout/absolute.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   absolute: () => (/* binding */ absolute)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/port-layout/util.js");

const absolute = (portsPositionArgs, elemBBox) => {
    return portsPositionArgs.map(({ x, y, angle }) => (0,_util__WEBPACK_IMPORTED_MODULE_0__.toResult)((0,_util__WEBPACK_IMPORTED_MODULE_0__.normalizePoint)(elemBBox, { x, y }), angle || 0));
};
//# sourceMappingURL=absolute.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/port-layout/ellipse.js":
/*!******************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/port-layout/ellipse.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ellipse: () => (/* binding */ ellipse),
/* harmony export */   ellipseSpread: () => (/* binding */ ellipseSpread)
/* harmony export */ });
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/port-layout/util.js");


const ellipse = (portsPositionArgs, elemBBox, groupPositionArgs) => {
    const startAngle = groupPositionArgs.start || 0;
    const stepAngle = groupPositionArgs.step || 20;
    return ellipseLayout(portsPositionArgs, elemBBox, startAngle, (index, count) => (index + 0.5 - count / 2) * stepAngle);
};
const ellipseSpread = (portsPositionArgs, elemBBox, groupPositionArgs) => {
    const startAngle = groupPositionArgs.start || 0;
    const stepAngle = groupPositionArgs.step || 360 / portsPositionArgs.length;
    return ellipseLayout(portsPositionArgs, elemBBox, startAngle, (index) => {
        return index * stepAngle;
    });
};
function ellipseLayout(portsPositionArgs, elemBBox, startAngle, stepFn) {
    const center = elemBBox.getCenter();
    const start = elemBBox.getTopCenter();
    const ratio = elemBBox.width / elemBBox.height;
    const ellipse = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Ellipse.fromRect(elemBBox);
    const count = portsPositionArgs.length;
    return portsPositionArgs.map((item, index) => {
        const angle = startAngle + stepFn(index, count);
        const p = start.clone().rotate(-angle, center).scale(ratio, 1, center);
        const theta = item.compensateRotate ? -ellipse.tangentTheta(p) : 0;
        if (item.dx || item.dy) {
            p.translate(item.dx || 0, item.dy || 0);
        }
        if (item.dr) {
            p.move(center, item.dr);
        }
        return (0,_util__WEBPACK_IMPORTED_MODULE_1__.toResult)(p.round(), theta, item);
    });
}
//# sourceMappingURL=ellipse.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/port-layout/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/port-layout/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PortLayout: () => (/* binding */ PortLayout)
/* harmony export */ });
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry */ "./node_modules/@antv/x6/es/registry/registry.js");
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./main */ "./node_modules/@antv/x6/es/registry/port-layout/main.js");


var PortLayout;
(function (PortLayout) {
    PortLayout.presets = _main__WEBPACK_IMPORTED_MODULE_1__;
    PortLayout.registry = _registry__WEBPACK_IMPORTED_MODULE_0__.Registry.create({
        type: 'port layout',
    });
    PortLayout.registry.register(PortLayout.presets, true);
})(PortLayout || (PortLayout = {}));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/port-layout/line.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/port-layout/line.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bottom: () => (/* binding */ bottom),
/* harmony export */   left: () => (/* binding */ left),
/* harmony export */   line: () => (/* binding */ line),
/* harmony export */   right: () => (/* binding */ right),
/* harmony export */   top: () => (/* binding */ top)
/* harmony export */ });
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/port-layout/util.js");
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};


const line = (portsPositionArgs, elemBBox, groupPositionArgs) => {
    const start = (0,_util__WEBPACK_IMPORTED_MODULE_1__.normalizePoint)(elemBBox, groupPositionArgs.start || elemBBox.getOrigin());
    const end = (0,_util__WEBPACK_IMPORTED_MODULE_1__.normalizePoint)(elemBBox, groupPositionArgs.end || elemBBox.getCorner());
    return lineLayout(portsPositionArgs, start, end, groupPositionArgs);
};
const left = (portsPositionArgs, elemBBox, groupPositionArgs) => {
    return lineLayout(portsPositionArgs, elemBBox.getTopLeft(), elemBBox.getBottomLeft(), groupPositionArgs);
};
const right = (portsPositionArgs, elemBBox, groupPositionArgs) => {
    return lineLayout(portsPositionArgs, elemBBox.getTopRight(), elemBBox.getBottomRight(), groupPositionArgs);
};
const top = (portsPositionArgs, elemBBox, groupPositionArgs) => {
    return lineLayout(portsPositionArgs, elemBBox.getTopLeft(), elemBBox.getTopRight(), groupPositionArgs);
};
const bottom = (portsPositionArgs, elemBBox, groupPositionArgs) => {
    return lineLayout(portsPositionArgs, elemBBox.getBottomLeft(), elemBBox.getBottomRight(), groupPositionArgs);
};
function lineLayout(portsPositionArgs, p1, p2, groupPositionArgs) {
    const line = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Line(p1, p2);
    const length = portsPositionArgs.length;
    return portsPositionArgs.map((_a, index) => {
        var { strict } = _a, offset = __rest(_a, ["strict"]);
        const ratio = strict || groupPositionArgs.strict
            ? (index + 1) / (length + 1)
            : (index + 0.5) / length;
        const p = line.pointAt(ratio);
        if (offset.dx || offset.dy) {
            p.translate(offset.dx || 0, offset.dy || 0);
        }
        return (0,_util__WEBPACK_IMPORTED_MODULE_1__.toResult)(p.round(), 0, offset);
    });
}
//# sourceMappingURL=line.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/port-layout/main.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/port-layout/main.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   absolute: () => (/* reexport safe */ _absolute__WEBPACK_IMPORTED_MODULE_0__.absolute),
/* harmony export */   bottom: () => (/* reexport safe */ _line__WEBPACK_IMPORTED_MODULE_2__.bottom),
/* harmony export */   ellipse: () => (/* reexport safe */ _ellipse__WEBPACK_IMPORTED_MODULE_1__.ellipse),
/* harmony export */   ellipseSpread: () => (/* reexport safe */ _ellipse__WEBPACK_IMPORTED_MODULE_1__.ellipseSpread),
/* harmony export */   left: () => (/* reexport safe */ _line__WEBPACK_IMPORTED_MODULE_2__.left),
/* harmony export */   line: () => (/* reexport safe */ _line__WEBPACK_IMPORTED_MODULE_2__.line),
/* harmony export */   right: () => (/* reexport safe */ _line__WEBPACK_IMPORTED_MODULE_2__.right),
/* harmony export */   top: () => (/* reexport safe */ _line__WEBPACK_IMPORTED_MODULE_2__.top)
/* harmony export */ });
/* harmony import */ var _absolute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./absolute */ "./node_modules/@antv/x6/es/registry/port-layout/absolute.js");
/* harmony import */ var _ellipse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ellipse */ "./node_modules/@antv/x6/es/registry/port-layout/ellipse.js");
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line */ "./node_modules/@antv/x6/es/registry/port-layout/line.js");



//# sourceMappingURL=main.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/port-layout/util.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/port-layout/util.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   normalizePoint: () => (/* binding */ normalizePoint),
/* harmony export */   toResult: () => (/* binding */ toResult)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");


function normalizePoint(bbox, args = {}) {
    return new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.NumberExt.normalizePercentage(args.x, bbox.width), _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.NumberExt.normalizePercentage(args.y, bbox.height));
}
function toResult(point, angle, rawArgs) {
    return Object.assign({ angle, position: point.toJSON() }, rawArgs);
}
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/registry.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/registry.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Registry: () => (/* binding */ Registry)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");

class Registry {
    constructor(options) {
        this.options = Object.assign({}, options);
        this.data = this.options.data || {};
        this.register = this.register.bind(this);
        this.unregister = this.unregister.bind(this);
    }
    get names() {
        return Object.keys(this.data);
    }
    register(name, options, force = false) {
        if (typeof name === 'object') {
            Object.entries(name).forEach(([key, val]) => {
                this.register(key, val, options);
            });
            return;
        }
        if (this.exist(name) && !force && !_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Platform.isApplyingHMR()) {
            this.onDuplicated(name);
        }
        const process = this.options.process;
        const entity = process
            ? _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(process, this, name, options)
            : options;
        this.data[name] = entity;
        return entity;
    }
    unregister(name) {
        const entity = name ? this.data[name] : null;
        delete this.data[name];
        return entity;
    }
    get(name) {
        return name ? this.data[name] : null;
    }
    exist(name) {
        return name ? this.data[name] != null : false;
    }
    onDuplicated(name) {
        // eslint-disable-next-line no-useless-catch
        try {
            // race
            if (this.options.onConflict) {
                _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(this.options.onConflict, this, name);
            }
            throw new Error(`${_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.StringExt.upperFirst(this.options.type)} with name '${name}' already registered.`);
        }
        catch (err) {
            throw err;
        }
    }
    onNotFound(name, prefix) {
        throw new Error(this.getSpellingSuggestion(name, prefix));
    }
    getSpellingSuggestion(name, prefix) {
        const suggestion = this.getSpellingSuggestionForName(name);
        const prefixed = prefix
            ? `${prefix} ${_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.StringExt.lowerFirst(this.options.type)}`
            : this.options.type;
        return (
        // eslint-disable-next-line
        `${_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.StringExt.upperFirst(prefixed)} with name '${name}' does not exist.${suggestion ? ` Did you mean '${suggestion}'?` : ''}`);
    }
    getSpellingSuggestionForName(name) {
        return _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.StringExt.getSpellingSuggestion(name, Object.keys(this.data), (candidate) => candidate);
    }
}
(function (Registry) {
    function create(options) {
        return new Registry(options);
    }
    Registry.create = create;
})(Registry || (Registry = {}));
//# sourceMappingURL=registry.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/router/er.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/router/er.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   er: () => (/* binding */ er)
/* harmony export */ });
const er = function (vertices, options, edgeView) {
    const offsetRaw = options.offset || 32;
    const min = options.min == null ? 16 : options.min;
    let offset = 0;
    let direction = options.direction;
    const sourceBBox = edgeView.sourceBBox;
    const targetBBox = edgeView.targetBBox;
    const sourcePoint = sourceBBox.getCenter();
    const targetPoint = targetBBox.getCenter();
    if (typeof offsetRaw === 'number') {
        offset = offsetRaw;
    }
    if (direction == null) {
        let dx = targetBBox.left - sourceBBox.right;
        let dy = targetBBox.top - sourceBBox.bottom;
        if (dx >= 0 && dy >= 0) {
            direction = dx >= dy ? 'L' : 'T';
        }
        else if (dx <= 0 && dy >= 0) {
            dx = sourceBBox.left - targetBBox.right;
            if (dx >= 0) {
                direction = dx >= dy ? 'R' : 'T';
            }
            else {
                direction = 'T';
            }
        }
        else if (dx >= 0 && dy <= 0) {
            dy = sourceBBox.top - targetBBox.bottom;
            if (dy >= 0) {
                direction = dx >= dy ? 'L' : 'B';
            }
            else {
                direction = 'L';
            }
        }
        else {
            dx = sourceBBox.left - targetBBox.right;
            dy = sourceBBox.top - targetBBox.bottom;
            if (dx >= 0 && dy >= 0) {
                direction = dx >= dy ? 'R' : 'B';
            }
            else if (dx <= 0 && dy >= 0) {
                direction = 'B';
            }
            else if (dx >= 0 && dy <= 0) {
                direction = 'R';
            }
            else {
                direction = Math.abs(dx) > Math.abs(dy) ? 'R' : 'B';
            }
        }
    }
    if (direction === 'H') {
        direction = targetPoint.x - sourcePoint.x >= 0 ? 'L' : 'R';
    }
    else if (direction === 'V') {
        direction = targetPoint.y - sourcePoint.y >= 0 ? 'T' : 'B';
    }
    if (offsetRaw === 'center') {
        if (direction === 'L') {
            offset = (targetBBox.left - sourceBBox.right) / 2;
        }
        else if (direction === 'R') {
            offset = (sourceBBox.left - targetBBox.right) / 2;
        }
        else if (direction === 'T') {
            offset = (targetBBox.top - sourceBBox.bottom) / 2;
        }
        else if (direction === 'B') {
            offset = (sourceBBox.top - targetBBox.bottom) / 2;
        }
    }
    let coord;
    let dim;
    let factor;
    const horizontal = direction === 'L' || direction === 'R';
    if (horizontal) {
        if (targetPoint.y === sourcePoint.y) {
            return [...vertices];
        }
        factor = direction === 'L' ? 1 : -1;
        coord = 'x';
        dim = 'width';
    }
    else {
        if (targetPoint.x === sourcePoint.x) {
            return [...vertices];
        }
        factor = direction === 'T' ? 1 : -1;
        coord = 'y';
        dim = 'height';
    }
    const source = sourcePoint.clone();
    const target = targetPoint.clone();
    source[coord] += factor * (sourceBBox[dim] / 2 + offset);
    target[coord] -= factor * (targetBBox[dim] / 2 + offset);
    if (horizontal) {
        const sourceX = source.x;
        const targetX = target.x;
        const sourceDelta = sourceBBox.width / 2 + min;
        const targetDelta = targetBBox.width / 2 + min;
        if (targetPoint.x > sourcePoint.x) {
            if (targetX <= sourceX) {
                source.x = Math.max(targetX, sourcePoint.x + sourceDelta);
                target.x = Math.min(sourceX, targetPoint.x - targetDelta);
            }
        }
        else if (targetX >= sourceX) {
            source.x = Math.min(targetX, sourcePoint.x - sourceDelta);
            target.x = Math.max(sourceX, targetPoint.x + targetDelta);
        }
    }
    else {
        const sourceY = source.y;
        const targetY = target.y;
        const sourceDelta = sourceBBox.height / 2 + min;
        const targetDelta = targetBBox.height / 2 + min;
        if (targetPoint.y > sourcePoint.y) {
            if (targetY <= sourceY) {
                source.y = Math.max(targetY, sourcePoint.y + sourceDelta);
                target.y = Math.min(sourceY, targetPoint.y - targetDelta);
            }
        }
        else if (targetY >= sourceY) {
            source.y = Math.min(targetY, sourcePoint.y - sourceDelta);
            target.y = Math.max(sourceY, targetPoint.y + targetDelta);
        }
    }
    return [source.toJSON(), ...vertices, target.toJSON()];
};
//# sourceMappingURL=er.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/router/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/router/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Router: () => (/* binding */ Router)
/* harmony export */ });
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry */ "./node_modules/@antv/x6/es/registry/registry.js");
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./main */ "./node_modules/@antv/x6/es/registry/router/main.js");


var Router;
(function (Router) {
    Router.presets = _main__WEBPACK_IMPORTED_MODULE_1__;
    Router.registry = _registry__WEBPACK_IMPORTED_MODULE_0__.Registry.create({
        type: 'router',
    });
    Router.registry.register(Router.presets, true);
})(Router || (Router = {}));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/router/loop.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/router/loop.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   loop: () => (/* binding */ loop)
/* harmony export */ });
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");

function rollup(points, merge) {
    if (merge != null && merge !== false) {
        const amount = typeof merge === 'boolean' ? 0 : merge;
        if (amount > 0) {
            const center1 = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(points[1]).move(points[2], amount);
            const center2 = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(points[1]).move(points[0], amount);
            return [center1.toJSON(), ...points, center2.toJSON()];
        }
        {
            const center = points[1];
            return [Object.assign({}, center), ...points, Object.assign({}, center)];
        }
    }
    return points;
}
const loop = function (vertices, options, edgeView) {
    const width = options.width || 50;
    const height = options.height || 80;
    const halfHeight = height / 2;
    const angle = options.angle || 'auto';
    const sourceAnchor = edgeView.sourceAnchor;
    const targetAnchor = edgeView.targetAnchor;
    const sourceBBox = edgeView.sourceBBox;
    const targetBBox = edgeView.targetBBox;
    if (sourceAnchor.equals(targetAnchor)) {
        const getVertices = (angle) => {
            const rad = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Angle.toRad(angle);
            const sin = Math.sin(rad);
            const cos = Math.cos(rad);
            const center = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(sourceAnchor.x + cos * width, sourceAnchor.y + sin * width);
            const ref = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(center.x - cos * halfHeight, center.y - sin * halfHeight);
            const p1 = ref.clone().rotate(-90, center);
            const p2 = ref.clone().rotate(90, center);
            return [p1.toJSON(), center.toJSON(), p2.toJSON()];
        };
        const validate = (end) => {
            const start = sourceAnchor.clone().move(end, -1);
            const line = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Line(start, end);
            return (!sourceBBox.containsPoint(end) && !sourceBBox.intersectsWithLine(line));
        };
        const angles = [0, 90, 180, 270, 45, 135, 225, 315];
        if (typeof angle === 'number') {
            return rollup(getVertices(angle), options.merge);
        }
        const center = sourceBBox.getCenter();
        if (center.equals(sourceAnchor)) {
            return rollup(getVertices(0), options.merge);
        }
        const deg = center.angleBetween(sourceAnchor, center.clone().translate(1, 0));
        let ret = getVertices(deg);
        if (validate(ret[1])) {
            return rollup(ret, options.merge);
        }
        // return the best vertices
        for (let i = 1, l = angles.length; i < l; i += 1) {
            ret = getVertices(deg + angles[i]);
            if (validate(ret[1])) {
                return rollup(ret, options.merge);
            }
        }
        return rollup(ret, options.merge);
    }
    {
        const line = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Line(sourceAnchor, targetAnchor);
        let parallel = line.parallel(-width);
        let center = parallel.getCenter();
        let p1 = parallel.start.clone().move(parallel.end, halfHeight);
        let p2 = parallel.end.clone().move(parallel.start, halfHeight);
        const ref = line.parallel(-1);
        const line1 = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Line(ref.start, center);
        const line2 = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Line(ref.end, center);
        if (sourceBBox.containsPoint(center) ||
            targetBBox.containsPoint(center) ||
            sourceBBox.intersectsWithLine(line1) ||
            sourceBBox.intersectsWithLine(line2) ||
            targetBBox.intersectsWithLine(line1) ||
            targetBBox.intersectsWithLine(line2)) {
            parallel = line.parallel(width);
            center = parallel.getCenter();
            p1 = parallel.start.clone().move(parallel.end, halfHeight);
            p2 = parallel.end.clone().move(parallel.start, halfHeight);
        }
        if (options.merge) {
            const line = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Line(sourceAnchor, targetAnchor);
            const normal = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Line(center, line.center).setLength(Number.MAX_SAFE_INTEGER);
            const intersects1 = sourceBBox.intersectsWithLine(normal);
            const intersects2 = targetBBox.intersectsWithLine(normal);
            const intersects = intersects1
                ? Array.isArray(intersects1)
                    ? intersects1
                    : [intersects1]
                : [];
            if (intersects2) {
                if (Array.isArray(intersects2)) {
                    intersects.push(...intersects2);
                }
                else {
                    intersects.push(intersects2);
                }
            }
            const anchor = line.center.closest(intersects);
            if (anchor) {
                edgeView.sourceAnchor = anchor.clone();
                edgeView.targetAnchor = anchor.clone();
            }
            else {
                edgeView.sourceAnchor = line.center.clone();
                edgeView.targetAnchor = line.center.clone();
            }
        }
        return rollup([p1.toJSON(), center.toJSON(), p2.toJSON()], options.merge);
    }
};
//# sourceMappingURL=loop.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/router/main.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/router/main.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   er: () => (/* reexport safe */ _er__WEBPACK_IMPORTED_MODULE_5__.er),
/* harmony export */   loop: () => (/* reexport safe */ _loop__WEBPACK_IMPORTED_MODULE_6__.loop),
/* harmony export */   manhattan: () => (/* reexport safe */ _manhattan_index__WEBPACK_IMPORTED_MODULE_4__.manhattan),
/* harmony export */   metro: () => (/* reexport safe */ _metro__WEBPACK_IMPORTED_MODULE_3__.metro),
/* harmony export */   normal: () => (/* reexport safe */ _normal__WEBPACK_IMPORTED_MODULE_0__.normal),
/* harmony export */   oneSide: () => (/* reexport safe */ _oneside__WEBPACK_IMPORTED_MODULE_1__.oneSide),
/* harmony export */   orth: () => (/* reexport safe */ _orth__WEBPACK_IMPORTED_MODULE_2__.orth)
/* harmony export */ });
/* harmony import */ var _normal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./normal */ "./node_modules/@antv/x6/es/registry/router/normal.js");
/* harmony import */ var _oneside__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./oneside */ "./node_modules/@antv/x6/es/registry/router/oneside.js");
/* harmony import */ var _orth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./orth */ "./node_modules/@antv/x6/es/registry/router/orth.js");
/* harmony import */ var _metro__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./metro */ "./node_modules/@antv/x6/es/registry/router/metro.js");
/* harmony import */ var _manhattan_index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./manhattan/index */ "./node_modules/@antv/x6/es/registry/router/manhattan/index.js");
/* harmony import */ var _er__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./er */ "./node_modules/@antv/x6/es/registry/router/er.js");
/* harmony import */ var _loop__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./loop */ "./node_modules/@antv/x6/es/registry/router/loop.js");







//# sourceMappingURL=main.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/router/manhattan/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/router/manhattan/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   manhattan: () => (/* binding */ manhattan)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./router */ "./node_modules/@antv/x6/es/registry/router/manhattan/router.js");
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./options */ "./node_modules/@antv/x6/es/registry/router/manhattan/options.js");



const manhattan = function (vertices, options, edgeView) {
    return _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(_router__WEBPACK_IMPORTED_MODULE_1__.router, this, vertices, Object.assign(Object.assign({}, _options__WEBPACK_IMPORTED_MODULE_2__.defaults), options), edgeView);
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/router/manhattan/obstacle-map.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/router/manhattan/obstacle-map.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ObstacleMap: () => (/* binding */ ObstacleMap)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");


/**
 * Helper structure to identify whether a point lies inside an obstacle.
 */
class ObstacleMap {
    constructor(options) {
        this.options = options;
        this.mapGridSize = 100;
        this.map = {};
    }
    /**
     * Builds a map of all nodes for quicker obstacle queries i.e. is a point
     * contained in any obstacle?
     *
     * A simplified grid search.
     */
    build(model, edge) {
        const options = this.options;
        // source or target node could be excluded from set of obstacles
        const excludedTerminals = options.excludeTerminals.reduce((memo, type) => {
            const terminal = edge[type];
            if (terminal) {
                const cell = model.getCell(terminal.cell);
                if (cell) {
                    memo.push(cell);
                }
            }
            return memo;
        }, []);
        let excludedAncestors = [];
        const source = model.getCell(edge.getSourceCellId());
        if (source) {
            excludedAncestors = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.union(excludedAncestors, source.getAncestors().map((cell) => cell.id));
        }
        const target = model.getCell(edge.getTargetCellId());
        if (target) {
            excludedAncestors = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.union(excludedAncestors, target.getAncestors().map((cell) => cell.id));
        }
        // The graph is divided into smaller cells, where each holds information
        // about which node belong to it. When we query whether a point lies
        // inside an obstacle we don't need to go through all obstacles, we check
        // only those in a particular cell.
        const mapGridSize = this.mapGridSize;
        model.getNodes().reduce((map, node) => {
            const excludedTerminal = excludedTerminals.some((cell) => cell.id === node.id);
            const excludedShape = node.shape
                ? options.excludeShapes.includes(node.shape)
                : false;
            const excludedNode = options.excludeNodes.some((item) => {
                if (typeof item === 'string') {
                    return node.id === item;
                }
                return item === node;
            });
            const excludedAncestor = excludedAncestors.includes(node.id);
            const excluded = excludedShape || excludedTerminal || excludedNode || excludedAncestor;
            if (node.isVisible() && !excluded) {
                const bbox = node.getBBox().moveAndExpand(options.paddingBox);
                const origin = bbox.getOrigin().snapToGrid(mapGridSize);
                const corner = bbox.getCorner().snapToGrid(mapGridSize);
                for (let x = origin.x; x <= corner.x; x += mapGridSize) {
                    for (let y = origin.y; y <= corner.y; y += mapGridSize) {
                        const key = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(x, y).toString();
                        if (map[key] == null) {
                            map[key] = [];
                        }
                        map[key].push(bbox);
                    }
                }
            }
            return map;
        }, this.map);
        return this;
    }
    isAccessible(point) {
        const key = point.clone().snapToGrid(this.mapGridSize).toString();
        const rects = this.map[key];
        return rects ? rects.every((rect) => !rect.containsPoint(point)) : true;
    }
}
//# sourceMappingURL=obstacle-map.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/router/manhattan/options.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/router/manhattan/options.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaults: () => (/* binding */ defaults),
/* harmony export */   resolve: () => (/* binding */ resolve),
/* harmony export */   resolveOptions: () => (/* binding */ resolveOptions)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _orth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../orth */ "./node_modules/@antv/x6/es/registry/router/orth.js");



const defaults = {
    step: 10,
    maxLoopCount: 2000,
    precision: 1,
    maxDirectionChange: 90,
    perpendicular: true,
    excludeTerminals: [],
    excludeNodes: [],
    excludeShapes: [],
    startDirections: ['top', 'right', 'bottom', 'left'],
    endDirections: ['top', 'right', 'bottom', 'left'],
    directionMap: {
        top: { x: 0, y: -1 },
        right: { x: 1, y: 0 },
        bottom: { x: 0, y: 1 },
        left: { x: -1, y: 0 },
    },
    cost() {
        const step = resolve(this.step, this);
        return step;
    },
    directions() {
        const step = resolve(this.step, this);
        const cost = resolve(this.cost, this);
        return [
            { cost, offsetX: step, offsetY: 0 },
            { cost, offsetX: -step, offsetY: 0 },
            { cost, offsetX: 0, offsetY: step },
            { cost, offsetX: 0, offsetY: -step },
        ];
    },
    penalties() {
        const step = resolve(this.step, this);
        return {
            0: 0,
            45: step / 2,
            90: step / 2,
        };
    },
    paddingBox() {
        const step = resolve(this.step, this);
        return {
            x: -step,
            y: -step,
            width: 2 * step,
            height: 2 * step,
        };
    },
    fallbackRouter: _orth__WEBPACK_IMPORTED_MODULE_2__.orth,
    draggingRouter: null,
    snapToGrid: true,
};
function resolve(input, options) {
    if (typeof input === 'function') {
        return input.call(options);
    }
    return input;
}
function resolveOptions(options) {
    const result = Object.keys(options).reduce((memo, key) => {
        const ret = memo;
        if (key === 'fallbackRouter' ||
            key === 'draggingRouter' ||
            key === 'fallbackRoute') {
            ret[key] = options[key];
        }
        else {
            ret[key] = resolve(options[key], options);
        }
        return memo;
    }, {});
    if (result.padding) {
        const sides = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.NumberExt.normalizeSides(result.padding);
        result.paddingBox = {
            x: -sides.left,
            y: -sides.top,
            width: sides.left + sides.right,
            height: sides.top + sides.bottom,
        };
    }
    result.directions.forEach((direction) => {
        const point1 = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(0, 0);
        const point2 = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(direction.offsetX, direction.offsetY);
        direction.angle = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Angle.normalize(point1.theta(point2));
    });
    return result;
}
//# sourceMappingURL=options.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/router/manhattan/router.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/router/manhattan/router.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   router: () => (/* binding */ router)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _sorted_set__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sorted-set */ "./node_modules/@antv/x6/es/registry/router/manhattan/sorted-set.js");
/* harmony import */ var _obstacle_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./obstacle-map */ "./node_modules/@antv/x6/es/registry/router/manhattan/obstacle-map.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/router/manhattan/util.js");
/* harmony import */ var _options__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./options */ "./node_modules/@antv/x6/es/registry/router/manhattan/options.js");






/**
 * Finds the route between two points (`from`, `to`).
 */
function findRoute(edgeView, from, to, map, options) {
    const precision = options.precision;
    let sourceEndpoint;
    let targetEndpoint;
    if (_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.isRectangle(from)) {
        sourceEndpoint = _util__WEBPACK_IMPORTED_MODULE_4__.round(_util__WEBPACK_IMPORTED_MODULE_4__.getSourceEndpoint(edgeView, options).clone(), precision);
    }
    else {
        sourceEndpoint = _util__WEBPACK_IMPORTED_MODULE_4__.round(from.clone(), precision);
    }
    if (_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.isRectangle(to)) {
        targetEndpoint = _util__WEBPACK_IMPORTED_MODULE_4__.round(_util__WEBPACK_IMPORTED_MODULE_4__.getTargetEndpoint(edgeView, options).clone(), precision);
    }
    else {
        targetEndpoint = _util__WEBPACK_IMPORTED_MODULE_4__.round(to.clone(), precision);
    }
    // Get grid for this route.
    const grid = _util__WEBPACK_IMPORTED_MODULE_4__.getGrid(options.step, sourceEndpoint, targetEndpoint);
    // Get pathfinding points.
    // -----------------------
    const startPoint = sourceEndpoint;
    const endPoint = targetEndpoint;
    let startPoints;
    let endPoints;
    if (_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.isRectangle(from)) {
        startPoints = _util__WEBPACK_IMPORTED_MODULE_4__.getRectPoints(startPoint, from, options.startDirections, grid, options);
    }
    else {
        startPoints = [startPoint];
    }
    if (_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.isRectangle(to)) {
        endPoints = _util__WEBPACK_IMPORTED_MODULE_4__.getRectPoints(targetEndpoint, to, options.endDirections, grid, options);
    }
    else {
        endPoints = [endPoint];
    }
    // take into account only accessible rect points (those not under obstacles)
    startPoints = startPoints.filter((p) => map.isAccessible(p));
    endPoints = endPoints.filter((p) => map.isAccessible(p));
    // There is an accessible route point on both sides.
    if (startPoints.length > 0 && endPoints.length > 0) {
        const openSet = new _sorted_set__WEBPACK_IMPORTED_MODULE_2__.SortedSet();
        // Keeps the actual points for given nodes of the open set.
        const points = {};
        // Keeps the point that is immediate predecessor of given element.
        const parents = {};
        // Cost from start to a point along best known path.
        const costs = {};
        for (let i = 0, n = startPoints.length; i < n; i += 1) {
            // startPoint is assumed to be aligned already
            const startPoint = startPoints[i];
            const key = _util__WEBPACK_IMPORTED_MODULE_4__.getKey(startPoint);
            openSet.add(key, _util__WEBPACK_IMPORTED_MODULE_4__.getCost(startPoint, endPoints));
            points[key] = startPoint;
            costs[key] = 0;
        }
        const previousRouteDirectionAngle = options.previousDirectionAngle;
        // undefined for first route
        const isPathBeginning = previousRouteDirectionAngle === undefined;
        // directions
        let direction;
        let directionChange;
        const directions = _util__WEBPACK_IMPORTED_MODULE_4__.getGridOffsets(grid, options);
        const numDirections = directions.length;
        const endPointsKeys = endPoints.reduce((res, endPoint) => {
            const key = _util__WEBPACK_IMPORTED_MODULE_4__.getKey(endPoint);
            res.push(key);
            return res;
        }, []);
        // main route finding loop
        const sameStartEndPoints = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.equalPoints(startPoints, endPoints);
        let loopsRemaining = options.maxLoopCount;
        while (!openSet.isEmpty() && loopsRemaining > 0) {
            // Get the closest item and mark it CLOSED
            const currentKey = openSet.pop();
            const currentPoint = points[currentKey];
            const currentParent = parents[currentKey];
            const currentCost = costs[currentKey];
            const isStartPoint = currentPoint.equals(startPoint);
            const isRouteBeginning = currentParent == null;
            let previousDirectionAngle;
            if (!isRouteBeginning) {
                previousDirectionAngle = _util__WEBPACK_IMPORTED_MODULE_4__.getDirectionAngle(currentParent, currentPoint, numDirections, grid, options);
            }
            else if (!isPathBeginning) {
                // a vertex on the route
                previousDirectionAngle = previousRouteDirectionAngle;
            }
            else if (!isStartPoint) {
                // beginning of route on the path
                previousDirectionAngle = _util__WEBPACK_IMPORTED_MODULE_4__.getDirectionAngle(startPoint, currentPoint, numDirections, grid, options);
            }
            else {
                previousDirectionAngle = null;
            }
            // Check if we reached any endpoint
            const skipEndCheck = isRouteBeginning && sameStartEndPoints;
            if (!skipEndCheck && endPointsKeys.indexOf(currentKey) >= 0) {
                options.previousDirectionAngle = previousDirectionAngle;
                return _util__WEBPACK_IMPORTED_MODULE_4__.reconstructRoute(parents, points, currentPoint, startPoint, endPoint);
            }
            // Go over all possible directions and find neighbors
            for (let i = 0; i < numDirections; i += 1) {
                direction = directions[i];
                const directionAngle = direction.angle;
                directionChange = _util__WEBPACK_IMPORTED_MODULE_4__.getDirectionChange(previousDirectionAngle, directionAngle);
                // Don't use the point changed rapidly.
                if (!(isPathBeginning && isStartPoint) &&
                    directionChange > options.maxDirectionChange) {
                    continue;
                }
                const neighborPoint = _util__WEBPACK_IMPORTED_MODULE_4__.align(currentPoint
                    .clone()
                    .translate(direction.gridOffsetX || 0, direction.gridOffsetY || 0), grid, precision);
                const neighborKey = _util__WEBPACK_IMPORTED_MODULE_4__.getKey(neighborPoint);
                // Closed points were already evaluated.
                if (openSet.isClose(neighborKey) || !map.isAccessible(neighborPoint)) {
                    continue;
                }
                // Neighbor is an end point.
                if (endPointsKeys.indexOf(neighborKey) >= 0) {
                    const isEndPoint = neighborPoint.equals(endPoint);
                    if (!isEndPoint) {
                        const endDirectionAngle = _util__WEBPACK_IMPORTED_MODULE_4__.getDirectionAngle(neighborPoint, endPoint, numDirections, grid, options);
                        const endDirectionChange = _util__WEBPACK_IMPORTED_MODULE_4__.getDirectionChange(directionAngle, endDirectionAngle);
                        if (endDirectionChange > options.maxDirectionChange) {
                            continue;
                        }
                    }
                }
                // The current direction is ok.
                // ----------------------------
                const neighborCost = direction.cost;
                const neighborPenalty = isStartPoint
                    ? 0
                    : options.penalties[directionChange];
                const costFromStart = currentCost + neighborCost + neighborPenalty;
                // Neighbor point has not been processed yet or the cost of
                // the path from start is lower than previously calculated.
                if (!openSet.isOpen(neighborKey) ||
                    costFromStart < costs[neighborKey]) {
                    points[neighborKey] = neighborPoint;
                    parents[neighborKey] = currentPoint;
                    costs[neighborKey] = costFromStart;
                    openSet.add(neighborKey, costFromStart + _util__WEBPACK_IMPORTED_MODULE_4__.getCost(neighborPoint, endPoints));
                }
            }
            loopsRemaining -= 1;
        }
    }
    if (options.fallbackRoute) {
        return _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(options.fallbackRoute, this, startPoint, endPoint, options);
    }
    return null;
}
function snap(vertices, gridSize = 10) {
    if (vertices.length <= 1) {
        return vertices;
    }
    for (let i = 0, len = vertices.length; i < len - 1; i += 1) {
        const first = vertices[i];
        const second = vertices[i + 1];
        if (first.x === second.x) {
            const x = gridSize * Math.round(first.x / gridSize);
            if (first.x !== x) {
                first.x = x;
                second.x = x;
            }
        }
        else if (first.y === second.y) {
            const y = gridSize * Math.round(first.y / gridSize);
            if (first.y !== y) {
                first.y = y;
                second.y = y;
            }
        }
    }
    return vertices;
}
const router = function (vertices, optionsRaw, edgeView) {
    const options = (0,_options__WEBPACK_IMPORTED_MODULE_5__.resolveOptions)(optionsRaw);
    const sourceBBox = _util__WEBPACK_IMPORTED_MODULE_4__.getSourceBBox(edgeView, options);
    const targetBBox = _util__WEBPACK_IMPORTED_MODULE_4__.getTargetBBox(edgeView, options);
    const sourceEndpoint = _util__WEBPACK_IMPORTED_MODULE_4__.getSourceEndpoint(edgeView, options);
    // pathfinding
    const map = new _obstacle_map__WEBPACK_IMPORTED_MODULE_3__.ObstacleMap(options).build(edgeView.graph.model, edgeView.cell);
    const oldVertices = vertices.map((p) => _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(p));
    const newVertices = [];
    // The origin of first route's grid, does not need snapping
    let tailPoint = sourceEndpoint;
    let from;
    let to;
    for (let i = 0, len = oldVertices.length; i <= len; i += 1) {
        let partialRoute = null;
        from = to || sourceBBox;
        to = oldVertices[i];
        // This is the last iteration
        if (to == null) {
            to = targetBBox;
            // If the target is a point, we should use dragging route
            // instead of main routing method if it has been provided.
            const edge = edgeView.cell;
            const isEndingAtPoint = edge.getSourceCellId() == null || edge.getTargetCellId() == null;
            if (isEndingAtPoint && typeof options.draggingRouter === 'function') {
                const dragFrom = from === sourceBBox ? sourceEndpoint : from;
                const dragTo = to.getOrigin();
                partialRoute = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(options.draggingRouter, edgeView, dragFrom, dragTo, options);
            }
        }
        // Find the partial route
        if (partialRoute == null) {
            partialRoute = findRoute(edgeView, from, to, map, options);
        }
        // Cannot found the partial route.
        if (partialRoute === null) {
            // eslint-next-line
            console.warn(`Unable to execute manhattan algorithm, use orth instead`);
            return _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(options.fallbackRouter, this, vertices, options, edgeView);
        }
        // Remove the first point if the previous partial route has
        // the same point as last.
        const leadPoint = partialRoute[0];
        if (leadPoint && leadPoint.equals(tailPoint)) {
            partialRoute.shift();
        }
        // Save tailPoint for next iteration
        tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;
        newVertices.push(...partialRoute);
    }
    if (options.snapToGrid) {
        return snap(newVertices, edgeView.graph.grid.getGridSize());
    }
    return newVertices;
};
//# sourceMappingURL=router.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/router/manhattan/sorted-set.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/router/manhattan/sorted-set.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SortedSet: () => (/* binding */ SortedSet)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");

const OPEN = 1;
const CLOSE = 2;
class SortedSet {
    constructor() {
        this.items = [];
        this.hash = {};
        this.values = {};
    }
    add(item, value) {
        if (this.hash[item]) {
            // item removal
            this.items.splice(this.items.indexOf(item), 1);
        }
        else {
            this.hash[item] = OPEN;
        }
        this.values[item] = value;
        const index = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.sortedIndexBy(this.items, item, (key) => this.values[key]);
        this.items.splice(index, 0, item);
    }
    pop() {
        const item = this.items.shift();
        if (item) {
            this.hash[item] = CLOSE;
        }
        return item;
    }
    isOpen(item) {
        return this.hash[item] === OPEN;
    }
    isClose(item) {
        return this.hash[item] === CLOSE;
    }
    isEmpty() {
        return this.items.length === 0;
    }
}
//# sourceMappingURL=sorted-set.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/router/manhattan/util.js":
/*!********************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/router/manhattan/util.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   align: () => (/* binding */ align),
/* harmony export */   getCost: () => (/* binding */ getCost),
/* harmony export */   getDirectionAngle: () => (/* binding */ getDirectionAngle),
/* harmony export */   getDirectionChange: () => (/* binding */ getDirectionChange),
/* harmony export */   getGrid: () => (/* binding */ getGrid),
/* harmony export */   getGridOffsets: () => (/* binding */ getGridOffsets),
/* harmony export */   getKey: () => (/* binding */ getKey),
/* harmony export */   getRectPoints: () => (/* binding */ getRectPoints),
/* harmony export */   getSourceBBox: () => (/* binding */ getSourceBBox),
/* harmony export */   getSourceEndpoint: () => (/* binding */ getSourceEndpoint),
/* harmony export */   getTargetBBox: () => (/* binding */ getTargetBBox),
/* harmony export */   getTargetEndpoint: () => (/* binding */ getTargetEndpoint),
/* harmony export */   normalizePoint: () => (/* binding */ normalizePoint),
/* harmony export */   reconstructRoute: () => (/* binding */ reconstructRoute),
/* harmony export */   round: () => (/* binding */ round)
/* harmony export */ });
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");

function getSourceBBox(view, options) {
    const bbox = view.sourceBBox.clone();
    if (options && options.paddingBox) {
        return bbox.moveAndExpand(options.paddingBox);
    }
    return bbox;
}
function getTargetBBox(view, options) {
    const bbox = view.targetBBox.clone();
    if (options && options.paddingBox) {
        return bbox.moveAndExpand(options.paddingBox);
    }
    return bbox;
}
function getSourceEndpoint(view, options) {
    if (view.sourceAnchor) {
        return view.sourceAnchor;
    }
    const sourceBBox = getSourceBBox(view, options);
    return sourceBBox.getCenter();
}
function getTargetEndpoint(view, options) {
    if (view.targetAnchor) {
        return view.targetAnchor;
    }
    const targetBBox = getTargetBBox(view, options);
    return targetBBox.getCenter();
}
// returns a direction index from start point to end point
// corrects for grid deformation between start and end
function getDirectionAngle(start, end, directionCount, grid, options) {
    const quadrant = 360 / directionCount;
    const angleTheta = start.theta(fixAngleEnd(start, end, grid, options));
    const normalizedAngle = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Angle.normalize(angleTheta + quadrant / 2);
    return quadrant * Math.floor(normalizedAngle / quadrant);
}
function fixAngleEnd(start, end, grid, options) {
    const step = options.step;
    const diffX = end.x - start.x;
    const diffY = end.y - start.y;
    const gridStepsX = diffX / grid.x;
    const gridStepsY = diffY / grid.y;
    const distanceX = gridStepsX * step;
    const distanceY = gridStepsY * step;
    return new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(start.x + distanceX, start.y + distanceY);
}
/**
 * Returns the change in direction between two direction angles.
 */
function getDirectionChange(angle1, angle2) {
    const change = Math.abs(angle1 - angle2);
    return change > 180 ? 360 - change : change;
}
// fix direction offsets according to current grid
function getGridOffsets(grid, options) {
    const step = options.step;
    options.directions.forEach((direction) => {
        direction.gridOffsetX = (direction.offsetX / step) * grid.x;
        direction.gridOffsetY = (direction.offsetY / step) * grid.y;
    });
    return options.directions;
}
// get grid size in x and y dimensions, adapted to source and target positions
function getGrid(step, source, target) {
    return {
        source: source.clone(),
        x: getGridDimension(target.x - source.x, step),
        y: getGridDimension(target.y - source.y, step),
    };
}
function getGridDimension(diff, step) {
    // return step if diff = 0
    if (!diff) {
        return step;
    }
    const abs = Math.abs(diff);
    const count = Math.round(abs / step);
    // return `abs` if less than one step apart
    if (!count) {
        return abs;
    }
    // otherwise, return corrected step
    const roundedDiff = count * step;
    const remainder = abs - roundedDiff;
    const correction = remainder / count;
    return step + correction;
}
function snapGrid(point, grid) {
    const source = grid.source;
    const x = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.GeometryUtil.snapToGrid(point.x - source.x, grid.x) + source.x;
    const y = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.GeometryUtil.snapToGrid(point.y - source.y, grid.y) + source.y;
    return new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(x, y);
}
function round(point, precision) {
    return point.round(precision);
}
function align(point, grid, precision) {
    return round(snapGrid(point.clone(), grid), precision);
}
function getKey(point) {
    return point.toString();
}
function normalizePoint(point) {
    return new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(point.x === 0 ? 0 : Math.abs(point.x) / point.x, point.y === 0 ? 0 : Math.abs(point.y) / point.y);
}
function getCost(from, anchors) {
    let min = Infinity;
    for (let i = 0, len = anchors.length; i < len; i += 1) {
        const dist = from.manhattanDistance(anchors[i]);
        if (dist < min) {
            min = dist;
        }
    }
    return min;
}
// Find points around the bbox taking given directions into account
// lines are drawn from anchor in given directions, intersections recorded
// if anchor is outside bbox, only those directions that intersect get a rect point
// the anchor itself is returned as rect point (representing some directions)
// (since those directions are unobstructed by the bbox)
function getRectPoints(anchor, bbox, directionList, grid, options) {
    const precision = options.precision;
    const directionMap = options.directionMap;
    const centerVector = anchor.diff(bbox.getCenter());
    const rectPoints = Object.keys(directionMap).reduce((res, key) => {
        if (directionList.includes(key)) {
            const direction = directionMap[key];
            // Create a line that is guaranteed to intersect the bbox if bbox
            // is in the direction even if anchor lies outside of bbox.
            const ending = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(anchor.x + direction.x * (Math.abs(centerVector.x) + bbox.width), anchor.y + direction.y * (Math.abs(centerVector.y) + bbox.height));
            const intersectionLine = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Line(anchor, ending);
            // Get the farther intersection, in case there are two
            // (that happens if anchor lies next to bbox)
            const intersections = intersectionLine.intersect(bbox) || [];
            let farthestIntersectionDistance;
            let farthestIntersection = null;
            for (let i = 0; i < intersections.length; i += 1) {
                const intersection = intersections[i];
                const distance = anchor.squaredDistance(intersection);
                if (farthestIntersectionDistance == null ||
                    distance > farthestIntersectionDistance) {
                    farthestIntersectionDistance = distance;
                    farthestIntersection = intersection;
                }
            }
            // If an intersection was found in this direction, it is our rectPoint
            if (farthestIntersection) {
                let target = align(farthestIntersection, grid, precision);
                // If the rectPoint lies inside the bbox, offset it by one more step
                if (bbox.containsPoint(target)) {
                    target = align(target.translate(direction.x * grid.x, direction.y * grid.y), grid, precision);
                }
                res.push(target);
            }
        }
        return res;
    }, []);
    // if anchor lies outside of bbox, add it to the array of points
    if (!bbox.containsPoint(anchor)) {
        rectPoints.push(align(anchor, grid, precision));
    }
    return rectPoints;
}
// reconstructs a route by concatenating points with their parents
function reconstructRoute(parents, points, tailPoint, from, to) {
    const route = [];
    let prevDiff = normalizePoint(to.diff(tailPoint));
    // tailPoint is assumed to be aligned already
    let currentKey = getKey(tailPoint);
    let parent = parents[currentKey];
    let point;
    while (parent) {
        // point is assumed to be aligned already
        point = points[currentKey];
        const diff = normalizePoint(point.diff(parent));
        if (!diff.equals(prevDiff)) {
            route.unshift(point);
            prevDiff = diff;
        }
        // parent is assumed to be aligned already
        currentKey = getKey(parent);
        parent = parents[currentKey];
    }
    // leadPoint is assumed to be aligned already
    const leadPoint = points[currentKey];
    const fromDiff = normalizePoint(leadPoint.diff(from));
    if (!fromDiff.equals(prevDiff)) {
        route.unshift(leadPoint);
    }
    return route;
}
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/router/metro.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/router/metro.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   metro: () => (/* binding */ metro)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _manhattan_options__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./manhattan/options */ "./node_modules/@antv/x6/es/registry/router/manhattan/options.js");
/* harmony import */ var _manhattan_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./manhattan/index */ "./node_modules/@antv/x6/es/registry/router/manhattan/index.js");




const defaults = {
    maxDirectionChange: 45,
    // an array of directions to find next points on the route
    // different from start/end directions
    directions() {
        const step = (0,_manhattan_options__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.step, this);
        const cost = (0,_manhattan_options__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.cost, this);
        const diagonalCost = Math.ceil(Math.sqrt((step * step) << 1)); // eslint-disable-line no-bitwise
        return [
            { cost, offsetX: step, offsetY: 0 },
            { cost: diagonalCost, offsetX: step, offsetY: step },
            { cost, offsetX: 0, offsetY: step },
            { cost: diagonalCost, offsetX: -step, offsetY: step },
            { cost, offsetX: -step, offsetY: 0 },
            { cost: diagonalCost, offsetX: -step, offsetY: -step },
            { cost, offsetX: 0, offsetY: -step },
            { cost: diagonalCost, offsetX: step, offsetY: -step },
        ];
    },
    // a simple route used in situations when main routing method fails
    // (exceed max number of loop iterations, inaccessible)
    fallbackRoute(from, to, options) {
        // Find a route which breaks by 45 degrees ignoring all obstacles.
        const theta = from.theta(to);
        const route = [];
        let a = { x: to.x, y: from.y };
        let b = { x: from.x, y: to.y };
        if (theta % 180 > 90) {
            const t = a;
            a = b;
            b = t;
        }
        const p1 = theta % 90 < 45 ? a : b;
        const l1 = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Line(from, p1);
        const alpha = 90 * Math.ceil(theta / 90);
        const p2 = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.fromPolar(l1.squaredLength(), _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Angle.toRad(alpha + 135), p1);
        const l2 = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Line(to, p2);
        const intersectionPoint = l1.intersectsWithLine(l2);
        const point = intersectionPoint || to;
        const directionFrom = intersectionPoint ? point : from;
        const quadrant = 360 / options.directions.length;
        const angleTheta = directionFrom.theta(to);
        const normalizedAngle = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Angle.normalize(angleTheta + quadrant / 2);
        const directionAngle = quadrant * Math.floor(normalizedAngle / quadrant);
        options.previousDirectionAngle = directionAngle;
        if (point)
            route.push(point.round());
        route.push(to);
        return route;
    },
};
const metro = function (vertices, options, linkView) {
    return _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(_manhattan_index__WEBPACK_IMPORTED_MODULE_3__.manhattan, this, vertices, Object.assign(Object.assign({}, defaults), options), linkView);
};
//# sourceMappingURL=metro.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/router/normal.js":
/*!************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/router/normal.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   normal: () => (/* binding */ normal)
/* harmony export */ });
const normal = function (vertices) {
    return [...vertices];
};
//# sourceMappingURL=normal.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/router/oneside.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/router/oneside.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   oneSide: () => (/* binding */ oneSide)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");

/**
 * Routes the edge always to/from a certain side
 */
const oneSide = function (vertices, options, edgeView) {
    const side = options.side || 'bottom';
    const padding = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.NumberExt.normalizeSides(options.padding || 40);
    const sourceBBox = edgeView.sourceBBox;
    const targetBBox = edgeView.targetBBox;
    const sourcePoint = sourceBBox.getCenter();
    const targetPoint = targetBBox.getCenter();
    let coord;
    let dim;
    let factor;
    switch (side) {
        case 'top':
            factor = -1;
            coord = 'y';
            dim = 'height';
            break;
        case 'left':
            factor = -1;
            coord = 'x';
            dim = 'width';
            break;
        case 'right':
            factor = 1;
            coord = 'x';
            dim = 'width';
            break;
        case 'bottom':
        default:
            factor = 1;
            coord = 'y';
            dim = 'height';
            break;
    }
    // Move the points from the center of the element to outside of it.
    sourcePoint[coord] += factor * (sourceBBox[dim] / 2 + padding[side]);
    targetPoint[coord] += factor * (targetBBox[dim] / 2 + padding[side]);
    // Make edge orthogonal (at least the first and last vertex).
    if (factor * (sourcePoint[coord] - targetPoint[coord]) > 0) {
        targetPoint[coord] = sourcePoint[coord];
    }
    else {
        sourcePoint[coord] = targetPoint[coord];
    }
    return [sourcePoint.toJSON(), ...vertices, targetPoint.toJSON()];
};
//# sourceMappingURL=oneside.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/router/orth.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/router/orth.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   orth: () => (/* binding */ orth)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/router/util.js");



/**
 * Returns a route with orthogonal line segments.
 */
const orth = function (vertices, options, edgeView) {
    let sourceBBox = _util__WEBPACK_IMPORTED_MODULE_2__.getSourceBBox(edgeView, options);
    let targetBBox = _util__WEBPACK_IMPORTED_MODULE_2__.getTargetBBox(edgeView, options);
    const sourceAnchor = _util__WEBPACK_IMPORTED_MODULE_2__.getSourceAnchor(edgeView, options);
    const targetAnchor = _util__WEBPACK_IMPORTED_MODULE_2__.getTargetAnchor(edgeView, options);
    // If anchor lies outside of bbox, the bbox expands to include it
    sourceBBox = sourceBBox.union(_util__WEBPACK_IMPORTED_MODULE_2__.getPointBBox(sourceAnchor));
    targetBBox = targetBBox.union(_util__WEBPACK_IMPORTED_MODULE_2__.getPointBBox(targetAnchor));
    const points = vertices.map((p) => _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(p));
    points.unshift(sourceAnchor);
    points.push(targetAnchor);
    // bearing of previous route segment
    let bearing = null;
    const result = [];
    for (let i = 0, len = points.length - 1; i < len; i += 1) {
        let route = null;
        const from = points[i];
        const to = points[i + 1];
        const isOrthogonal = Private.getBearing(from, to) != null;
        if (i === 0) {
            // source
            if (i + 1 === len) {
                // source -> target
                // Expand one of the nodes by 1px to detect situations when the two
                // nodes are positioned next to each other with no gap in between.
                if (sourceBBox.intersectsWithRect(targetBBox.clone().inflate(1))) {
                    route = Private.insideNode(from, to, sourceBBox, targetBBox);
                }
                else if (!isOrthogonal) {
                    route = Private.nodeToNode(from, to, sourceBBox, targetBBox);
                }
            }
            else {
                // source -> vertex
                if (sourceBBox.containsPoint(to)) {
                    route = Private.insideNode(from, to, sourceBBox, _util__WEBPACK_IMPORTED_MODULE_2__.getPointBBox(to).moveAndExpand(_util__WEBPACK_IMPORTED_MODULE_2__.getPaddingBox(options)));
                }
                else if (!isOrthogonal) {
                    route = Private.nodeToVertex(from, to, sourceBBox);
                }
            }
        }
        else if (i + 1 === len) {
            // vertex -> target
            // prevent overlaps with previous line segment
            const isOrthogonalLoop = isOrthogonal && Private.getBearing(to, from) === bearing;
            if (targetBBox.containsPoint(from) || isOrthogonalLoop) {
                route = Private.insideNode(from, to, _util__WEBPACK_IMPORTED_MODULE_2__.getPointBBox(from).moveAndExpand(_util__WEBPACK_IMPORTED_MODULE_2__.getPaddingBox(options)), targetBBox, bearing);
            }
            else if (!isOrthogonal) {
                route = Private.vertexToNode(from, to, targetBBox, bearing);
            }
        }
        else if (!isOrthogonal) {
            // vertex -> vertex
            route = Private.vertexToVertex(from, to, bearing);
        }
        // set bearing for next iteration
        if (route) {
            result.push(...route.points);
            bearing = route.direction;
        }
        else {
            // orthogonal route and not looped
            bearing = Private.getBearing(from, to);
        }
        // push `to` point to identified orthogonal vertices array
        if (i + 1 < len) {
            result.push(to);
        }
    }
    return result;
};
var Private;
(function (Private) {
    /**
     * Bearing to opposite bearing map
     */
    const opposites = {
        N: 'S',
        S: 'N',
        E: 'W',
        W: 'E',
    };
    /**
     * Bearing to radians map
     */
    const radians = {
        N: (-Math.PI / 2) * 3,
        S: -Math.PI / 2,
        E: 0,
        W: Math.PI,
    };
    /**
     * Returns a point `p` where lines p,p1 and p,p2 are perpendicular
     * and p is not contained in the given box
     */
    function freeJoin(p1, p2, bbox) {
        let p = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(p1.x, p2.y);
        if (bbox.containsPoint(p)) {
            p = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(p2.x, p1.y);
        }
        // kept for reference
        // if (bbox.containsPoint(p)) {
        //   return null
        // }
        return p;
    }
    /**
     * Returns either width or height of a bbox based on the given bearing.
     */
    function getBBoxSize(bbox, bearing) {
        return bbox[bearing === 'W' || bearing === 'E' ? 'width' : 'height'];
    }
    Private.getBBoxSize = getBBoxSize;
    function getBearing(from, to) {
        if (from.x === to.x) {
            return from.y > to.y ? 'N' : 'S';
        }
        if (from.y === to.y) {
            return from.x > to.x ? 'W' : 'E';
        }
        return null;
    }
    Private.getBearing = getBearing;
    function vertexToVertex(from, to, bearing) {
        const p1 = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(from.x, to.y);
        const p2 = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(to.x, from.y);
        const d1 = getBearing(from, p1);
        const d2 = getBearing(from, p2);
        const opposite = bearing ? opposites[bearing] : null;
        const p = d1 === bearing || (d1 !== opposite && (d2 === opposite || d2 !== bearing))
            ? p1
            : p2;
        return { points: [p], direction: getBearing(p, to) };
    }
    Private.vertexToVertex = vertexToVertex;
    function nodeToVertex(from, to, fromBBox) {
        const p = freeJoin(from, to, fromBBox);
        return { points: [p], direction: getBearing(p, to) };
    }
    Private.nodeToVertex = nodeToVertex;
    function vertexToNode(from, to, toBBox, bearing) {
        const points = [new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(from.x, to.y), new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(to.x, from.y)];
        const freePoints = points.filter((p) => !toBBox.containsPoint(p));
        const freeBearingPoints = freePoints.filter((p) => getBearing(p, from) !== bearing);
        let p;
        if (freeBearingPoints.length > 0) {
            // Try to pick a point which bears the same direction as the previous segment.
            p = freeBearingPoints.filter((p) => getBearing(from, p) === bearing).pop();
            p = p || freeBearingPoints[0];
            return {
                points: [p],
                direction: getBearing(p, to),
            };
        }
        {
            // Here we found only points which are either contained in the element or they would create
            // a link segment going in opposite direction from the previous one.
            // We take the point inside element and move it outside the element in the direction the
            // route is going. Now we can join this point with the current end (using freeJoin).
            p = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.difference(points, freePoints)[0];
            const p2 = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(to).move(p, -getBBoxSize(toBBox, bearing) / 2);
            const p1 = freeJoin(p2, from, toBBox);
            return {
                points: [p1, p2],
                direction: getBearing(p2, to),
            };
        }
    }
    Private.vertexToNode = vertexToNode;
    function nodeToNode(from, to, fromBBox, toBBox) {
        let route = nodeToVertex(to, from, toBBox);
        const p1 = route.points[0];
        if (fromBBox.containsPoint(p1)) {
            route = nodeToVertex(from, to, fromBBox);
            const p2 = route.points[0];
            if (toBBox.containsPoint(p2)) {
                const fromBorder = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(from).move(p2, -getBBoxSize(fromBBox, getBearing(from, p2)) / 2);
                const toBorder = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(to).move(p1, -getBBoxSize(toBBox, getBearing(to, p1)) / 2);
                const mid = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Line(fromBorder, toBorder).getCenter();
                const startRoute = nodeToVertex(from, mid, fromBBox);
                const endRoute = vertexToVertex(mid, to, startRoute.direction);
                route.points = [startRoute.points[0], endRoute.points[0]];
                route.direction = endRoute.direction;
            }
        }
        return route;
    }
    Private.nodeToNode = nodeToNode;
    // Finds route for situations where one node is inside the other.
    // Typically the route is directed outside the outer node first and
    // then back towards the inner node.
    function insideNode(from, to, fromBBox, toBBox, bearing) {
        const boundary = fromBBox.union(toBBox).inflate(1);
        // start from the point which is closer to the boundary
        const center = boundary.getCenter();
        const reversed = center.distance(to) > center.distance(from);
        const start = reversed ? to : from;
        const end = reversed ? from : to;
        let p1;
        let p2;
        let p3;
        if (bearing) {
            // Points on circle with radius equals 'W + H` are always outside the rectangle
            // with width W and height H if the center of that circle is the center of that rectangle.
            p1 = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.fromPolar(boundary.width + boundary.height, radians[bearing], start);
            p1 = boundary.getNearestPointToPoint(p1).move(p1, -1);
        }
        else {
            p1 = boundary.getNearestPointToPoint(start).move(start, 1);
        }
        p2 = freeJoin(p1, end, boundary);
        let points;
        if (p1.round().equals(p2.round())) {
            p2 = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.fromPolar(boundary.width + boundary.height, _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Angle.toRad(p1.theta(start)) + Math.PI / 2, end);
            p2 = boundary.getNearestPointToPoint(p2).move(end, 1).round();
            p3 = freeJoin(p1, p2, boundary);
            points = reversed ? [p2, p3, p1] : [p1, p3, p2];
        }
        else {
            points = reversed ? [p2, p1] : [p1, p2];
        }
        const direction = reversed ? getBearing(p1, to) : getBearing(p2, to);
        return {
            points,
            direction,
        };
    }
    Private.insideNode = insideNode;
})(Private || (Private = {}));
//# sourceMappingURL=orth.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/router/util.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/router/util.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getPaddingBox: () => (/* binding */ getPaddingBox),
/* harmony export */   getPointBBox: () => (/* binding */ getPointBBox),
/* harmony export */   getSourceAnchor: () => (/* binding */ getSourceAnchor),
/* harmony export */   getSourceBBox: () => (/* binding */ getSourceBBox),
/* harmony export */   getTargetAnchor: () => (/* binding */ getTargetAnchor),
/* harmony export */   getTargetBBox: () => (/* binding */ getTargetBBox)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");


function getPointBBox(p) {
    return new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle(p.x, p.y, 0, 0);
}
function getPaddingBox(options = {}) {
    const sides = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.NumberExt.normalizeSides(options.padding || 20);
    return {
        x: -sides.left,
        y: -sides.top,
        width: sides.left + sides.right,
        height: sides.top + sides.bottom,
    };
}
function getSourceBBox(view, options = {}) {
    return view.sourceBBox.clone().moveAndExpand(getPaddingBox(options));
}
function getTargetBBox(view, options = {}) {
    return view.targetBBox.clone().moveAndExpand(getPaddingBox(options));
}
function getSourceAnchor(view, options = {}) {
    if (view.sourceAnchor) {
        return view.sourceAnchor;
    }
    const bbox = getSourceBBox(view, options);
    return bbox.getCenter();
}
function getTargetAnchor(view, options = {}) {
    if (view.targetAnchor) {
        return view.targetAnchor;
    }
    const bbox = getTargetBBox(view, options);
    return bbox.getCenter();
}
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/tool/anchor.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/tool/anchor.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SourceAnchor: () => (/* binding */ SourceAnchor),
/* harmony export */   TargetAnchor: () => (/* binding */ TargetAnchor)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _view_tool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../view/tool */ "./node_modules/@antv/x6/es/view/tool.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/tool/util.js");




class Anchor extends _view_tool__WEBPACK_IMPORTED_MODULE_2__.ToolsView.ToolItem {
    get type() {
        return this.options.type;
    }
    onRender() {
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.container, this.prefixClassName(`edge-tool-${this.type}-anchor`));
        this.toggleArea(false);
        this.update();
    }
    update() {
        const type = this.type;
        const edgeView = this.cellView;
        const terminalView = edgeView.getTerminalView(type);
        if (terminalView) {
            this.updateAnchor();
            this.updateArea();
            this.container.style.display = '';
        }
        else {
            this.container.style.display = 'none';
        }
        return this;
    }
    updateAnchor() {
        const childNodes = this.childNodes;
        if (!childNodes) {
            return;
        }
        const anchorNode = childNodes.anchor;
        if (!anchorNode) {
            return;
        }
        const type = this.type;
        const edgeView = this.cellView;
        const options = this.options;
        const position = edgeView.getTerminalAnchor(type);
        const customAnchor = edgeView.cell.prop([type, 'anchor']);
        anchorNode.setAttribute('transform', `translate(${position.x}, ${position.y})`);
        const anchorAttrs = customAnchor
            ? options.customAnchorAttrs
            : options.defaultAnchorAttrs;
        if (anchorAttrs) {
            Object.keys(anchorAttrs).forEach((attrName) => {
                anchorNode.setAttribute(attrName, anchorAttrs[attrName]);
            });
        }
    }
    updateArea() {
        const childNodes = this.childNodes;
        if (!childNodes) {
            return;
        }
        const areaNode = childNodes.area;
        if (!areaNode) {
            return;
        }
        const type = this.type;
        const edgeView = this.cellView;
        const terminalView = edgeView.getTerminalView(type);
        if (terminalView) {
            const terminalCell = terminalView.cell;
            const magnet = edgeView.getTerminalMagnet(type);
            let padding = this.options.areaPadding || 0;
            if (!Number.isFinite(padding)) {
                padding = 0;
            }
            let bbox;
            let angle;
            let center;
            if (terminalView.isEdgeElement(magnet)) {
                bbox = terminalView.getBBox();
                angle = 0;
                center = bbox.getCenter();
            }
            else {
                bbox = terminalView.getUnrotatedBBoxOfElement(magnet);
                angle = terminalCell.getAngle();
                center = bbox.getCenter();
                if (angle) {
                    center.rotate(-angle, terminalCell.getBBox().getCenter());
                }
            }
            bbox.inflate(padding);
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.attr(areaNode, {
                x: -bbox.width / 2,
                y: -bbox.height / 2,
                width: bbox.width,
                height: bbox.height,
                transform: `translate(${center.x}, ${center.y}) rotate(${angle})`,
            });
        }
    }
    toggleArea(visible) {
        if (this.childNodes) {
            const elem = this.childNodes.area;
            if (elem) {
                elem.style.display = visible ? '' : 'none';
            }
        }
    }
    onMouseDown(evt) {
        if (this.guard(evt)) {
            return;
        }
        evt.stopPropagation();
        evt.preventDefault();
        this.graph.view.undelegateEvents();
        if (this.options.documentEvents) {
            this.delegateDocumentEvents(this.options.documentEvents);
        }
        this.focus();
        this.toggleArea(this.options.restrictArea);
        this.cell.startBatch('move-anchor', {
            ui: true,
            toolId: this.cid,
        });
    }
    resetAnchor(anchor) {
        const type = this.type;
        const cell = this.cell;
        if (anchor) {
            cell.prop([type, 'anchor'], anchor, {
                rewrite: true,
                ui: true,
                toolId: this.cid,
            });
        }
        else {
            cell.removeProp([type, 'anchor'], {
                ui: true,
                toolId: this.cid,
            });
        }
    }
    onMouseMove(evt) {
        const terminalType = this.type;
        const edgeView = this.cellView;
        const terminalView = edgeView.getTerminalView(terminalType);
        if (terminalView == null) {
            return;
        }
        const e = this.normalizeEvent(evt);
        const terminalCell = terminalView.cell;
        const terminalMagnet = edgeView.getTerminalMagnet(terminalType);
        let coords = this.graph.coord.clientToLocalPoint(e.clientX, e.clientY);
        const snapFn = this.options.snap;
        if (typeof snapFn === 'function') {
            const tmp = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(snapFn, edgeView, coords, terminalView, terminalMagnet, terminalType, edgeView, this);
            coords = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(tmp);
        }
        if (this.options.restrictArea) {
            if (terminalView.isEdgeElement(terminalMagnet)) {
                const pointAtConnection = terminalView.getClosestPoint(coords);
                if (pointAtConnection) {
                    coords = pointAtConnection;
                }
            }
            else {
                const bbox = terminalView.getUnrotatedBBoxOfElement(terminalMagnet);
                const angle = terminalCell.getAngle();
                const origin = terminalCell.getBBox().getCenter();
                const rotatedCoords = coords.clone().rotate(angle, origin);
                if (!bbox.containsPoint(rotatedCoords)) {
                    coords = bbox
                        .getNearestPointToPoint(rotatedCoords)
                        .rotate(-angle, origin);
                }
            }
        }
        let anchor;
        const anchorFn = this.options.anchor;
        if (typeof anchorFn === 'function') {
            anchor = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(anchorFn, edgeView, coords, terminalView, terminalMagnet, terminalType, edgeView, this);
        }
        this.resetAnchor(anchor);
        this.update();
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onMouseUp(evt) {
        this.graph.view.delegateEvents();
        this.undelegateDocumentEvents();
        this.blur();
        this.toggleArea(false);
        const edgeView = this.cellView;
        if (this.options.removeRedundancies) {
            edgeView.removeRedundantLinearVertices({ ui: true, toolId: this.cid });
        }
        this.cell.stopBatch('move-anchor', { ui: true, toolId: this.cid });
    }
    onDblClick() {
        const anchor = this.options.resetAnchor;
        if (anchor) {
            this.resetAnchor(anchor === true ? undefined : anchor);
        }
        this.update();
    }
}
(function (Anchor) {
    Anchor.config({
        tagName: 'g',
        markup: [
            {
                tagName: 'circle',
                selector: 'anchor',
                attrs: {
                    cursor: 'pointer',
                },
            },
            {
                tagName: 'rect',
                selector: 'area',
                attrs: {
                    'pointer-events': 'none',
                    fill: 'none',
                    stroke: '#33334F',
                    'stroke-dasharray': '2,4',
                    rx: 5,
                    ry: 5,
                },
            },
        ],
        events: {
            mousedown: 'onMouseDown',
            touchstart: 'onMouseDown',
            dblclick: 'onDblClick',
        },
        documentEvents: {
            mousemove: 'onMouseMove',
            touchmove: 'onMouseMove',
            mouseup: 'onMouseUp',
            touchend: 'onMouseUp',
            touchcancel: 'onMouseUp',
        },
        customAnchorAttrs: {
            'stroke-width': 4,
            stroke: '#33334F',
            fill: '#FFFFFF',
            r: 5,
        },
        defaultAnchorAttrs: {
            'stroke-width': 2,
            stroke: '#FFFFFF',
            fill: '#33334F',
            r: 6,
        },
        areaPadding: 6,
        snapRadius: 10,
        resetAnchor: true,
        restrictArea: true,
        removeRedundancies: true,
        anchor: _util__WEBPACK_IMPORTED_MODULE_3__.getAnchor,
        snap(pos, terminalView, terminalMagnet, terminalType, edgeView, toolView) {
            const snapRadius = toolView.options.snapRadius || 0;
            const isSource = terminalType === 'source';
            const refIndex = isSource ? 0 : -1;
            const ref = this.cell.getVertexAt(refIndex) ||
                this.getTerminalAnchor(isSource ? 'target' : 'source');
            if (ref) {
                if (Math.abs(ref.x - pos.x) < snapRadius)
                    pos.x = ref.x;
                if (Math.abs(ref.y - pos.y) < snapRadius)
                    pos.y = ref.y;
            }
            return pos;
        },
    });
})(Anchor || (Anchor = {}));
const SourceAnchor = Anchor.define({
    name: 'source-anchor',
    type: 'source',
});
const TargetAnchor = Anchor.define({
    name: 'target-anchor',
    type: 'target',
});
//# sourceMappingURL=anchor.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/tool/arrowhead.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/tool/arrowhead.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SourceArrowhead: () => (/* binding */ SourceArrowhead),
/* harmony export */   TargetArrowhead: () => (/* binding */ TargetArrowhead)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _view_tool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../view/tool */ "./node_modules/@antv/x6/es/view/tool.js");
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};



class Arrowhead extends _view_tool__WEBPACK_IMPORTED_MODULE_2__.ToolsView.ToolItem {
    get type() {
        return this.options.type;
    }
    get ratio() {
        return this.options.ratio;
    }
    init() {
        if (this.options.attrs) {
            const _a = this.options.attrs, { class: className } = _a, attrs = __rest(_a, ["class"]);
            this.setAttrs(attrs, this.container);
            if (className) {
                _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.container, className);
            }
        }
    }
    onRender() {
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.container, this.prefixClassName(`edge-tool-${this.type}-arrowhead`));
        this.update();
    }
    update() {
        const ratio = this.ratio;
        const edgeView = this.cellView;
        const tangent = edgeView.getTangentAtRatio(ratio);
        const position = tangent ? tangent.start : edgeView.getPointAtRatio(ratio);
        const angle = (tangent && tangent.vector().vectorAngle(new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(1, 0))) || 0;
        if (!position) {
            return this;
        }
        const matrix = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.createSVGMatrix()
            .translate(position.x, position.y)
            .rotate(angle);
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.transform(this.container, matrix, { absolute: true });
        return this;
    }
    onMouseDown(evt) {
        if (this.guard(evt)) {
            return;
        }
        evt.stopPropagation();
        evt.preventDefault();
        const edgeView = this.cellView;
        if (edgeView.can('arrowheadMovable')) {
            edgeView.cell.startBatch('move-arrowhead', {
                ui: true,
                toolId: this.cid,
            });
            const coords = this.graph.snapToGrid(evt.clientX, evt.clientY);
            const data = edgeView.prepareArrowheadDragging(this.type, {
                x: coords.x,
                y: coords.y,
                options: Object.assign(Object.assign({}, this.options), { toolId: this.cid }),
            });
            this.cellView.setEventData(evt, data);
            this.delegateDocumentEvents(this.options.documentEvents, evt.data);
            edgeView.graph.view.undelegateEvents();
            this.container.style.pointerEvents = 'none';
        }
        this.focus();
    }
    onMouseMove(evt) {
        const e = this.normalizeEvent(evt);
        const coords = this.graph.snapToGrid(e.clientX, e.clientY);
        this.cellView.onMouseMove(e, coords.x, coords.y);
        this.update();
    }
    onMouseUp(evt) {
        this.undelegateDocumentEvents();
        const e = this.normalizeEvent(evt);
        const edgeView = this.cellView;
        const coords = this.graph.snapToGrid(e.clientX, e.clientY);
        edgeView.onMouseUp(e, coords.x, coords.y);
        this.graph.view.delegateEvents();
        this.blur();
        this.container.style.pointerEvents = '';
        edgeView.cell.stopBatch('move-arrowhead', {
            ui: true,
            toolId: this.cid,
        });
    }
}
(function (Arrowhead) {
    Arrowhead.config({
        tagName: 'path',
        isSVGElement: true,
        events: {
            mousedown: 'onMouseDown',
            touchstart: 'onMouseDown',
        },
        documentEvents: {
            mousemove: 'onMouseMove',
            touchmove: 'onMouseMove',
            mouseup: 'onMouseUp',
            touchend: 'onMouseUp',
            touchcancel: 'onMouseUp',
        },
    });
})(Arrowhead || (Arrowhead = {}));
const SourceArrowhead = Arrowhead.define({
    name: 'source-arrowhead',
    type: 'source',
    ratio: 0,
    attrs: {
        d: 'M 10 -8 -10 0 10 8 Z',
        fill: '#333',
        stroke: '#fff',
        'stroke-width': 2,
        cursor: 'move',
    },
});
const TargetArrowhead = Arrowhead.define({
    name: 'target-arrowhead',
    type: 'target',
    ratio: 1,
    attrs: {
        d: 'M -10 -8 10 0 -10 8 Z',
        fill: '#333',
        stroke: '#fff',
        'stroke-width': 2,
        cursor: 'move',
    },
});
//# sourceMappingURL=arrowhead.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/tool/boundary.js":
/*!************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/tool/boundary.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Boundary: () => (/* binding */ Boundary)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _view_tool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../view/tool */ "./node_modules/@antv/x6/es/view/tool.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/tool/util.js");
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};



class Boundary extends _view_tool__WEBPACK_IMPORTED_MODULE_1__.ToolsView.ToolItem {
    onRender() {
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.container, this.prefixClassName('cell-tool-boundary'));
        if (this.options.attrs) {
            const _a = this.options.attrs, { class: className } = _a, attrs = __rest(_a, ["class"]);
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.attr(this.container, _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.kebablizeAttrs(attrs));
            if (className) {
                _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.container, className);
            }
        }
        this.update();
    }
    update() {
        const view = this.cellView;
        const options = this.options;
        const { useCellGeometry, rotate } = options;
        const padding = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.NumberExt.normalizeSides(options.padding);
        let bbox = _util__WEBPACK_IMPORTED_MODULE_2__.getViewBBox(view, useCellGeometry).moveAndExpand({
            x: -padding.left,
            y: -padding.top,
            width: padding.left + padding.right,
            height: padding.top + padding.bottom,
        });
        const cell = view.cell;
        if (cell.isNode()) {
            const angle = cell.getAngle();
            if (angle) {
                if (rotate) {
                    const origin = cell.getBBox().getCenter();
                    _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.rotate(this.container, angle, origin.x, origin.y, {
                        absolute: true,
                    });
                }
                else {
                    bbox = bbox.bbox(angle);
                }
            }
        }
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.attr(this.container, bbox.toJSON());
        return this;
    }
}
(function (Boundary) {
    Boundary.config({
        name: 'boundary',
        tagName: 'rect',
        padding: 10,
        useCellGeometry: true,
        attrs: {
            fill: 'none',
            stroke: '#333',
            'stroke-width': 0.5,
            'stroke-dasharray': '5, 5',
            'pointer-events': 'none',
        },
    });
})(Boundary || (Boundary = {}));
//# sourceMappingURL=boundary.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/tool/button.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/tool/button.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Button: () => (/* binding */ Button)
/* harmony export */ });
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _view_tool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../view/tool */ "./node_modules/@antv/x6/es/view/tool.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/tool/util.js");




class Button extends _view_tool__WEBPACK_IMPORTED_MODULE_2__.ToolsView.ToolItem {
    onRender() {
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.addClass(this.container, this.prefixClassName('cell-tool-button'));
        this.update();
    }
    update() {
        this.updatePosition();
        return this;
    }
    updatePosition() {
        const view = this.cellView;
        const matrix = view.cell.isEdge()
            ? this.getEdgeMatrix()
            : this.getNodeMatrix();
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.transform(this.container, matrix, { absolute: true });
    }
    getNodeMatrix() {
        const view = this.cellView;
        const options = this.options;
        let { x = 0, y = 0 } = options;
        const { offset, useCellGeometry, rotate } = options;
        let bbox = _util__WEBPACK_IMPORTED_MODULE_3__.getViewBBox(view, useCellGeometry);
        const angle = view.cell.getAngle();
        if (!rotate) {
            bbox = bbox.bbox(angle);
        }
        let offsetX = 0;
        let offsetY = 0;
        if (typeof offset === 'number') {
            offsetX = offset;
            offsetY = offset;
        }
        else if (typeof offset === 'object') {
            offsetX = offset.x;
            offsetY = offset.y;
        }
        x = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.NumberExt.normalizePercentage(x, bbox.width);
        y = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.NumberExt.normalizePercentage(y, bbox.height);
        let matrix = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.createSVGMatrix().translate(bbox.x + bbox.width / 2, bbox.y + bbox.height / 2);
        if (rotate) {
            matrix = matrix.rotate(angle);
        }
        matrix = matrix.translate(x + offsetX - bbox.width / 2, y + offsetY - bbox.height / 2);
        return matrix;
    }
    getEdgeMatrix() {
        const view = this.cellView;
        const options = this.options;
        const { offset = 0, distance = 0, rotate } = options;
        let tangent;
        let position;
        let angle;
        const d = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.NumberExt.normalizePercentage(distance, 1);
        if (d >= 0 && d <= 1) {
            tangent = view.getTangentAtRatio(d);
        }
        else {
            tangent = view.getTangentAtLength(d);
        }
        if (tangent) {
            position = tangent.start;
            angle = tangent.vector().vectorAngle(new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(1, 0)) || 0;
        }
        else {
            position = view.getConnection().start;
            angle = 0;
        }
        let matrix = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.createSVGMatrix()
            .translate(position.x, position.y)
            .rotate(angle);
        if (typeof offset === 'object') {
            matrix = matrix.translate(offset.x || 0, offset.y || 0);
        }
        else {
            matrix = matrix.translate(0, offset);
        }
        if (!rotate) {
            matrix = matrix.rotate(-angle);
        }
        return matrix;
    }
    onMouseDown(e) {
        if (this.guard(e)) {
            return;
        }
        e.stopPropagation();
        e.preventDefault();
        const onClick = this.options.onClick;
        if (typeof onClick === 'function') {
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(onClick, this.cellView, {
                e,
                view: this.cellView,
                cell: this.cellView.cell,
                btn: this,
            });
        }
    }
}
(function (Button) {
    Button.config({
        name: 'button',
        useCellGeometry: true,
        events: {
            mousedown: 'onMouseDown',
            touchstart: 'onMouseDown',
        },
    });
})(Button || (Button = {}));
(function (Button) {
    Button.Remove = Button.define({
        name: 'button-remove',
        markup: [
            {
                tagName: 'circle',
                selector: 'button',
                attrs: {
                    r: 7,
                    fill: '#FF1D00',
                    cursor: 'pointer',
                },
            },
            {
                tagName: 'path',
                selector: 'icon',
                attrs: {
                    d: 'M -3 -3 3 3 M -3 3 3 -3',
                    fill: 'none',
                    stroke: '#FFFFFF',
                    'stroke-width': 2,
                    'pointer-events': 'none',
                },
            },
        ],
        distance: 60,
        offset: 0,
        useCellGeometry: true,
        onClick({ view, btn }) {
            btn.parent.remove();
            view.cell.remove({ ui: true, toolId: btn.cid });
        },
    });
})(Button || (Button = {}));
//# sourceMappingURL=button.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/tool/editor.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/tool/editor.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CellEditor: () => (/* binding */ CellEditor)
/* harmony export */ });
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _view_tool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../view/tool */ "./node_modules/@antv/x6/es/view/tool.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util */ "./node_modules/@antv/x6/es/util/index.js");




class CellEditor extends _view_tool__WEBPACK_IMPORTED_MODULE_2__.ToolsView.ToolItem {
    constructor() {
        super(...arguments);
        this.labelIndex = -1;
        this.distance = 0.5;
        this.dblClick = this.onCellDblClick.bind(this);
    }
    onRender() {
        const cellView = this.cellView;
        if (cellView) {
            cellView.on('cell:dblclick', this.dblClick);
        }
    }
    createElement() {
        const classNames = [
            this.prefixClassName(`${this.cell.isEdge() ? 'edge' : 'node'}-tool-editor`),
            this.prefixClassName('cell-tool-editor'),
        ];
        this.editor = _view_tool__WEBPACK_IMPORTED_MODULE_2__.ToolsView.createElement('div', false);
        this.addClass(classNames, this.editor);
        this.editor.contentEditable = 'true';
        this.container.appendChild(this.editor);
    }
    removeElement() {
        this.undelegateDocumentEvents();
        if (this.editor) {
            this.container.removeChild(this.editor);
            this.editor = null;
        }
    }
    updateEditor() {
        const { cell, editor } = this;
        if (!editor) {
            return;
        }
        const { style } = editor;
        if (cell.isNode()) {
            this.updateNodeEditorTransform();
        }
        else if (cell.isEdge()) {
            this.updateEdgeEditorTransform();
        }
        // set font style
        const { attrs } = this.options;
        style.fontSize = `${attrs.fontSize}px`;
        style.fontFamily = attrs.fontFamily;
        style.color = attrs.color;
        style.backgroundColor = attrs.backgroundColor;
        // set init value
        const text = this.getCellText() || '';
        editor.innerText = text;
        this.setCellText(''); // clear display value when edit status because char ghosting.
        return this;
    }
    updateNodeEditorTransform() {
        const { graph, cell, editor } = this;
        if (!editor) {
            return;
        }
        let pos = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create();
        let minWidth = 20;
        let translate = '';
        let { x, y } = this.options;
        const { width, height } = this.options;
        if (typeof x !== 'undefined' && typeof y !== 'undefined') {
            const bbox = cell.getBBox();
            x = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.NumberExt.normalizePercentage(x, bbox.width);
            y = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.NumberExt.normalizePercentage(y, bbox.height);
            pos = bbox.topLeft.translate(x, y);
            minWidth = bbox.width - x * 2;
        }
        else {
            const bbox = cell.getBBox();
            pos = bbox.center;
            minWidth = bbox.width - 4;
            translate = 'translate(-50%, -50%)';
        }
        const scale = graph.scale();
        const { style } = editor;
        pos = graph.localToGraph(pos);
        style.left = `${pos.x}px`;
        style.top = `${pos.y}px`;
        style.transform = `scale(${scale.sx}, ${scale.sy}) ${translate}`;
        style.minWidth = `${minWidth}px`;
        if (typeof width === 'number') {
            style.width = `${width}px`;
        }
        if (typeof height === 'number') {
            style.height = `${height}px`;
        }
    }
    updateEdgeEditorTransform() {
        if (!this.event) {
            return;
        }
        const { graph, editor } = this;
        if (!editor) {
            return;
        }
        let pos = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create();
        let minWidth = 20;
        const { style } = editor;
        const target = this.event.target;
        const parent = target.parentElement;
        const isEdgeLabel = parent && _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.hasClass(parent, this.prefixClassName('edge-label'));
        if (isEdgeLabel) {
            const index = parent.getAttribute('data-index') || '0';
            this.labelIndex = parseInt(index, 10);
            const matrix = parent.getAttribute('transform');
            const { translation } = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.parseTransformString(matrix);
            pos = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(translation.tx, translation.ty);
            minWidth = _util__WEBPACK_IMPORTED_MODULE_3__.Util.getBBox(target).width;
        }
        else {
            if (!this.options.labelAddable) {
                return this;
            }
            pos = graph.clientToLocal(_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(this.event.clientX, this.event.clientY));
            const view = this.cellView;
            const d = view.path.closestPointLength(pos);
            this.distance = d;
            this.labelIndex = -1;
        }
        pos = graph.localToGraph(pos);
        const scale = graph.scale();
        style.left = `${pos.x}px`;
        style.top = `${pos.y}px`;
        style.minWidth = `${minWidth}px`;
        style.transform = `scale(${scale.sx}, ${scale.sy}) translate(-50%, -50%)`;
    }
    onDocumentMouseUp(e) {
        if (this.editor && e.target !== this.editor) {
            const value = this.editor.innerText.replace(/\n$/, '') || '';
            // set value, when value is null, we will remove label in edge
            this.setCellText(value !== '' ? value : null);
            // remove tool
            this.removeElement();
        }
    }
    onCellDblClick({ e }) {
        if (!this.editor) {
            e.stopPropagation();
            this.removeElement();
            this.event = e;
            this.createElement();
            this.updateEditor();
            this.autoFocus();
            this.delegateDocumentEvents(this.options.documentEvents);
        }
    }
    onMouseDown(e) {
        e.stopPropagation();
    }
    autoFocus() {
        setTimeout(() => {
            if (this.editor) {
                this.editor.focus();
                this.selectText();
            }
        });
    }
    selectText() {
        if (window.getSelection && this.editor) {
            const range = document.createRange();
            const selection = window.getSelection();
            range.selectNodeContents(this.editor);
            selection.removeAllRanges();
            selection.addRange(range);
        }
    }
    getCellText() {
        const { getText } = this.options;
        if (typeof getText === 'function') {
            return _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(getText, this.cellView, {
                cell: this.cell,
                index: this.labelIndex,
            });
        }
        if (typeof getText === 'string') {
            if (this.cell.isNode()) {
                return this.cell.attr(getText);
            }
            if (this.cell.isEdge()) {
                if (this.labelIndex !== -1) {
                    return this.cell.prop(`labels/${this.labelIndex}/attrs/${getText}`);
                }
            }
        }
    }
    setCellText(value) {
        const setText = this.options.setText;
        if (typeof setText === 'function') {
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(setText, this.cellView, {
                cell: this.cell,
                value,
                index: this.labelIndex,
                distance: this.distance,
            });
            return;
        }
        if (typeof setText === 'string') {
            if (this.cell.isNode()) {
                if (value !== null) {
                    this.cell.attr(setText, value);
                }
                return;
            }
            if (this.cell.isEdge()) {
                const edge = this.cell;
                if (this.labelIndex === -1) {
                    if (value) {
                        const newLabel = {
                            position: {
                                distance: this.distance,
                            },
                            attrs: {},
                        };
                        _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.setByPath(newLabel, `attrs/${setText}`, value);
                        edge.appendLabel(newLabel);
                    }
                }
                else {
                    if (value !== null) {
                        edge.prop(`labels/${this.labelIndex}/attrs/${setText}`, value);
                    }
                    else if (typeof this.labelIndex === 'number') {
                        edge.removeLabelAt(this.labelIndex);
                    }
                }
            }
        }
    }
    onRemove() {
        const cellView = this.cellView;
        if (cellView) {
            cellView.off('cell:dblclick', this.dblClick);
        }
        this.removeElement();
    }
}
(function (CellEditor) {
    CellEditor.config({
        tagName: 'div',
        isSVGElement: false,
        events: {
            mousedown: 'onMouseDown',
            touchstart: 'onMouseDown',
        },
        documentEvents: {
            mouseup: 'onDocumentMouseUp',
            touchend: 'onDocumentMouseUp',
            touchcancel: 'onDocumentMouseUp',
        },
    });
})(CellEditor || (CellEditor = {}));
(function (CellEditor) {
    CellEditor.NodeEditor = CellEditor.define({
        attrs: {
            fontSize: 14,
            fontFamily: 'Arial, helvetica, sans-serif',
            color: '#000',
            backgroundColor: '#fff',
        },
        getText: 'text/text',
        setText: 'text/text',
    });
    CellEditor.EdgeEditor = CellEditor.define({
        attrs: {
            fontSize: 14,
            fontFamily: 'Arial, helvetica, sans-serif',
            color: '#000',
            backgroundColor: '#fff',
        },
        labelAddable: true,
        getText: 'label/text',
        setText: 'label/text',
    });
})(CellEditor || (CellEditor = {}));
//# sourceMappingURL=editor.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/tool/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/tool/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EdgeTool: () => (/* binding */ EdgeTool),
/* harmony export */   NodeTool: () => (/* binding */ NodeTool)
/* harmony export */ });
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../registry */ "./node_modules/@antv/x6/es/registry/registry.js");
/* harmony import */ var _view_tool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../view/tool */ "./node_modules/@antv/x6/es/view/tool.js");
/* harmony import */ var _button__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./button */ "./node_modules/@antv/x6/es/registry/tool/button.js");
/* harmony import */ var _boundary__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./boundary */ "./node_modules/@antv/x6/es/registry/tool/boundary.js");
/* harmony import */ var _vertices__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./vertices */ "./node_modules/@antv/x6/es/registry/tool/vertices.js");
/* harmony import */ var _segments__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./segments */ "./node_modules/@antv/x6/es/registry/tool/segments.js");
/* harmony import */ var _anchor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./anchor */ "./node_modules/@antv/x6/es/registry/tool/anchor.js");
/* harmony import */ var _arrowhead__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./arrowhead */ "./node_modules/@antv/x6/es/registry/tool/arrowhead.js");
/* harmony import */ var _editor__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./editor */ "./node_modules/@antv/x6/es/registry/tool/editor.js");
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};









var NodeTool;
(function (NodeTool) {
    NodeTool.presets = {
        boundary: _boundary__WEBPACK_IMPORTED_MODULE_3__.Boundary,
        button: _button__WEBPACK_IMPORTED_MODULE_2__.Button,
        'button-remove': _button__WEBPACK_IMPORTED_MODULE_2__.Button.Remove,
        'node-editor': _editor__WEBPACK_IMPORTED_MODULE_8__.CellEditor.NodeEditor,
    };
    NodeTool.registry = _registry__WEBPACK_IMPORTED_MODULE_0__.Registry.create({
        type: 'node tool',
        process(name, options) {
            if (typeof options === 'function') {
                return options;
            }
            let parent = _view_tool__WEBPACK_IMPORTED_MODULE_1__.ToolsView.ToolItem;
            const { inherit } = options, others = __rest(options, ["inherit"]);
            if (inherit) {
                const base = this.get(inherit);
                if (base == null) {
                    this.onNotFound(inherit, 'inherited');
                }
                else {
                    parent = base;
                }
            }
            if (others.name == null) {
                others.name = name;
            }
            return parent.define.call(parent, others);
        },
    });
    NodeTool.registry.register(NodeTool.presets, true);
})(NodeTool || (NodeTool = {}));
var EdgeTool;
(function (EdgeTool) {
    EdgeTool.presets = {
        boundary: _boundary__WEBPACK_IMPORTED_MODULE_3__.Boundary,
        vertices: _vertices__WEBPACK_IMPORTED_MODULE_4__.Vertices,
        segments: _segments__WEBPACK_IMPORTED_MODULE_5__.Segments,
        button: _button__WEBPACK_IMPORTED_MODULE_2__.Button,
        'button-remove': _button__WEBPACK_IMPORTED_MODULE_2__.Button.Remove,
        'source-anchor': _anchor__WEBPACK_IMPORTED_MODULE_6__.SourceAnchor,
        'target-anchor': _anchor__WEBPACK_IMPORTED_MODULE_6__.TargetAnchor,
        'source-arrowhead': _arrowhead__WEBPACK_IMPORTED_MODULE_7__.SourceArrowhead,
        'target-arrowhead': _arrowhead__WEBPACK_IMPORTED_MODULE_7__.TargetArrowhead,
        'edge-editor': _editor__WEBPACK_IMPORTED_MODULE_8__.CellEditor.EdgeEditor,
    };
    EdgeTool.registry = _registry__WEBPACK_IMPORTED_MODULE_0__.Registry.create({
        type: 'edge tool',
        process(name, options) {
            if (typeof options === 'function') {
                return options;
            }
            let parent = _view_tool__WEBPACK_IMPORTED_MODULE_1__.ToolsView.ToolItem;
            const { inherit } = options, others = __rest(options, ["inherit"]);
            if (inherit) {
                const base = this.get(inherit);
                if (base == null) {
                    this.onNotFound(inherit, 'inherited');
                }
                else {
                    parent = base;
                }
            }
            if (others.name == null) {
                others.name = name;
            }
            return parent.define.call(parent, others);
        },
    });
    EdgeTool.registry.register(EdgeTool.presets, true);
})(EdgeTool || (EdgeTool = {}));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/tool/segments.js":
/*!************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/tool/segments.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Segments: () => (/* binding */ Segments)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _view_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../view/view */ "./node_modules/@antv/x6/es/view/view.js");
/* harmony import */ var _view_tool__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../view/tool */ "./node_modules/@antv/x6/es/view/tool.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/registry/tool/util.js");





class Segments extends _view_tool__WEBPACK_IMPORTED_MODULE_3__.ToolsView.ToolItem {
    constructor() {
        super(...arguments);
        this.handles = [];
    }
    get vertices() {
        return this.cellView.cell.getVertices();
    }
    update() {
        this.render();
        return this;
    }
    onRender() {
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.container, this.prefixClassName('edge-tool-segments'));
        this.resetHandles();
        const edgeView = this.cellView;
        const vertices = [...this.vertices];
        vertices.unshift(edgeView.sourcePoint);
        vertices.push(edgeView.targetPoint);
        for (let i = 0, l = vertices.length; i < l - 1; i += 1) {
            const vertex = vertices[i];
            const nextVertex = vertices[i + 1];
            const handle = this.renderHandle(vertex, nextVertex, i);
            this.stamp(handle.container);
            this.handles.push(handle);
        }
        return this;
    }
    renderHandle(vertex, nextVertex, index) {
        const handle = this.options.createHandle({
            index,
            graph: this.graph,
            guard: (evt) => this.guard(evt),
            attrs: this.options.attrs || {},
        });
        if (this.options.processHandle) {
            this.options.processHandle(handle);
        }
        this.updateHandle(handle, vertex, nextVertex);
        this.container.appendChild(handle.container);
        this.startHandleListening(handle);
        return handle;
    }
    startHandleListening(handle) {
        handle.on('change', this.onHandleChange, this);
        handle.on('changing', this.onHandleChanging, this);
        handle.on('changed', this.onHandleChanged, this);
    }
    stopHandleListening(handle) {
        handle.off('change', this.onHandleChange, this);
        handle.off('changing', this.onHandleChanging, this);
        handle.off('changed', this.onHandleChanged, this);
    }
    resetHandles() {
        const handles = this.handles;
        this.handles = [];
        if (handles) {
            handles.forEach((handle) => {
                this.stopHandleListening(handle);
                handle.remove();
            });
        }
    }
    shiftHandleIndexes(delta) {
        const handles = this.handles;
        for (let i = 0, n = handles.length; i < n; i += 1) {
            handles[i].options.index += delta;
        }
    }
    resetAnchor(type, anchor) {
        const edge = this.cellView.cell;
        const options = {
            ui: true,
            toolId: this.cid,
        };
        if (anchor) {
            edge.prop([type, 'anchor'], anchor, options);
        }
        else {
            edge.removeProp([type, 'anchor'], options);
        }
    }
    snapHandle(handle, position, data) {
        const axis = handle.options.axis;
        const index = handle.options.index;
        const edgeView = this.cellView;
        const edge = edgeView.cell;
        const vertices = edge.getVertices();
        const prev = vertices[index - 2] || data.sourceAnchor;
        const next = vertices[index + 1] || data.targetAnchor;
        const snapRadius = this.options.snapRadius;
        if (Math.abs(position[axis] - prev[axis]) < snapRadius) {
            position[axis] = prev[axis];
        }
        else if (Math.abs(position[axis] - next[axis]) < snapRadius) {
            position[axis] = next[axis];
        }
        return position;
    }
    onHandleChanging({ handle, e, }) {
        const graph = this.graph;
        const options = this.options;
        const edgeView = this.cellView;
        const anchorFn = options.anchor;
        const axis = handle.options.axis;
        const index = handle.options.index - 1;
        const data = this.getEventData(e);
        const evt = this.normalizeEvent(e);
        const coords = graph.snapToGrid(evt.clientX, evt.clientY);
        const position = this.snapHandle(handle, coords.clone(), data);
        const vertices = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(this.vertices);
        let vertex = vertices[index];
        let nextVertex = vertices[index + 1];
        // First Segment
        const sourceView = edgeView.sourceView;
        const sourceBBox = edgeView.sourceBBox;
        let changeSourceAnchor = false;
        let deleteSourceAnchor = false;
        if (!vertex) {
            vertex = edgeView.sourceAnchor.toJSON();
            vertex[axis] = position[axis];
            if (sourceBBox.containsPoint(vertex)) {
                changeSourceAnchor = true;
            }
            else {
                vertices.unshift(vertex);
                this.shiftHandleIndexes(1);
                deleteSourceAnchor = true;
            }
        }
        else if (index === 0) {
            if (sourceBBox.containsPoint(vertex)) {
                vertices.shift();
                this.shiftHandleIndexes(-1);
                changeSourceAnchor = true;
            }
            else {
                vertex[axis] = position[axis];
                deleteSourceAnchor = true;
            }
        }
        else {
            vertex[axis] = position[axis];
        }
        if (typeof anchorFn === 'function' && sourceView) {
            if (changeSourceAnchor) {
                const sourceAnchorPosition = data.sourceAnchor.clone();
                sourceAnchorPosition[axis] = position[axis];
                const sourceAnchor = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(anchorFn, edgeView, sourceAnchorPosition, sourceView, edgeView.sourceMagnet || sourceView.container, 'source', edgeView, this);
                this.resetAnchor('source', sourceAnchor);
            }
            if (deleteSourceAnchor) {
                this.resetAnchor('source', data.sourceAnchorDef);
            }
        }
        // Last segment
        const targetView = edgeView.targetView;
        const targetBBox = edgeView.targetBBox;
        let changeTargetAnchor = false;
        let deleteTargetAnchor = false;
        if (!nextVertex) {
            nextVertex = edgeView.targetAnchor.toJSON();
            nextVertex[axis] = position[axis];
            if (targetBBox.containsPoint(nextVertex)) {
                changeTargetAnchor = true;
            }
            else {
                vertices.push(nextVertex);
                deleteTargetAnchor = true;
            }
        }
        else if (index === vertices.length - 2) {
            if (targetBBox.containsPoint(nextVertex)) {
                vertices.pop();
                changeTargetAnchor = true;
            }
            else {
                nextVertex[axis] = position[axis];
                deleteTargetAnchor = true;
            }
        }
        else {
            nextVertex[axis] = position[axis];
        }
        if (typeof anchorFn === 'function' && targetView) {
            if (changeTargetAnchor) {
                const targetAnchorPosition = data.targetAnchor.clone();
                targetAnchorPosition[axis] = position[axis];
                const targetAnchor = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(anchorFn, edgeView, targetAnchorPosition, targetView, edgeView.targetMagnet || targetView.container, 'target', edgeView, this);
                this.resetAnchor('target', targetAnchor);
            }
            if (deleteTargetAnchor) {
                this.resetAnchor('target', data.targetAnchorDef);
            }
        }
        if (!_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.equalPoints(vertices, this.vertices)) {
            this.cellView.cell.setVertices(vertices, { ui: true, toolId: this.cid });
        }
        this.updateHandle(handle, vertex, nextVertex, 0);
        if (!options.stopPropagation) {
            edgeView.notifyMouseMove(evt, coords.x, coords.y);
        }
    }
    onHandleChange({ handle, e }) {
        const options = this.options;
        const handles = this.handles;
        const edgeView = this.cellView;
        const index = handle.options.index;
        if (!Array.isArray(handles)) {
            return;
        }
        for (let i = 0, n = handles.length; i < n; i += 1) {
            if (i !== index) {
                handles[i].hide();
            }
        }
        this.focus();
        this.setEventData(e, {
            sourceAnchor: edgeView.sourceAnchor.clone(),
            targetAnchor: edgeView.targetAnchor.clone(),
            sourceAnchorDef: _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(this.cell.prop(['source', 'anchor'])),
            targetAnchorDef: _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(this.cell.prop(['target', 'anchor'])),
        });
        this.cell.startBatch('move-segment', { ui: true, toolId: this.cid });
        if (!options.stopPropagation) {
            const normalizedEvent = this.normalizeEvent(e);
            const coords = this.graph.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);
            edgeView.notifyMouseDown(normalizedEvent, coords.x, coords.y);
        }
    }
    onHandleChanged({ e }) {
        const options = this.options;
        const edgeView = this.cellView;
        if (options.removeRedundancies) {
            edgeView.removeRedundantLinearVertices({ ui: true, toolId: this.cid });
        }
        const normalizedEvent = this.normalizeEvent(e);
        const coords = this.graph.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);
        this.render();
        this.blur();
        this.cell.stopBatch('move-segment', { ui: true, toolId: this.cid });
        if (!options.stopPropagation) {
            edgeView.notifyMouseUp(normalizedEvent, coords.x, coords.y);
        }
        edgeView.checkMouseleave(normalizedEvent);
        options.onChanged && options.onChanged({ edge: edgeView.cell, edgeView });
    }
    updateHandle(handle, vertex, nextVertex, offset = 0) {
        const precision = this.options.precision || 0;
        const vertical = Math.abs(vertex.x - nextVertex.x) < precision;
        const horizontal = Math.abs(vertex.y - nextVertex.y) < precision;
        if (vertical || horizontal) {
            const segmentLine = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Line(vertex, nextVertex);
            const length = segmentLine.length();
            if (length < this.options.threshold) {
                handle.hide();
            }
            else {
                const position = segmentLine.getCenter();
                const axis = vertical ? 'x' : 'y';
                position[axis] += offset || 0;
                const angle = segmentLine.vector().vectorAngle(new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(1, 0));
                handle.updatePosition(position.x, position.y, angle, this.cellView);
                handle.show();
                handle.options.axis = axis;
            }
        }
        else {
            handle.hide();
        }
    }
    onRemove() {
        this.resetHandles();
    }
}
(function (Segments) {
    class Handle extends _view_view__WEBPACK_IMPORTED_MODULE_2__.View {
        constructor(options) {
            super();
            this.options = options;
            this.render();
            this.delegateEvents({
                mousedown: 'onMouseDown',
                touchstart: 'onMouseDown',
            });
        }
        render() {
            this.container = _view_view__WEBPACK_IMPORTED_MODULE_2__.View.createElement('rect', true);
            const attrs = this.options.attrs;
            if (typeof attrs === 'function') {
                const defaults = Segments.getDefaults();
                this.setAttrs(Object.assign(Object.assign({}, defaults.attrs), attrs(this)));
            }
            else {
                this.setAttrs(attrs);
            }
            this.addClass(this.prefixClassName('edge-tool-segment'));
        }
        updatePosition(x, y, angle, view) {
            const p = view.getClosestPoint(new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(x, y)) || new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(x, y);
            let matrix = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.createSVGMatrix().translate(p.x, p.y);
            if (!p.equals({ x, y })) {
                const line = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Line(x, y, p.x, p.y);
                let deg = line.vector().vectorAngle(new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(1, 0));
                if (deg !== 0) {
                    deg += 90;
                }
                matrix = matrix.rotate(deg);
            }
            else {
                matrix = matrix.rotate(angle);
            }
            this.setAttrs({
                transform: _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.matrixToTransformString(matrix),
                cursor: angle % 180 === 0 ? 'row-resize' : 'col-resize',
            });
        }
        onMouseDown(evt) {
            if (this.options.guard(evt)) {
                return;
            }
            this.trigger('change', { e: evt, handle: this });
            evt.stopPropagation();
            evt.preventDefault();
            this.options.graph.view.undelegateEvents();
            this.delegateDocumentEvents({
                mousemove: 'onMouseMove',
                touchmove: 'onMouseMove',
                mouseup: 'onMouseUp',
                touchend: 'onMouseUp',
                touchcancel: 'onMouseUp',
            }, evt.data);
        }
        onMouseMove(evt) {
            this.emit('changing', { e: evt, handle: this });
        }
        onMouseUp(evt) {
            this.emit('changed', { e: evt, handle: this });
            this.undelegateDocumentEvents();
            this.options.graph.view.delegateEvents();
        }
        show() {
            this.container.style.display = '';
        }
        hide() {
            this.container.style.display = 'none';
        }
    }
    Segments.Handle = Handle;
})(Segments || (Segments = {}));
(function (Segments) {
    Segments.config({
        name: 'segments',
        precision: 0.5,
        threshold: 40,
        snapRadius: 10,
        stopPropagation: true,
        removeRedundancies: true,
        attrs: {
            width: 20,
            height: 8,
            x: -10,
            y: -4,
            rx: 4,
            ry: 4,
            fill: '#333',
            stroke: '#fff',
            'stroke-width': 2,
        },
        createHandle: (options) => new Segments.Handle(options),
        anchor: _util__WEBPACK_IMPORTED_MODULE_4__.getAnchor,
    });
})(Segments || (Segments = {}));
//# sourceMappingURL=segments.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/tool/util.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/tool/util.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getAnchor: () => (/* binding */ getAnchor),
/* harmony export */   getViewBBox: () => (/* binding */ getViewBBox)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _connection_strategy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../connection-strategy */ "./node_modules/@antv/x6/es/registry/connection-strategy/index.js");


function getAnchor(pos, terminalView, terminalMagnet, type) {
    const end = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(_connection_strategy__WEBPACK_IMPORTED_MODULE_1__.ConnectionStrategy.presets.pinRelative, this.graph, {}, terminalView, terminalMagnet, pos, this.cell, type, {});
    return end.anchor;
}
function getViewBBox(view, quick) {
    if (quick) {
        return view.cell.getBBox();
    }
    return view.cell.isEdge()
        ? view.getConnection().bbox()
        : view.getUnrotatedBBoxOfElement(view.container);
}
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/registry/tool/vertices.js":
/*!************************************************************!*\
  !*** ./node_modules/@antv/x6/es/registry/tool/vertices.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Vertices: () => (/* binding */ Vertices)
/* harmony export */ });
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../config */ "./node_modules/@antv/x6/es/config/index.js");
/* harmony import */ var _view_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../view/view */ "./node_modules/@antv/x6/es/view/view.js");
/* harmony import */ var _view_tool__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../view/tool */ "./node_modules/@antv/x6/es/view/tool.js");





class Vertices extends _view_tool__WEBPACK_IMPORTED_MODULE_4__.ToolsView.ToolItem {
    constructor() {
        super(...arguments);
        this.handles = [];
    }
    get vertices() {
        return this.cellView.cell.getVertices();
    }
    onRender() {
        this.addClass(this.prefixClassName('edge-tool-vertices'));
        if (this.options.addable) {
            this.updatePath();
        }
        this.resetHandles();
        this.renderHandles();
        return this;
    }
    update() {
        const vertices = this.vertices;
        if (vertices.length === this.handles.length) {
            this.updateHandles();
        }
        else {
            this.resetHandles();
            this.renderHandles();
        }
        if (this.options.addable) {
            this.updatePath();
        }
        return this;
    }
    resetHandles() {
        const handles = this.handles;
        this.handles = [];
        if (handles) {
            handles.forEach((handle) => {
                this.stopHandleListening(handle);
                handle.remove();
            });
        }
    }
    renderHandles() {
        const vertices = this.vertices;
        for (let i = 0, l = vertices.length; i < l; i += 1) {
            const vertex = vertices[i];
            const createHandle = this.options.createHandle;
            const processHandle = this.options.processHandle;
            const handle = createHandle({
                index: i,
                graph: this.graph,
                guard: (evt) => this.guard(evt),
                attrs: this.options.attrs || {},
            });
            if (processHandle) {
                processHandle(handle);
            }
            handle.updatePosition(vertex.x, vertex.y);
            this.stamp(handle.container);
            this.container.appendChild(handle.container);
            this.handles.push(handle);
            this.startHandleListening(handle);
        }
    }
    updateHandles() {
        const vertices = this.vertices;
        for (let i = 0, l = vertices.length; i < l; i += 1) {
            const vertex = vertices[i];
            const handle = this.handles[i];
            if (handle) {
                handle.updatePosition(vertex.x, vertex.y);
            }
        }
    }
    updatePath() {
        const connection = this.childNodes.connection;
        if (connection) {
            connection.setAttribute('d', this.cellView.getConnectionPathData());
        }
    }
    startHandleListening(handle) {
        const edgeView = this.cellView;
        if (edgeView.can('vertexMovable')) {
            handle.on('change', this.onHandleChange, this);
            handle.on('changing', this.onHandleChanging, this);
            handle.on('changed', this.onHandleChanged, this);
        }
        if (edgeView.can('vertexDeletable')) {
            handle.on('remove', this.onHandleRemove, this);
        }
    }
    stopHandleListening(handle) {
        const edgeView = this.cellView;
        if (edgeView.can('vertexMovable')) {
            handle.off('change', this.onHandleChange, this);
            handle.off('changing', this.onHandleChanging, this);
            handle.off('changed', this.onHandleChanged, this);
        }
        if (edgeView.can('vertexDeletable')) {
            handle.off('remove', this.onHandleRemove, this);
        }
    }
    getNeighborPoints(index) {
        const edgeView = this.cellView;
        const vertices = this.vertices;
        const prev = index > 0 ? vertices[index - 1] : edgeView.sourceAnchor;
        const next = index < vertices.length - 1 ? vertices[index + 1] : edgeView.targetAnchor;
        return {
            prev: _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(prev),
            next: _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(next),
        };
    }
    getMouseEventArgs(evt) {
        const e = this.normalizeEvent(evt);
        const { x, y } = this.graph.snapToGrid(e.clientX, e.clientY);
        return { e, x, y };
    }
    onHandleChange({ e }) {
        this.focus();
        const edgeView = this.cellView;
        edgeView.cell.startBatch('move-vertex', { ui: true, toolId: this.cid });
        if (!this.options.stopPropagation) {
            const { e: evt, x, y } = this.getMouseEventArgs(e);
            this.eventData(evt, { start: { x, y } });
            edgeView.notifyMouseDown(evt, x, y);
        }
    }
    onHandleChanging({ handle, e, }) {
        const edgeView = this.cellView;
        const index = handle.options.index;
        const { e: evt, x, y } = this.getMouseEventArgs(e);
        const vertex = { x, y };
        this.snapVertex(vertex, index);
        edgeView.cell.setVertexAt(index, vertex, { ui: true, toolId: this.cid });
        handle.updatePosition(vertex.x, vertex.y);
        if (!this.options.stopPropagation) {
            edgeView.notifyMouseMove(evt, x, y);
        }
    }
    stopBatch(vertexAdded) {
        this.cell.stopBatch('move-vertex', { ui: true, toolId: this.cid });
        if (vertexAdded) {
            this.cell.stopBatch('add-vertex', { ui: true, toolId: this.cid });
        }
    }
    onHandleChanged({ e }) {
        const options = this.options;
        const edgeView = this.cellView;
        if (options.addable) {
            this.updatePath();
        }
        if (!options.removeRedundancies) {
            this.stopBatch(this.eventData(e).vertexAdded);
            return;
        }
        const verticesRemoved = edgeView.removeRedundantLinearVertices({
            ui: true,
            toolId: this.cid,
        });
        if (verticesRemoved) {
            this.render();
        }
        this.blur();
        this.stopBatch(this.eventData(e).vertexAdded);
        const { e: evt, x, y } = this.getMouseEventArgs(e);
        if (!this.options.stopPropagation) {
            edgeView.notifyMouseUp(evt, x, y);
            const { start } = this.eventData(evt);
            if (start) {
                const { x: startX, y: startY } = start;
                if (startX === x && startY === y) {
                    edgeView.onClick(evt, x, y);
                }
            }
        }
        edgeView.checkMouseleave(evt);
        options.onChanged && options.onChanged({ edge: edgeView.cell, edgeView });
    }
    snapVertex(vertex, index) {
        const snapRadius = this.options.snapRadius || 0;
        if (snapRadius > 0) {
            const neighbors = this.getNeighborPoints(index);
            const prev = neighbors.prev;
            const next = neighbors.next;
            if (Math.abs(vertex.x - prev.x) < snapRadius) {
                vertex.x = prev.x;
            }
            else if (Math.abs(vertex.x - next.x) < snapRadius) {
                vertex.x = next.x;
            }
            if (Math.abs(vertex.y - prev.y) < snapRadius) {
                vertex.y = neighbors.prev.y;
            }
            else if (Math.abs(vertex.y - next.y) < snapRadius) {
                vertex.y = next.y;
            }
        }
    }
    onHandleRemove({ handle, e }) {
        if (this.options.removable) {
            const index = handle.options.index;
            const edgeView = this.cellView;
            edgeView.cell.removeVertexAt(index, { ui: true });
            if (this.options.addable) {
                this.updatePath();
            }
            edgeView.checkMouseleave(this.normalizeEvent(e));
        }
    }
    allowAddVertex(e) {
        const guard = this.guard(e);
        const addable = this.options.addable && this.cellView.can('vertexAddable');
        const matchModifiers = this.options.modifiers
            ? _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.ModifierKey.isMatch(e, this.options.modifiers)
            : true;
        return !guard && addable && matchModifiers;
    }
    onPathMouseDown(evt) {
        const edgeView = this.cellView;
        if (!this.allowAddVertex(evt)) {
            return;
        }
        evt.stopPropagation();
        evt.preventDefault();
        const e = this.normalizeEvent(evt);
        const vertex = this.graph.snapToGrid(e.clientX, e.clientY).toJSON();
        edgeView.cell.startBatch('add-vertex', { ui: true, toolId: this.cid });
        const index = edgeView.getVertexIndex(vertex.x, vertex.y);
        this.snapVertex(vertex, index);
        edgeView.cell.insertVertex(vertex, index, {
            ui: true,
            toolId: this.cid,
        });
        this.render();
        const handle = this.handles[index];
        this.eventData(e, { vertexAdded: true });
        handle.onMouseDown(e);
    }
    onRemove() {
        this.resetHandles();
    }
}
(function (Vertices) {
    class Handle extends _view_view__WEBPACK_IMPORTED_MODULE_3__.View {
        get graph() {
            return this.options.graph;
        }
        constructor(options) {
            super();
            this.options = options;
            this.render();
            this.delegateEvents({
                mousedown: 'onMouseDown',
                touchstart: 'onMouseDown',
                dblclick: 'onDoubleClick',
            });
        }
        render() {
            this.container = _view_view__WEBPACK_IMPORTED_MODULE_3__.View.createElement('circle', true);
            const attrs = this.options.attrs;
            if (typeof attrs === 'function') {
                const defaults = Vertices.getDefaults();
                this.setAttrs(Object.assign(Object.assign({}, defaults.attrs), attrs(this)));
            }
            else {
                this.setAttrs(attrs);
            }
            this.addClass(this.prefixClassName('edge-tool-vertex'));
        }
        updatePosition(x, y) {
            this.setAttrs({ cx: x, cy: y });
        }
        onMouseDown(evt) {
            if (this.options.guard(evt)) {
                return;
            }
            evt.stopPropagation();
            evt.preventDefault();
            this.graph.view.undelegateEvents();
            this.delegateDocumentEvents({
                mousemove: 'onMouseMove',
                touchmove: 'onMouseMove',
                mouseup: 'onMouseUp',
                touchend: 'onMouseUp',
                touchcancel: 'onMouseUp',
            }, evt.data);
            this.emit('change', { e: evt, handle: this });
        }
        onMouseMove(evt) {
            this.emit('changing', { e: evt, handle: this });
        }
        onMouseUp(evt) {
            this.emit('changed', { e: evt, handle: this });
            this.undelegateDocumentEvents();
            this.graph.view.delegateEvents();
        }
        onDoubleClick(evt) {
            this.emit('remove', { e: evt, handle: this });
        }
    }
    Vertices.Handle = Handle;
})(Vertices || (Vertices = {}));
(function (Vertices) {
    const pathClassName = _config__WEBPACK_IMPORTED_MODULE_2__.Config.prefix('edge-tool-vertex-path');
    Vertices.config({
        name: 'vertices',
        snapRadius: 20,
        addable: true,
        removable: true,
        removeRedundancies: true,
        stopPropagation: true,
        attrs: {
            r: 6,
            fill: '#333',
            stroke: '#fff',
            cursor: 'move',
            'stroke-width': 2,
        },
        createHandle: (options) => new Vertices.Handle(options),
        markup: [
            {
                tagName: 'path',
                selector: 'connection',
                className: pathClassName,
                attrs: {
                    fill: 'none',
                    stroke: 'transparent',
                    'stroke-width': 10,
                    cursor: 'pointer',
                },
            },
        ],
        events: {
            [`mousedown .${pathClassName}`]: 'onPathMouseDown',
            [`touchstart .${pathClassName}`]: 'onPathMouseDown',
        },
    });
})(Vertices || (Vertices = {}));
//# sourceMappingURL=vertices.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/renderer/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@antv/x6/es/renderer/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Renderer: () => (/* reexport safe */ _renderer__WEBPACK_IMPORTED_MODULE_0__.Renderer)
/* harmony export */ });
/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./renderer */ "./node_modules/@antv/x6/es/renderer/renderer.js");

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/renderer/queueJob.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/x6/es/renderer/queueJob.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JOB_PRIORITY: () => (/* binding */ JOB_PRIORITY),
/* harmony export */   JobQueue: () => (/* binding */ JobQueue)
/* harmony export */ });
class JobQueue {
    constructor() {
        this.isFlushing = false;
        this.isFlushPending = false;
        this.scheduleId = 0;
        this.queue = [];
        this.frameInterval = 33;
        this.initialTime = Date.now();
    }
    queueJob(job) {
        if (job.priority & JOB_PRIORITY.PRIOR) {
            job.cb();
        }
        else {
            const index = this.findInsertionIndex(job);
            if (index >= 0) {
                this.queue.splice(index, 0, job);
            }
        }
    }
    queueFlush() {
        if (!this.isFlushing && !this.isFlushPending) {
            this.isFlushPending = true;
            this.scheduleJob();
        }
    }
    queueFlushSync() {
        if (!this.isFlushing && !this.isFlushPending) {
            this.isFlushPending = true;
            this.flushJobsSync();
        }
    }
    clearJobs() {
        this.queue.length = 0;
        this.isFlushing = false;
        this.isFlushPending = false;
        this.cancelScheduleJob();
    }
    flushJobs() {
        this.isFlushPending = false;
        this.isFlushing = true;
        const startTime = this.getCurrentTime();
        let job;
        while ((job = this.queue.shift())) {
            job.cb();
            if (this.getCurrentTime() - startTime >= this.frameInterval) {
                break;
            }
        }
        this.isFlushing = false;
        if (this.queue.length) {
            this.queueFlush();
        }
    }
    flushJobsSync() {
        this.isFlushPending = false;
        this.isFlushing = true;
        let job;
        while ((job = this.queue.shift())) {
            try {
                job.cb();
            }
            catch (error) {
                // eslint-disable-next-line
                console.log(error);
            }
        }
        this.isFlushing = false;
    }
    findInsertionIndex(job) {
        let left = 0;
        let ins = this.queue.length;
        let right = ins - 1;
        const priority = job.priority;
        while (left <= right) {
            const mid = ((right - left) >> 1) + left;
            if (priority <= this.queue[mid].priority) {
                left = mid + 1;
            }
            else {
                ins = mid;
                right = mid - 1;
            }
        }
        return ins;
    }
    scheduleJob() {
        if ('requestIdleCallback' in window) {
            if (this.scheduleId) {
                this.cancelScheduleJob();
            }
            this.scheduleId = window.requestIdleCallback(this.flushJobs.bind(this), {
                timeout: 100,
            });
        }
        else {
            if (this.scheduleId) {
                this.cancelScheduleJob();
            }
            this.scheduleId = window.setTimeout(this.flushJobs.bind(this));
        }
    }
    cancelScheduleJob() {
        if ('cancelIdleCallback' in window) {
            if (this.scheduleId) {
                window.cancelIdleCallback(this.scheduleId);
            }
            this.scheduleId = 0;
        }
        else {
            if (this.scheduleId) {
                clearTimeout(this.scheduleId);
            }
            this.scheduleId = 0;
        }
    }
    getCurrentTime() {
        const hasPerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';
        if (hasPerformanceNow) {
            return performance.now();
        }
        return Date.now() - this.initialTime;
    }
}
var JOB_PRIORITY;
(function (JOB_PRIORITY) {
    JOB_PRIORITY[JOB_PRIORITY["Update"] = 2] = "Update";
    JOB_PRIORITY[JOB_PRIORITY["RenderEdge"] = 4] = "RenderEdge";
    JOB_PRIORITY[JOB_PRIORITY["RenderNode"] = 8] = "RenderNode";
    JOB_PRIORITY[JOB_PRIORITY["PRIOR"] = 1048576] = "PRIOR";
})(JOB_PRIORITY || (JOB_PRIORITY = {}));
// function findInsertionIndex(job: Job) {
//   let start = 0
//   for (let i = 0, len = queue.length; i < len; i += 1) {
//     const j = queue[i]
//     if (j.id === job.id) {
//       console.log('xx', j.bit, job.bit)
//     }
//     if (j.id === job.id && (job.bit ^ (job.bit & j.bit)) === 0) {
//       return -1
//     }
//     if (j.priority <= job.priority) {
//       start += 1
//     }
//   }
//   return start
// }
//# sourceMappingURL=queueJob.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/renderer/renderer.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/x6/es/renderer/renderer.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Renderer: () => (/* binding */ Renderer)
/* harmony export */ });
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _graph_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../graph/base */ "./node_modules/@antv/x6/es/graph/base.js");
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model */ "./node_modules/@antv/x6/es/model/index.js");
/* harmony import */ var _scheduler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scheduler */ "./node_modules/@antv/x6/es/renderer/scheduler.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/x6/es/util/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/* eslint-disable @typescript-eslint/no-unused-vars */





class Renderer extends _graph_base__WEBPACK_IMPORTED_MODULE_1__.Base {
    constructor() {
        super(...arguments);
        this.schedule = new _scheduler__WEBPACK_IMPORTED_MODULE_3__.Scheduler(this.graph);
    }
    requestViewUpdate(view, flag, options = {}) {
        this.schedule.requestViewUpdate(view, flag, options);
    }
    isViewMounted(view) {
        return this.schedule.isViewMounted(view);
    }
    setRenderArea(area) {
        this.schedule.setRenderArea(area);
    }
    findViewByElem(elem) {
        if (elem == null) {
            return null;
        }
        const container = this.options.container;
        const target = typeof elem === 'string'
            ? container.querySelector(elem)
            : elem instanceof Element
                ? elem
                : elem[0];
        if (target) {
            const id = this.graph.view.findAttr('data-cell-id', target);
            if (id) {
                const views = this.schedule.views;
                if (views[id]) {
                    return views[id].view;
                }
            }
        }
        return null;
    }
    findViewByCell(cell) {
        if (cell == null) {
            return null;
        }
        const id = _model__WEBPACK_IMPORTED_MODULE_2__.Cell.isCell(cell) ? cell.id : cell;
        const views = this.schedule.views;
        if (views[id]) {
            return views[id].view;
        }
        return null;
    }
    findViewsFromPoint(p) {
        const ref = { x: p.x, y: p.y };
        return this.model
            .getCells()
            .map((cell) => this.findViewByCell(cell))
            .filter((view) => {
            if (view != null) {
                return _util__WEBPACK_IMPORTED_MODULE_4__.Util.getBBox(view.container, {
                    target: this.view.stage,
                }).containsPoint(ref);
            }
            return false;
        });
    }
    findEdgeViewsFromPoint(p, threshold = 5) {
        return this.model
            .getEdges()
            .map((edge) => this.findViewByCell(edge))
            .filter((view) => {
            if (view != null) {
                const point = view.getClosestPoint(p);
                if (point) {
                    return point.distance(p) <= threshold;
                }
            }
            return false;
        });
    }
    findViewsInArea(rect, options = {}) {
        const area = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle.create(rect);
        return this.model
            .getCells()
            .map((cell) => this.findViewByCell(cell))
            .filter((view) => {
            if (view) {
                if (options.nodeOnly && !view.isNodeView()) {
                    return false;
                }
                const bbox = _util__WEBPACK_IMPORTED_MODULE_4__.Util.getBBox(view.container, {
                    target: this.view.stage,
                });
                if (bbox.width === 0) {
                    bbox.inflate(1, 0);
                }
                else if (bbox.height === 0) {
                    bbox.inflate(0, 1);
                }
                return options.strict
                    ? area.containsRect(bbox)
                    : area.isIntersectWithRect(bbox);
            }
            return false;
        });
    }
    dispose() {
        this.schedule.dispose();
    }
}
__decorate([
    _graph_base__WEBPACK_IMPORTED_MODULE_1__.Base.dispose()
], Renderer.prototype, "dispose", null);
//# sourceMappingURL=renderer.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/renderer/scheduler.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/x6/es/renderer/scheduler.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Scheduler: () => (/* binding */ Scheduler)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../view */ "./node_modules/@antv/x6/es/view/index.js");
/* harmony import */ var _queueJob__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./queueJob */ "./node_modules/@antv/x6/es/renderer/queueJob.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};



class Scheduler extends _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Disposable {
    get model() {
        return this.graph.model;
    }
    get container() {
        return this.graph.view.stage;
    }
    constructor(graph) {
        super();
        this.views = {};
        this.willRemoveViews = {};
        this.queue = new _queueJob__WEBPACK_IMPORTED_MODULE_2__.JobQueue();
        this.graph = graph;
        this.init();
    }
    init() {
        this.startListening();
        this.renderViews(this.model.getCells());
    }
    startListening() {
        this.model.on('reseted', this.onModelReseted, this);
        this.model.on('cell:added', this.onCellAdded, this);
        this.model.on('cell:removed', this.onCellRemoved, this);
        this.model.on('cell:change:zIndex', this.onCellZIndexChanged, this);
        this.model.on('cell:change:visible', this.onCellVisibleChanged, this);
    }
    stopListening() {
        this.model.off('reseted', this.onModelReseted, this);
        this.model.off('cell:added', this.onCellAdded, this);
        this.model.off('cell:removed', this.onCellRemoved, this);
        this.model.off('cell:change:zIndex', this.onCellZIndexChanged, this);
        this.model.off('cell:change:visible', this.onCellVisibleChanged, this);
    }
    onModelReseted({ options }) {
        this.queue.clearJobs();
        this.removeZPivots();
        this.resetViews();
        const cells = this.model.getCells();
        this.renderViews(cells, Object.assign(Object.assign({}, options), { queue: cells.map((cell) => cell.id) }));
    }
    onCellAdded({ cell, options }) {
        this.renderViews([cell], options);
    }
    onCellRemoved({ cell }) {
        this.removeViews([cell]);
    }
    onCellZIndexChanged({ cell, options, }) {
        const viewItem = this.views[cell.id];
        if (viewItem) {
            this.requestViewUpdate(viewItem.view, Scheduler.FLAG_INSERT, options, _queueJob__WEBPACK_IMPORTED_MODULE_2__.JOB_PRIORITY.Update, true);
        }
    }
    onCellVisibleChanged({ cell, current, }) {
        this.toggleVisible(cell, !!current);
    }
    requestViewUpdate(view, flag, options = {}, priority = _queueJob__WEBPACK_IMPORTED_MODULE_2__.JOB_PRIORITY.Update, flush = true) {
        const id = view.cell.id;
        const viewItem = this.views[id];
        if (!viewItem) {
            return;
        }
        viewItem.flag = flag;
        viewItem.options = options;
        const priorAction = view.hasAction(flag, ['translate', 'resize', 'rotate']);
        if (priorAction || options.async === false) {
            priority = _queueJob__WEBPACK_IMPORTED_MODULE_2__.JOB_PRIORITY.PRIOR; // eslint-disable-line
            flush = false; // eslint-disable-line
        }
        this.queue.queueJob({
            id,
            priority,
            cb: () => {
                this.renderViewInArea(view, flag, options);
                const queue = options.queue;
                if (queue) {
                    const index = queue.indexOf(view.cell.id);
                    if (index >= 0) {
                        queue.splice(index, 1);
                    }
                    if (queue.length === 0) {
                        this.graph.trigger('render:done');
                    }
                }
            },
        });
        const effectedEdges = this.getEffectedEdges(view);
        effectedEdges.forEach((edge) => {
            this.requestViewUpdate(edge.view, edge.flag, options, priority, false);
        });
        if (flush) {
            this.flush();
        }
    }
    setRenderArea(area) {
        this.renderArea = area;
        this.flushWaitingViews();
    }
    isViewMounted(view) {
        if (view == null) {
            return false;
        }
        const viewItem = this.views[view.cell.id];
        if (!viewItem) {
            return false;
        }
        return viewItem.state === Scheduler.ViewState.MOUNTED;
    }
    renderViews(cells, options = {}) {
        cells.sort((c1, c2) => {
            if (c1.isNode() && c2.isEdge()) {
                return -1;
            }
            return 0;
        });
        cells.forEach((cell) => {
            const id = cell.id;
            const views = this.views;
            let flag = 0;
            let viewItem = views[id];
            if (viewItem) {
                flag = Scheduler.FLAG_INSERT;
            }
            else {
                const cellView = this.createCellView(cell);
                if (cellView) {
                    cellView.graph = this.graph;
                    flag = Scheduler.FLAG_INSERT | cellView.getBootstrapFlag();
                    viewItem = {
                        view: cellView,
                        flag,
                        options,
                        state: Scheduler.ViewState.CREATED,
                    };
                    this.views[id] = viewItem;
                }
            }
            if (viewItem) {
                this.requestViewUpdate(viewItem.view, flag, options, this.getRenderPriority(viewItem.view), false);
            }
        });
        this.flush();
    }
    renderViewInArea(view, flag, options = {}) {
        const cell = view.cell;
        const id = cell.id;
        const viewItem = this.views[id];
        if (!viewItem) {
            return;
        }
        let result = 0;
        if (this.isUpdatable(view)) {
            result = this.updateView(view, flag, options);
            viewItem.flag = result;
        }
        else {
            if (viewItem.state === Scheduler.ViewState.MOUNTED) {
                result = this.updateView(view, flag, options);
                viewItem.flag = result;
            }
            else {
                viewItem.state = Scheduler.ViewState.WAITING;
            }
        }
        if (result) {
            if (cell.isEdge() &&
                (result & view.getFlag(['source', 'target'])) === 0) {
                this.queue.queueJob({
                    id,
                    priority: _queueJob__WEBPACK_IMPORTED_MODULE_2__.JOB_PRIORITY.RenderEdge,
                    cb: () => {
                        this.updateView(view, flag, options);
                    },
                });
            }
        }
    }
    removeViews(cells) {
        cells.forEach((cell) => {
            const id = cell.id;
            const viewItem = this.views[id];
            if (viewItem) {
                this.willRemoveViews[id] = viewItem;
                delete this.views[id];
                this.queue.queueJob({
                    id,
                    priority: this.getRenderPriority(viewItem.view),
                    cb: () => {
                        this.removeView(viewItem.view);
                    },
                });
            }
        });
        this.flush();
    }
    flush() {
        this.graph.options.async
            ? this.queue.queueFlush()
            : this.queue.queueFlushSync();
    }
    flushWaitingViews() {
        Object.values(this.views).forEach((viewItem) => {
            if (viewItem && viewItem.state === Scheduler.ViewState.WAITING) {
                const { view, flag, options } = viewItem;
                this.requestViewUpdate(view, flag, options, this.getRenderPriority(view), false);
            }
        });
        this.flush();
    }
    updateView(view, flag, options = {}) {
        if (view == null) {
            return 0;
        }
        if (_view__WEBPACK_IMPORTED_MODULE_1__.CellView.isCellView(view)) {
            if (flag & Scheduler.FLAG_REMOVE) {
                this.removeView(view.cell);
                return 0;
            }
            if (flag & Scheduler.FLAG_INSERT) {
                this.insertView(view);
                flag ^= Scheduler.FLAG_INSERT; // eslint-disable-line
            }
        }
        if (!flag) {
            return 0;
        }
        return view.confirmUpdate(flag, options);
    }
    insertView(view) {
        const viewItem = this.views[view.cell.id];
        if (viewItem) {
            const zIndex = view.cell.getZIndex();
            const pivot = this.addZPivot(zIndex);
            this.container.insertBefore(view.container, pivot);
            if (!view.cell.isVisible()) {
                this.toggleVisible(view.cell, false);
            }
            viewItem.state = Scheduler.ViewState.MOUNTED;
            this.graph.trigger('view:mounted', { view });
        }
    }
    resetViews() {
        this.willRemoveViews = Object.assign(Object.assign({}, this.views), this.willRemoveViews);
        Object.values(this.willRemoveViews).forEach((viewItem) => {
            if (viewItem) {
                this.removeView(viewItem.view);
            }
        });
        this.views = {};
        this.willRemoveViews = {};
    }
    removeView(view) {
        const cell = view.cell;
        const viewItem = this.willRemoveViews[cell.id];
        if (viewItem && view) {
            viewItem.view.remove();
            delete this.willRemoveViews[cell.id];
            this.graph.trigger('view:unmounted', { view });
        }
    }
    toggleVisible(cell, visible) {
        const edges = this.model.getConnectedEdges(cell);
        for (let i = 0, len = edges.length; i < len; i += 1) {
            const edge = edges[i];
            if (visible) {
                const source = edge.getSourceCell();
                const target = edge.getTargetCell();
                if ((source && !source.isVisible()) ||
                    (target && !target.isVisible())) {
                    continue;
                }
                this.toggleVisible(edge, true);
            }
            else {
                this.toggleVisible(edge, false);
            }
        }
        const viewItem = this.views[cell.id];
        if (viewItem) {
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.css(viewItem.view.container, {
                display: visible ? 'unset' : 'none',
            });
        }
    }
    addZPivot(zIndex = 0) {
        if (this.zPivots == null) {
            this.zPivots = {};
        }
        const pivots = this.zPivots;
        let pivot = pivots[zIndex];
        if (pivot) {
            return pivot;
        }
        pivot = pivots[zIndex] = document.createComment(`z-index:${zIndex + 1}`);
        let neighborZ = -Infinity;
        // eslint-disable-next-line
        for (const key in pivots) {
            const currentZ = +key;
            if (currentZ < zIndex && currentZ > neighborZ) {
                neighborZ = currentZ;
                if (neighborZ === zIndex - 1) {
                    continue;
                }
            }
        }
        const layer = this.container;
        if (neighborZ !== -Infinity) {
            const neighborPivot = pivots[neighborZ];
            layer.insertBefore(pivot, neighborPivot.nextSibling);
        }
        else {
            layer.insertBefore(pivot, layer.firstChild);
        }
        return pivot;
    }
    removeZPivots() {
        if (this.zPivots) {
            Object.values(this.zPivots).forEach((elem) => {
                if (elem && elem.parentNode) {
                    elem.parentNode.removeChild(elem);
                }
            });
        }
        this.zPivots = {};
    }
    createCellView(cell) {
        const options = { graph: this.graph };
        const createViewHook = this.graph.options.createCellView;
        if (createViewHook) {
            const ret = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(createViewHook, this.graph, cell);
            if (ret) {
                return new ret(cell, options); // eslint-disable-line new-cap
            }
            if (ret === null) {
                // null means not render
                return null;
            }
        }
        const view = cell.view;
        if (view != null && typeof view === 'string') {
            const def = _view__WEBPACK_IMPORTED_MODULE_1__.CellView.registry.get(view);
            if (def) {
                return new def(cell, options); // eslint-disable-line new-cap
            }
            return _view__WEBPACK_IMPORTED_MODULE_1__.CellView.registry.onNotFound(view);
        }
        if (cell.isNode()) {
            return new _view__WEBPACK_IMPORTED_MODULE_1__.NodeView(cell, options);
        }
        if (cell.isEdge()) {
            return new _view__WEBPACK_IMPORTED_MODULE_1__.EdgeView(cell, options);
        }
        return null;
    }
    getEffectedEdges(view) {
        const effectedEdges = [];
        const cell = view.cell;
        const edges = this.model.getConnectedEdges(cell);
        for (let i = 0, n = edges.length; i < n; i += 1) {
            const edge = edges[i];
            const viewItem = this.views[edge.id];
            if (!viewItem) {
                continue;
            }
            const edgeView = viewItem.view;
            if (!this.isViewMounted(edgeView)) {
                continue;
            }
            const flagLabels = ['update'];
            if (edge.getTargetCell() === cell) {
                flagLabels.push('target');
            }
            if (edge.getSourceCell() === cell) {
                flagLabels.push('source');
            }
            effectedEdges.push({
                id: edge.id,
                view: edgeView,
                flag: edgeView.getFlag(flagLabels),
            });
        }
        return effectedEdges;
    }
    isUpdatable(view) {
        if (view.isNodeView()) {
            if (this.renderArea) {
                return this.renderArea.isIntersectWithRect(view.cell.getBBox());
            }
            return true;
        }
        if (view.isEdgeView()) {
            const edge = view.cell;
            const sourceCell = edge.getSourceCell();
            const targetCell = edge.getTargetCell();
            if (this.renderArea && sourceCell && targetCell) {
                return (this.renderArea.isIntersectWithRect(sourceCell.getBBox()) ||
                    this.renderArea.isIntersectWithRect(targetCell.getBBox()));
            }
        }
        return true;
    }
    getRenderPriority(view) {
        return view.cell.isNode()
            ? _queueJob__WEBPACK_IMPORTED_MODULE_2__.JOB_PRIORITY.RenderNode
            : _queueJob__WEBPACK_IMPORTED_MODULE_2__.JOB_PRIORITY.RenderEdge;
    }
    dispose() {
        this.stopListening();
        // clear views
        Object.keys(this.views).forEach((id) => {
            this.views[id].view.dispose();
        });
        this.views = {};
    }
}
__decorate([
    _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Disposable.dispose()
], Scheduler.prototype, "dispose", null);
(function (Scheduler) {
    Scheduler.FLAG_INSERT = 1 << 30;
    Scheduler.FLAG_REMOVE = 1 << 29;
    Scheduler.FLAG_RENDER = (1 << 26) - 1;
})(Scheduler || (Scheduler = {}));
(function (Scheduler) {
    let ViewState;
    (function (ViewState) {
        ViewState[ViewState["CREATED"] = 0] = "CREATED";
        ViewState[ViewState["MOUNTED"] = 1] = "MOUNTED";
        ViewState[ViewState["WAITING"] = 2] = "WAITING";
    })(ViewState = Scheduler.ViewState || (Scheduler.ViewState = {}));
})(Scheduler || (Scheduler = {}));
//# sourceMappingURL=scheduler.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/shape/base.js":
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/base.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Base: () => (/* binding */ Base)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model */ "./node_modules/@antv/x6/es/model/index.js");
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};


class Base extends _model__WEBPACK_IMPORTED_MODULE_1__.Node {
    get label() {
        return this.getLabel();
    }
    set label(val) {
        this.setLabel(val);
    }
    getLabel() {
        return this.getAttrByPath('text/text');
    }
    setLabel(label, options) {
        if (label == null) {
            this.removeLabel();
        }
        else {
            this.setAttrByPath('text/text', label, options);
        }
        return this;
    }
    removeLabel() {
        this.removeAttrByPath('text/text');
        return this;
    }
}
(function (Base) {
    Base.bodyAttr = {
        fill: '#ffffff',
        stroke: '#333333',
        strokeWidth: 2,
    };
    Base.labelAttr = {
        fontSize: 14,
        fill: '#000000',
        refX: 0.5,
        refY: 0.5,
        textAnchor: 'middle',
        textVerticalAnchor: 'middle',
        fontFamily: 'Arial, helvetica, sans-serif',
    };
    Base.config({
        attrs: { text: Object.assign({}, Base.labelAttr) },
        propHooks(metadata) {
            const { label } = metadata, others = __rest(metadata, ["label"]);
            if (label) {
                _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.setByPath(others, 'attrs/text/text', label);
            }
            return others;
        },
        visible: true,
    });
})(Base || (Base = {}));
//# sourceMappingURL=base.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/shape/circle.js":
/*!**************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/circle.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Circle: () => (/* binding */ Circle)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/shape/util.js");

const Circle = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createShape)('circle', {
    attrs: {
        body: {
            refCx: '50%',
            refCy: '50%',
            refR: '50%',
        },
    },
});
//# sourceMappingURL=circle.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/shape/edge.js":
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/edge.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Edge: () => (/* binding */ Edge)
/* harmony export */ });
/* harmony import */ var _model_edge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model/edge */ "./node_modules/@antv/x6/es/model/edge.js");

const Edge = _model_edge__WEBPACK_IMPORTED_MODULE_0__.Edge.define({
    shape: 'edge',
    markup: [
        {
            tagName: 'path',
            selector: 'wrap',
            groupSelector: 'lines',
            attrs: {
                fill: 'none',
                cursor: 'pointer',
                stroke: 'transparent',
                strokeLinecap: 'round',
            },
        },
        {
            tagName: 'path',
            selector: 'line',
            groupSelector: 'lines',
            attrs: {
                fill: 'none',
                pointerEvents: 'none',
            },
        },
    ],
    attrs: {
        lines: {
            connection: true,
            strokeLinejoin: 'round',
        },
        wrap: {
            strokeWidth: 10,
        },
        line: {
            stroke: '#333',
            strokeWidth: 2,
            targetMarker: 'classic',
        },
    },
});
//# sourceMappingURL=edge.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/shape/ellipse.js":
/*!***************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/ellipse.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ellipse: () => (/* binding */ Ellipse)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/shape/util.js");

const Ellipse = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createShape)('ellipse', {
    attrs: {
        body: {
            refCx: '50%',
            refCy: '50%',
            refRx: '50%',
            refRy: '50%',
        },
    },
});
//# sourceMappingURL=ellipse.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/shape/html.js":
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/html.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HTML: () => (/* binding */ HTML)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../view */ "./node_modules/@antv/x6/es/view/index.js");
/* harmony import */ var _model_node__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model/node */ "./node_modules/@antv/x6/es/model/node.js");
/* harmony import */ var _view_node__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../view/node */ "./node_modules/@antv/x6/es/view/node.js");
/* harmony import */ var _graph_graph__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../graph/graph */ "./node_modules/@antv/x6/es/graph/graph.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};





class HTML extends _model_node__WEBPACK_IMPORTED_MODULE_2__.Node {
}
(function (HTML) {
    class View extends _view_node__WEBPACK_IMPORTED_MODULE_3__.NodeView {
        init() {
            super.init();
            this.cell.on('change:*', this.onCellChangeAny, this);
        }
        onCellChangeAny({ key }) {
            const content = HTML.shapeMaps[this.cell.shape];
            if (content) {
                const { effect } = content;
                if (!effect || effect.includes(key)) {
                    this.renderHTMLComponent();
                }
            }
        }
        confirmUpdate(flag) {
            const ret = super.confirmUpdate(flag);
            return this.handleAction(ret, View.action, () => this.renderHTMLComponent());
        }
        renderHTMLComponent() {
            const container = this.selectors && this.selectors.foContent;
            if (container) {
                _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.empty(container);
                const content = HTML.shapeMaps[this.cell.shape];
                if (!content) {
                    return;
                }
                let { html } = content;
                if (typeof html === 'function') {
                    html = html(this.cell);
                }
                if (html) {
                    if (typeof html === 'string') {
                        container.innerHTML = html;
                    }
                    else {
                        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.append(container, html);
                    }
                }
            }
        }
        dispose() {
            this.cell.off('change:*', this.onCellChangeAny, this);
        }
    }
    __decorate([
        View.dispose()
    ], View.prototype, "dispose", null);
    HTML.View = View;
    (function (View) {
        View.action = 'html';
        View.config({
            bootstrap: [View.action],
            actions: {
                html: View.action,
            },
        });
        _view_node__WEBPACK_IMPORTED_MODULE_3__.NodeView.registry.register('html-view', View, true);
    })(View = HTML.View || (HTML.View = {}));
})(HTML || (HTML = {}));
(function (HTML) {
    HTML.config({
        view: 'html-view',
        markup: [
            {
                tagName: 'rect',
                selector: 'body',
            },
            Object.assign({}, _view__WEBPACK_IMPORTED_MODULE_1__.Markup.getForeignObjectMarkup()),
            {
                tagName: 'text',
                selector: 'label',
            },
        ],
        attrs: {
            body: {
                fill: 'none',
                stroke: 'none',
                refWidth: '100%',
                refHeight: '100%',
            },
            fo: {
                refWidth: '100%',
                refHeight: '100%',
            },
        },
    });
    _model_node__WEBPACK_IMPORTED_MODULE_2__.Node.registry.register('html', HTML, true);
})(HTML || (HTML = {}));
(function (HTML) {
    HTML.shapeMaps = {};
    function register(config) {
        const { shape, html, effect, inherit } = config, others = __rest(config, ["shape", "html", "effect", "inherit"]);
        if (!shape) {
            throw new Error('should specify shape in config');
        }
        HTML.shapeMaps[shape] = {
            html,
            effect,
        };
        _graph_graph__WEBPACK_IMPORTED_MODULE_4__.Graph.registerNode(shape, Object.assign({ inherit: inherit || 'html' }, others), true);
    }
    HTML.register = register;
})(HTML || (HTML = {}));
//# sourceMappingURL=html.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/shape/image.js":
/*!*************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/image.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Image: () => (/* binding */ Image)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/shape/util.js");

const Image = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createShape)('image', {
    attrs: {
        image: {
            refWidth: '100%',
            refHeight: '100%',
        },
    },
    propHooks: (0,_util__WEBPACK_IMPORTED_MODULE_0__.getImageUrlHook)(),
}, {
    selector: 'image',
});
//# sourceMappingURL=image.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/shape/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Circle: () => (/* reexport safe */ _circle__WEBPACK_IMPORTED_MODULE_8__.Circle),
/* harmony export */   Edge: () => (/* reexport safe */ _edge__WEBPACK_IMPORTED_MODULE_1__.Edge),
/* harmony export */   Ellipse: () => (/* reexport safe */ _ellipse__WEBPACK_IMPORTED_MODULE_2__.Ellipse),
/* harmony export */   HTML: () => (/* reexport safe */ _html__WEBPACK_IMPORTED_MODULE_9__.HTML),
/* harmony export */   Image: () => (/* reexport safe */ _image__WEBPACK_IMPORTED_MODULE_7__.Image),
/* harmony export */   Path: () => (/* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_5__.Path),
/* harmony export */   Polygon: () => (/* reexport safe */ _polygon__WEBPACK_IMPORTED_MODULE_3__.Polygon),
/* harmony export */   Polyline: () => (/* reexport safe */ _polyline__WEBPACK_IMPORTED_MODULE_4__.Polyline),
/* harmony export */   Rect: () => (/* reexport safe */ _rect__WEBPACK_IMPORTED_MODULE_0__.Rect),
/* harmony export */   TextBlock: () => (/* reexport safe */ _text_block__WEBPACK_IMPORTED_MODULE_6__.TextBlock)
/* harmony export */ });
/* harmony import */ var _rect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rect */ "./node_modules/@antv/x6/es/shape/rect.js");
/* harmony import */ var _edge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./edge */ "./node_modules/@antv/x6/es/shape/edge.js");
/* harmony import */ var _ellipse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ellipse */ "./node_modules/@antv/x6/es/shape/ellipse.js");
/* harmony import */ var _polygon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./polygon */ "./node_modules/@antv/x6/es/shape/polygon.js");
/* harmony import */ var _polyline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./polyline */ "./node_modules/@antv/x6/es/shape/polyline.js");
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./path */ "./node_modules/@antv/x6/es/shape/path.js");
/* harmony import */ var _text_block__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./text-block */ "./node_modules/@antv/x6/es/shape/text-block.js");
/* harmony import */ var _image__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./image */ "./node_modules/@antv/x6/es/shape/image.js");
/* harmony import */ var _circle__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./circle */ "./node_modules/@antv/x6/es/shape/circle.js");
/* harmony import */ var _html__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./html */ "./node_modules/@antv/x6/es/shape/html.js");












//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/shape/path.js":
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/path.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Path: () => (/* binding */ Path)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./node_modules/@antv/x6/es/shape/base.js");
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};


const Path = _base__WEBPACK_IMPORTED_MODULE_1__.Base.define({
    shape: 'path',
    markup: [
        {
            tagName: 'rect',
            selector: 'bg',
        },
        {
            tagName: 'path',
            selector: 'body',
        },
        {
            tagName: 'text',
            selector: 'label',
        },
    ],
    attrs: {
        bg: {
            refWidth: '100%',
            refHeight: '100%',
            fill: 'none',
            stroke: 'none',
            pointerEvents: 'all',
        },
        body: {
            fill: 'none',
            stroke: '#000',
            strokeWidth: 2,
        },
    },
    propHooks(metadata) {
        const { path } = metadata, others = __rest(metadata, ["path"]);
        if (path) {
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.setByPath(others, 'attrs/body/refD', path);
        }
        return others;
    },
});
//# sourceMappingURL=path.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/shape/poly.js":
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/poly.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Poly: () => (/* binding */ Poly)
/* harmony export */ });
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base */ "./node_modules/@antv/x6/es/shape/base.js");
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};



class Poly extends _base__WEBPACK_IMPORTED_MODULE_2__.Base {
    get points() {
        return this.getPoints();
    }
    set points(pts) {
        this.setPoints(pts);
    }
    getPoints() {
        return this.getAttrByPath('body/refPoints');
    }
    setPoints(points, options) {
        if (points == null) {
            this.removePoints();
        }
        else {
            this.setAttrByPath('body/refPoints', Poly.pointsToString(points), options);
        }
        return this;
    }
    removePoints() {
        this.removeAttrByPath('body/refPoints');
        return this;
    }
}
(function (Poly) {
    function pointsToString(points) {
        return typeof points === 'string'
            ? points
            : points
                .map((p) => {
                if (Array.isArray(p)) {
                    return p.join(',');
                }
                if (_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.isPointLike(p)) {
                    return `${p.x}, ${p.y}`;
                }
                return '';
            })
                .join(' ');
    }
    Poly.pointsToString = pointsToString;
    Poly.config({
        propHooks(metadata) {
            const { points } = metadata, others = __rest(metadata, ["points"]);
            if (points) {
                const data = pointsToString(points);
                if (data) {
                    _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.setByPath(others, 'attrs/body/refPoints', data);
                }
            }
            return others;
        },
    });
})(Poly || (Poly = {}));
//# sourceMappingURL=poly.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/shape/polygon.js":
/*!***************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/polygon.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Polygon: () => (/* binding */ Polygon)
/* harmony export */ });
/* harmony import */ var _poly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./poly */ "./node_modules/@antv/x6/es/shape/poly.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/shape/util.js");


const Polygon = (0,_util__WEBPACK_IMPORTED_MODULE_1__.createShape)('polygon', {}, { parent: _poly__WEBPACK_IMPORTED_MODULE_0__.Poly });
//# sourceMappingURL=polygon.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/shape/polyline.js":
/*!****************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/polyline.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Polyline: () => (/* binding */ Polyline)
/* harmony export */ });
/* harmony import */ var _poly__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./poly */ "./node_modules/@antv/x6/es/shape/poly.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/shape/util.js");


const Polyline = (0,_util__WEBPACK_IMPORTED_MODULE_1__.createShape)('polyline', {}, { parent: _poly__WEBPACK_IMPORTED_MODULE_0__.Poly });
//# sourceMappingURL=polyline.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/shape/rect.js":
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/rect.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Rect: () => (/* binding */ Rect)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/x6/es/shape/util.js");

const Rect = (0,_util__WEBPACK_IMPORTED_MODULE_0__.createShape)('rect', {
    attrs: {
        body: {
            refWidth: '100%',
            refHeight: '100%',
        },
    },
});
//# sourceMappingURL=rect.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/shape/text-block.js":
/*!******************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/text-block.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextBlock: () => (/* binding */ TextBlock)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../registry */ "./node_modules/@antv/x6/es/registry/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base */ "./node_modules/@antv/x6/es/shape/base.js");
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};



const TextBlock = _base__WEBPACK_IMPORTED_MODULE_2__.Base.define({
    shape: 'text-block',
    markup: [
        {
            tagName: 'rect',
            selector: 'body',
        },
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Platform.SUPPORT_FOREIGNOBJECT
            ? {
                tagName: 'foreignObject',
                selector: 'foreignObject',
                children: [
                    {
                        tagName: 'div',
                        ns: _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.ns.xhtml,
                        selector: 'label',
                        style: {
                            width: '100%',
                            height: '100%',
                            position: 'static',
                            backgroundColor: 'transparent',
                            textAlign: 'center',
                            margin: 0,
                            padding: '0px 5px',
                            boxSizing: 'border-box',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                        },
                    },
                ],
            }
            : {
                tagName: 'text',
                selector: 'label',
                attrs: {
                    textAnchor: 'middle',
                },
            },
    ],
    attrs: {
        body: Object.assign(Object.assign({}, _base__WEBPACK_IMPORTED_MODULE_2__.Base.bodyAttr), { refWidth: '100%', refHeight: '100%' }),
        foreignObject: {
            refWidth: '100%',
            refHeight: '100%',
        },
        label: {
            style: {
                fontSize: 14,
            },
        },
    },
    propHooks(metadata) {
        const { text } = metadata, others = __rest(metadata, ["text"]);
        if (text) {
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.setByPath(others, 'attrs/label/text', text);
        }
        return others;
    },
    attrHooks: {
        text: {
            set(text, { cell, view, refBBox, elem, attrs }) {
                if (elem instanceof HTMLElement) {
                    elem.textContent = text;
                }
                else {
                    // No foreign object
                    const style = attrs.style || {};
                    const wrapValue = { text, width: -5, height: '100%' };
                    const wrapAttrs = Object.assign({ textVerticalAnchor: 'middle' }, style);
                    const textWrap = _registry__WEBPACK_IMPORTED_MODULE_1__.Attr.presets.textWrap;
                    _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(textWrap.set, this, wrapValue, {
                        cell,
                        view,
                        elem,
                        refBBox,
                        attrs: wrapAttrs,
                    });
                    return { fill: style.color || null };
                }
            },
            position(text, { refBBox, elem }) {
                if (elem instanceof SVGElement) {
                    return refBBox.getCenter();
                }
            },
        },
    },
});
//# sourceMappingURL=text-block.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/shape/util.js":
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/shape/util.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createShape: () => (/* binding */ createShape),
/* harmony export */   getImageUrlHook: () => (/* binding */ getImageUrlHook),
/* harmony export */   getMarkup: () => (/* binding */ getMarkup)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./node_modules/@antv/x6/es/shape/base.js");
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};


function getMarkup(tagName, selector = 'body') {
    return [
        {
            tagName,
            selector,
        },
        {
            tagName: 'text',
            selector: 'label',
        },
    ];
}
function getImageUrlHook(attrName = 'xlink:href') {
    const hook = (metadata) => {
        const { imageUrl, imageWidth, imageHeight } = metadata, others = __rest(metadata, ["imageUrl", "imageWidth", "imageHeight"]);
        if (imageUrl != null || imageWidth != null || imageHeight != null) {
            const apply = () => {
                if (others.attrs) {
                    const image = others.attrs.image;
                    if (imageUrl != null) {
                        image[attrName] = imageUrl;
                    }
                    if (imageWidth != null) {
                        image.width = imageWidth;
                    }
                    if (imageHeight != null) {
                        image.height = imageHeight;
                    }
                    others.attrs.image = image;
                }
            };
            if (others.attrs) {
                if (others.attrs.image == null) {
                    others.attrs.image = {};
                }
                apply();
            }
            else {
                others.attrs = {
                    image: {},
                };
                apply();
            }
        }
        return others;
    };
    return hook;
}
function createShape(shape, config, options = {}) {
    const defaults = {
        constructorName: shape,
        markup: getMarkup(shape, options.selector),
        attrs: {
            [shape]: Object.assign({}, _base__WEBPACK_IMPORTED_MODULE_1__.Base.bodyAttr),
        },
    };
    const base = options.parent || _base__WEBPACK_IMPORTED_MODULE_1__.Base;
    return base.define(_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.merge(defaults, config, { shape }));
}
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/style/raw.js":
/*!***********************************************!*\
  !*** ./node_modules/@antv/x6/es/style/raw.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   content: () => (/* binding */ content)
/* harmony export */ });
/* eslint-disable */
/**
 * Auto generated file, do not modify it!
 */
const content = `.x6-graph {
  position: relative;
  overflow: hidden;
  outline: none;
  touch-action: none;
}
.x6-graph-background,
.x6-graph-grid,
.x6-graph-svg {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}
.x6-graph-background-stage,
.x6-graph-grid-stage,
.x6-graph-svg-stage {
  user-select: none;
}
.x6-graph.x6-graph-pannable {
  cursor: grab;
  cursor: -moz-grab;
  cursor: -webkit-grab;
}
.x6-graph.x6-graph-panning {
  cursor: grabbing;
  cursor: -moz-grabbing;
  cursor: -webkit-grabbing;
  user-select: none;
}
.x6-node {
  cursor: move;
  /* stylelint-disable-next-line */
}
.x6-node.x6-node-immovable {
  cursor: default;
}
.x6-node * {
  -webkit-user-drag: none;
}
.x6-node .scalable * {
  vector-effect: non-scaling-stroke;
}
.x6-node [magnet='true'] {
  cursor: crosshair;
  transition: opacity 0.3s;
}
.x6-node [magnet='true']:hover {
  opacity: 0.7;
}
.x6-node foreignObject {
  display: block;
  overflow: visible;
  background-color: transparent;
}
.x6-node foreignObject > body {
  position: static;
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: visible;
  background-color: transparent;
}
.x6-edge .source-marker,
.x6-edge .target-marker {
  vector-effect: non-scaling-stroke;
}
.x6-edge .connection {
  stroke-linejoin: round;
  fill: none;
}
.x6-edge .connection-wrap {
  cursor: move;
  opacity: 0;
  fill: none;
  stroke: #000;
  stroke-width: 15;
  stroke-linecap: round;
  stroke-linejoin: round;
}
.x6-edge .connection-wrap:hover {
  opacity: 0.4;
  stroke-opacity: 0.4;
}
.x6-edge .vertices {
  cursor: move;
  opacity: 0;
}
.x6-edge .vertices .vertex {
  fill: #1abc9c;
}
.x6-edge .vertices .vertex :hover {
  fill: #34495e;
  stroke: none;
}
.x6-edge .vertices .vertex-remove {
  cursor: pointer;
  fill: #fff;
}
.x6-edge .vertices .vertex-remove-area {
  cursor: pointer;
  opacity: 0.1;
}
.x6-edge .vertices .vertex-group:hover .vertex-remove-area {
  opacity: 1;
}
.x6-edge .arrowheads {
  cursor: move;
  opacity: 0;
}
.x6-edge .arrowheads .arrowhead {
  fill: #1abc9c;
}
.x6-edge .arrowheads .arrowhead :hover {
  fill: #f39c12;
  stroke: none;
}
.x6-edge .tools {
  cursor: pointer;
  opacity: 0;
}
.x6-edge .tools .tool-options {
  display: none;
}
.x6-edge .tools .tool-remove circle {
  fill: #f00;
}
.x6-edge .tools .tool-remove path {
  fill: #fff;
}
.x6-edge:hover .vertices,
.x6-edge:hover .arrowheads,
.x6-edge:hover .tools {
  opacity: 1;
}
.x6-highlight-opacity {
  opacity: 0.3;
}
.x6-cell-tool-editor {
  position: relative;
  display: inline-block;
  min-height: 1em;
  margin: 0;
  padding: 0;
  line-height: 1;
  white-space: normal;
  text-align: center;
  vertical-align: top;
  overflow-wrap: normal;
  outline: none;
  transform-origin: 0 0;
  -webkit-user-drag: none;
}
.x6-edge-tool-editor {
  border: 1px solid #275fc5;
  border-radius: 2px;
}
`;
//# sourceMappingURL=raw.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/util/index.js":
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/util/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Util: () => (/* binding */ Util)
/* harmony export */ });
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _registry_marker_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../registry/marker/util */ "./node_modules/@antv/x6/es/registry/marker/util.js");



var Util;
(function (Util) {
    Util.normalizeMarker = _registry_marker_util__WEBPACK_IMPORTED_MODULE_2__.normalize;
    /**
     * Transforms point by an SVG transformation represented by `matrix`.
     */
    function transformPoint(point, matrix) {
        const ret = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.createSVGPoint(point.x, point.y).matrixTransform(matrix);
        return new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(ret.x, ret.y);
    }
    Util.transformPoint = transformPoint;
    /**
     * Transforms line by an SVG transformation represented by `matrix`.
     */
    function transformLine(line, matrix) {
        return new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Line(transformPoint(line.start, matrix), transformPoint(line.end, matrix));
    }
    Util.transformLine = transformLine;
    /**
     * Transforms polyline by an SVG transformation represented by `matrix`.
     */
    function transformPolyline(polyline, matrix) {
        let points = polyline instanceof _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Polyline ? polyline.points : polyline;
        if (!Array.isArray(points)) {
            points = [];
        }
        return new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Polyline(points.map((p) => transformPoint(p, matrix)));
    }
    Util.transformPolyline = transformPolyline;
    function transformRectangle(rect, matrix) {
        const svgDocument = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.createSvgElement('svg');
        const p = svgDocument.createSVGPoint();
        p.x = rect.x;
        p.y = rect.y;
        const corner1 = p.matrixTransform(matrix);
        p.x = rect.x + rect.width;
        p.y = rect.y;
        const corner2 = p.matrixTransform(matrix);
        p.x = rect.x + rect.width;
        p.y = rect.y + rect.height;
        const corner3 = p.matrixTransform(matrix);
        p.x = rect.x;
        p.y = rect.y + rect.height;
        const corner4 = p.matrixTransform(matrix);
        const minX = Math.min(corner1.x, corner2.x, corner3.x, corner4.x);
        const maxX = Math.max(corner1.x, corner2.x, corner3.x, corner4.x);
        const minY = Math.min(corner1.y, corner2.y, corner3.y, corner4.y);
        const maxY = Math.max(corner1.y, corner2.y, corner3.y, corner4.y);
        return new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle(minX, minY, maxX - minX, maxY - minY);
    }
    Util.transformRectangle = transformRectangle;
    /**
     * Returns the bounding box of the element after transformations are
     * applied. If `withoutTransformations` is `true`, transformations of
     * the element will not be considered when computing the bounding box.
     * If `target` is specified, bounding box will be computed relatively
     * to the `target` element.
     */
    function bbox(elem, withoutTransformations, target) {
        let box;
        const ownerSVGElement = elem.ownerSVGElement;
        // If the element is not in the live DOM, it does not have a bounding
        // box defined and so fall back to 'zero' dimension element.
        if (!ownerSVGElement) {
            return new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle(0, 0, 0, 0);
        }
        try {
            box = elem.getBBox();
        }
        catch (e) {
            // Fallback for IE.
            box = {
                x: elem.clientLeft,
                y: elem.clientTop,
                width: elem.clientWidth,
                height: elem.clientHeight,
            };
        }
        if (withoutTransformations) {
            return _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle.create(box);
        }
        const matrix = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.getTransformToElement(elem, target || ownerSVGElement);
        return transformRectangle(box, matrix);
    }
    Util.bbox = bbox;
    /**
     * Returns the bounding box of the element after transformations are
     * applied. Unlike `bbox()`, this function fixes a browser implementation
     * bug to return the correct bounding box if this elemenent is a group of
     * svg elements (if `options.recursive` is specified).
     */
    function getBBox(elem, options = {}) {
        let outputBBox;
        const ownerSVGElement = elem.ownerSVGElement;
        // If the element is not in the live DOM, it does not have a bounding box
        // defined and so fall back to 'zero' dimension element.
        // If the element is not an SVGGraphicsElement, we could not measure the
        // bounding box either
        if (!ownerSVGElement || !_antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.isSVGGraphicsElement(elem)) {
            if (_antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.isHTMLElement(elem)) {
                // If the element is a HTMLElement, return the position relative to the body
                const { left, top, width, height } = getBoundingOffsetRect(elem);
                return new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle(left, top, width, height);
            }
            return new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle(0, 0, 0, 0);
        }
        let target = options.target;
        const recursive = options.recursive;
        if (!recursive) {
            try {
                outputBBox = elem.getBBox();
            }
            catch (e) {
                outputBBox = {
                    x: elem.clientLeft,
                    y: elem.clientTop,
                    width: elem.clientWidth,
                    height: elem.clientHeight,
                };
            }
            if (!target) {
                return _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle.create(outputBBox);
            }
            // transform like target
            const matrix = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.getTransformToElement(elem, target);
            return transformRectangle(outputBBox, matrix);
        }
        // recursive
        {
            const children = elem.childNodes;
            const n = children.length;
            if (n === 0) {
                return getBBox(elem, {
                    target,
                });
            }
            if (!target) {
                target = elem; // eslint-disable-line
            }
            for (let i = 0; i < n; i += 1) {
                const child = children[i];
                let childBBox;
                if (child.childNodes.length === 0) {
                    childBBox = getBBox(child, {
                        target,
                    });
                }
                else {
                    // if child is a group element, enter it with a recursive call
                    childBBox = getBBox(child, {
                        target,
                        recursive: true,
                    });
                }
                if (!outputBBox) {
                    outputBBox = childBBox;
                }
                else {
                    outputBBox = outputBBox.union(childBBox);
                }
            }
            return outputBBox;
        }
    }
    Util.getBBox = getBBox;
    function getBoundingOffsetRect(elem) {
        let left = 0;
        let top = 0;
        let width = 0;
        let height = 0;
        if (elem) {
            let current = elem;
            while (current) {
                left += current.offsetLeft;
                top += current.offsetTop;
                current = current.offsetParent;
                if (current) {
                    left += parseInt(_antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.getComputedStyle(current, 'borderLeft'), 10);
                    top += parseInt(_antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.getComputedStyle(current, 'borderTop'), 10);
                }
            }
            width = elem.offsetWidth;
            height = elem.offsetHeight;
        }
        return {
            left,
            top,
            width,
            height,
        };
    }
    Util.getBoundingOffsetRect = getBoundingOffsetRect;
    /**
     * Convert the SVGElement to an equivalent geometric shape. The element's
     * transformations are not taken into account.
     *
     * SVGRectElement      => Rectangle
     *
     * SVGLineElement      => Line
     *
     * SVGCircleElement    => Ellipse
     *
     * SVGEllipseElement   => Ellipse
     *
     * SVGPolygonElement   => Polyline
     *
     * SVGPolylineElement  => Polyline
     *
     * SVGPathElement      => Path
     *
     * others              => Rectangle
     */
    function toGeometryShape(elem) {
        const attr = (name) => {
            const s = elem.getAttribute(name);
            const v = s ? parseFloat(s) : 0;
            return Number.isNaN(v) ? 0 : v;
        };
        switch (elem instanceof SVGElement && elem.nodeName.toLowerCase()) {
            case 'rect':
                return new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle(attr('x'), attr('y'), attr('width'), attr('height'));
            case 'circle':
                return new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Ellipse(attr('cx'), attr('cy'), attr('r'), attr('r'));
            case 'ellipse':
                return new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Ellipse(attr('cx'), attr('cy'), attr('rx'), attr('ry'));
            case 'polyline': {
                const points = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.getPointsFromSvgElement(elem);
                return new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Polyline(points);
            }
            case 'polygon': {
                const points = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.getPointsFromSvgElement(elem);
                if (points.length > 1) {
                    points.push(points[0]);
                }
                return new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Polyline(points);
            }
            case 'path': {
                let d = elem.getAttribute('d');
                if (!_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Path.isValid(d)) {
                    d = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Path.normalize(d);
                }
                return _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Path.parse(d);
            }
            case 'line': {
                return new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Line(attr('x1'), attr('y1'), attr('x2'), attr('y2'));
            }
            default:
                break;
        }
        // Anything else is a rectangle
        return getBBox(elem);
    }
    Util.toGeometryShape = toGeometryShape;
    function translateAndAutoOrient(elem, position, reference, target) {
        const pos = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(position);
        const ref = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(reference);
        if (!target) {
            const svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement;
            target = svg; // eslint-disable-line
        }
        // Clean-up previously set transformations except the scale.
        // If we didn't clean up the previous transformations then they'd
        // add up with the old ones. Scale is an exception as it doesn't
        // add up, consider: `this.scale(2).scale(2).scale(2)`. The result
        // is that the element is scaled by the factor 2, not 8.
        const s = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.scale(elem);
        elem.setAttribute('transform', '');
        const bbox = getBBox(elem, {
            target,
        }).scale(s.sx, s.sy);
        // 1. Translate to origin.
        const translateToOrigin = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.createSVGTransform();
        translateToOrigin.setTranslate(-bbox.x - bbox.width / 2, -bbox.y - bbox.height / 2);
        // 2. Rotate around origin.
        const rotateAroundOrigin = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.createSVGTransform();
        const angle = pos.angleBetween(ref, pos.clone().translate(1, 0));
        if (angle)
            rotateAroundOrigin.setRotate(angle, 0, 0);
        // 3. Translate to the `position` + the offset (half my width)
        //    towards the `reference` point.
        const translateFromOrigin = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.createSVGTransform();
        const finalPosition = pos.clone().move(ref, bbox.width / 2);
        translateFromOrigin.setTranslate(2 * pos.x - finalPosition.x, 2 * pos.y - finalPosition.y);
        // 4. Get the current transformation matrix of this node
        const ctm = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.getTransformToElement(elem, target);
        // 5. Apply transformations and the scale
        const transform = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.createSVGTransform();
        transform.setMatrix(translateFromOrigin.matrix.multiply(rotateAroundOrigin.matrix.multiply(translateToOrigin.matrix.multiply(ctm.scale(s.sx, s.sy)))));
        elem.setAttribute('transform', _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.matrixToTransformString(transform.matrix));
    }
    Util.translateAndAutoOrient = translateAndAutoOrient;
    function findShapeNode(magnet) {
        if (magnet == null) {
            return null;
        }
        let node = magnet;
        do {
            let tagName = node.tagName;
            if (typeof tagName !== 'string')
                return null;
            tagName = tagName.toUpperCase();
            if (_antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.hasClass(node, 'x6-port')) {
                node = node.nextElementSibling;
            }
            else if (tagName === 'G') {
                node = node.firstElementChild;
            }
            else if (tagName === 'TITLE') {
                node = node.nextElementSibling;
            }
            else
                break;
        } while (node);
        return node;
    }
    Util.findShapeNode = findShapeNode;
    // BBox is calculated by the attribute and shape of the node.
    // Because of the reduction in DOM API calls, there is a significant performance improvement.
    function getBBoxV2(elem) {
        const node = findShapeNode(elem);
        if (!_antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.isSVGGraphicsElement(node)) {
            if (_antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.isHTMLElement(elem)) {
                const { left, top, width, height } = getBoundingOffsetRect(elem);
                return new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle(left, top, width, height);
            }
            return new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle(0, 0, 0, 0);
        }
        const shape = toGeometryShape(node);
        const bbox = shape.bbox() || _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle.create();
        // const transform = node.getAttribute('transform')
        // if (transform) {
        //   const nodeMatrix = Dom.transformStringToMatrix(transform)
        //   return transformRectangle(bbox, nodeMatrix)
        // }
        return bbox;
    }
    Util.getBBoxV2 = getBBoxV2;
})(Util || (Util = {}));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/view/attr.js":
/*!***********************************************!*\
  !*** ./node_modules/@antv/x6/es/view/attr.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AttrManager: () => (/* binding */ AttrManager)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _registry_attr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../registry/attr */ "./node_modules/@antv/x6/es/registry/attr/index.js");
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./view */ "./node_modules/@antv/x6/es/view/view.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/x6/es/util/index.js");





class AttrManager {
    constructor(view) {
        this.view = view;
    }
    get cell() {
        return this.view.cell;
    }
    getDefinition(attrName) {
        return this.cell.getAttrDefinition(attrName);
    }
    processAttrs(elem, raw) {
        let normal;
        let set;
        let offset;
        let position;
        const specials = [];
        // divide the attributes between normal and special
        Object.keys(raw).forEach((name) => {
            const val = raw[name];
            const definition = this.getDefinition(name);
            const isValid = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(_registry_attr__WEBPACK_IMPORTED_MODULE_2__.Attr.isValidDefinition, this.view, definition, val, {
                elem,
                attrs: raw,
                cell: this.cell,
                view: this.view,
            });
            if (definition && isValid) {
                if (typeof definition === 'string') {
                    if (normal == null) {
                        normal = {};
                    }
                    normal[definition] = val;
                }
                else if (val !== null) {
                    specials.push({ name, definition });
                }
            }
            else {
                if (normal == null) {
                    normal = {};
                }
                const normalName = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.CASE_SENSITIVE_ATTR.includes(name)
                    ? name
                    : _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.StringExt.kebabCase(name);
                normal[normalName] = val;
            }
        });
        specials.forEach(({ name, definition }) => {
            const val = raw[name];
            const setDefine = definition;
            if (typeof setDefine.set === 'function') {
                if (set == null) {
                    set = {};
                }
                set[name] = val;
            }
            const offsetDefine = definition;
            if (typeof offsetDefine.offset === 'function') {
                if (offset == null) {
                    offset = {};
                }
                offset[name] = val;
            }
            const positionDefine = definition;
            if (typeof positionDefine.position === 'function') {
                if (position == null) {
                    position = {};
                }
                position[name] = val;
            }
        });
        return {
            raw,
            normal,
            set,
            offset,
            position,
        };
    }
    mergeProcessedAttrs(allProcessedAttrs, roProcessedAttrs) {
        allProcessedAttrs.set = Object.assign(Object.assign({}, allProcessedAttrs.set), roProcessedAttrs.set);
        allProcessedAttrs.position = Object.assign(Object.assign({}, allProcessedAttrs.position), roProcessedAttrs.position);
        allProcessedAttrs.offset = Object.assign(Object.assign({}, allProcessedAttrs.offset), roProcessedAttrs.offset);
        // Handle also the special transform property.
        const transform = allProcessedAttrs.normal && allProcessedAttrs.normal.transform;
        if (transform != null && roProcessedAttrs.normal) {
            roProcessedAttrs.normal.transform = transform;
        }
        allProcessedAttrs.normal = roProcessedAttrs.normal;
    }
    findAttrs(cellAttrs, rootNode, selectorCache, selectors) {
        const merge = [];
        const result = new _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dictionary();
        Object.keys(cellAttrs).forEach((selector) => {
            const attrs = cellAttrs[selector];
            if (!_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.isPlainObject(attrs)) {
                return;
            }
            const { isCSSSelector, elems } = _view__WEBPACK_IMPORTED_MODULE_3__.View.find(selector, rootNode, selectors);
            selectorCache[selector] = elems;
            for (let i = 0, l = elems.length; i < l; i += 1) {
                const elem = elems[i];
                const unique = selectors && selectors[selector] === elem;
                const prev = result.get(elem);
                if (prev) {
                    if (!prev.array) {
                        merge.push(elem);
                        prev.array = true;
                        prev.attrs = [prev.attrs];
                        prev.priority = [prev.priority];
                    }
                    const attributes = prev.attrs;
                    const selectedLength = prev.priority;
                    if (unique) {
                        // node referenced by `selector`
                        attributes.unshift(attrs);
                        selectedLength.unshift(-1);
                    }
                    else {
                        // node referenced by `groupSelector` or CSSSelector
                        const sortIndex = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.sortedIndex(selectedLength, isCSSSelector ? -1 : l);
                        attributes.splice(sortIndex, 0, attrs);
                        selectedLength.splice(sortIndex, 0, l);
                    }
                }
                else {
                    result.set(elem, {
                        elem,
                        attrs,
                        priority: unique ? -1 : l,
                        array: false,
                    });
                }
            }
        });
        merge.forEach((node) => {
            const item = result.get(node);
            const arr = item.attrs;
            item.attrs = arr.reduceRight((memo, attrs) => _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.merge(memo, attrs), {});
        });
        return result;
    }
    updateRelativeAttrs(elem, processedAttrs, refBBox) {
        const rawAttrs = processedAttrs.raw || {};
        let nodeAttrs = processedAttrs.normal || {};
        const setAttrs = processedAttrs.set;
        const positionAttrs = processedAttrs.position;
        const offsetAttrs = processedAttrs.offset;
        const getOptions = () => ({
            elem,
            cell: this.cell,
            view: this.view,
            attrs: rawAttrs,
            refBBox: refBBox.clone(),
        });
        if (setAttrs != null) {
            Object.keys(setAttrs).forEach((name) => {
                const val = setAttrs[name];
                const def = this.getDefinition(name);
                if (def != null) {
                    const ret = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(def.set, this.view, val, getOptions());
                    if (typeof ret === 'object') {
                        nodeAttrs = Object.assign(Object.assign({}, nodeAttrs), ret);
                    }
                    else if (ret != null) {
                        nodeAttrs[name] = ret;
                    }
                }
            });
        }
        if (elem instanceof HTMLElement) {
            // TODO: setting the `transform` attribute on HTMLElements
            // via `node.style.transform = 'matrix(...)';` would introduce
            // a breaking change (e.g. basic.TextBlock).
            this.view.setAttrs(nodeAttrs, elem);
            return;
        }
        // The final translation of the subelement.
        const nodeTransform = nodeAttrs.transform;
        const transform = nodeTransform ? `${nodeTransform}` : null;
        const nodeMatrix = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.transformStringToMatrix(transform);
        const nodePosition = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point(nodeMatrix.e, nodeMatrix.f);
        if (nodeTransform) {
            delete nodeAttrs.transform;
            nodeMatrix.e = 0;
            nodeMatrix.f = 0;
        }
        let positioned = false;
        if (positionAttrs != null) {
            Object.keys(positionAttrs).forEach((name) => {
                const val = positionAttrs[name];
                const def = this.getDefinition(name);
                if (def != null) {
                    const ts = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(def.position, this.view, val, getOptions());
                    if (ts != null) {
                        positioned = true;
                        nodePosition.translate(_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(ts));
                    }
                }
            });
        }
        // The node bounding box could depend on the `size`
        // set from the previous loop.
        this.view.setAttrs(nodeAttrs, elem);
        let offseted = false;
        if (offsetAttrs != null) {
            // Check if the node is visible
            const nodeBoundingRect = this.view.getBoundingRectOfElement(elem);
            if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {
                const nodeBBox = _util__WEBPACK_IMPORTED_MODULE_4__.Util.transformRectangle(nodeBoundingRect, nodeMatrix);
                Object.keys(offsetAttrs).forEach((name) => {
                    const val = offsetAttrs[name];
                    const def = this.getDefinition(name);
                    if (def != null) {
                        const ts = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(def.offset, this.view, val, {
                            elem,
                            cell: this.cell,
                            view: this.view,
                            attrs: rawAttrs,
                            refBBox: nodeBBox,
                        });
                        if (ts != null) {
                            offseted = true;
                            nodePosition.translate(_antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(ts));
                        }
                    }
                });
            }
        }
        if (nodeTransform != null || positioned || offseted) {
            nodePosition.round(1);
            nodeMatrix.e = nodePosition.x;
            nodeMatrix.f = nodePosition.y;
            elem.setAttribute('transform', _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.matrixToTransformString(nodeMatrix));
        }
    }
    update(rootNode, attrs, options) {
        const selectorCache = {};
        const nodesAttrs = this.findAttrs(options.attrs || attrs, rootNode, selectorCache, options.selectors);
        // `nodesAttrs` are different from all attributes, when
        // rendering only attributes sent to this method.
        const nodesAllAttrs = options.attrs
            ? this.findAttrs(attrs, rootNode, selectorCache, options.selectors)
            : nodesAttrs;
        const specialItems = [];
        nodesAttrs.each((data) => {
            const node = data.elem;
            const nodeAttrs = data.attrs;
            const processed = this.processAttrs(node, nodeAttrs);
            if (processed.set == null &&
                processed.position == null &&
                processed.offset == null) {
                this.view.setAttrs(processed.normal, node);
            }
            else {
                const data = nodesAllAttrs.get(node);
                const nodeAllAttrs = data ? data.attrs : null;
                const refSelector = nodeAllAttrs && nodeAttrs.ref == null
                    ? nodeAllAttrs.ref
                    : nodeAttrs.ref;
                let refNode;
                if (refSelector) {
                    refNode = (selectorCache[refSelector] ||
                        this.view.find(refSelector, rootNode, options.selectors))[0];
                    if (!refNode) {
                        throw new Error(`"${refSelector}" reference does not exist.`);
                    }
                }
                else {
                    refNode = null;
                }
                const item = {
                    node,
                    refNode,
                    attributes: nodeAllAttrs,
                    processedAttributes: processed,
                };
                // If an element in the list is positioned relative to this one, then
                // we want to insert this one before it in the list.
                const index = specialItems.findIndex((item) => item.refNode === node);
                if (index > -1) {
                    specialItems.splice(index, 0, item);
                }
                else {
                    specialItems.push(item);
                }
            }
        });
        const bboxCache = new _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dictionary();
        let rotatableMatrix;
        specialItems.forEach((item) => {
            const node = item.node;
            const refNode = item.refNode;
            let unrotatedRefBBox;
            const isRefNodeRotatable = refNode != null &&
                options.rotatableNode != null &&
                _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.contains(options.rotatableNode, refNode);
            // Find the reference element bounding box. If no reference was
            // provided, we use the optional bounding box.
            if (refNode) {
                unrotatedRefBBox = bboxCache.get(refNode);
            }
            if (!unrotatedRefBBox) {
                const target = (isRefNodeRotatable ? options.rotatableNode : rootNode);
                unrotatedRefBBox = refNode
                    ? _util__WEBPACK_IMPORTED_MODULE_4__.Util.getBBox(refNode, { target })
                    : options.rootBBox;
                if (refNode) {
                    bboxCache.set(refNode, unrotatedRefBBox);
                }
            }
            let processedAttrs;
            if (options.attrs && item.attributes) {
                // If there was a special attribute affecting the position amongst
                // passed-in attributes we have to merge it with the rest of the
                // element's attributes as they are necessary to update the position
                // relatively (i.e `ref-x` && 'ref-dx').
                processedAttrs = this.processAttrs(node, item.attributes);
                this.mergeProcessedAttrs(processedAttrs, item.processedAttributes);
            }
            else {
                processedAttrs = item.processedAttributes;
            }
            let refBBox = unrotatedRefBBox;
            if (isRefNodeRotatable &&
                options.rotatableNode != null &&
                !options.rotatableNode.contains(node)) {
                // If the referenced node is inside the rotatable group while the
                // updated node is outside, we need to take the rotatable node
                // transformation into account.
                if (!rotatableMatrix) {
                    rotatableMatrix = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.transformStringToMatrix(_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.attr(options.rotatableNode, 'transform'));
                }
                refBBox = _util__WEBPACK_IMPORTED_MODULE_4__.Util.transformRectangle(unrotatedRefBBox, rotatableMatrix);
            }
            this.updateRelativeAttrs(node, processedAttrs, refBBox);
        });
    }
}
//# sourceMappingURL=attr.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/view/cache.js":
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/view/cache.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Cache: () => (/* binding */ Cache)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/x6/es/util/index.js");


class Cache {
    constructor(view) {
        this.view = view;
        this.clean();
    }
    clean() {
        if (this.elemCache) {
            this.elemCache.dispose();
        }
        this.elemCache = new _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dictionary();
        this.pathCache = {};
    }
    get(elem) {
        const cache = this.elemCache;
        if (!cache.has(elem)) {
            this.elemCache.set(elem, {});
        }
        return this.elemCache.get(elem);
    }
    getData(elem) {
        const meta = this.get(elem);
        if (!meta.data) {
            meta.data = {};
        }
        return meta.data;
    }
    getMatrix(elem) {
        const meta = this.get(elem);
        if (meta.matrix == null) {
            const target = this.view.container;
            meta.matrix = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.getTransformToParentElement(elem, target);
        }
        return _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.createSVGMatrix(meta.matrix);
    }
    getShape(elem) {
        const meta = this.get(elem);
        if (meta.shape == null) {
            meta.shape = _util__WEBPACK_IMPORTED_MODULE_1__.Util.toGeometryShape(elem);
        }
        return meta.shape.clone();
    }
    getBoundingRect(elem) {
        const meta = this.get(elem);
        if (meta.boundingRect == null) {
            meta.boundingRect = _util__WEBPACK_IMPORTED_MODULE_1__.Util.getBBoxV2(elem);
        }
        return meta.boundingRect.clone();
    }
}
//# sourceMappingURL=cache.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/view/cell.js":
/*!***********************************************!*\
  !*** ./node_modules/@antv/x6/es/view/cell.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CellView: () => (/* binding */ CellView)
/* harmony export */ });
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _registry_registry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../registry/registry */ "./node_modules/@antv/x6/es/registry/registry.js");
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./view */ "./node_modules/@antv/x6/es/view/view.js");
/* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cache */ "./node_modules/@antv/x6/es/view/cache.js");
/* harmony import */ var _markup__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./markup */ "./node_modules/@antv/x6/es/view/markup.js");
/* harmony import */ var _tool__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tool */ "./node_modules/@antv/x6/es/view/tool.js");
/* harmony import */ var _attr__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./attr */ "./node_modules/@antv/x6/es/view/attr.js");
/* harmony import */ var _flag__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./flag */ "./node_modules/@antv/x6/es/view/flag.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/x6/es/util/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
/* eslint-disable @typescript-eslint/no-unused-vars */










class CellView extends _view__WEBPACK_IMPORTED_MODULE_3__.View {
    static getDefaults() {
        return this.defaults;
    }
    static config(options) {
        this.defaults = this.getOptions(options);
    }
    static getOptions(options) {
        const mergeActions = (arr1, arr2) => {
            if (arr2 != null) {
                return _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.ArrayExt.uniq([
                    ...(Array.isArray(arr1) ? arr1 : [arr1]),
                    ...(Array.isArray(arr2) ? arr2 : [arr2]),
                ]);
            }
            return Array.isArray(arr1) ? [...arr1] : [arr1];
        };
        const ret = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.cloneDeep(this.getDefaults());
        const { bootstrap, actions, events, documentEvents } = options, others = __rest(options, ["bootstrap", "actions", "events", "documentEvents"]);
        if (bootstrap) {
            ret.bootstrap = mergeActions(ret.bootstrap, bootstrap);
        }
        if (actions) {
            Object.entries(actions).forEach(([key, val]) => {
                const raw = ret.actions[key];
                if (val && raw) {
                    ret.actions[key] = mergeActions(raw, val);
                }
                else if (val) {
                    ret.actions[key] = mergeActions(val);
                }
            });
        }
        if (events) {
            ret.events = Object.assign(Object.assign({}, ret.events), events);
        }
        if (options.documentEvents) {
            ret.documentEvents = Object.assign(Object.assign({}, ret.documentEvents), documentEvents);
        }
        return _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.merge(ret, others);
    }
    get [Symbol.toStringTag]() {
        return CellView.toStringTag;
    }
    constructor(cell, options = {}) {
        super();
        this.cell = cell;
        this.options = this.ensureOptions(options);
        this.graph = this.options.graph;
        this.attr = new _attr__WEBPACK_IMPORTED_MODULE_7__.AttrManager(this);
        this.flag = new _flag__WEBPACK_IMPORTED_MODULE_8__.FlagManager(this, this.options.actions, this.options.bootstrap);
        this.cache = new _cache__WEBPACK_IMPORTED_MODULE_4__.Cache(this);
        this.setContainer(this.ensureContainer());
        this.setup();
        this.init();
    }
    init() { }
    onRemove() {
        this.removeTools();
    }
    get priority() {
        return this.options.priority;
    }
    get rootSelector() {
        return this.options.rootSelector;
    }
    getConstructor() {
        return this.constructor;
    }
    ensureOptions(options) {
        return this.getConstructor().getOptions(options);
    }
    getContainerTagName() {
        return this.options.isSvgElement ? 'g' : 'div';
    }
    getContainerStyle() { }
    getContainerAttrs() {
        return {
            'data-cell-id': this.cell.id,
            'data-shape': this.cell.shape,
        };
    }
    getContainerClassName() {
        return this.prefixClassName('cell');
    }
    ensureContainer() {
        return _view__WEBPACK_IMPORTED_MODULE_3__.View.createElement(this.getContainerTagName(), this.options.isSvgElement);
    }
    setContainer(container) {
        if (this.container !== container) {
            this.undelegateEvents();
            this.container = container;
            if (this.options.events != null) {
                this.delegateEvents(this.options.events);
            }
            const attrs = this.getContainerAttrs();
            if (attrs != null) {
                this.setAttrs(attrs, container);
            }
            const style = this.getContainerStyle();
            if (style != null) {
                this.setStyle(style, container);
            }
            const className = this.getContainerClassName();
            if (className != null) {
                this.addClass(className, container);
            }
        }
        return this;
    }
    isNodeView() {
        return false;
    }
    isEdgeView() {
        return false;
    }
    render() {
        return this;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    confirmUpdate(flag, options = {}) {
        return 0;
    }
    getBootstrapFlag() {
        return this.flag.getBootstrapFlag();
    }
    getFlag(actions) {
        return this.flag.getFlag(actions);
    }
    hasAction(flag, actions) {
        return this.flag.hasAction(flag, actions);
    }
    removeAction(flag, actions) {
        return this.flag.removeAction(flag, actions);
    }
    handleAction(flag, action, handle, additionalRemovedActions) {
        if (this.hasAction(flag, action)) {
            handle();
            const removedFlags = [action];
            if (additionalRemovedActions) {
                if (typeof additionalRemovedActions === 'string') {
                    removedFlags.push(additionalRemovedActions);
                }
                else {
                    removedFlags.push(...additionalRemovedActions);
                }
            }
            return this.removeAction(flag, removedFlags);
        }
        return flag;
    }
    setup() {
        this.cell.on('changed', this.onCellChanged, this);
    }
    onCellChanged({ options }) {
        this.onAttrsChange(options);
    }
    onAttrsChange(options) {
        let flag = this.flag.getChangedFlag();
        if (options.updated || !flag) {
            return;
        }
        if (options.dirty && this.hasAction(flag, 'update')) {
            flag |= this.getFlag('render'); // eslint-disable-line no-bitwise
        }
        // tool changes should be sync render
        if (options.toolId) {
            options.async = false;
        }
        if (this.graph != null) {
            this.graph.renderer.requestViewUpdate(this, flag, options);
        }
    }
    parseJSONMarkup(markup, rootElem) {
        const result = _markup__WEBPACK_IMPORTED_MODULE_5__.Markup.parseJSONMarkup(markup);
        const selectors = result.selectors;
        const rootSelector = this.rootSelector;
        if (rootElem && rootSelector) {
            if (selectors[rootSelector]) {
                throw new Error('Invalid root selector');
            }
            selectors[rootSelector] = rootElem;
        }
        return result;
    }
    can(feature) {
        let interacting = this.graph.options.interacting;
        if (typeof interacting === 'function') {
            interacting = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(interacting, this.graph, this);
        }
        if (typeof interacting === 'object') {
            let val = interacting[feature];
            if (typeof val === 'function') {
                val = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(val, this.graph, this);
            }
            return val !== false;
        }
        if (typeof interacting === 'boolean') {
            return interacting;
        }
        return false;
    }
    cleanCache() {
        this.cache.clean();
        return this;
    }
    getCache(elem) {
        return this.cache.get(elem);
    }
    getDataOfElement(elem) {
        return this.cache.getData(elem);
    }
    getMatrixOfElement(elem) {
        return this.cache.getMatrix(elem);
    }
    getShapeOfElement(elem) {
        return this.cache.getShape(elem);
    }
    getBoundingRectOfElement(elem) {
        return this.cache.getBoundingRect(elem);
    }
    getBBoxOfElement(elem) {
        const rect = this.getBoundingRectOfElement(elem);
        const matrix = this.getMatrixOfElement(elem);
        const rm = this.getRootRotatedMatrix();
        const tm = this.getRootTranslatedMatrix();
        return _util__WEBPACK_IMPORTED_MODULE_9__.Util.transformRectangle(rect, tm.multiply(rm).multiply(matrix));
    }
    getUnrotatedBBoxOfElement(elem) {
        const rect = this.getBoundingRectOfElement(elem);
        const matrix = this.getMatrixOfElement(elem);
        const tm = this.getRootTranslatedMatrix();
        return _util__WEBPACK_IMPORTED_MODULE_9__.Util.transformRectangle(rect, tm.multiply(matrix));
    }
    getBBox(options = {}) {
        let bbox;
        if (options.useCellGeometry) {
            const cell = this.cell;
            const angle = cell.isNode() ? cell.getAngle() : 0;
            bbox = cell.getBBox().bbox(angle);
        }
        else {
            bbox = this.getBBoxOfElement(this.container);
        }
        return this.graph.coord.localToGraphRect(bbox);
    }
    getRootTranslatedMatrix() {
        const cell = this.cell;
        const pos = cell.isNode() ? cell.getPosition() : { x: 0, y: 0 };
        return _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.createSVGMatrix().translate(pos.x, pos.y);
    }
    getRootRotatedMatrix() {
        let matrix = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.createSVGMatrix();
        const cell = this.cell;
        const angle = cell.isNode() ? cell.getAngle() : 0;
        if (angle) {
            const bbox = cell.getBBox();
            const cx = bbox.width / 2;
            const cy = bbox.height / 2;
            matrix = matrix.translate(cx, cy).rotate(angle).translate(-cx, -cy);
        }
        return matrix;
    }
    findMagnet(elem = this.container) {
        return this.findByAttr('magnet', elem);
    }
    updateAttrs(rootNode, attrs, options = {}) {
        if (options.rootBBox == null) {
            options.rootBBox = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle();
        }
        if (options.selectors == null) {
            options.selectors = this.selectors;
        }
        this.attr.update(rootNode, attrs, options);
    }
    isEdgeElement(magnet) {
        return this.cell.isEdge() && (magnet == null || magnet === this.container);
    }
    // #region highlight
    prepareHighlight(elem, options = {}) {
        const magnet = elem || this.container;
        options.partial = magnet === this.container;
        return magnet;
    }
    highlight(elem, options = {}) {
        const magnet = this.prepareHighlight(elem, options);
        this.notify('cell:highlight', {
            magnet,
            options,
            view: this,
            cell: this.cell,
        });
        if (this.isEdgeView()) {
            this.notify('edge:highlight', {
                magnet,
                options,
                view: this,
                edge: this.cell,
                cell: this.cell,
            });
        }
        else if (this.isNodeView()) {
            this.notify('node:highlight', {
                magnet,
                options,
                view: this,
                node: this.cell,
                cell: this.cell,
            });
        }
        return this;
    }
    unhighlight(elem, options = {}) {
        const magnet = this.prepareHighlight(elem, options);
        this.notify('cell:unhighlight', {
            magnet,
            options,
            view: this,
            cell: this.cell,
        });
        if (this.isNodeView()) {
            this.notify('node:unhighlight', {
                magnet,
                options,
                view: this,
                node: this.cell,
                cell: this.cell,
            });
        }
        else if (this.isEdgeView()) {
            this.notify('edge:unhighlight', {
                magnet,
                options,
                view: this,
                edge: this.cell,
                cell: this.cell,
            });
        }
        return this;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    notifyUnhighlight(magnet, options) { }
    // #endregion
    getEdgeTerminal(magnet, x, y, edge, type) {
        const cell = this.cell;
        const portId = this.findAttr('port', magnet);
        const selector = magnet.getAttribute('data-selector');
        const terminal = { cell: cell.id };
        if (selector != null) {
            terminal.magnet = selector;
        }
        if (portId != null) {
            terminal.port = portId;
            if (cell.isNode()) {
                if (!cell.hasPort(portId) && selector == null) {
                    // port created via the `port` attribute (not API)
                    terminal.selector = this.getSelector(magnet);
                }
            }
        }
        else if (selector == null && this.container !== magnet) {
            terminal.selector = this.getSelector(magnet);
        }
        return terminal;
    }
    getMagnetFromEdgeTerminal(terminal) {
        const cell = this.cell;
        const root = this.container;
        const portId = terminal.port;
        let selector = terminal.magnet;
        let magnet;
        if (portId != null && cell.isNode() && cell.hasPort(portId)) {
            magnet = this.findPortElem(portId, selector) || root;
        }
        else {
            if (!selector) {
                selector = terminal.selector;
            }
            if (!selector && portId != null) {
                selector = `[port="${portId}"]`;
            }
            magnet = this.findOne(selector, root, this.selectors);
        }
        return magnet;
    }
    hasTools(name) {
        const tools = this.tools;
        if (tools == null) {
            return false;
        }
        if (name == null) {
            return true;
        }
        return tools.name === name;
    }
    addTools(config) {
        this.removeTools();
        if (config) {
            if (!this.can('toolsAddable')) {
                return this;
            }
            const tools = _tool__WEBPACK_IMPORTED_MODULE_6__.ToolsView.isToolsView(config)
                ? config
                : new _tool__WEBPACK_IMPORTED_MODULE_6__.ToolsView(config);
            this.tools = tools;
            tools.config({ view: this });
            tools.mount();
        }
        return this;
    }
    updateTools(options = {}) {
        if (this.tools) {
            this.tools.update(options);
        }
        return this;
    }
    removeTools() {
        if (this.tools) {
            this.tools.remove();
            this.tools = null;
        }
        return this;
    }
    hideTools() {
        if (this.tools) {
            this.tools.hide();
        }
        return this;
    }
    showTools() {
        if (this.tools) {
            this.tools.show();
        }
        return this;
    }
    renderTools() {
        const tools = this.cell.getTools();
        this.addTools(tools);
        return this;
    }
    notify(name, args) {
        this.trigger(name, args);
        this.graph.trigger(name, args);
        return this;
    }
    getEventArgs(e, x, y) {
        const view = this; // eslint-disable-line @typescript-eslint/no-this-alias
        const cell = view.cell;
        if (x == null || y == null) {
            return { e, view, cell };
        }
        return { e, x, y, view, cell };
    }
    onClick(e, x, y) {
        this.notify('cell:click', this.getEventArgs(e, x, y));
    }
    onDblClick(e, x, y) {
        this.notify('cell:dblclick', this.getEventArgs(e, x, y));
    }
    onContextMenu(e, x, y) {
        this.notify('cell:contextmenu', this.getEventArgs(e, x, y));
    }
    onMouseDown(e, x, y) {
        if (this.cell.model) {
            this.cachedModelForMouseEvent = this.cell.model;
            this.cachedModelForMouseEvent.startBatch('mouse');
        }
        this.notify('cell:mousedown', this.getEventArgs(e, x, y));
    }
    onMouseUp(e, x, y) {
        this.notify('cell:mouseup', this.getEventArgs(e, x, y));
        if (this.cachedModelForMouseEvent) {
            this.cachedModelForMouseEvent.stopBatch('mouse', { cell: this.cell });
            this.cachedModelForMouseEvent = null;
        }
    }
    onMouseMove(e, x, y) {
        this.notify('cell:mousemove', this.getEventArgs(e, x, y));
    }
    onMouseOver(e) {
        this.notify('cell:mouseover', this.getEventArgs(e));
    }
    onMouseOut(e) {
        this.notify('cell:mouseout', this.getEventArgs(e));
    }
    onMouseEnter(e) {
        this.notify('cell:mouseenter', this.getEventArgs(e));
    }
    onMouseLeave(e) {
        this.notify('cell:mouseleave', this.getEventArgs(e));
    }
    onMouseWheel(e, x, y, delta) {
        this.notify('cell:mousewheel', Object.assign({ delta }, this.getEventArgs(e, x, y)));
    }
    onCustomEvent(e, name, x, y) {
        this.notify('cell:customevent', Object.assign({ name }, this.getEventArgs(e, x, y)));
        this.notify(name, Object.assign({}, this.getEventArgs(e, x, y)));
    }
    onMagnetMouseDown(e, magnet, x, y) { }
    onMagnetDblClick(e, magnet, x, y) { }
    onMagnetContextMenu(e, magnet, x, y) { }
    onLabelMouseDown(e, x, y) { }
    checkMouseleave(e) {
        const target = this.getEventTarget(e, { fromPoint: true });
        const view = this.graph.findViewByElem(target);
        if (view === this) {
            return;
        }
        // Leaving the current view
        this.onMouseLeave(e);
        if (!view) {
            return;
        }
        // Entering another view
        view.onMouseEnter(e);
    }
    dispose() {
        this.cell.off('changed', this.onCellChanged, this);
    }
}
CellView.defaults = {
    isSvgElement: true,
    rootSelector: 'root',
    priority: 0,
    bootstrap: [],
    actions: {},
};
__decorate([
    CellView.dispose()
], CellView.prototype, "dispose", null);
(function (CellView) {
    CellView.Flag = _flag__WEBPACK_IMPORTED_MODULE_8__.FlagManager;
    CellView.Attr = _attr__WEBPACK_IMPORTED_MODULE_7__.AttrManager;
})(CellView || (CellView = {}));
(function (CellView) {
    CellView.toStringTag = `X6.${CellView.name}`;
    function isCellView(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof CellView) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const view = instance;
        if ((tag == null || tag === CellView.toStringTag) &&
            typeof view.isNodeView === 'function' &&
            typeof view.isEdgeView === 'function' &&
            typeof view.confirmUpdate === 'function') {
            return true;
        }
        return false;
    }
    CellView.isCellView = isCellView;
})(CellView || (CellView = {}));
// decorators
// ----
(function (CellView) {
    function priority(value) {
        return function (ctor) {
            ctor.config({ priority: value });
        };
    }
    CellView.priority = priority;
    function bootstrap(actions) {
        return function (ctor) {
            ctor.config({ bootstrap: actions });
        };
    }
    CellView.bootstrap = bootstrap;
})(CellView || (CellView = {}));
(function (CellView) {
    CellView.registry = _registry_registry__WEBPACK_IMPORTED_MODULE_2__.Registry.create({
        type: 'view',
    });
})(CellView || (CellView = {}));
//# sourceMappingURL=cell.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/view/edge.js":
/*!***********************************************!*\
  !*** ./node_modules/@antv/x6/es/view/edge.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EdgeView: () => (/* binding */ EdgeView)
/* harmony export */ });
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../registry */ "./node_modules/@antv/x6/es/registry/index.js");
/* harmony import */ var _model_edge__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../model/edge */ "./node_modules/@antv/x6/es/model/edge.js");
/* harmony import */ var _cell__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cell */ "./node_modules/@antv/x6/es/view/cell.js");
/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./node */ "./node_modules/@antv/x6/es/view/node.js");
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};






class EdgeView extends _cell__WEBPACK_IMPORTED_MODULE_4__.CellView {
    constructor() {
        super(...arguments);
        this.POINT_ROUNDING = 2;
        this.labelDestroyFn = {};
        // #endregion
    }
    get [Symbol.toStringTag]() {
        return EdgeView.toStringTag;
    }
    getContainerClassName() {
        return [super.getContainerClassName(), this.prefixClassName('edge')].join(' ');
    }
    get sourceBBox() {
        const sourceView = this.sourceView;
        if (!sourceView) {
            const sourceDef = this.cell.getSource();
            return new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle(sourceDef.x, sourceDef.y);
        }
        const sourceMagnet = this.sourceMagnet;
        if (sourceView.isEdgeElement(sourceMagnet)) {
            return new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle(this.sourceAnchor.x, this.sourceAnchor.y);
        }
        return sourceView.getBBoxOfElement(sourceMagnet || sourceView.container);
    }
    get targetBBox() {
        const targetView = this.targetView;
        if (!targetView) {
            const targetDef = this.cell.getTarget();
            return new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle(targetDef.x, targetDef.y);
        }
        const targetMagnet = this.targetMagnet;
        if (targetView.isEdgeElement(targetMagnet)) {
            return new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle(this.targetAnchor.x, this.targetAnchor.y);
        }
        return targetView.getBBoxOfElement(targetMagnet || targetView.container);
    }
    isEdgeView() {
        return true;
    }
    confirmUpdate(flag, options = {}) {
        let ref = flag;
        if (this.hasAction(ref, 'source')) {
            if (!this.updateTerminalProperties('source')) {
                return ref;
            }
            ref = this.removeAction(ref, 'source');
        }
        if (this.hasAction(ref, 'target')) {
            if (!this.updateTerminalProperties('target')) {
                return ref;
            }
            ref = this.removeAction(ref, 'target');
        }
        if (this.hasAction(ref, 'render')) {
            this.render();
            ref = this.removeAction(ref, ['render', 'update', 'labels', 'tools']);
            return ref;
        }
        ref = this.handleAction(ref, 'update', () => this.update(options));
        ref = this.handleAction(ref, 'labels', () => this.onLabelsChange(options));
        ref = this.handleAction(ref, 'tools', () => this.renderTools());
        return ref;
    }
    // #region render
    render() {
        this.empty();
        this.renderMarkup();
        this.labelContainer = null;
        this.renderLabels();
        this.update();
        this.renderTools();
        return this;
    }
    renderMarkup() {
        const markup = this.cell.markup;
        if (markup) {
            if (typeof markup === 'string') {
                throw new TypeError('Not support string markup.');
            }
            return this.renderJSONMarkup(markup);
        }
        throw new TypeError('Invalid edge markup.');
    }
    renderJSONMarkup(markup) {
        const ret = this.parseJSONMarkup(markup, this.container);
        this.selectors = ret.selectors;
        this.container.append(ret.fragment);
    }
    customizeLabels() {
        if (this.labelContainer) {
            const edge = this.cell;
            const labels = edge.labels;
            for (let i = 0, n = labels.length; i < n; i += 1) {
                const label = labels[i];
                const container = this.labelCache[i];
                const selectors = this.labelSelectors[i];
                const onEdgeLabelRendered = this.graph.options.onEdgeLabelRendered;
                if (onEdgeLabelRendered) {
                    const fn = onEdgeLabelRendered({
                        edge,
                        label,
                        container,
                        selectors,
                    });
                    if (fn) {
                        this.labelDestroyFn[i] = fn;
                    }
                }
            }
        }
    }
    destroyCustomizeLabels() {
        const labels = this.cell.labels;
        if (this.labelCache && this.labelSelectors && this.labelDestroyFn) {
            for (let i = 0, n = labels.length; i < n; i += 1) {
                const fn = this.labelDestroyFn[i];
                const container = this.labelCache[i];
                const selectors = this.labelSelectors[i];
                if (fn && container && selectors) {
                    fn({
                        edge: this.cell,
                        label: labels[i],
                        container,
                        selectors,
                    });
                }
            }
        }
        this.labelDestroyFn = {};
    }
    renderLabels() {
        const edge = this.cell;
        const labels = edge.getLabels();
        const count = labels.length;
        let container = this.labelContainer;
        this.labelCache = {};
        this.labelSelectors = {};
        if (count <= 0) {
            if (container && container.parentNode) {
                container.parentNode.removeChild(container);
            }
            return this;
        }
        if (container) {
            this.empty(container);
        }
        else {
            container = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.createSvgElement('g');
            this.addClass(this.prefixClassName('edge-labels'), container);
            this.labelContainer = container;
        }
        for (let i = 0, ii = labels.length; i < ii; i += 1) {
            const label = labels[i];
            const normalized = this.normalizeLabelMarkup(this.parseLabelMarkup(label.markup));
            let labelNode;
            let selectors;
            if (normalized) {
                labelNode = normalized.node;
                selectors = normalized.selectors;
            }
            else {
                const defaultLabel = edge.getDefaultLabel();
                const normalized = this.normalizeLabelMarkup(this.parseLabelMarkup(defaultLabel.markup));
                labelNode = normalized.node;
                selectors = normalized.selectors;
            }
            labelNode.setAttribute('data-index', `${i}`);
            container.appendChild(labelNode);
            const rootSelector = this.rootSelector;
            if (selectors[rootSelector]) {
                throw new Error('Ambiguous label root selector.');
            }
            selectors[rootSelector] = labelNode;
            this.labelCache[i] = labelNode;
            this.labelSelectors[i] = selectors;
        }
        if (container.parentNode == null) {
            this.container.appendChild(container);
        }
        this.updateLabels();
        this.customizeLabels();
        return this;
    }
    onLabelsChange(options = {}) {
        this.destroyCustomizeLabels();
        if (this.shouldRerenderLabels(options)) {
            this.renderLabels();
        }
        else {
            this.updateLabels();
        }
        this.updateLabelPositions();
    }
    shouldRerenderLabels(options = {}) {
        const previousLabels = this.cell.previous('labels');
        if (previousLabels == null) {
            return true;
        }
        // Here is an optimization for cases when we know, that change does
        // not require re-rendering of all labels.
        if ('propertyPathArray' in options && 'propertyValue' in options) {
            // The label is setting by `prop()` method
            const pathArray = options.propertyPathArray || [];
            const pathLength = pathArray.length;
            if (pathLength > 1) {
                // We are changing a single label here e.g. 'labels/0/position'
                const index = pathArray[1];
                if (previousLabels[index]) {
                    if (pathLength === 2) {
                        // We are changing the entire label. Need to check if the
                        // markup is also being changed.
                        return (typeof options.propertyValue === 'object' &&
                            _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.has(options.propertyValue, 'markup'));
                    }
                    // We are changing a label property but not the markup
                    if (pathArray[2] !== 'markup') {
                        return false;
                    }
                }
            }
        }
        return true;
    }
    parseLabelMarkup(markup) {
        if (markup) {
            if (typeof markup === 'string') {
                return this.parseLabelStringMarkup(markup);
            }
            return this.parseJSONMarkup(markup);
        }
        return null;
    }
    parseLabelStringMarkup(labelMarkup) {
        const children = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Vector.createVectors(labelMarkup);
        const fragment = document.createDocumentFragment();
        for (let i = 0, n = children.length; i < n; i += 1) {
            const currentChild = children[i].node;
            fragment.appendChild(currentChild);
        }
        return { fragment, selectors: {} };
    }
    normalizeLabelMarkup(markup) {
        if (markup == null) {
            return;
        }
        const fragment = markup.fragment;
        if (!(fragment instanceof DocumentFragment) || !fragment.hasChildNodes()) {
            throw new Error('Invalid label markup.');
        }
        let vel;
        const childNodes = fragment.childNodes;
        if (childNodes.length > 1 || childNodes[0].nodeName.toUpperCase() !== 'G') {
            vel = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Vector.create('g').append(fragment);
        }
        else {
            vel = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Vector.create(childNodes[0]);
        }
        vel.addClass(this.prefixClassName('edge-label'));
        return {
            node: vel.node,
            selectors: markup.selectors,
        };
    }
    updateLabels() {
        if (this.labelContainer) {
            const edge = this.cell;
            const labels = edge.labels;
            const canLabelMove = this.can('edgeLabelMovable');
            const defaultLabel = edge.getDefaultLabel();
            for (let i = 0, n = labels.length; i < n; i += 1) {
                const elem = this.labelCache[i];
                const selectors = this.labelSelectors[i];
                elem.setAttribute('cursor', canLabelMove ? 'move' : 'default');
                const label = labels[i];
                const attrs = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.merge({}, defaultLabel.attrs, label.attrs);
                this.updateAttrs(elem, attrs, {
                    selectors,
                    rootBBox: label.size ? _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Rectangle.fromSize(label.size) : undefined,
                });
            }
        }
    }
    renderTools() {
        const tools = this.cell.getTools();
        this.addTools(tools);
        return this;
    }
    // #endregion
    // #region updating
    update(options = {}) {
        this.cleanCache();
        this.updateConnection(options);
        const _a = this.cell.getAttrs(), { text } = _a, attrs = __rest(_a, ["text"]);
        if (attrs != null) {
            this.updateAttrs(this.container, attrs, {
                selectors: this.selectors,
            });
        }
        this.updateLabelPositions();
        this.updateTools(options);
        return this;
    }
    removeRedundantLinearVertices(options = {}) {
        const edge = this.cell;
        const vertices = edge.getVertices();
        const routePoints = [this.sourceAnchor, ...vertices, this.targetAnchor];
        const rawCount = routePoints.length;
        // Puts the route points into a polyline and try to simplify.
        const polyline = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Polyline(routePoints);
        polyline.simplify({ threshold: 0.01 });
        const simplifiedPoints = polyline.points.map((point) => point.toJSON());
        const simplifiedCount = simplifiedPoints.length;
        // If simplification did not remove any redundant vertices.
        if (rawCount === simplifiedCount) {
            return 0;
        }
        // Sets simplified polyline points as edge vertices.
        // Removes first and last polyline points again (source/target anchors).
        edge.setVertices(simplifiedPoints.slice(1, simplifiedCount - 1), options);
        return rawCount - simplifiedCount;
    }
    getTerminalView(type) {
        switch (type) {
            case 'source':
                return this.sourceView || null;
            case 'target':
                return this.targetView || null;
            default:
                throw new Error(`Unknown terminal type '${type}'`);
        }
    }
    getTerminalAnchor(type) {
        switch (type) {
            case 'source':
                return _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(this.sourceAnchor);
            case 'target':
                return _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(this.targetAnchor);
            default:
                throw new Error(`Unknown terminal type '${type}'`);
        }
    }
    getTerminalConnectionPoint(type) {
        switch (type) {
            case 'source':
                return _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(this.sourcePoint);
            case 'target':
                return _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(this.targetPoint);
            default:
                throw new Error(`Unknown terminal type '${type}'`);
        }
    }
    getTerminalMagnet(type, options = {}) {
        switch (type) {
            case 'source': {
                if (options.raw) {
                    return this.sourceMagnet;
                }
                const sourceView = this.sourceView;
                if (!sourceView) {
                    return null;
                }
                return this.sourceMagnet || sourceView.container;
            }
            case 'target': {
                if (options.raw) {
                    return this.targetMagnet;
                }
                const targetView = this.targetView;
                if (!targetView) {
                    return null;
                }
                return this.targetMagnet || targetView.container;
            }
            default: {
                throw new Error(`Unknown terminal type '${type}'`);
            }
        }
    }
    updateConnection(options = {}) {
        const edge = this.cell;
        // The edge is being translated by an ancestor that will shift
        // source, target and vertices by an equal distance.
        // todo isFragmentDescendantOf is invalid
        if (options.translateBy &&
            edge.isFragmentDescendantOf(options.translateBy)) {
            const tx = options.tx || 0;
            const ty = options.ty || 0;
            this.routePoints = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Polyline(this.routePoints).translate(tx, ty).points;
            this.translateConnectionPoints(tx, ty);
            this.path.translate(tx, ty);
        }
        else {
            const vertices = edge.getVertices();
            // 1. Find anchor points
            const anchors = this.findAnchors(vertices);
            this.sourceAnchor = anchors.source;
            this.targetAnchor = anchors.target;
            // 2. Find route points
            this.routePoints = this.findRoutePoints(vertices);
            // 3. Find connection points
            const connectionPoints = this.findConnectionPoints(this.routePoints, this.sourceAnchor, this.targetAnchor);
            this.sourcePoint = connectionPoints.source;
            this.targetPoint = connectionPoints.target;
            // 4. Find Marker Connection Point
            const markerPoints = this.findMarkerPoints(this.routePoints, this.sourcePoint, this.targetPoint);
            // 5. Make path
            this.path = this.findPath(this.routePoints, markerPoints.source || this.sourcePoint, markerPoints.target || this.targetPoint);
        }
        this.cleanCache();
    }
    findAnchors(vertices) {
        const edge = this.cell;
        const source = edge.source;
        const target = edge.target;
        const firstVertex = vertices[0];
        const lastVertex = vertices[vertices.length - 1];
        if (target.priority && !source.priority) {
            // Reversed order
            return this.findAnchorsOrdered('target', lastVertex, 'source', firstVertex);
        }
        // Usual order
        return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex);
    }
    findAnchorsOrdered(firstType, firstPoint, secondType, secondPoint) {
        let firstAnchor;
        let secondAnchor;
        const edge = this.cell;
        const firstTerminal = edge[firstType];
        const secondTerminal = edge[secondType];
        const firstView = this.getTerminalView(firstType);
        const secondView = this.getTerminalView(secondType);
        const firstMagnet = this.getTerminalMagnet(firstType);
        const secondMagnet = this.getTerminalMagnet(secondType);
        if (firstView) {
            let firstRef;
            if (firstPoint) {
                firstRef = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(firstPoint);
            }
            else if (secondView) {
                firstRef = secondMagnet;
            }
            else {
                firstRef = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(secondTerminal);
            }
            firstAnchor = this.getAnchor(firstTerminal.anchor, firstView, firstMagnet, firstRef, firstType);
        }
        else {
            firstAnchor = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(firstTerminal);
        }
        if (secondView) {
            const secondRef = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(secondPoint || firstAnchor);
            secondAnchor = this.getAnchor(secondTerminal.anchor, secondView, secondMagnet, secondRef, secondType);
        }
        else {
            secondAnchor = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.isPointLike(secondTerminal)
                ? _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(secondTerminal)
                : new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point();
        }
        return {
            [firstType]: firstAnchor,
            [secondType]: secondAnchor,
        };
    }
    getAnchor(def, cellView, magnet, ref, terminalType) {
        const isEdge = cellView.isEdgeElement(magnet);
        const connecting = this.graph.options.connecting;
        let config = typeof def === 'string' ? { name: def } : def;
        if (!config) {
            const defaults = isEdge
                ? (terminalType === 'source'
                    ? connecting.sourceEdgeAnchor
                    : connecting.targetEdgeAnchor) || connecting.edgeAnchor
                : (terminalType === 'source'
                    ? connecting.sourceAnchor
                    : connecting.targetAnchor) || connecting.anchor;
            config = typeof defaults === 'string' ? { name: defaults } : defaults;
        }
        if (!config) {
            throw new Error(`Anchor should be specified.`);
        }
        let anchor;
        const name = config.name;
        if (isEdge) {
            const fn = _registry__WEBPACK_IMPORTED_MODULE_2__.EdgeAnchor.registry.get(name);
            if (typeof fn !== 'function') {
                return _registry__WEBPACK_IMPORTED_MODULE_2__.EdgeAnchor.registry.onNotFound(name);
            }
            anchor = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(fn, this, cellView, magnet, ref, config.args || {}, terminalType);
        }
        else {
            const fn = _registry__WEBPACK_IMPORTED_MODULE_2__.NodeAnchor.registry.get(name);
            if (typeof fn !== 'function') {
                return _registry__WEBPACK_IMPORTED_MODULE_2__.NodeAnchor.registry.onNotFound(name);
            }
            anchor = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(fn, this, cellView, magnet, ref, config.args || {}, terminalType);
        }
        return anchor ? anchor.round(this.POINT_ROUNDING) : new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point();
    }
    findRoutePoints(vertices = []) {
        const defaultRouter = this.graph.options.connecting.router || _registry__WEBPACK_IMPORTED_MODULE_2__.Router.presets.normal;
        const router = this.cell.getRouter() || defaultRouter;
        let routePoints;
        if (typeof router === 'function') {
            routePoints = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(router, this, vertices, {}, this);
        }
        else {
            const name = typeof router === 'string' ? router : router.name;
            const args = typeof router === 'string' ? {} : router.args || {};
            const fn = name ? _registry__WEBPACK_IMPORTED_MODULE_2__.Router.registry.get(name) : _registry__WEBPACK_IMPORTED_MODULE_2__.Router.presets.normal;
            if (typeof fn !== 'function') {
                return _registry__WEBPACK_IMPORTED_MODULE_2__.Router.registry.onNotFound(name);
            }
            routePoints = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(fn, this, vertices, args, this);
        }
        return routePoints == null
            ? vertices.map((p) => _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(p))
            : routePoints.map((p) => _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(p));
    }
    findConnectionPoints(routePoints, sourceAnchor, targetAnchor) {
        const edge = this.cell;
        const connecting = this.graph.options.connecting;
        const sourceTerminal = edge.getSource();
        const targetTerminal = edge.getTarget();
        const sourceView = this.sourceView;
        const targetView = this.targetView;
        const firstRoutePoint = routePoints[0];
        const lastRoutePoint = routePoints[routePoints.length - 1];
        // source
        let sourcePoint;
        if (sourceView && !sourceView.isEdgeElement(this.sourceMagnet)) {
            const sourceMagnet = this.sourceMagnet || sourceView.container;
            const sourcePointRef = firstRoutePoint || targetAnchor;
            const sourceLine = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Line(sourcePointRef, sourceAnchor);
            const connectionPointDef = sourceTerminal.connectionPoint ||
                connecting.sourceConnectionPoint ||
                connecting.connectionPoint;
            sourcePoint = this.getConnectionPoint(connectionPointDef, sourceView, sourceMagnet, sourceLine, 'source');
        }
        else {
            sourcePoint = sourceAnchor;
        }
        // target
        let targetPoint;
        if (targetView && !targetView.isEdgeElement(this.targetMagnet)) {
            const targetMagnet = this.targetMagnet || targetView.container;
            const targetConnectionPointDef = targetTerminal.connectionPoint ||
                connecting.targetConnectionPoint ||
                connecting.connectionPoint;
            const targetPointRef = lastRoutePoint || sourceAnchor;
            const targetLine = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Line(targetPointRef, targetAnchor);
            targetPoint = this.getConnectionPoint(targetConnectionPointDef, targetView, targetMagnet, targetLine, 'target');
        }
        else {
            targetPoint = targetAnchor;
        }
        return {
            source: sourcePoint,
            target: targetPoint,
        };
    }
    getConnectionPoint(def, view, magnet, line, endType) {
        const anchor = line.end;
        if (def == null) {
            return anchor;
        }
        const name = typeof def === 'string' ? def : def.name;
        const args = typeof def === 'string' ? {} : def.args;
        const fn = _registry__WEBPACK_IMPORTED_MODULE_2__.ConnectionPoint.registry.get(name);
        if (typeof fn !== 'function') {
            return _registry__WEBPACK_IMPORTED_MODULE_2__.ConnectionPoint.registry.onNotFound(name);
        }
        const connectionPoint = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(fn, this, line, view, magnet, args || {}, endType);
        return connectionPoint ? connectionPoint.round(this.POINT_ROUNDING) : anchor;
    }
    findMarkerPoints(routePoints, sourcePoint, targetPoint) {
        const getLineWidth = (type) => {
            const attrs = this.cell.getAttrs();
            const keys = Object.keys(attrs);
            for (let i = 0, l = keys.length; i < l; i += 1) {
                const attr = attrs[keys[i]];
                if (attr[`${type}Marker`] || attr[`${type}-marker`]) {
                    const strokeWidth = attr.strokeWidth || attr['stroke-width'];
                    if (strokeWidth) {
                        return parseFloat(strokeWidth);
                    }
                    break;
                }
            }
            return null;
        };
        const firstRoutePoint = routePoints[0];
        const lastRoutePoint = routePoints[routePoints.length - 1];
        let sourceMarkerPoint;
        let targetMarkerPoint;
        const sourceStrokeWidth = getLineWidth('source');
        if (sourceStrokeWidth) {
            sourceMarkerPoint = sourcePoint
                .clone()
                .move(firstRoutePoint || targetPoint, -sourceStrokeWidth);
        }
        const targetStrokeWidth = getLineWidth('target');
        if (targetStrokeWidth) {
            targetMarkerPoint = targetPoint
                .clone()
                .move(lastRoutePoint || sourcePoint, -targetStrokeWidth);
        }
        this.sourceMarkerPoint = sourceMarkerPoint || sourcePoint.clone();
        this.targetMarkerPoint = targetMarkerPoint || targetPoint.clone();
        return {
            source: sourceMarkerPoint,
            target: targetMarkerPoint,
        };
    }
    findPath(routePoints, sourcePoint, targetPoint) {
        const def = this.cell.getConnector() || this.graph.options.connecting.connector;
        let name;
        let args;
        let fn;
        if (typeof def === 'string') {
            name = def;
        }
        else {
            name = def.name;
            args = def.args;
        }
        if (name) {
            const method = _registry__WEBPACK_IMPORTED_MODULE_2__.Connector.registry.get(name);
            if (typeof method !== 'function') {
                return _registry__WEBPACK_IMPORTED_MODULE_2__.Connector.registry.onNotFound(name);
            }
            fn = method;
        }
        else {
            fn = _registry__WEBPACK_IMPORTED_MODULE_2__.Connector.presets.normal;
        }
        const path = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(fn, this, sourcePoint, targetPoint, routePoints, Object.assign(Object.assign({}, args), { raw: true }), this);
        return typeof path === 'string' ? _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Path.parse(path) : path;
    }
    translateConnectionPoints(tx, ty) {
        this.sourcePoint.translate(tx, ty);
        this.targetPoint.translate(tx, ty);
        this.sourceAnchor.translate(tx, ty);
        this.targetAnchor.translate(tx, ty);
        this.sourceMarkerPoint.translate(tx, ty);
        this.targetMarkerPoint.translate(tx, ty);
    }
    updateLabelPositions() {
        if (this.labelContainer == null) {
            return this;
        }
        const path = this.path;
        if (!path) {
            return this;
        }
        const edge = this.cell;
        const labels = edge.getLabels();
        if (labels.length === 0) {
            return this;
        }
        const defaultLabel = edge.getDefaultLabel();
        const defaultPosition = this.normalizeLabelPosition(defaultLabel.position);
        for (let i = 0, ii = labels.length; i < ii; i += 1) {
            const label = labels[i];
            const labelNode = this.labelCache[i];
            if (!labelNode) {
                continue;
            }
            const labelPosition = this.normalizeLabelPosition(label.position);
            const pos = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.merge({}, defaultPosition, labelPosition);
            const matrix = this.getLabelTransformationMatrix(pos);
            labelNode.setAttribute('transform', _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.matrixToTransformString(matrix));
        }
        return this;
    }
    updateTerminalProperties(type) {
        const edge = this.cell;
        const graph = this.graph;
        const terminal = edge[type];
        const nodeId = terminal && terminal.cell;
        const viewKey = `${type}View`;
        // terminal is a point
        if (!nodeId) {
            this[viewKey] = null;
            this.updateTerminalMagnet(type);
            return true;
        }
        const terminalCell = graph.getCellById(nodeId);
        if (!terminalCell) {
            throw new Error(`Edge's ${type} node with id "${nodeId}" not exists`);
        }
        const endView = terminalCell.findView(graph);
        if (!endView) {
            return false;
        }
        this[viewKey] = endView;
        this.updateTerminalMagnet(type);
        return true;
    }
    updateTerminalMagnet(type) {
        const propName = `${type}Magnet`;
        const terminalView = this.getTerminalView(type);
        if (terminalView) {
            let magnet = terminalView.getMagnetFromEdgeTerminal(this.cell[type]);
            if (magnet === terminalView.container) {
                magnet = null;
            }
            this[propName] = magnet;
        }
        else {
            this[propName] = null;
        }
    }
    getLabelPositionAngle(idx) {
        const label = this.cell.getLabelAt(idx);
        if (label && label.position && typeof label.position === 'object') {
            return label.position.angle || 0;
        }
        return 0;
    }
    getLabelPositionArgs(idx) {
        const label = this.cell.getLabelAt(idx);
        if (label && label.position && typeof label.position === 'object') {
            return label.position.options;
        }
    }
    getDefaultLabelPositionArgs() {
        const defaultLabel = this.cell.getDefaultLabel();
        if (defaultLabel &&
            defaultLabel.position &&
            typeof defaultLabel.position === 'object') {
            return defaultLabel.position.options;
        }
    }
    mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs) {
        if (labelPositionArgs === null) {
            return null;
        }
        if (labelPositionArgs === undefined) {
            if (defaultLabelPositionArgs === null) {
                return null;
            }
            return defaultLabelPositionArgs;
        }
        return _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.merge({}, defaultLabelPositionArgs, labelPositionArgs);
    }
    // #endregion
    getConnection() {
        return this.path != null ? this.path.clone() : null;
    }
    getConnectionPathData() {
        if (this.path == null) {
            return '';
        }
        const cache = this.cache.pathCache;
        if (!_antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.has(cache, 'data')) {
            cache.data = this.path.serialize();
        }
        return cache.data || '';
    }
    getConnectionSubdivisions() {
        if (this.path == null) {
            return null;
        }
        const cache = this.cache.pathCache;
        if (!_antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.has(cache, 'segmentSubdivisions')) {
            cache.segmentSubdivisions = this.path.getSegmentSubdivisions();
        }
        return cache.segmentSubdivisions;
    }
    getConnectionLength() {
        if (this.path == null) {
            return 0;
        }
        const cache = this.cache.pathCache;
        if (!_antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.has(cache, 'length')) {
            cache.length = this.path.length({
                segmentSubdivisions: this.getConnectionSubdivisions(),
            });
        }
        return cache.length;
    }
    getPointAtLength(length) {
        if (this.path == null) {
            return null;
        }
        return this.path.pointAtLength(length, {
            segmentSubdivisions: this.getConnectionSubdivisions(),
        });
    }
    getPointAtRatio(ratio) {
        if (this.path == null) {
            return null;
        }
        if (_antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.NumberExt.isPercentage(ratio)) {
            // eslint-disable-next-line
            ratio = parseFloat(ratio) / 100;
        }
        return this.path.pointAt(ratio, {
            segmentSubdivisions: this.getConnectionSubdivisions(),
        });
    }
    getTangentAtLength(length) {
        if (this.path == null) {
            return null;
        }
        return this.path.tangentAtLength(length, {
            segmentSubdivisions: this.getConnectionSubdivisions(),
        });
    }
    getTangentAtRatio(ratio) {
        if (this.path == null) {
            return null;
        }
        return this.path.tangentAt(ratio, {
            segmentSubdivisions: this.getConnectionSubdivisions(),
        });
    }
    getClosestPoint(point) {
        if (this.path == null) {
            return null;
        }
        return this.path.closestPoint(point, {
            segmentSubdivisions: this.getConnectionSubdivisions(),
        });
    }
    getClosestPointLength(point) {
        if (this.path == null) {
            return null;
        }
        return this.path.closestPointLength(point, {
            segmentSubdivisions: this.getConnectionSubdivisions(),
        });
    }
    getClosestPointRatio(point) {
        if (this.path == null) {
            return null;
        }
        return this.path.closestPointNormalizedLength(point, {
            segmentSubdivisions: this.getConnectionSubdivisions(),
        });
    }
    getLabelPosition(x, y, p3, p4) {
        const pos = { distance: 0 };
        // normalize data from the two possible signatures
        let angle = 0;
        let options;
        if (typeof p3 === 'number') {
            angle = p3;
            options = p4;
        }
        else {
            options = p3;
        }
        if (options != null) {
            pos.options = options;
        }
        // identify distance/offset settings
        const isOffsetAbsolute = options && options.absoluteOffset;
        const isDistanceRelative = !(options && options.absoluteDistance);
        const isDistanceAbsoluteReverse = options && options.absoluteDistance && options.reverseDistance;
        // find closest point t
        const path = this.path;
        const pathOptions = {
            segmentSubdivisions: this.getConnectionSubdivisions(),
        };
        const labelPoint = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(x, y);
        const t = path.closestPointT(labelPoint, pathOptions);
        // distance
        const totalLength = this.getConnectionLength() || 0;
        let labelDistance = path.lengthAtT(t, pathOptions);
        if (isDistanceRelative) {
            labelDistance = totalLength > 0 ? labelDistance / totalLength : 0;
        }
        if (isDistanceAbsoluteReverse) {
            // fix for end point (-0 => 1)
            labelDistance = -1 * (totalLength - labelDistance) || 1;
        }
        pos.distance = labelDistance;
        // offset
        // use absolute offset if:
        // - options.absoluteOffset is true,
        // - options.absoluteOffset is not true but there is no tangent
        let tangent;
        if (!isOffsetAbsolute)
            tangent = path.tangentAtT(t);
        let labelOffset;
        if (tangent) {
            labelOffset = tangent.pointOffset(labelPoint);
        }
        else {
            const closestPoint = path.pointAtT(t);
            const labelOffsetDiff = labelPoint.diff(closestPoint);
            labelOffset = { x: labelOffsetDiff.x, y: labelOffsetDiff.y };
        }
        pos.offset = labelOffset;
        pos.angle = angle;
        return pos;
    }
    normalizeLabelPosition(pos) {
        if (typeof pos === 'number') {
            return { distance: pos };
        }
        return pos;
    }
    getLabelTransformationMatrix(labelPosition) {
        const pos = this.normalizeLabelPosition(labelPosition);
        const options = pos.options || {};
        const labelAngle = pos.angle || 0;
        const labelDistance = pos.distance;
        const isDistanceRelative = labelDistance > 0 && labelDistance <= 1;
        let labelOffset = 0;
        const offsetCoord = { x: 0, y: 0 };
        const offset = pos.offset;
        if (offset) {
            if (typeof offset === 'number') {
                labelOffset = offset;
            }
            else {
                if (offset.x != null) {
                    offsetCoord.x = offset.x;
                }
                if (offset.y != null) {
                    offsetCoord.y = offset.y;
                }
            }
        }
        const isOffsetAbsolute = offsetCoord.x !== 0 || offsetCoord.y !== 0 || labelOffset === 0;
        const isKeepGradient = options.keepGradient;
        const isEnsureLegibility = options.ensureLegibility;
        const path = this.path;
        const pathOpt = { segmentSubdivisions: this.getConnectionSubdivisions() };
        const distance = isDistanceRelative
            ? labelDistance * this.getConnectionLength()
            : labelDistance;
        const tangent = path.tangentAtLength(distance, pathOpt);
        let translation;
        let angle = labelAngle;
        if (tangent) {
            if (isOffsetAbsolute) {
                translation = tangent.start;
                translation.translate(offsetCoord);
            }
            else {
                const normal = tangent.clone();
                normal.rotate(-90, tangent.start);
                normal.setLength(labelOffset);
                translation = normal.end;
            }
            if (isKeepGradient) {
                angle = tangent.angle() + labelAngle;
                if (isEnsureLegibility) {
                    angle = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Angle.normalize(((angle + 90) % 180) - 90);
                }
            }
        }
        else {
            // fallback - the connection has zero length
            translation = path.start;
            if (isOffsetAbsolute) {
                translation.translate(offsetCoord);
            }
        }
        return _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.createSVGMatrix()
            .translate(translation.x, translation.y)
            .rotate(angle);
    }
    getVertexIndex(x, y) {
        const edge = this.cell;
        const vertices = edge.getVertices();
        const vertexLength = this.getClosestPointLength(new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(x, y));
        let index = 0;
        if (vertexLength != null) {
            for (const ii = vertices.length; index < ii; index += 1) {
                const currentVertex = vertices[index];
                const currentLength = this.getClosestPointLength(currentVertex);
                if (currentLength != null && vertexLength < currentLength) {
                    break;
                }
            }
        }
        return index;
    }
    getEventArgs(e, x, y) {
        const view = this; // eslint-disable-line
        const edge = view.cell;
        const cell = edge;
        if (x == null || y == null) {
            return { e, view, edge, cell };
        }
        return { e, x, y, view, edge, cell };
    }
    notifyUnhandledMouseDown(e, x, y) {
        this.notify('edge:unhandled:mousedown', {
            e,
            x,
            y,
            view: this,
            cell: this.cell,
            edge: this.cell,
        });
    }
    notifyMouseDown(e, x, y) {
        super.onMouseDown(e, x, y);
        this.notify('edge:mousedown', this.getEventArgs(e, x, y));
    }
    notifyMouseMove(e, x, y) {
        super.onMouseMove(e, x, y);
        this.notify('edge:mousemove', this.getEventArgs(e, x, y));
    }
    notifyMouseUp(e, x, y) {
        super.onMouseUp(e, x, y);
        this.notify('edge:mouseup', this.getEventArgs(e, x, y));
    }
    onClick(e, x, y) {
        super.onClick(e, x, y);
        this.notify('edge:click', this.getEventArgs(e, x, y));
    }
    onDblClick(e, x, y) {
        super.onDblClick(e, x, y);
        this.notify('edge:dblclick', this.getEventArgs(e, x, y));
    }
    onContextMenu(e, x, y) {
        super.onContextMenu(e, x, y);
        this.notify('edge:contextmenu', this.getEventArgs(e, x, y));
    }
    onMouseDown(e, x, y) {
        this.notifyMouseDown(e, x, y);
        this.startEdgeDragging(e, x, y);
    }
    onMouseMove(e, x, y) {
        const data = this.getEventData(e);
        switch (data.action) {
            case 'drag-label': {
                this.dragLabel(e, x, y);
                break;
            }
            case 'drag-arrowhead': {
                this.dragArrowhead(e, x, y);
                break;
            }
            case 'drag-edge': {
                this.dragEdge(e, x, y);
                break;
            }
            default:
                break;
        }
        this.notifyMouseMove(e, x, y);
        return data;
    }
    onMouseUp(e, x, y) {
        const data = this.getEventData(e);
        switch (data.action) {
            case 'drag-label': {
                this.stopLabelDragging(e, x, y);
                break;
            }
            case 'drag-arrowhead': {
                this.stopArrowheadDragging(e, x, y);
                break;
            }
            case 'drag-edge': {
                this.stopEdgeDragging(e, x, y);
                break;
            }
            default:
                break;
        }
        this.notifyMouseUp(e, x, y);
        this.checkMouseleave(e);
        return data;
    }
    onMouseOver(e) {
        super.onMouseOver(e);
        this.notify('edge:mouseover', this.getEventArgs(e));
    }
    onMouseOut(e) {
        super.onMouseOut(e);
        this.notify('edge:mouseout', this.getEventArgs(e));
    }
    onMouseEnter(e) {
        super.onMouseEnter(e);
        this.notify('edge:mouseenter', this.getEventArgs(e));
    }
    onMouseLeave(e) {
        super.onMouseLeave(e);
        this.notify('edge:mouseleave', this.getEventArgs(e));
    }
    onMouseWheel(e, x, y, delta) {
        super.onMouseWheel(e, x, y, delta);
        this.notify('edge:mousewheel', Object.assign({ delta }, this.getEventArgs(e, x, y)));
    }
    onCustomEvent(e, name, x, y) {
        // For default edge tool
        const tool = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.Dom.findParentByClass(e.target, 'edge-tool', this.container);
        if (tool) {
            e.stopPropagation(); // no further action to be executed
            if (this.can('useEdgeTools')) {
                if (name === 'edge:remove') {
                    this.cell.remove({ ui: true });
                    return;
                }
                this.notify('edge:customevent', Object.assign({ name }, this.getEventArgs(e, x, y)));
            }
            this.notifyMouseDown(e, x, y);
        }
        else {
            this.notify('edge:customevent', Object.assign({ name }, this.getEventArgs(e, x, y)));
            super.onCustomEvent(e, name, x, y);
        }
    }
    onLabelMouseDown(e, x, y) {
        this.notifyMouseDown(e, x, y);
        this.startLabelDragging(e, x, y);
        const stopPropagation = this.getEventData(e).stopPropagation;
        if (stopPropagation) {
            e.stopPropagation();
        }
    }
    // #region drag edge
    startEdgeDragging(e, x, y) {
        if (!this.can('edgeMovable')) {
            this.notifyUnhandledMouseDown(e, x, y);
            return;
        }
        this.setEventData(e, {
            x,
            y,
            moving: false,
            action: 'drag-edge',
        });
    }
    dragEdge(e, x, y) {
        const data = this.getEventData(e);
        if (!data.moving) {
            data.moving = true;
            this.addClass('edge-moving');
            this.notify('edge:move', {
                e,
                x,
                y,
                view: this,
                cell: this.cell,
                edge: this.cell,
            });
        }
        this.cell.translate(x - data.x, y - data.y, { ui: true });
        this.setEventData(e, { x, y });
        this.notify('edge:moving', {
            e,
            x,
            y,
            view: this,
            cell: this.cell,
            edge: this.cell,
        });
    }
    stopEdgeDragging(e, x, y) {
        const data = this.getEventData(e);
        if (data.moving) {
            this.removeClass('edge-moving');
            this.notify('edge:moved', {
                e,
                x,
                y,
                view: this,
                cell: this.cell,
                edge: this.cell,
            });
        }
        data.moving = false;
    }
    // #endregion
    // #region drag arrowhead
    prepareArrowheadDragging(type, options) {
        const magnet = this.getTerminalMagnet(type);
        const data = {
            action: 'drag-arrowhead',
            x: options.x,
            y: options.y,
            isNewEdge: options.isNewEdge === true,
            terminalType: type,
            initialMagnet: magnet,
            initialTerminal: _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.clone(this.cell[type]),
            fallbackAction: options.fallbackAction || 'revert',
            getValidateConnectionArgs: this.createValidateConnectionArgs(type),
            options: options.options,
        };
        this.beforeArrowheadDragging(data);
        return data;
    }
    createValidateConnectionArgs(type) {
        const args = [];
        args[4] = type;
        args[5] = this;
        let opposite;
        let i = 0;
        let j = 0;
        if (type === 'source') {
            i = 2;
            opposite = 'target';
        }
        else {
            j = 2;
            opposite = 'source';
        }
        const terminal = this.cell[opposite];
        const cellId = terminal.cell;
        if (cellId) {
            let magnet;
            const view = (args[i] = this.graph.findViewByCell(cellId));
            if (view) {
                magnet = view.getMagnetFromEdgeTerminal(terminal);
                if (magnet === view.container) {
                    magnet = undefined;
                }
            }
            args[i + 1] = magnet;
        }
        return (cellView, magnet) => {
            args[j] = cellView;
            args[j + 1] = cellView.container === magnet ? undefined : magnet;
            return args;
        };
    }
    beforeArrowheadDragging(data) {
        data.zIndex = this.cell.zIndex;
        this.cell.toFront();
        const style = this.container.style;
        data.pointerEvents = style.pointerEvents;
        style.pointerEvents = 'none';
        if (this.graph.options.connecting.highlight) {
            this.highlightAvailableMagnets(data);
        }
    }
    afterArrowheadDragging(data) {
        if (data.zIndex != null) {
            this.cell.setZIndex(data.zIndex, { ui: true });
            data.zIndex = null;
        }
        const container = this.container;
        container.style.pointerEvents = data.pointerEvents || '';
        if (this.graph.options.connecting.highlight) {
            this.unhighlightAvailableMagnets(data);
        }
    }
    validateConnection(sourceView, sourceMagnet, targetView, targetMagnet, terminalType, edgeView, candidateTerminal) {
        const options = this.graph.options.connecting;
        const allowLoop = options.allowLoop;
        const allowNode = options.allowNode;
        const allowEdge = options.allowEdge;
        const allowPort = options.allowPort;
        const allowMulti = options.allowMulti;
        const validate = options.validateConnection;
        const edge = edgeView ? edgeView.cell : null;
        const terminalView = terminalType === 'target' ? targetView : sourceView;
        const terminalMagnet = terminalType === 'target' ? targetMagnet : sourceMagnet;
        let valid = true;
        const doValidate = (validate) => {
            const sourcePort = terminalType === 'source'
                ? candidateTerminal
                    ? candidateTerminal.port
                    : null
                : edge
                    ? edge.getSourcePortId()
                    : null;
            const targetPort = terminalType === 'target'
                ? candidateTerminal
                    ? candidateTerminal.port
                    : null
                : edge
                    ? edge.getTargetPortId()
                    : null;
            return _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(validate, this.graph, {
                edge,
                edgeView,
                sourceView,
                targetView,
                sourcePort,
                targetPort,
                sourceMagnet,
                targetMagnet,
                sourceCell: sourceView ? sourceView.cell : null,
                targetCell: targetView ? targetView.cell : null,
                type: terminalType,
            });
        };
        if (allowLoop != null) {
            if (typeof allowLoop === 'boolean') {
                if (!allowLoop && sourceView === targetView) {
                    valid = false;
                }
            }
            else {
                valid = doValidate(allowLoop);
            }
        }
        if (valid && allowPort != null) {
            if (typeof allowPort === 'boolean') {
                if (!allowPort && terminalMagnet) {
                    valid = false;
                }
            }
            else {
                valid = doValidate(allowPort);
            }
        }
        if (valid && allowEdge != null) {
            if (typeof allowEdge === 'boolean') {
                if (!allowEdge && EdgeView.isEdgeView(terminalView)) {
                    valid = false;
                }
            }
            else {
                valid = doValidate(allowEdge);
            }
        }
        // When judging nodes, the influence of the ports should be excluded,
        // because the ports and nodes have the same terminalView
        if (valid && allowNode != null && terminalMagnet == null) {
            if (typeof allowNode === 'boolean') {
                if (!allowNode && _node__WEBPACK_IMPORTED_MODULE_5__.NodeView.isNodeView(terminalView)) {
                    valid = false;
                }
            }
            else {
                valid = doValidate(allowNode);
            }
        }
        if (valid && allowMulti != null && edgeView) {
            const edge = edgeView.cell;
            const source = terminalType === 'source'
                ? candidateTerminal
                : edge.getSource();
            const target = terminalType === 'target'
                ? candidateTerminal
                : edge.getTarget();
            const terminalCell = candidateTerminal
                ? this.graph.getCellById(candidateTerminal.cell)
                : null;
            if (source && target && source.cell && target.cell && terminalCell) {
                if (typeof allowMulti === 'function') {
                    valid = doValidate(allowMulti);
                }
                else {
                    const connectedEdges = this.graph.model.getConnectedEdges(terminalCell, {
                        outgoing: terminalType === 'source',
                        incoming: terminalType === 'target',
                    });
                    if (connectedEdges.length) {
                        if (allowMulti === 'withPort') {
                            const exist = connectedEdges.some((link) => {
                                const s = link.getSource();
                                const t = link.getTarget();
                                return (s &&
                                    t &&
                                    s.cell === source.cell &&
                                    t.cell === target.cell &&
                                    s.port != null &&
                                    s.port === source.port &&
                                    t.port != null &&
                                    t.port === target.port);
                            });
                            if (exist) {
                                valid = false;
                            }
                        }
                        else if (!allowMulti) {
                            const exist = connectedEdges.some((link) => {
                                const s = link.getSource();
                                const t = link.getTarget();
                                return (s && t && s.cell === source.cell && t.cell === target.cell);
                            });
                            if (exist) {
                                valid = false;
                            }
                        }
                    }
                }
            }
        }
        if (valid && validate != null) {
            valid = doValidate(validate);
        }
        return valid;
    }
    allowConnectToBlank(edge) {
        const graph = this.graph;
        const options = graph.options.connecting;
        const allowBlank = options.allowBlank;
        if (typeof allowBlank !== 'function') {
            return !!allowBlank;
        }
        const edgeView = graph.findViewByCell(edge);
        const sourceCell = edge.getSourceCell();
        const targetCell = edge.getTargetCell();
        const sourceView = graph.findViewByCell(sourceCell);
        const targetView = graph.findViewByCell(targetCell);
        return _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(allowBlank, graph, {
            edge,
            edgeView,
            sourceCell,
            targetCell,
            sourceView,
            targetView,
            sourcePort: edge.getSourcePortId(),
            targetPort: edge.getTargetPortId(),
            sourceMagnet: edgeView.sourceMagnet,
            targetMagnet: edgeView.targetMagnet,
        });
    }
    validateEdge(edge, type, initialTerminal) {
        const graph = this.graph;
        if (!this.allowConnectToBlank(edge)) {
            const sourceId = edge.getSourceCellId();
            const targetId = edge.getTargetCellId();
            if (!(sourceId && targetId)) {
                return false;
            }
        }
        const validate = graph.options.connecting.validateEdge;
        if (validate) {
            return _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.FunctionExt.call(validate, graph, {
                edge,
                type,
                previous: initialTerminal,
            });
        }
        return true;
    }
    arrowheadDragging(target, x, y, data) {
        data.x = x;
        data.y = y;
        // Checking views right under the pointer
        if (data.currentTarget !== target) {
            // Unhighlight the previous view under pointer if there was one.
            if (data.currentMagnet && data.currentView) {
                data.currentView.unhighlight(data.currentMagnet, {
                    type: 'magnetAdsorbed',
                });
            }
            data.currentView = this.graph.findViewByElem(target);
            if (data.currentView) {
                // If we found a view that is under the pointer, we need to find
                // the closest magnet based on the real target element of the event.
                data.currentMagnet = data.currentView.findMagnet(target);
                if (data.currentMagnet &&
                    this.validateConnection(...data.getValidateConnectionArgs(data.currentView, data.currentMagnet), data.currentView.getEdgeTerminal(data.currentMagnet, x, y, this.cell, data.terminalType))) {
                    data.currentView.highlight(data.currentMagnet, {
                        type: 'magnetAdsorbed',
                    });
                }
                else {
                    // This type of connection is not valid. Disregard this magnet.
                    data.currentMagnet = null;
                }
            }
            else {
                // Make sure we'll unset previous magnet.
                data.currentMagnet = null;
            }
        }
        data.currentTarget = target;
        this.cell.prop(data.terminalType, { x, y }, Object.assign(Object.assign({}, data.options), { ui: true }));
    }
    arrowheadDragged(data, x, y) {
        const view = data.currentView;
        const magnet = data.currentMagnet;
        if (!magnet || !view) {
            return;
        }
        view.unhighlight(magnet, { type: 'magnetAdsorbed' });
        const type = data.terminalType;
        const terminal = view.getEdgeTerminal(magnet, x, y, this.cell, type);
        this.cell.setTerminal(type, terminal, { ui: true });
    }
    snapArrowhead(x, y, data) {
        const graph = this.graph;
        const { snap, allowEdge } = graph.options.connecting;
        const radius = (typeof snap === 'object' && snap.radius) || 50;
        const anchor = (typeof snap === 'object' && snap.anchor) || 'center';
        const views = graph.renderer.findViewsInArea({
            x: x - radius,
            y: y - radius,
            width: 2 * radius,
            height: 2 * radius,
        }, { nodeOnly: true });
        if (allowEdge) {
            const edgeViews = graph.renderer
                .findEdgeViewsFromPoint({ x, y }, radius)
                .filter((view) => {
                return view !== this;
            });
            views.push(...edgeViews);
        }
        const prevView = data.closestView || null;
        const prevMagnet = data.closestMagnet || null;
        data.closestView = null;
        data.closestMagnet = null;
        let distance;
        let minDistance = Number.MAX_SAFE_INTEGER;
        const pos = new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point(x, y);
        views.forEach((view) => {
            if (view.container.getAttribute('magnet') !== 'false') {
                if (view.isNodeView()) {
                    distance =
                        anchor === 'center'
                            ? view.cell.getBBox().getCenter().distance(pos)
                            : view.cell.getBBox().getNearestPointToPoint(pos).distance(pos);
                }
                else if (view.isEdgeView()) {
                    const point = view.getClosestPoint(pos);
                    if (point) {
                        distance = point.distance(pos);
                    }
                    else {
                        distance = Number.MAX_SAFE_INTEGER;
                    }
                }
                if (distance < radius && distance < minDistance) {
                    if (prevMagnet === view.container ||
                        this.validateConnection(...data.getValidateConnectionArgs(view, null), view.getEdgeTerminal(view.container, x, y, this.cell, data.terminalType))) {
                        minDistance = distance;
                        data.closestView = view;
                        data.closestMagnet = view.container;
                    }
                }
            }
            view.container.querySelectorAll('[magnet]').forEach((magnet) => {
                if (magnet.getAttribute('magnet') !== 'false') {
                    const bbox = view.getBBoxOfElement(magnet);
                    distance = pos.distance(bbox.getCenter());
                    if (distance < radius && distance < minDistance) {
                        if (prevMagnet === magnet ||
                            this.validateConnection(...data.getValidateConnectionArgs(view, magnet), view.getEdgeTerminal(magnet, x, y, this.cell, data.terminalType))) {
                            minDistance = distance;
                            data.closestView = view;
                            data.closestMagnet = magnet;
                        }
                    }
                }
            });
        });
        let terminal;
        const type = data.terminalType;
        const closestView = data.closestView;
        const closestMagnet = data.closestMagnet;
        const changed = prevMagnet !== closestMagnet;
        if (prevView && changed) {
            prevView.unhighlight(prevMagnet, {
                type: 'magnetAdsorbed',
            });
        }
        if (closestView) {
            if (!changed) {
                return;
            }
            closestView.highlight(closestMagnet, {
                type: 'magnetAdsorbed',
            });
            terminal = closestView.getEdgeTerminal(closestMagnet, x, y, this.cell, type);
        }
        else {
            terminal = { x, y };
        }
        this.cell.setTerminal(type, terminal, {}, Object.assign(Object.assign({}, data.options), { ui: true }));
    }
    snapArrowheadEnd(data) {
        // Finish off link snapping.
        // Everything except view unhighlighting was already done on pointermove.
        const closestView = data.closestView;
        const closestMagnet = data.closestMagnet;
        if (closestView && closestMagnet) {
            closestView.unhighlight(closestMagnet, {
                type: 'magnetAdsorbed',
            });
            data.currentMagnet = closestView.findMagnet(closestMagnet);
        }
        data.closestView = null;
        data.closestMagnet = null;
    }
    finishEmbedding(data) {
        // Resets parent of the edge if embedding is enabled
        if (this.graph.options.embedding.enabled && this.cell.updateParent()) {
            // Make sure we don't reverse to the original 'z' index
            data.zIndex = null;
        }
    }
    fallbackConnection(data) {
        switch (data.fallbackAction) {
            case 'remove':
                this.cell.remove({ ui: true });
                break;
            case 'revert':
            default:
                this.cell.prop(data.terminalType, data.initialTerminal, {
                    ui: true,
                });
                break;
        }
    }
    notifyConnectionEvent(data, e) {
        const terminalType = data.terminalType;
        const initialTerminal = data.initialTerminal;
        const currentTerminal = this.cell[terminalType];
        const changed = currentTerminal && !_model_edge__WEBPACK_IMPORTED_MODULE_3__.Edge.equalTerminals(initialTerminal, currentTerminal);
        if (changed) {
            const graph = this.graph;
            const previous = initialTerminal;
            const previousCell = previous.cell
                ? graph.getCellById(previous.cell)
                : null;
            const previousPort = previous.port;
            const previousView = previousCell
                ? graph.findViewByCell(previousCell)
                : null;
            const previousPoint = previousCell || data.isNewEdge
                ? null
                : _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(initialTerminal).toJSON();
            const current = currentTerminal;
            const currentCell = current.cell ? graph.getCellById(current.cell) : null;
            const currentPort = current.port;
            const currentView = currentCell ? graph.findViewByCell(currentCell) : null;
            const currentPoint = currentCell
                ? null
                : _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_0__.Point.create(currentTerminal).toJSON();
            this.notify('edge:connected', {
                e,
                previousCell,
                previousPort,
                previousView,
                previousPoint,
                currentCell,
                currentView,
                currentPort,
                currentPoint,
                previousMagnet: data.initialMagnet,
                currentMagnet: data.currentMagnet,
                edge: this.cell,
                view: this,
                type: terminalType,
                isNew: data.isNewEdge,
            });
        }
    }
    highlightAvailableMagnets(data) {
        const graph = this.graph;
        const cells = graph.model.getCells();
        data.marked = {};
        for (let i = 0, ii = cells.length; i < ii; i += 1) {
            const view = graph.findViewByCell(cells[i]);
            // Prevent highlighting new edge
            // Close https://github.com/antvis/X6/issues/2853
            if (!view || view.cell.id === this.cell.id) {
                continue;
            }
            const magnets = Array.prototype.slice.call(view.container.querySelectorAll('[magnet]'));
            if (view.container.getAttribute('magnet') !== 'false') {
                magnets.push(view.container);
            }
            const availableMagnets = magnets.filter((magnet) => this.validateConnection(...data.getValidateConnectionArgs(view, magnet), view.getEdgeTerminal(magnet, data.x, data.y, this.cell, data.terminalType)));
            if (availableMagnets.length > 0) {
                // highlight all available magnets
                for (let j = 0, jj = availableMagnets.length; j < jj; j += 1) {
                    view.highlight(availableMagnets[j], { type: 'magnetAvailable' });
                }
                // highlight the entire view
                view.highlight(null, { type: 'nodeAvailable' });
                data.marked[view.cell.id] = availableMagnets;
            }
        }
    }
    unhighlightAvailableMagnets(data) {
        const marked = data.marked || {};
        Object.keys(marked).forEach((id) => {
            const view = this.graph.findViewByCell(id);
            if (view) {
                const magnets = marked[id];
                magnets.forEach((magnet) => {
                    view.unhighlight(magnet, { type: 'magnetAvailable' });
                });
                view.unhighlight(null, { type: 'nodeAvailable' });
            }
        });
        data.marked = null;
    }
    startArrowheadDragging(e, x, y) {
        if (!this.can('arrowheadMovable')) {
            this.notifyUnhandledMouseDown(e, x, y);
            return;
        }
        const elem = e.target;
        const type = elem.getAttribute('data-terminal');
        const data = this.prepareArrowheadDragging(type, { x, y });
        this.setEventData(e, data);
    }
    dragArrowhead(e, x, y) {
        const data = this.getEventData(e);
        if (this.graph.options.connecting.snap) {
            this.snapArrowhead(x, y, data);
        }
        else {
            this.arrowheadDragging(this.getEventTarget(e), x, y, data);
        }
    }
    stopArrowheadDragging(e, x, y) {
        const graph = this.graph;
        const data = this.getEventData(e);
        if (graph.options.connecting.snap) {
            this.snapArrowheadEnd(data);
        }
        else {
            this.arrowheadDragged(data, x, y);
        }
        const valid = this.validateEdge(this.cell, data.terminalType, data.initialTerminal);
        if (valid) {
            this.finishEmbedding(data);
            this.notifyConnectionEvent(data, e);
        }
        else {
            // If the changed edge is not allowed, revert to its previous state.
            this.fallbackConnection(data);
        }
        this.afterArrowheadDragging(data);
    }
    // #endregion
    // #region drag lable
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    startLabelDragging(e, x, y) {
        if (this.can('edgeLabelMovable')) {
            const target = e.currentTarget;
            const index = parseInt(target.getAttribute('data-index'), 10);
            const positionAngle = this.getLabelPositionAngle(index);
            const labelPositionArgs = this.getLabelPositionArgs(index);
            const defaultLabelPositionArgs = this.getDefaultLabelPositionArgs();
            const positionArgs = this.mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);
            this.setEventData(e, {
                index,
                positionAngle,
                positionArgs,
                stopPropagation: true,
                action: 'drag-label',
            });
        }
        else {
            // If labels can't be dragged no default action is triggered.
            this.setEventData(e, { stopPropagation: true });
        }
        this.graph.view.delegateDragEvents(e, this);
    }
    dragLabel(e, x, y) {
        const data = this.getEventData(e);
        const originLabel = this.cell.getLabelAt(data.index);
        const label = _antv_x6_common__WEBPACK_IMPORTED_MODULE_1__.ObjectExt.merge({}, originLabel, {
            position: this.getLabelPosition(x, y, data.positionAngle, data.positionArgs),
        });
        this.cell.setLabelAt(data.index, label);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    stopLabelDragging(e, x, y) { }
}
(function (EdgeView) {
    EdgeView.toStringTag = `X6.${EdgeView.name}`;
    function isEdgeView(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof EdgeView) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const view = instance;
        if ((tag == null || tag === EdgeView.toStringTag) &&
            typeof view.isNodeView === 'function' &&
            typeof view.isEdgeView === 'function' &&
            typeof view.confirmUpdate === 'function' &&
            typeof view.update === 'function' &&
            typeof view.getConnection === 'function') {
            return true;
        }
        return false;
    }
    EdgeView.isEdgeView = isEdgeView;
})(EdgeView || (EdgeView = {}));
EdgeView.config({
    isSvgElement: true,
    priority: 1,
    bootstrap: ['render', 'source', 'target'],
    actions: {
        view: ['render'],
        markup: ['render'],
        attrs: ['update'],
        source: ['source', 'update'],
        target: ['target', 'update'],
        router: ['update'],
        connector: ['update'],
        labels: ['labels'],
        defaultLabel: ['labels'],
        tools: ['tools'],
        vertices: ['vertices', 'update'],
    },
});
EdgeView.registry.register('edge', EdgeView, true);
//# sourceMappingURL=edge.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/view/flag.js":
/*!***********************************************!*\
  !*** ./node_modules/@antv/x6/es/view/flag.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FlagManager: () => (/* binding */ FlagManager)
/* harmony export */ });
/* eslint-disable no-bitwise */
class FlagManager {
    get cell() {
        return this.view.cell;
    }
    constructor(view, actions, bootstrap = []) {
        this.view = view;
        const flags = {};
        const attrs = {};
        let shift = 0;
        Object.keys(actions).forEach((attr) => {
            let labels = actions[attr];
            if (!Array.isArray(labels)) {
                labels = [labels];
            }
            labels.forEach((label) => {
                let flag = flags[label];
                if (!flag) {
                    shift += 1;
                    flag = flags[label] = 1 << shift;
                }
                attrs[attr] |= flag;
            });
        });
        let labels = bootstrap;
        if (!Array.isArray(labels)) {
            labels = [labels];
        }
        labels.forEach((label) => {
            if (!flags[label]) {
                shift += 1;
                flags[label] = 1 << shift;
            }
        });
        // 26 - 30 are reserved for paper flags
        // 31+ overflows maximal number
        if (shift > 25) {
            throw new Error('Maximum number of flags exceeded.');
        }
        this.flags = flags;
        this.attrs = attrs;
        this.bootstrap = bootstrap;
    }
    getFlag(label) {
        const flags = this.flags;
        if (flags == null) {
            return 0;
        }
        if (Array.isArray(label)) {
            return label.reduce((memo, key) => memo | flags[key], 0);
        }
        return flags[label] | 0;
    }
    hasAction(flag, label) {
        return flag & this.getFlag(label);
    }
    removeAction(flag, label) {
        return flag ^ (flag & this.getFlag(label));
    }
    getBootstrapFlag() {
        return this.getFlag(this.bootstrap);
    }
    getChangedFlag() {
        let flag = 0;
        if (!this.attrs) {
            return flag;
        }
        Object.keys(this.attrs).forEach((attr) => {
            if (this.cell.hasChanged(attr)) {
                flag |= this.attrs[attr];
            }
        });
        return flag;
    }
}
//# sourceMappingURL=flag.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/view/index.js":
/*!************************************************!*\
  !*** ./node_modules/@antv/x6/es/view/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CellView: () => (/* reexport safe */ _cell__WEBPACK_IMPORTED_MODULE_2__.CellView),
/* harmony export */   EdgeView: () => (/* reexport safe */ _edge__WEBPACK_IMPORTED_MODULE_3__.EdgeView),
/* harmony export */   Markup: () => (/* reexport safe */ _markup__WEBPACK_IMPORTED_MODULE_0__.Markup),
/* harmony export */   NodeView: () => (/* reexport safe */ _node__WEBPACK_IMPORTED_MODULE_4__.NodeView),
/* harmony export */   ToolsView: () => (/* reexport safe */ _tool__WEBPACK_IMPORTED_MODULE_5__.ToolsView),
/* harmony export */   View: () => (/* reexport safe */ _view__WEBPACK_IMPORTED_MODULE_1__.View)
/* harmony export */ });
/* harmony import */ var _markup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./markup */ "./node_modules/@antv/x6/es/view/markup.js");
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./view */ "./node_modules/@antv/x6/es/view/view.js");
/* harmony import */ var _cell__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cell */ "./node_modules/@antv/x6/es/view/cell.js");
/* harmony import */ var _edge__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./edge */ "./node_modules/@antv/x6/es/view/edge.js");
/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./node */ "./node_modules/@antv/x6/es/view/node.js");
/* harmony import */ var _tool__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tool */ "./node_modules/@antv/x6/es/view/tool.js");






//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/view/markup.js":
/*!*************************************************!*\
  !*** ./node_modules/@antv/x6/es/view/markup.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Markup: () => (/* binding */ Markup)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");

// eslint-disable-next-line
var Markup;
(function (Markup) {
    function isJSONMarkup(markup) {
        return markup != null && !isStringMarkup(markup);
    }
    Markup.isJSONMarkup = isJSONMarkup;
    function isStringMarkup(markup) {
        return markup != null && typeof markup === 'string';
    }
    Markup.isStringMarkup = isStringMarkup;
    function clone(markup) {
        return markup == null || isStringMarkup(markup)
            ? markup
            : _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(markup);
    }
    Markup.clone = clone;
    /**
     * Removes blank space in markup to prevent create empty text node.
     */
    function sanitize(markup) {
        return `${markup}`
            .trim()
            .replace(/[\r|\n]/g, ' ')
            .replace(/>\s+</g, '><');
    }
    Markup.sanitize = sanitize;
    function parseJSONMarkup(markup, options = { ns: _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.ns.svg }) {
        const fragment = document.createDocumentFragment();
        const groups = {};
        const selectors = {};
        const queue = [
            {
                markup: Array.isArray(markup) ? markup : [markup],
                parent: fragment,
                ns: options.ns,
            },
        ];
        while (queue.length > 0) {
            const item = queue.pop();
            let ns = item.ns || _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.ns.svg;
            const defines = item.markup;
            const parentNode = item.parent;
            defines.forEach((define) => {
                // tagName
                const tagName = define.tagName;
                if (!tagName) {
                    throw new TypeError('Invalid tagName');
                }
                // ns
                if (define.ns) {
                    ns = define.ns;
                }
                const node = ns
                    ? _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.createElementNS(tagName, ns)
                    : _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.createElement(tagName);
                // attrs
                const attrs = define.attrs;
                if (attrs) {
                    _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.attr(node, _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.kebablizeAttrs(attrs));
                }
                // style
                const style = define.style;
                if (style) {
                    _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.css(node, style);
                }
                // classname
                const className = define.className;
                if (className != null) {
                    node.setAttribute('class', Array.isArray(className) ? className.join(' ') : className);
                }
                // textContent
                if (define.textContent) {
                    node.textContent = define.textContent;
                }
                // selector
                const selector = define.selector;
                if (selector != null) {
                    if (selectors[selector]) {
                        throw new TypeError('Selector must be unique');
                    }
                    selectors[selector] = node;
                }
                // group
                if (define.groupSelector) {
                    let nodeGroups = define.groupSelector;
                    if (!Array.isArray(nodeGroups)) {
                        nodeGroups = [nodeGroups];
                    }
                    nodeGroups.forEach((name) => {
                        if (!groups[name]) {
                            groups[name] = [];
                        }
                        groups[name].push(node);
                    });
                }
                parentNode.appendChild(node);
                // children
                const children = define.children;
                if (Array.isArray(children)) {
                    queue.push({ ns, markup: children, parent: node });
                }
            });
        }
        Object.keys(groups).forEach((groupName) => {
            if (selectors[groupName]) {
                throw new Error('Ambiguous group selector');
            }
            selectors[groupName] = groups[groupName];
        });
        return { fragment, selectors, groups };
    }
    Markup.parseJSONMarkup = parseJSONMarkup;
    function createContainer(firstChild) {
        return firstChild instanceof SVGElement
            ? _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.createSvgElement('g')
            : _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.createElement('div');
    }
    function renderMarkup(markup) {
        if (isStringMarkup(markup)) {
            const nodes = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Vector.createVectors(markup);
            const count = nodes.length;
            if (count === 1) {
                return {
                    elem: nodes[0].node,
                };
            }
            if (count > 1) {
                const elem = createContainer(nodes[0].node);
                nodes.forEach((node) => {
                    elem.appendChild(node.node);
                });
                return { elem };
            }
            return {};
        }
        const result = parseJSONMarkup(markup);
        const fragment = result.fragment;
        let elem = null;
        if (fragment.childNodes.length > 1) {
            elem = createContainer(fragment.firstChild);
            elem.appendChild(fragment);
        }
        else {
            elem = fragment.firstChild;
        }
        return { elem, selectors: result.selectors };
    }
    Markup.renderMarkup = renderMarkup;
    function parseLabelStringMarkup(markup) {
        const children = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Vector.createVectors(markup);
        const fragment = document.createDocumentFragment();
        for (let i = 0, n = children.length; i < n; i += 1) {
            const currentChild = children[i].node;
            fragment.appendChild(currentChild);
        }
        return { fragment, selectors: {} };
    }
    Markup.parseLabelStringMarkup = parseLabelStringMarkup;
})(Markup || (Markup = {}));
// eslint-disable-next-line
(function (Markup) {
    function getSelector(elem, stop, prev) {
        if (elem != null) {
            let selector;
            const tagName = elem.tagName.toLowerCase();
            if (elem === stop) {
                if (typeof prev === 'string') {
                    selector = `> ${tagName} > ${prev}`;
                }
                else {
                    selector = `> ${tagName}`;
                }
                return selector;
            }
            const parent = elem.parentNode;
            if (parent && parent.childNodes.length > 1) {
                const nth = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.index(elem) + 1;
                selector = `${tagName}:nth-child(${nth})`;
            }
            else {
                selector = tagName;
            }
            if (prev) {
                selector += ` > ${prev}`;
            }
            return getSelector(elem.parentNode, stop, selector);
        }
        return prev;
    }
    Markup.getSelector = getSelector;
})(Markup || (Markup = {}));
// eslint-disable-next-line
(function (Markup) {
    function getPortContainerMarkup() {
        return 'g';
    }
    Markup.getPortContainerMarkup = getPortContainerMarkup;
    function getPortMarkup() {
        return {
            tagName: 'circle',
            selector: 'circle',
            attrs: {
                r: 10,
                fill: '#FFFFFF',
                stroke: '#000000',
            },
        };
    }
    Markup.getPortMarkup = getPortMarkup;
    function getPortLabelMarkup() {
        return {
            tagName: 'text',
            selector: 'text',
            attrs: {
                fill: '#000000',
            },
        };
    }
    Markup.getPortLabelMarkup = getPortLabelMarkup;
})(Markup || (Markup = {}));
// eslint-disable-next-line
(function (Markup) {
    function getEdgeMarkup() {
        return [
            {
                tagName: 'path',
                selector: 'wrap',
                groupSelector: 'lines',
                attrs: {
                    fill: 'none',
                    cursor: 'pointer',
                    stroke: 'transparent',
                    strokeLinecap: 'round',
                },
            },
            {
                tagName: 'path',
                selector: 'line',
                groupSelector: 'lines',
                attrs: {
                    fill: 'none',
                    pointerEvents: 'none',
                },
            },
        ];
    }
    Markup.getEdgeMarkup = getEdgeMarkup;
})(Markup || (Markup = {}));
// eslint-disable-next-line
(function (Markup) {
    function getForeignObjectMarkup(bare = false) {
        return {
            tagName: 'foreignObject',
            selector: 'fo',
            children: [
                {
                    ns: _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.ns.xhtml,
                    tagName: 'body',
                    selector: 'foBody',
                    attrs: {
                        xmlns: _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.ns.xhtml,
                    },
                    style: {
                        width: '100%',
                        height: '100%',
                        background: 'transparent',
                    },
                    children: bare
                        ? []
                        : [
                            {
                                tagName: 'div',
                                selector: 'foContent',
                                style: {
                                    width: '100%',
                                    height: '100%',
                                },
                            },
                        ],
                },
            ],
        };
    }
    Markup.getForeignObjectMarkup = getForeignObjectMarkup;
})(Markup || (Markup = {}));
//# sourceMappingURL=markup.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/view/node.js":
/*!***********************************************!*\
  !*** ./node_modules/@antv/x6/es/view/node.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NodeView: () => (/* binding */ NodeView)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-geometry */ "./node_modules/@antv/x6-geometry/es/index.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../config */ "./node_modules/@antv/x6/es/config/index.js");
/* harmony import */ var _model_cell__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../model/cell */ "./node_modules/@antv/x6/es/model/cell.js");
/* harmony import */ var _cell__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cell */ "./node_modules/@antv/x6/es/view/cell.js");
/* harmony import */ var _markup__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./markup */ "./node_modules/@antv/x6/es/view/markup.js");






class NodeView extends _cell__WEBPACK_IMPORTED_MODULE_4__.CellView {
    constructor() {
        super(...arguments);
        this.portsCache = {};
        // #endregion
    }
    get [Symbol.toStringTag]() {
        return NodeView.toStringTag;
    }
    getContainerClassName() {
        const classList = [
            super.getContainerClassName(),
            this.prefixClassName('node'),
        ];
        if (!this.can('nodeMovable')) {
            classList.push(this.prefixClassName('node-immovable'));
        }
        return classList.join(' ');
    }
    updateClassName(e) {
        const target = e.target;
        if (target.hasAttribute('magnet')) {
            // port
            const className = this.prefixClassName('port-unconnectable');
            if (this.can('magnetConnectable')) {
                _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.removeClass(target, className);
            }
            else {
                _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(target, className);
            }
        }
        else {
            // node
            const className = this.prefixClassName('node-immovable');
            if (this.can('nodeMovable')) {
                this.removeClass(className);
            }
            else {
                this.addClass(className);
            }
        }
    }
    isNodeView() {
        return true;
    }
    confirmUpdate(flag, options = {}) {
        let ret = flag;
        if (this.hasAction(ret, 'ports')) {
            this.removePorts();
            this.cleanPortsCache();
        }
        if (this.hasAction(ret, 'render')) {
            this.render();
            ret = this.removeAction(ret, [
                'render',
                'update',
                'resize',
                'translate',
                'rotate',
                'ports',
                'tools',
            ]);
        }
        else {
            ret = this.handleAction(ret, 'resize', () => this.resize(), 'update');
            ret = this.handleAction(ret, 'update', () => this.update(), 
            // `update()` will render ports when useCSSSelectors are enabled
            _config__WEBPACK_IMPORTED_MODULE_2__.Config.useCSSSelector ? 'ports' : null);
            ret = this.handleAction(ret, 'translate', () => this.translate());
            ret = this.handleAction(ret, 'rotate', () => this.rotate());
            ret = this.handleAction(ret, 'ports', () => this.renderPorts());
            ret = this.handleAction(ret, 'tools', () => {
                if (this.getFlag('tools') === flag) {
                    this.renderTools();
                }
                else {
                    this.updateTools(options);
                }
            });
        }
        return ret;
    }
    update(partialAttrs) {
        this.cleanCache();
        // When CSS selector strings are used, make sure no rule matches port nodes.
        if (_config__WEBPACK_IMPORTED_MODULE_2__.Config.useCSSSelector) {
            this.removePorts();
        }
        const node = this.cell;
        const size = node.getSize();
        const attrs = node.getAttrs();
        this.updateAttrs(this.container, attrs, {
            attrs: partialAttrs === attrs ? null : partialAttrs,
            rootBBox: new _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle(0, 0, size.width, size.height),
            selectors: this.selectors,
        });
        if (_config__WEBPACK_IMPORTED_MODULE_2__.Config.useCSSSelector) {
            this.renderPorts();
        }
    }
    renderMarkup() {
        const markup = this.cell.markup;
        if (markup) {
            if (typeof markup === 'string') {
                throw new TypeError('Not support string markup.');
            }
            return this.renderJSONMarkup(markup);
        }
        throw new TypeError('Invalid node markup.');
    }
    renderJSONMarkup(markup) {
        const ret = this.parseJSONMarkup(markup, this.container);
        this.selectors = ret.selectors;
        this.container.appendChild(ret.fragment);
    }
    render() {
        this.empty();
        this.renderMarkup();
        this.resize();
        this.updateTransform();
        if (!_config__WEBPACK_IMPORTED_MODULE_2__.Config.useCSSSelector) {
            this.renderPorts();
        }
        this.renderTools();
        return this;
    }
    resize() {
        if (this.cell.getAngle()) {
            this.rotate();
        }
        this.update();
    }
    translate() {
        this.updateTransform();
    }
    rotate() {
        this.updateTransform();
    }
    getTranslationString() {
        const position = this.cell.getPosition();
        return `translate(${position.x},${position.y})`;
    }
    getRotationString() {
        const angle = this.cell.getAngle();
        if (angle) {
            const size = this.cell.getSize();
            return `rotate(${angle},${size.width / 2},${size.height / 2})`;
        }
    }
    updateTransform() {
        let transform = this.getTranslationString();
        const rot = this.getRotationString();
        if (rot) {
            transform += ` ${rot}`;
        }
        this.container.setAttribute('transform', transform);
    }
    // #region ports
    findPortElem(portId, selector) {
        const cache = portId ? this.portsCache[portId] : null;
        if (!cache) {
            return null;
        }
        const portRoot = cache.portContentElement;
        const portSelectors = cache.portContentSelectors || {};
        return this.findOne(selector, portRoot, portSelectors);
    }
    cleanPortsCache() {
        this.portsCache = {};
    }
    removePorts() {
        Object.values(this.portsCache).forEach((cached) => {
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.remove(cached.portElement);
        });
    }
    renderPorts() {
        const container = this.container;
        // References to rendered elements without z-index
        const references = [];
        container.childNodes.forEach((child) => {
            references.push(child);
        });
        const parsedPorts = this.cell.getParsedPorts();
        const portsGropsByZ = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.groupBy(parsedPorts, 'zIndex');
        const autoZIndexKey = 'auto';
        // render non-z first
        if (portsGropsByZ[autoZIndexKey]) {
            portsGropsByZ[autoZIndexKey].forEach((port) => {
                const portElement = this.getPortElement(port);
                container.append(portElement);
                references.push(portElement);
            });
        }
        Object.keys(portsGropsByZ).forEach((key) => {
            if (key !== autoZIndexKey) {
                const zIndex = parseInt(key, 10);
                this.appendPorts(portsGropsByZ[key], zIndex, references);
            }
        });
        this.updatePorts();
    }
    appendPorts(ports, zIndex, refs) {
        const elems = ports.map((p) => this.getPortElement(p));
        if (refs[zIndex] || zIndex < 0) {
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.before(refs[Math.max(zIndex, 0)], elems);
        }
        else {
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.append(this.container, elems);
        }
    }
    getPortElement(port) {
        const cached = this.portsCache[port.id];
        if (cached) {
            return cached.portElement;
        }
        return this.createPortElement(port);
    }
    createPortElement(port) {
        let renderResult = _markup__WEBPACK_IMPORTED_MODULE_5__.Markup.renderMarkup(this.cell.getPortContainerMarkup());
        const portElement = renderResult.elem;
        if (portElement == null) {
            throw new Error('Invalid port container markup.');
        }
        renderResult = _markup__WEBPACK_IMPORTED_MODULE_5__.Markup.renderMarkup(this.getPortMarkup(port));
        const portContentElement = renderResult.elem;
        const portContentSelectors = renderResult.selectors;
        if (portContentElement == null) {
            throw new Error('Invalid port markup.');
        }
        this.setAttrs({
            port: port.id,
            'port-group': port.group,
        }, portContentElement);
        let portClass = 'x6-port';
        if (port.group) {
            portClass += ` x6-port-${port.group}`;
        }
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(portElement, portClass);
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(portElement, 'x6-port');
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(portContentElement, 'x6-port-body');
        portElement.appendChild(portContentElement);
        let portSelectors = portContentSelectors;
        let portLabelElement;
        let portLabelSelectors;
        const existLabel = this.existPortLabel(port);
        if (existLabel) {
            renderResult = _markup__WEBPACK_IMPORTED_MODULE_5__.Markup.renderMarkup(this.getPortLabelMarkup(port.label));
            portLabelElement = renderResult.elem;
            portLabelSelectors = renderResult.selectors;
            if (portLabelElement == null) {
                throw new Error('Invalid port label markup.');
            }
            if (portContentSelectors && portLabelSelectors) {
                // eslint-disable-next-line
                for (const key in portLabelSelectors) {
                    if (portContentSelectors[key] && key !== this.rootSelector) {
                        throw new Error('Selectors within port must be unique.');
                    }
                }
                portSelectors = Object.assign(Object.assign({}, portContentSelectors), portLabelSelectors);
            }
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(portLabelElement, 'x6-port-label');
            portElement.appendChild(portLabelElement);
        }
        this.portsCache[port.id] = {
            portElement,
            portSelectors,
            portLabelElement,
            portLabelSelectors,
            portContentElement,
            portContentSelectors,
        };
        if (this.graph.options.onPortRendered) {
            this.graph.options.onPortRendered({
                port,
                node: this.cell,
                container: portElement,
                selectors: portSelectors,
                labelContainer: portLabelElement,
                labelSelectors: portLabelSelectors,
                contentContainer: portContentElement,
                contentSelectors: portContentSelectors,
            });
        }
        return portElement;
    }
    updatePorts() {
        const groups = this.cell.getParsedGroups();
        const groupList = Object.keys(groups);
        if (groupList.length === 0) {
            this.updatePortGroup();
        }
        else {
            groupList.forEach((groupName) => this.updatePortGroup(groupName));
        }
    }
    updatePortGroup(groupName) {
        const bbox = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.fromSize(this.cell.getSize());
        const metrics = this.cell.getPortsLayoutByGroup(groupName, bbox);
        for (let i = 0, n = metrics.length; i < n; i += 1) {
            const metric = metrics[i];
            const portId = metric.portId;
            const cached = this.portsCache[portId] || {};
            const portLayout = metric.portLayout;
            this.applyPortTransform(cached.portElement, portLayout);
            if (metric.portAttrs != null) {
                const options = {
                    selectors: cached.portSelectors || {},
                };
                if (metric.portSize) {
                    options.rootBBox = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.fromSize(metric.portSize);
                }
                this.updateAttrs(cached.portElement, metric.portAttrs, options);
            }
            const labelLayout = metric.labelLayout;
            if (labelLayout && cached.portLabelElement) {
                this.applyPortTransform(cached.portLabelElement, labelLayout, -(portLayout.angle || 0));
                if (labelLayout.attrs) {
                    const options = {
                        selectors: cached.portLabelSelectors || {},
                    };
                    if (metric.labelSize) {
                        options.rootBBox = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Rectangle.fromSize(metric.labelSize);
                    }
                    this.updateAttrs(cached.portLabelElement, labelLayout.attrs, options);
                }
            }
        }
    }
    applyPortTransform(element, layout, initialAngle = 0) {
        const angle = layout.angle;
        const position = layout.position;
        const matrix = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.createSVGMatrix()
            .rotate(initialAngle)
            .translate(position.x || 0, position.y || 0)
            .rotate(angle || 0);
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.transform(element, matrix, { absolute: true });
    }
    getPortMarkup(port) {
        return port.markup || this.cell.portMarkup;
    }
    getPortLabelMarkup(label) {
        return label.markup || this.cell.portLabelMarkup;
    }
    existPortLabel(port) {
        return port.attrs && port.attrs.text;
    }
    getEventArgs(e, x, y) {
        const view = this; // eslint-disable-line
        const node = view.cell;
        const cell = node;
        if (x == null || y == null) {
            return { e, view, node, cell };
        }
        return { e, x, y, view, node, cell };
    }
    getPortEventArgs(e, port, pos) {
        const view = this; // eslint-disable-line
        const node = view.cell;
        const cell = node;
        if (pos) {
            return {
                e,
                x: pos.x,
                y: pos.y,
                view,
                node,
                cell,
                port,
            };
        }
        return { e, view, node, cell, port };
    }
    notifyMouseDown(e, x, y) {
        super.onMouseDown(e, x, y);
        this.notify('node:mousedown', this.getEventArgs(e, x, y));
    }
    notifyMouseMove(e, x, y) {
        super.onMouseMove(e, x, y);
        this.notify('node:mousemove', this.getEventArgs(e, x, y));
    }
    notifyMouseUp(e, x, y) {
        super.onMouseUp(e, x, y);
        this.notify('node:mouseup', this.getEventArgs(e, x, y));
    }
    notifyPortEvent(name, e, pos) {
        const port = this.findAttr('port', e.target);
        if (port) {
            const originType = e.type;
            if (name === 'node:port:mouseenter') {
                e.type = 'mouseenter';
            }
            else if (name === 'node:port:mouseleave') {
                e.type = 'mouseleave';
            }
            this.notify(name, this.getPortEventArgs(e, port, pos));
            e.type = originType;
        }
    }
    onClick(e, x, y) {
        super.onClick(e, x, y);
        this.notify('node:click', this.getEventArgs(e, x, y));
        this.notifyPortEvent('node:port:click', e, { x, y });
    }
    onDblClick(e, x, y) {
        super.onDblClick(e, x, y);
        this.notify('node:dblclick', this.getEventArgs(e, x, y));
        this.notifyPortEvent('node:port:dblclick', e, { x, y });
    }
    onContextMenu(e, x, y) {
        super.onContextMenu(e, x, y);
        this.notify('node:contextmenu', this.getEventArgs(e, x, y));
        this.notifyPortEvent('node:port:contextmenu', e, { x, y });
    }
    onMouseDown(e, x, y) {
        if (this.isPropagationStopped(e)) {
            return;
        }
        this.notifyMouseDown(e, x, y);
        this.notifyPortEvent('node:port:mousedown', e, { x, y });
        this.startNodeDragging(e, x, y);
    }
    onMouseMove(e, x, y) {
        const data = this.getEventData(e);
        const action = data.action;
        if (action === 'magnet') {
            this.dragMagnet(e, x, y);
        }
        else {
            if (action === 'move') {
                const meta = data;
                const view = meta.targetView || this;
                view.dragNode(e, x, y);
                view.notify('node:moving', {
                    e,
                    x,
                    y,
                    view,
                    cell: view.cell,
                    node: view.cell,
                });
            }
            this.notifyMouseMove(e, x, y);
            this.notifyPortEvent('node:port:mousemove', e, { x, y });
        }
        this.setEventData(e, data);
    }
    onMouseUp(e, x, y) {
        const data = this.getEventData(e);
        const action = data.action;
        if (action === 'magnet') {
            this.stopMagnetDragging(e, x, y);
        }
        else {
            this.notifyMouseUp(e, x, y);
            this.notifyPortEvent('node:port:mouseup', e, { x, y });
            if (action === 'move') {
                const meta = data;
                const view = meta.targetView || this;
                view.stopNodeDragging(e, x, y);
            }
        }
        const magnet = data.targetMagnet;
        if (magnet) {
            this.onMagnetClick(e, magnet, x, y);
        }
        this.checkMouseleave(e);
    }
    onMouseOver(e) {
        super.onMouseOver(e);
        this.notify('node:mouseover', this.getEventArgs(e));
        // mock mouseenter event,so we can get correct trigger time when move mouse from node to port
        // wo also need to change e.type for use get correct event args
        this.notifyPortEvent('node:port:mouseenter', e);
        this.notifyPortEvent('node:port:mouseover', e);
    }
    onMouseOut(e) {
        super.onMouseOut(e);
        this.notify('node:mouseout', this.getEventArgs(e));
        // mock mouseleave event,so we can get correct trigger time when move mouse from port to node
        // wo also need to change e.type for use get correct event args
        this.notifyPortEvent('node:port:mouseleave', e);
        this.notifyPortEvent('node:port:mouseout', e);
    }
    onMouseEnter(e) {
        this.updateClassName(e);
        super.onMouseEnter(e);
        this.notify('node:mouseenter', this.getEventArgs(e));
    }
    onMouseLeave(e) {
        super.onMouseLeave(e);
        this.notify('node:mouseleave', this.getEventArgs(e));
    }
    onMouseWheel(e, x, y, delta) {
        super.onMouseWheel(e, x, y, delta);
        this.notify('node:mousewheel', Object.assign({ delta }, this.getEventArgs(e, x, y)));
    }
    onMagnetClick(e, magnet, x, y) {
        const graph = this.graph;
        const count = graph.view.getMouseMovedCount(e);
        if (count > graph.options.clickThreshold) {
            return;
        }
        this.notify('node:magnet:click', Object.assign({ magnet }, this.getEventArgs(e, x, y)));
    }
    onMagnetDblClick(e, magnet, x, y) {
        this.notify('node:magnet:dblclick', Object.assign({ magnet }, this.getEventArgs(e, x, y)));
    }
    onMagnetContextMenu(e, magnet, x, y) {
        this.notify('node:magnet:contextmenu', Object.assign({ magnet }, this.getEventArgs(e, x, y)));
    }
    onMagnetMouseDown(e, magnet, x, y) {
        this.startMagnetDragging(e, x, y);
    }
    onCustomEvent(e, name, x, y) {
        this.notify('node:customevent', Object.assign({ name }, this.getEventArgs(e, x, y)));
        super.onCustomEvent(e, name, x, y);
    }
    prepareEmbedding(e) {
        const graph = this.graph;
        const data = this.getEventData(e);
        const node = data.cell || this.cell;
        const view = graph.findViewByCell(node);
        const localPoint = graph.snapToGrid(e.clientX, e.clientY);
        this.notify('node:embed', {
            e,
            node,
            view,
            cell: node,
            x: localPoint.x,
            y: localPoint.y,
            currentParent: node.getParent(),
        });
    }
    processEmbedding(e, data) {
        const cell = data.cell || this.cell;
        const graph = data.graph || this.graph;
        const options = graph.options.embedding;
        const findParent = options.findParent;
        let candidates = typeof findParent === 'function'
            ? _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(findParent, graph, {
                view: this,
                node: this.cell,
            }).filter((c) => {
                return (_model_cell__WEBPACK_IMPORTED_MODULE_3__.Cell.isCell(c) &&
                    this.cell.id !== c.id &&
                    !c.isDescendantOf(this.cell));
            })
            : graph.model.getNodesUnderNode(cell, {
                by: findParent,
            });
        // Picks the node with the highest `z` index
        if (options.frontOnly) {
            if (candidates.length > 0) {
                const zIndexMap = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.groupBy(candidates, 'zIndex');
                const maxZIndex = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ArrayExt.max(Object.keys(zIndexMap).map((z) => parseInt(z, 10)));
                if (maxZIndex) {
                    candidates = zIndexMap[maxZIndex];
                }
            }
        }
        // Filter the nodes which is invisiable
        candidates = candidates.filter((candidate) => candidate.visible);
        let newCandidateView = null;
        const prevCandidateView = data.candidateEmbedView;
        const validateEmbeding = options.validate;
        for (let i = candidates.length - 1; i >= 0; i -= 1) {
            const candidate = candidates[i];
            if (prevCandidateView && prevCandidateView.cell.id === candidate.id) {
                // candidate remains the same
                newCandidateView = prevCandidateView;
                break;
            }
            else {
                const view = candidate.findView(graph);
                if (validateEmbeding &&
                    _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(validateEmbeding, graph, {
                        child: this.cell,
                        parent: view.cell,
                        childView: this,
                        parentView: view,
                    })) {
                    // flip to the new candidate
                    newCandidateView = view;
                    break;
                }
            }
        }
        this.clearEmbedding(data);
        if (newCandidateView) {
            newCandidateView.highlight(null, { type: 'embedding' });
        }
        data.candidateEmbedView = newCandidateView;
        const localPoint = graph.snapToGrid(e.clientX, e.clientY);
        this.notify('node:embedding', {
            e,
            cell,
            node: cell,
            view: graph.findViewByCell(cell),
            x: localPoint.x,
            y: localPoint.y,
            currentParent: cell.getParent(),
            candidateParent: newCandidateView ? newCandidateView.cell : null,
        });
    }
    clearEmbedding(data) {
        const candidateView = data.candidateEmbedView;
        if (candidateView) {
            candidateView.unhighlight(null, { type: 'embedding' });
            data.candidateEmbedView = null;
        }
    }
    finalizeEmbedding(e, data) {
        this.graph.startBatch('embedding');
        const cell = data.cell || this.cell;
        const graph = data.graph || this.graph;
        const view = graph.findViewByCell(cell);
        const parent = cell.getParent();
        const candidateView = data.candidateEmbedView;
        if (candidateView) {
            // Candidate view is chosen to become the parent of the node.
            candidateView.unhighlight(null, { type: 'embedding' });
            data.candidateEmbedView = null;
            if (parent == null || parent.id !== candidateView.cell.id) {
                candidateView.cell.insertChild(cell, undefined, { ui: true });
            }
        }
        else if (parent) {
            parent.unembed(cell, { ui: true });
        }
        graph.model.getConnectedEdges(cell, { deep: true }).forEach((edge) => {
            edge.updateParent({ ui: true });
        });
        if (view && candidateView) {
            const localPoint = graph.snapToGrid(e.clientX, e.clientY);
            view.notify('node:embedded', {
                e,
                cell,
                x: localPoint.x,
                y: localPoint.y,
                node: cell,
                view: graph.findViewByCell(cell),
                previousParent: parent,
                currentParent: cell.getParent(),
            });
        }
        this.graph.stopBatch('embedding');
    }
    getDelegatedView() {
        let cell = this.cell;
        let view = this; // eslint-disable-line
        while (view) {
            if (cell.isEdge()) {
                break;
            }
            if (!cell.hasParent() || view.can('stopDelegateOnDragging')) {
                return view;
            }
            cell = cell.getParent();
            view = this.graph.findViewByCell(cell);
        }
        return null;
    }
    validateMagnet(cellView, magnet, e) {
        if (magnet.getAttribute('magnet') !== 'passive') {
            const validate = this.graph.options.connecting.validateMagnet;
            if (validate) {
                return _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(validate, this.graph, {
                    e,
                    magnet,
                    view: cellView,
                    cell: cellView.cell,
                });
            }
            return true;
        }
        return false;
    }
    startMagnetDragging(e, x, y) {
        if (!this.can('magnetConnectable')) {
            return;
        }
        e.stopPropagation();
        const magnet = e.currentTarget;
        const graph = this.graph;
        this.setEventData(e, {
            targetMagnet: magnet,
        });
        if (this.validateMagnet(this, magnet, e)) {
            if (graph.options.magnetThreshold <= 0) {
                this.startConnectting(e, magnet, x, y);
            }
            this.setEventData(e, {
                action: 'magnet',
            });
            this.stopPropagation(e);
        }
        else {
            this.onMouseDown(e, x, y);
        }
        graph.view.delegateDragEvents(e, this);
    }
    startConnectting(e, magnet, x, y) {
        this.graph.model.startBatch('add-edge');
        const edgeView = this.createEdgeFromMagnet(magnet, x, y);
        edgeView.setEventData(e, edgeView.prepareArrowheadDragging('target', {
            x,
            y,
            isNewEdge: true,
            fallbackAction: 'remove',
        }));
        this.setEventData(e, { edgeView });
        edgeView.notifyMouseDown(e, x, y);
    }
    getDefaultEdge(sourceView, sourceMagnet) {
        let edge;
        const create = this.graph.options.connecting.createEdge;
        if (create) {
            edge = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(create, this.graph, {
                sourceMagnet,
                sourceView,
                sourceCell: sourceView.cell,
            });
        }
        return edge;
    }
    createEdgeFromMagnet(magnet, x, y) {
        const graph = this.graph;
        const model = graph.model;
        const edge = this.getDefaultEdge(this, magnet);
        edge.setSource(Object.assign(Object.assign({}, edge.getSource()), this.getEdgeTerminal(magnet, x, y, edge, 'source')));
        edge.setTarget(Object.assign(Object.assign({}, edge.getTarget()), { x, y }));
        edge.addTo(model, { async: false, ui: true });
        return edge.findView(graph);
    }
    dragMagnet(e, x, y) {
        const data = this.getEventData(e);
        const edgeView = data.edgeView;
        if (edgeView) {
            edgeView.onMouseMove(e, x, y);
            this.autoScrollGraph(e.clientX, e.clientY);
        }
        else {
            const graph = this.graph;
            const magnetThreshold = graph.options.magnetThreshold;
            const currentTarget = this.getEventTarget(e);
            const targetMagnet = data.targetMagnet;
            // magnetThreshold when the pointer leaves the magnet
            if (magnetThreshold === 'onleave') {
                if (targetMagnet === currentTarget ||
                    targetMagnet.contains(currentTarget)) {
                    return;
                }
                // eslint-disable-next-line no-lonely-if
            }
            else {
                // magnetThreshold defined as a number of movements
                if (graph.view.getMouseMovedCount(e) <= magnetThreshold) {
                    return;
                }
            }
            this.startConnectting(e, targetMagnet, x, y);
        }
    }
    stopMagnetDragging(e, x, y) {
        const data = this.eventData(e);
        const edgeView = data.edgeView;
        if (edgeView) {
            edgeView.onMouseUp(e, x, y);
            this.graph.model.stopBatch('add-edge');
        }
    }
    notifyUnhandledMouseDown(e, x, y) {
        this.notify('node:unhandled:mousedown', {
            e,
            x,
            y,
            view: this,
            cell: this.cell,
            node: this.cell,
        });
    }
    notifyNodeMove(name, e, x, y, cell) {
        let cells = [cell];
        const selection = this.graph.getPlugin('selection');
        if (selection && selection.isSelectionMovable()) {
            const selectedCells = selection.getSelectedCells();
            if (selectedCells.includes(cell)) {
                cells = selectedCells.filter((c) => c.isNode());
            }
        }
        cells.forEach((c) => {
            this.notify(name, {
                e,
                x,
                y,
                cell: c,
                node: c,
                view: c.findView(this.graph),
            });
        });
    }
    getRestrictArea(view) {
        const restrict = this.graph.options.translating.restrict;
        const area = typeof restrict === 'function'
            ? _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.FunctionExt.call(restrict, this.graph, view)
            : restrict;
        if (typeof area === 'number') {
            return this.graph.transform.getGraphArea().inflate(area);
        }
        if (area === true) {
            return this.graph.transform.getGraphArea();
        }
        return area || null;
    }
    startNodeDragging(e, x, y) {
        const targetView = this.getDelegatedView();
        if (targetView == null || !targetView.can('nodeMovable')) {
            return this.notifyUnhandledMouseDown(e, x, y);
        }
        this.setEventData(e, {
            targetView,
            action: 'move',
        });
        const position = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.Point.create(targetView.cell.getPosition());
        targetView.setEventData(e, {
            moving: false,
            offset: position.diff(x, y),
            restrict: this.getRestrictArea(targetView),
        });
    }
    dragNode(e, x, y) {
        const node = this.cell;
        const graph = this.graph;
        const gridSize = graph.getGridSize();
        const data = this.getEventData(e);
        const offset = data.offset;
        const restrict = data.restrict;
        if (!data.moving) {
            data.moving = true;
            this.addClass('node-moving');
            this.notifyNodeMove('node:move', e, x, y, this.cell);
        }
        this.autoScrollGraph(e.clientX, e.clientY);
        const posX = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.GeometryUtil.snapToGrid(x + offset.x, gridSize);
        const posY = _antv_x6_geometry__WEBPACK_IMPORTED_MODULE_1__.GeometryUtil.snapToGrid(y + offset.y, gridSize);
        node.setPosition(posX, posY, {
            restrict,
            deep: true,
            ui: true,
        });
        if (graph.options.embedding.enabled) {
            if (!data.embedding) {
                this.prepareEmbedding(e);
                data.embedding = true;
            }
            this.processEmbedding(e, data);
        }
    }
    stopNodeDragging(e, x, y) {
        const data = this.getEventData(e);
        if (data.embedding) {
            this.finalizeEmbedding(e, data);
        }
        if (data.moving) {
            this.removeClass('node-moving');
            this.notifyNodeMove('node:moved', e, x, y, this.cell);
        }
        data.moving = false;
        data.embedding = false;
    }
    // eslint-disable-next-line
    autoScrollGraph(x, y) {
        const scroller = this.graph.getPlugin('scroller');
        if (scroller) {
            scroller.autoScroll(x, y);
        }
    }
}
(function (NodeView) {
    NodeView.toStringTag = `X6.${NodeView.name}`;
    function isNodeView(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof NodeView) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const view = instance;
        if ((tag == null || tag === NodeView.toStringTag) &&
            typeof view.isNodeView === 'function' &&
            typeof view.isEdgeView === 'function' &&
            typeof view.confirmUpdate === 'function' &&
            typeof view.update === 'function' &&
            typeof view.findPortElem === 'function' &&
            typeof view.resize === 'function' &&
            typeof view.rotate === 'function' &&
            typeof view.translate === 'function') {
            return true;
        }
        return false;
    }
    NodeView.isNodeView = isNodeView;
})(NodeView || (NodeView = {}));
NodeView.config({
    isSvgElement: true,
    priority: 0,
    bootstrap: ['render'],
    actions: {
        view: ['render'],
        markup: ['render'],
        attrs: ['update'],
        size: ['resize', 'ports', 'tools'],
        angle: ['rotate', 'tools'],
        position: ['translate', 'tools'],
        ports: ['ports'],
        tools: ['tools'],
    },
});
NodeView.registry.register('node', NodeView, true);
//# sourceMappingURL=node.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/view/tool.js":
/*!***********************************************!*\
  !*** ./node_modules/@antv/x6/es/view/tool.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ToolsView: () => (/* binding */ ToolsView)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _registry_tool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../registry/tool */ "./node_modules/@antv/x6/es/registry/tool/index.js");
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./view */ "./node_modules/@antv/x6/es/view/view.js");
/* harmony import */ var _cell__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cell */ "./node_modules/@antv/x6/es/view/cell.js");
/* harmony import */ var _markup__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./markup */ "./node_modules/@antv/x6/es/view/markup.js");





class ToolsView extends _view__WEBPACK_IMPORTED_MODULE_2__.View {
    get name() {
        return this.options.name;
    }
    get graph() {
        return this.cellView.graph;
    }
    get cell() {
        return this.cellView.cell;
    }
    get [Symbol.toStringTag]() {
        return ToolsView.toStringTag;
    }
    constructor(options = {}) {
        super();
        this.svgContainer = this.createContainer(true, options);
        this.htmlContainer = this.createContainer(false, options);
        this.config(options);
    }
    createContainer(svg, options) {
        const container = svg
            ? _view__WEBPACK_IMPORTED_MODULE_2__.View.createElement('g', true)
            : _view__WEBPACK_IMPORTED_MODULE_2__.View.createElement('div', false);
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(container, this.prefixClassName('cell-tools'));
        if (options.className) {
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(container, options.className);
        }
        return container;
    }
    config(options) {
        this.options = Object.assign(Object.assign({}, this.options), options);
        if (!_cell__WEBPACK_IMPORTED_MODULE_3__.CellView.isCellView(options.view) || options.view === this.cellView) {
            return this;
        }
        this.cellView = options.view;
        if (this.cell.isEdge()) {
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.svgContainer, this.prefixClassName('edge-tools'));
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.htmlContainer, this.prefixClassName('edge-tools'));
        }
        else if (this.cell.isNode()) {
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.svgContainer, this.prefixClassName('node-tools'));
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.htmlContainer, this.prefixClassName('node-tools'));
        }
        this.svgContainer.setAttribute('data-cell-id', this.cell.id);
        this.htmlContainer.setAttribute('data-cell-id', this.cell.id);
        if (this.name) {
            this.svgContainer.setAttribute('data-tools-name', this.name);
            this.htmlContainer.setAttribute('data-tools-name', this.name);
        }
        const tools = this.options.items;
        if (!Array.isArray(tools)) {
            return this;
        }
        this.tools = [];
        const normalizedTools = [];
        tools.forEach((meta) => {
            if (ToolsView.ToolItem.isToolItem(meta)) {
                if (meta.name === 'vertices') {
                    normalizedTools.unshift(meta);
                }
                else {
                    normalizedTools.push(meta);
                }
            }
            else {
                const name = typeof meta === 'object' ? meta.name : meta;
                if (name === 'vertices') {
                    normalizedTools.unshift(meta);
                }
                else {
                    normalizedTools.push(meta);
                }
            }
        });
        for (let i = 0; i < normalizedTools.length; i += 1) {
            const meta = normalizedTools[i];
            let tool;
            if (ToolsView.ToolItem.isToolItem(meta)) {
                tool = meta;
            }
            else {
                const name = typeof meta === 'object' ? meta.name : meta;
                const args = typeof meta === 'object' ? meta.args || {} : {};
                if (name) {
                    if (this.cell.isNode()) {
                        const ctor = _registry_tool__WEBPACK_IMPORTED_MODULE_1__.NodeTool.registry.get(name);
                        if (ctor) {
                            tool = new ctor(args); // eslint-disable-line
                        }
                        else {
                            return _registry_tool__WEBPACK_IMPORTED_MODULE_1__.NodeTool.registry.onNotFound(name);
                        }
                    }
                    else if (this.cell.isEdge()) {
                        const ctor = _registry_tool__WEBPACK_IMPORTED_MODULE_1__.EdgeTool.registry.get(name);
                        if (ctor) {
                            tool = new ctor(args); // eslint-disable-line
                        }
                        else {
                            return _registry_tool__WEBPACK_IMPORTED_MODULE_1__.EdgeTool.registry.onNotFound(name);
                        }
                    }
                }
            }
            if (tool) {
                tool.config(this.cellView, this);
                tool.render();
                const container = tool.options.isSVGElement !== false
                    ? this.svgContainer
                    : this.htmlContainer;
                container.appendChild(tool.container);
                this.tools.push(tool);
            }
        }
        return this;
    }
    update(options = {}) {
        const tools = this.tools;
        if (tools) {
            tools.forEach((tool) => {
                if (options.toolId !== tool.cid && tool.isVisible()) {
                    tool.update();
                }
            });
        }
        return this;
    }
    focus(focusedTool) {
        const tools = this.tools;
        if (tools) {
            tools.forEach((tool) => {
                if (focusedTool === tool) {
                    tool.show();
                }
                else {
                    tool.hide();
                }
            });
        }
        return this;
    }
    blur(blurredTool) {
        const tools = this.tools;
        if (tools) {
            tools.forEach((tool) => {
                if (tool !== blurredTool && !tool.isVisible()) {
                    tool.show();
                    tool.update();
                }
            });
        }
        return this;
    }
    hide() {
        return this.focus(null);
    }
    show() {
        return this.blur(null);
    }
    remove() {
        const tools = this.tools;
        if (tools) {
            tools.forEach((tool) => tool.remove());
            this.tools = null;
        }
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.remove(this.svgContainer);
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.remove(this.htmlContainer);
        return super.remove();
    }
    mount() {
        const tools = this.tools;
        const cellView = this.cellView;
        if (cellView && tools) {
            const hasSVG = tools.some((tool) => tool.options.isSVGElement !== false);
            const hasHTML = tools.some((tool) => tool.options.isSVGElement === false);
            if (hasSVG) {
                const parent = this.options.local
                    ? cellView.container
                    : cellView.graph.view.decorator;
                parent.appendChild(this.svgContainer);
            }
            if (hasHTML) {
                this.graph.container.appendChild(this.htmlContainer);
            }
        }
        return this;
    }
}
(function (ToolsView) {
    ToolsView.toStringTag = `X6.${ToolsView.name}`;
    function isToolsView(instance) {
        if (instance == null) {
            return false;
        }
        if (instance instanceof ToolsView) {
            return true;
        }
        const tag = instance[Symbol.toStringTag];
        const view = instance;
        if ((tag == null || tag === ToolsView.toStringTag) &&
            view.graph != null &&
            view.cell != null &&
            typeof view.config === 'function' &&
            typeof view.update === 'function' &&
            typeof view.focus === 'function' &&
            typeof view.blur === 'function' &&
            typeof view.show === 'function' &&
            typeof view.hide === 'function') {
            return true;
        }
        return false;
    }
    ToolsView.isToolsView = isToolsView;
})(ToolsView || (ToolsView = {}));
(function (ToolsView) {
    class ToolItem extends _view__WEBPACK_IMPORTED_MODULE_2__.View {
        static getDefaults() {
            return this.defaults;
        }
        static config(options) {
            this.defaults = this.getOptions(options);
        }
        static getOptions(options) {
            return _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.merge(_antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.cloneDeep(this.getDefaults()), options);
        }
        get graph() {
            return this.cellView.graph;
        }
        get cell() {
            return this.cellView.cell;
        }
        get name() {
            return this.options.name;
        }
        get [Symbol.toStringTag]() {
            return ToolItem.toStringTag;
        }
        constructor(options = {}) {
            super();
            this.visible = true;
            this.options = this.getOptions(options);
            this.container = _view__WEBPACK_IMPORTED_MODULE_2__.View.createElement(this.options.tagName || 'g', this.options.isSVGElement !== false);
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.container, this.prefixClassName('cell-tool'));
            if (typeof this.options.className === 'string') {
                _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.container, this.options.className);
            }
            this.init();
        }
        init() { }
        getOptions(options) {
            const ctor = this.constructor;
            return ctor.getOptions(options);
        }
        delegateEvents() {
            if (this.options.events) {
                super.delegateEvents(this.options.events);
            }
            return this;
        }
        config(view, toolsView) {
            this.cellView = view;
            this.parent = toolsView;
            this.stamp(this.container);
            if (this.cell.isEdge()) {
                _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.container, this.prefixClassName('edge-tool'));
            }
            else if (this.cell.isNode()) {
                _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(this.container, this.prefixClassName('node-tool'));
            }
            if (this.name) {
                this.container.setAttribute('data-tool-name', this.name);
            }
            this.delegateEvents();
            return this;
        }
        render() {
            this.empty();
            const markup = this.options.markup;
            if (markup) {
                const meta = _markup__WEBPACK_IMPORTED_MODULE_4__.Markup.parseJSONMarkup(markup);
                this.container.appendChild(meta.fragment);
                this.childNodes = meta.selectors;
            }
            this.onRender();
            return this;
        }
        onRender() { }
        update() {
            return this;
        }
        stamp(elem) {
            if (elem) {
                elem.setAttribute('data-cell-id', this.cellView.cell.id);
            }
        }
        show() {
            this.container.style.display = '';
            this.visible = true;
            return this;
        }
        hide() {
            this.container.style.display = 'none';
            this.visible = false;
            return this;
        }
        isVisible() {
            return this.visible;
        }
        focus() {
            const opacity = this.options.focusOpacity;
            if (opacity != null && Number.isFinite(opacity)) {
                this.container.style.opacity = `${opacity}`;
            }
            this.parent.focus(this);
            return this;
        }
        blur() {
            this.container.style.opacity = '';
            this.parent.blur(this);
            return this;
        }
        guard(evt) {
            if (this.graph == null || this.cellView == null) {
                return true;
            }
            return this.graph.view.guard(evt, this.cellView);
        }
    }
    // #region static
    ToolItem.defaults = {
        isSVGElement: true,
        tagName: 'g',
    };
    ToolsView.ToolItem = ToolItem;
    (function (ToolItem) {
        let counter = 0;
        function getClassName(name) {
            if (name) {
                return _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.StringExt.pascalCase(name);
            }
            counter += 1;
            return `CustomTool${counter}`;
        }
        function define(options) {
            const tool = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.ObjectExt.createClass(getClassName(options.name), this);
            tool.config(options);
            return tool;
        }
        ToolItem.define = define;
    })(ToolItem = ToolsView.ToolItem || (ToolsView.ToolItem = {}));
    (function (ToolItem) {
        ToolItem.toStringTag = `X6.${ToolItem.name}`;
        function isToolItem(instance) {
            if (instance == null) {
                return false;
            }
            if (instance instanceof ToolItem) {
                return true;
            }
            const tag = instance[Symbol.toStringTag];
            const view = instance;
            if ((tag == null || tag === ToolItem.toStringTag) &&
                view.graph != null &&
                view.cell != null &&
                typeof view.config === 'function' &&
                typeof view.update === 'function' &&
                typeof view.focus === 'function' &&
                typeof view.blur === 'function' &&
                typeof view.show === 'function' &&
                typeof view.hide === 'function' &&
                typeof view.isVisible === 'function') {
                return true;
            }
            return false;
        }
        ToolItem.isToolItem = isToolItem;
    })(ToolItem = ToolsView.ToolItem || (ToolsView.ToolItem = {}));
})(ToolsView || (ToolsView = {}));
//# sourceMappingURL=tool.js.map

/***/ }),

/***/ "./node_modules/@antv/x6/es/view/view.js":
/*!***********************************************!*\
  !*** ./node_modules/@antv/x6/es/view/view.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   View: () => (/* binding */ View)
/* harmony export */ });
/* harmony import */ var _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6-common */ "./node_modules/@antv/x6-common/es/index.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config */ "./node_modules/@antv/x6/es/config/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


class View extends _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Basecoat {
    get priority() {
        return 2;
    }
    /** If need remove `this.container` DOM */
    get disposeContainer() {
        return true;
    }
    constructor() {
        super();
        this.cid = Private.uniqueId();
        View.views[this.cid] = this;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    confirmUpdate(flag, options) {
        return 0;
    }
    empty(elem = this.container) {
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.empty(elem);
        return this;
    }
    unmount(elem = this.container) {
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.remove(elem);
        return this;
    }
    remove(elem = this.container) {
        if (elem === this.container) {
            this.removeEventListeners(document);
            this.onRemove();
            delete View.views[this.cid];
            if (this.disposeContainer) {
                this.unmount(elem);
            }
        }
        else {
            this.unmount(elem);
        }
        return this;
    }
    onRemove() { }
    setClass(className, elem = this.container) {
        elem.classList.value = Array.isArray(className)
            ? className.join(' ')
            : className;
    }
    addClass(className, elem = this.container) {
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.addClass(elem, Array.isArray(className) ? className.join(' ') : className);
        return this;
    }
    removeClass(className, elem = this.container) {
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.removeClass(elem, Array.isArray(className) ? className.join(' ') : className);
        return this;
    }
    setStyle(style, elem = this.container) {
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.css(elem, style);
        return this;
    }
    setAttrs(attrs, elem = this.container) {
        if (attrs != null && elem != null) {
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.attr(elem, attrs);
        }
        return this;
    }
    /**
     * Returns the value of the specified attribute of `node`.
     *
     * If the node does not set a value for attribute, start recursing up
     * the DOM tree from node to lookup for attribute at the ancestors of
     * node. If the recursion reaches CellView's root node and attribute
     * is not found even there, return `null`.
     */
    findAttr(attrName, elem = this.container) {
        let current = elem;
        while (current && current.nodeType === 1) {
            const value = current.getAttribute(attrName);
            if (value != null) {
                return value;
            }
            if (current === this.container) {
                return null;
            }
            current = current.parentNode;
        }
        return null;
    }
    find(selector, rootElem = this.container, selectors = this.selectors) {
        return View.find(selector, rootElem, selectors).elems;
    }
    findOne(selector, rootElem = this.container, selectors = this.selectors) {
        const nodes = this.find(selector, rootElem, selectors);
        return nodes.length > 0 ? nodes[0] : null;
    }
    findByAttr(attrName, elem = this.container) {
        let node = elem;
        while (node && node.getAttribute) {
            const val = node.getAttribute(attrName);
            if ((val != null || node === this.container) && val !== 'false') {
                return node;
            }
            node = node.parentNode;
        }
        // If the overall cell has set `magnet === false`, then returns
        // `null` to announce there is no magnet found for this cell.
        // This is especially useful to set on cells that have 'ports'.
        // In this case, only the ports have set `magnet === true` and the
        // overall element has `magnet === false`.
        return null;
    }
    getSelector(elem, prevSelector) {
        let selector;
        if (elem === this.container) {
            if (typeof prevSelector === 'string') {
                selector = `> ${prevSelector}`;
            }
            return selector;
        }
        if (elem) {
            const nth = _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.index(elem) + 1;
            selector = `${elem.tagName.toLowerCase()}:nth-child(${nth})`;
            if (prevSelector) {
                selector += ` > ${prevSelector}`;
            }
            selector = this.getSelector(elem.parentNode, selector);
        }
        return selector;
    }
    prefixClassName(className) {
        return _config__WEBPACK_IMPORTED_MODULE_1__.Config.prefix(className);
    }
    delegateEvents(events, append) {
        if (events == null) {
            return this;
        }
        if (!append) {
            this.undelegateEvents();
        }
        const splitter = /^(\S+)\s*(.*)$/;
        Object.keys(events).forEach((key) => {
            const match = key.match(splitter);
            if (match == null) {
                return;
            }
            const method = this.getEventHandler(events[key]);
            if (typeof method === 'function') {
                this.delegateEvent(match[1], match[2], method);
            }
        });
        return this;
    }
    undelegateEvents() {
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.Event.off(this.container, this.getEventNamespace());
        return this;
    }
    delegateDocumentEvents(events, data) {
        this.addEventListeners(document, events, data);
        return this;
    }
    undelegateDocumentEvents() {
        this.removeEventListeners(document);
        return this;
    }
    delegateEvent(eventName, selector, listener) {
        _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.Event.on(this.container, eventName + this.getEventNamespace(), selector, listener);
        return this;
    }
    undelegateEvent(eventName, selector, listener) {
        const name = eventName + this.getEventNamespace();
        if (selector == null) {
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.Event.off(this.container, name);
        }
        else if (typeof selector === 'string') {
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.Event.off(this.container, name, selector, listener);
        }
        else {
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.Event.off(this.container, name, selector);
        }
        return this;
    }
    addEventListeners(elem, events, data) {
        if (events == null) {
            return this;
        }
        const ns = this.getEventNamespace();
        Object.keys(events).forEach((eventName) => {
            const method = this.getEventHandler(events[eventName]);
            if (typeof method === 'function') {
                _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.Event.on(elem, eventName + ns, data, method);
            }
        });
        return this;
    }
    removeEventListeners(elem) {
        if (elem != null) {
            _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.Event.off(elem, this.getEventNamespace());
        }
        return this;
    }
    getEventNamespace() {
        return `.${_config__WEBPACK_IMPORTED_MODULE_1__.Config.prefixCls}-event-${this.cid}`;
    }
    // eslint-disable-next-line
    getEventHandler(handler) {
        // eslint-disable-next-line
        let method;
        if (typeof handler === 'string') {
            const fn = this[handler];
            if (typeof fn === 'function') {
                method = (...args) => fn.call(this, ...args);
            }
        }
        else {
            method = (...args) => handler.call(this, ...args);
        }
        return method;
    }
    getEventTarget(e, options = {}) {
        // Touchmove/Touchend event's target is not reflecting the element
        // under the coordinates as mousemove does.
        // It holds the element when a touchstart triggered.
        const { target, type, clientX = 0, clientY = 0 } = e;
        if (options.fromPoint || type === 'touchmove' || type === 'touchend') {
            return document.elementFromPoint(clientX, clientY);
        }
        return target;
    }
    stopPropagation(e) {
        this.setEventData(e, { propagationStopped: true });
        return this;
    }
    isPropagationStopped(e) {
        return this.getEventData(e).propagationStopped === true;
    }
    getEventData(e) {
        return this.eventData(e);
    }
    setEventData(e, data) {
        return this.eventData(e, data);
    }
    eventData(e, data) {
        if (e == null) {
            throw new TypeError('Event object required');
        }
        let currentData = e.data;
        const key = `__${this.cid}__`;
        // get
        if (data == null) {
            if (currentData == null) {
                return {};
            }
            return currentData[key] || {};
        }
        // set
        if (currentData == null) {
            currentData = e.data = {};
        }
        if (currentData[key] == null) {
            currentData[key] = Object.assign({}, data);
        }
        else {
            currentData[key] = Object.assign(Object.assign({}, currentData[key]), data);
        }
        return currentData[key];
    }
    normalizeEvent(evt) {
        return View.normalizeEvent(evt);
    }
    dispose() {
        this.remove();
    }
}
__decorate([
    View.dispose()
], View.prototype, "dispose", null);
(function (View) {
    function createElement(tagName, isSvgElement) {
        return isSvgElement
            ? _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.createSvgElement(tagName || 'g')
            : _antv_x6_common__WEBPACK_IMPORTED_MODULE_0__.Dom.createElementNS(tagName || 'div');
    }
    View.createElement = createElement;
    function find(selector, rootElem, selectors) {
        if (!selector || selector === '.') {
            return { elems: [rootElem] };
        }
        if (selectors) {
            const nodes = selectors[selector];
            if (nodes) {
                return { elems: Array.isArray(nodes) ? nodes : [nodes] };
            }
        }
        if (_config__WEBPACK_IMPORTED_MODULE_1__.Config.useCSSSelector) {
            const validSelector = selector.includes('>')
                ? `:scope ${selector}`
                : selector;
            return {
                isCSSSelector: true,
                // $(rootElem).find(selector).toArray() as Element[]
                elems: Array.prototype.slice.call(rootElem.querySelectorAll(validSelector)),
            };
        }
        return { elems: [] };
    }
    View.find = find;
    function normalizeEvent(evt) {
        let normalizedEvent = evt;
        const originalEvent = evt.originalEvent;
        const touchEvt = originalEvent &&
            originalEvent.changedTouches &&
            originalEvent.changedTouches[0];
        if (touchEvt) {
            // eslint-disable-next-line no-restricted-syntax
            for (const key in evt) {
                if (touchEvt[key] === undefined) {
                    touchEvt[key] = evt[key];
                }
            }
            normalizedEvent = touchEvt;
        }
        return normalizedEvent;
    }
    View.normalizeEvent = normalizeEvent;
})(View || (View = {}));
(function (View) {
    View.views = {};
    function getView(cid) {
        return View.views[cid] || null;
    }
    View.getView = getView;
})(View || (View = {}));
var Private;
(function (Private) {
    let counter = 0;
    function uniqueId() {
        const id = `v${counter}`;
        counter += 1;
        return id;
    }
    Private.uniqueId = uniqueId;
})(Private || (Private = {}));
//# sourceMappingURL=view.js.map

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./css/designer.css":
/*!****************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./css/designer.css ***!
  \****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.x6-graph-background {
    background-color: var(--mud-palette-background);
}

.x6-widget-selection-box {
    border: 2px dashed var(--mud-palette-secondary);
}

.x6-widget-selection-inner {
    border: 1px solid var(--mud-palette-secondary);
}

.elsa-snapline .x6-widget-snapline-horizontal, 
.elsa-snapline .x6-widget-snapline-vertical {
    stroke: var(--mud-palette-secondary);
}

.elsa-activity {
    border-left: solid 6px var(--mud-palette-info);
    filter: drop-shadow(0 4px 3px rgb(0 0 0 / 0.07)) drop-shadow(0 2px 2px rgb(0 0 0 / 0.06)); 
    height: 100%;
}`, "",{"version":3,"sources":["webpack://./css/designer.css"],"names":[],"mappings":"AAAA;IACI,+CAA+C;AACnD;;AAEA;IACI,+CAA+C;AACnD;;AAEA;IACI,8CAA8C;AAClD;;AAEA;;IAEI,oCAAoC;AACxC;;AAEA;IACI,8CAA8C;IAC9C,yFAAyF;IACzF,YAAY;AAChB","sourcesContent":[".x6-graph-background {\r\n    background-color: var(--mud-palette-background);\r\n}\r\n\r\n.x6-widget-selection-box {\r\n    border: 2px dashed var(--mud-palette-secondary);\r\n}\r\n\r\n.x6-widget-selection-inner {\r\n    border: 1px solid var(--mud-palette-secondary);\r\n}\r\n\r\n.elsa-snapline .x6-widget-snapline-horizontal, \r\n.elsa-snapline .x6-widget-snapline-vertical {\r\n    stroke: var(--mud-palette-secondary);\r\n}\r\n\r\n.elsa-activity {\r\n    border-left: solid 6px var(--mud-palette-info);\r\n    filter: drop-shadow(0 4px 3px rgb(0 0 0 / 0.07)) drop-shadow(0 2px 2px rgb(0 0 0 / 0.06)); \r\n    height: 100%;\r\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {



module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];
  if (!cssMapping) {
    return content;
  }
  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    return [content].concat([sourceMapping]).join("\n");
  }
  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/d3-dispatch/src/dispatch.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-dispatch/src/dispatch.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var noop = {value: () => {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dispatch);


/***/ }),

/***/ "./node_modules/d3-force/src/center.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-force/src/center.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y) {
  var nodes, strength = 1;

  if (x == null) x = 0;
  if (y == null) y = 0;

  function force() {
    var i,
        n = nodes.length,
        node,
        sx = 0,
        sy = 0;

    for (i = 0; i < n; ++i) {
      node = nodes[i], sx += node.x, sy += node.y;
    }

    for (sx = (sx / n - x) * strength, sy = (sy / n - y) * strength, i = 0; i < n; ++i) {
      node = nodes[i], node.x -= sx, node.y -= sy;
    }
  }

  force.initialize = function(_) {
    nodes = _;
  };

  force.x = function(_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function(_) {
    return arguments.length ? (y = +_, force) : y;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-force/src/collide.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-force/src/collide.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_quadtree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-quadtree */ "./node_modules/d3-quadtree/src/quadtree.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force/src/constant.js");
/* harmony import */ var _jiggle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./jiggle.js */ "./node_modules/d3-force/src/jiggle.js");




function x(d) {
  return d.x + d.vx;
}

function y(d) {
  return d.y + d.vy;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(radius) {
  var nodes,
      radii,
      random,
      strength = 1,
      iterations = 1;

  if (typeof radius !== "function") radius = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(radius == null ? 1 : +radius);

  function force() {
    var i, n = nodes.length,
        tree,
        node,
        xi,
        yi,
        ri,
        ri2;

    for (var k = 0; k < iterations; ++k) {
      tree = (0,d3_quadtree__WEBPACK_IMPORTED_MODULE_1__["default"])(nodes, x, y).visitAfter(prepare);
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply);
      }
    }

    function apply(quad, x0, y0, x1, y1) {
      var data = quad.data, rj = quad.r, r = ri + rj;
      if (data) {
        if (data.index > node.index) {
          var x = xi - data.x - data.vx,
              y = yi - data.y - data.vy,
              l = x * x + y * y;
          if (l < r * r) {
            if (x === 0) x = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(random), l += x * x;
            if (y === 0) y = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(random), l += y * y;
            l = (r - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
            node.vy += (y *= l) * r;
            data.vx -= x * (r = 1 - r);
            data.vy -= y * r;
          }
        }
        return;
      }
      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
    }
  }

  function prepare(quad) {
    if (quad.data) return quad.r = radii[quad.data.index];
    for (var i = quad.r = 0; i < 4; ++i) {
      if (quad[i] && quad[i].r > quad.r) {
        quad.r = quad[i].r;
      }
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    radii = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
  }

  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : radius;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-force/src/constant.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-force/src/constant.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-force/src/jiggle.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-force/src/jiggle.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(random) {
  return (random() - 0.5) * 1e-6;
}


/***/ }),

/***/ "./node_modules/d3-force/src/lcg.js":
/*!******************************************!*\
  !*** ./node_modules/d3-force/src/lcg.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
const a = 1664525;
const c = 1013904223;
const m = 4294967296; // 2^32

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  let s = 1;
  return () => (s = (a * s + c) % m) / m;
}


/***/ }),

/***/ "./node_modules/d3-force/src/link.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-force/src/link.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force/src/constant.js");
/* harmony import */ var _jiggle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jiggle.js */ "./node_modules/d3-force/src/jiggle.js");



function index(d) {
  return d.index;
}

function find(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node) throw new Error("node not found: " + nodeId);
  return node;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(links) {
  var id = index,
      strength = defaultStrength,
      strengths,
      distance = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(30),
      distances,
      nodes,
      count,
      bias,
      random,
      iterations = 1;

  if (links == null) links = [];

  function defaultStrength(link) {
    return 1 / Math.min(count[link.source.index], count[link.target.index]);
  }

  function force(alpha) {
    for (var k = 0, n = links.length; k < iterations; ++k) {
      for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
        link = links[i], source = link.source, target = link.target;
        x = target.x + target.vx - source.x - source.vx || (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(random);
        y = target.y + target.vy - source.y - source.vy || (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(random);
        l = Math.sqrt(x * x + y * y);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x *= l, y *= l;
        target.vx -= x * (b = bias[i]);
        target.vy -= y * b;
        source.vx += x * (b = 1 - b);
        source.vy += y * b;
      }
    }
  }

  function initialize() {
    if (!nodes) return;

    var i,
        n = nodes.length,
        m = links.length,
        nodeById = new Map(nodes.map((d, i) => [id(d, i, nodes), d])),
        link;

    for (i = 0, count = new Array(n); i < m; ++i) {
      link = links[i], link.index = i;
      if (typeof link.source !== "object") link.source = find(nodeById, link.source);
      if (typeof link.target !== "object") link.target = find(nodeById, link.target);
      count[link.source.index] = (count[link.source.index] || 0) + 1;
      count[link.target.index] = (count[link.target.index] || 0) + 1;
    }

    for (i = 0, bias = new Array(m); i < m; ++i) {
      link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
    }

    strengths = new Array(m), initializeStrength();
    distances = new Array(m), initializeDistance();
  }

  function initializeStrength() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }

  function initializeDistance() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance(links[i], i, links);
    }
  }

  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };

  force.links = function(_) {
    return arguments.length ? (links = _, initialize(), force) : links;
  };

  force.id = function(_) {
    return arguments.length ? (id = _, force) : id;
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initializeStrength(), force) : strength;
  };

  force.distance = function(_) {
    return arguments.length ? (distance = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initializeDistance(), force) : distance;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-force/src/manyBody.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-force/src/manyBody.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_quadtree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-quadtree */ "./node_modules/d3-quadtree/src/quadtree.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force/src/constant.js");
/* harmony import */ var _jiggle_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./jiggle.js */ "./node_modules/d3-force/src/jiggle.js");
/* harmony import */ var _simulation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./simulation.js */ "./node_modules/d3-force/src/simulation.js");





/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var nodes,
      node,
      random,
      alpha,
      strength = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(-30),
      strengths,
      distanceMin2 = 1,
      distanceMax2 = Infinity,
      theta2 = 0.81;

  function force(_) {
    var i, n = nodes.length, tree = (0,d3_quadtree__WEBPACK_IMPORTED_MODULE_1__["default"])(nodes, _simulation_js__WEBPACK_IMPORTED_MODULE_2__.x, _simulation_js__WEBPACK_IMPORTED_MODULE_2__.y).visitAfter(accumulate);
    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    strengths = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
  }

  function accumulate(quad) {
    var strength = 0, q, c, weight = 0, x, y, i;

    // For internal nodes, accumulate forces from child quadrants.
    if (quad.length) {
      for (x = y = i = 0; i < 4; ++i) {
        if ((q = quad[i]) && (c = Math.abs(q.value))) {
          strength += q.value, weight += c, x += c * q.x, y += c * q.y;
        }
      }
      quad.x = x / weight;
      quad.y = y / weight;
    }

    // For leaf nodes, accumulate forces from coincident quadrants.
    else {
      q = quad;
      q.x = q.data.x;
      q.y = q.data.y;
      do strength += strengths[q.data.index];
      while (q = q.next);
    }

    quad.value = strength;
  }

  function apply(quad, x1, _, x2) {
    if (!quad.value) return true;

    var x = quad.x - node.x,
        y = quad.y - node.y,
        w = x2 - x1,
        l = x * x + y * y;

    // Apply the Barnes-Hut approximation if possible.
    // Limit forces for very close nodes; randomize direction if coincident.
    if (w * w / theta2 < l) {
      if (l < distanceMax2) {
        if (x === 0) x = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_3__["default"])(random), l += x * x;
        if (y === 0) y = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_3__["default"])(random), l += y * y;
        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        node.vx += x * quad.value * alpha / l;
        node.vy += y * quad.value * alpha / l;
      }
      return true;
    }

    // Otherwise, process points directly.
    else if (quad.length || l >= distanceMax2) return;

    // Limit forces for very close nodes; randomize direction if coincident.
    if (quad.data !== node || quad.next) {
      if (x === 0) x = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_3__["default"])(random), l += x * x;
      if (y === 0) y = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_3__["default"])(random), l += y * y;
      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
    }

    do if (quad.data !== node) {
      w = strengths[quad.data.index] * alpha / l;
      node.vx += x * w;
      node.vy += y * w;
    } while (quad = quad.next);
  }

  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : strength;
  };

  force.distanceMin = function(_) {
    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
  };

  force.distanceMax = function(_) {
    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
  };

  force.theta = function(_) {
    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-force/src/simulation.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-force/src/simulation.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   x: () => (/* binding */ x),
/* harmony export */   y: () => (/* binding */ y)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timer.js");
/* harmony import */ var _lcg_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lcg.js */ "./node_modules/d3-force/src/lcg.js");




function x(d) {
  return d.x;
}

function y(d) {
  return d.y;
}

var initialRadius = 10,
    initialAngle = Math.PI * (3 - Math.sqrt(5));

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(nodes) {
  var simulation,
      alpha = 1,
      alphaMin = 0.001,
      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
      alphaTarget = 0,
      velocityDecay = 0.6,
      forces = new Map(),
      stepper = (0,d3_timer__WEBPACK_IMPORTED_MODULE_0__.timer)(step),
      event = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_1__["default"])("tick", "end"),
      random = (0,_lcg_js__WEBPACK_IMPORTED_MODULE_2__["default"])();

  if (nodes == null) nodes = [];

  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }

  function tick(iterations) {
    var i, n = nodes.length, node;

    if (iterations === undefined) iterations = 1;

    for (var k = 0; k < iterations; ++k) {
      alpha += (alphaTarget - alpha) * alphaDecay;

      forces.forEach(function(force) {
        force(alpha);
      });

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        if (node.fx == null) node.x += node.vx *= velocityDecay;
        else node.x = node.fx, node.vx = 0;
        if (node.fy == null) node.y += node.vy *= velocityDecay;
        else node.y = node.fy, node.vy = 0;
      }
    }

    return simulation;
  }

  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (node.fx != null) node.x = node.fx;
      if (node.fy != null) node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(0.5 + i), angle = i * initialAngle;
        node.x = radius * Math.cos(angle);
        node.y = radius * Math.sin(angle);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }

  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes, random);
    return force;
  }

  initializeNodes();

  return simulation = {
    tick: tick,

    restart: function() {
      return stepper.restart(step), simulation;
    },

    stop: function() {
      return stepper.stop(), simulation;
    },

    nodes: function(_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
    },

    alpha: function(_) {
      return arguments.length ? (alpha = +_, simulation) : alpha;
    },

    alphaMin: function(_) {
      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
    },

    alphaDecay: function(_) {
      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
    },

    alphaTarget: function(_) {
      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
    },

    velocityDecay: function(_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
    },

    randomSource: function(_) {
      return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;
    },

    force: function(name, _) {
      return arguments.length > 1 ? ((_ == null ? forces.delete(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
    },

    find: function(x, y, radius) {
      var i = 0,
          n = nodes.length,
          dx,
          dy,
          d2,
          node,
          closest;

      if (radius == null) radius = Infinity;
      else radius *= radius;

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x - node.x;
        dy = y - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius) closest = node, radius = d2;
      }

      return closest;
    },

    on: function(name, _) {
      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
    }
  };
}


/***/ }),

/***/ "./node_modules/d3-force/src/x.js":
/*!****************************************!*\
  !*** ./node_modules/d3-force/src/x.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force/src/constant.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  var strength = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(0.1),
      nodes,
      strengths,
      xz;

  if (typeof x !== "function") x = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(x == null ? 0 : +x);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : strength;
  };

  force.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : x;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-force/src/y.js":
/*!****************************************!*\
  !*** ./node_modules/d3-force/src/y.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force/src/constant.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(y) {
  var strength = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(0.1),
      nodes,
      strengths,
      yz;

  if (typeof y !== "function") y = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(y == null ? 0 : +y);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : strength;
  };

  force.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : y;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/add.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-quadtree/src/add.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addAll: () => (/* binding */ addAll),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(d) {
  const x = +this._x.call(null, d),
      y = +this._y.call(null, d);
  return add(this.cover(x, y), x, y, d);
}

function add(tree, x, y, d) {
  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = {data: d},
      x0 = tree._x0,
      y0 = tree._y0,
      x1 = tree._x1,
      y1 = tree._y1,
      xm,
      ym,
      xp,
      yp,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return tree._root = leaf, tree;

  // Find the existing leaf for the new point, or add it.
  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  }

  // Is the new point is exactly coincident with the existing point?
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

  // Otherwise, split the leaf node until the old and new point are separated.
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  var d, i, n = data.length,
      x,
      y,
      xz = new Array(n),
      yz = new Array(n),
      x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity;

  // Compute the points and their extent.
  for (i = 0; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  }

  // If there were no (valid) points, abort.
  if (x0 > x1 || y0 > y1) return this;

  // Expand the tree to cover the new points.
  this.cover(x0, y0).cover(x1, y1);

  // Add the new points.
  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/cover.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-quadtree/src/cover.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y) {
  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1;

  // If the quadtree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing quadrant boundaries don’t change due to floating point error!
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
  }

  // Otherwise, double repeatedly to cover.
  else {
    var z = x1 - x0 || 1,
        node = this._root,
        parent,
        i;

    while (x0 > x || x >= x1 || y0 > y || y >= y1) {
      i = (y < y0) << 1 | (x < x0);
      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
      switch (i) {
        case 0: x1 = x0 + z, y1 = y0 + z; break;
        case 1: x0 = x1 - z, y1 = y0 + z; break;
        case 2: x1 = x0 + z, y0 = y1 - z; break;
        case 3: x0 = x1 - z, y0 = y1 - z; break;
      }
    }

    if (this._root && this._root.length) this._root = node;
  }

  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/data.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/data.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do data.push(node.data); while (node = node.next)
  });
  return data;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/extent.js":
/*!************************************************!*\
  !*** ./node_modules/d3-quadtree/src/extent.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length
      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/find.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/find.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "./node_modules/d3-quadtree/src/quad.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      x1,
      y1,
      x2,
      y2,
      x3 = this._x1,
      y3 = this._y1,
      quads = [],
      node = this._root,
      q,
      i;

  if (node) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x - radius, y0 = y - radius;
    x3 = x + radius, y3 = y + radius;
    radius *= radius;
  }

  while (q = quads.pop()) {

    // Stop searching if this quadrant can’t contain a closer node.
    if (!(node = q.node)
        || (x1 = q.x0) > x3
        || (y1 = q.y0) > y3
        || (x2 = q.x1) < x0
        || (y2 = q.y1) < y0) continue;

    // Bisect the current quadrant.
    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2;

      quads.push(
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[3], xm, ym, x2, y2),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[2], x1, ym, xm, y2),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[1], xm, y1, x2, ym),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[0], x1, y1, xm, ym)
      );

      // Visit the closest quadrant first.
      if (i = (y >= ym) << 1 | (x >= xm)) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    }

    // Visit this point. (Visiting coincident points isn’t necessary!)
    else {
      var dx = x - +this._x.call(null, node.data),
          dy = y - +this._y.call(null, node.data),
          d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x0 = x - d, y0 = y - d;
        x3 = x + d, y3 = y + d;
        data = node.data;
      }
    }
  }

  return data;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/quad.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/quad.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/quadtree.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-quadtree/src/quadtree.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quadtree)
/* harmony export */ });
/* harmony import */ var _add_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./add.js */ "./node_modules/d3-quadtree/src/add.js");
/* harmony import */ var _cover_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cover.js */ "./node_modules/d3-quadtree/src/cover.js");
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data.js */ "./node_modules/d3-quadtree/src/data.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./extent.js */ "./node_modules/d3-quadtree/src/extent.js");
/* harmony import */ var _find_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./find.js */ "./node_modules/d3-quadtree/src/find.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-quadtree/src/remove.js");
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./root.js */ "./node_modules/d3-quadtree/src/root.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./size.js */ "./node_modules/d3-quadtree/src/size.js");
/* harmony import */ var _visit_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./visit.js */ "./node_modules/d3-quadtree/src/visit.js");
/* harmony import */ var _visitAfter_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./visitAfter.js */ "./node_modules/d3-quadtree/src/visitAfter.js");
/* harmony import */ var _x_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./x.js */ "./node_modules/d3-quadtree/src/x.js");
/* harmony import */ var _y_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./y.js */ "./node_modules/d3-quadtree/src/y.js");













function quadtree(nodes, x, y) {
  var tree = new Quadtree(x == null ? _x_js__WEBPACK_IMPORTED_MODULE_0__.defaultX : x, y == null ? _y_js__WEBPACK_IMPORTED_MODULE_1__.defaultY : y, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
  this._x = x;
  this._y = y;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = {data: leaf.data}, next = copy;
  while (leaf = leaf.next) next = next.next = {data: leaf.data};
  return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function() {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      node = this._root,
      nodes,
      child;

  if (!node) return copy;

  if (!node.length) return copy._root = leaf_copy(node), copy;

  nodes = [{source: node, target: copy._root = new Array(4)}];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
        else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = _add_js__WEBPACK_IMPORTED_MODULE_2__["default"];
treeProto.addAll = _add_js__WEBPACK_IMPORTED_MODULE_2__.addAll;
treeProto.cover = _cover_js__WEBPACK_IMPORTED_MODULE_3__["default"];
treeProto.data = _data_js__WEBPACK_IMPORTED_MODULE_4__["default"];
treeProto.extent = _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"];
treeProto.find = _find_js__WEBPACK_IMPORTED_MODULE_6__["default"];
treeProto.remove = _remove_js__WEBPACK_IMPORTED_MODULE_7__["default"];
treeProto.removeAll = _remove_js__WEBPACK_IMPORTED_MODULE_7__.removeAll;
treeProto.root = _root_js__WEBPACK_IMPORTED_MODULE_8__["default"];
treeProto.size = _size_js__WEBPACK_IMPORTED_MODULE_9__["default"];
treeProto.visit = _visit_js__WEBPACK_IMPORTED_MODULE_10__["default"];
treeProto.visitAfter = _visitAfter_js__WEBPACK_IMPORTED_MODULE_11__["default"];
treeProto.x = _x_js__WEBPACK_IMPORTED_MODULE_0__["default"];
treeProto.y = _y_js__WEBPACK_IMPORTED_MODULE_1__["default"];


/***/ }),

/***/ "./node_modules/d3-quadtree/src/remove.js":
/*!************************************************!*\
  !*** ./node_modules/d3-quadtree/src/remove.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   removeAll: () => (/* binding */ removeAll)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1,
      x,
      y,
      xm,
      ym,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return this;

  // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.
  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
  }

  // Find the point to remove.
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;

  // If there are multiple coincident points, remove just the point.
  if (previous) return (next ? previous.next = next : delete previous.next), this;

  // If this is the root point, remove it.
  if (!parent) return this._root = next, this;

  // Remove this leaf.
  next ? parent[i] = next : delete parent[i];

  // If the parent now contains exactly one leaf, collapse superfluous parents.
  if ((node = parent[0] || parent[1] || parent[2] || parent[3])
      && node === (parent[3] || parent[2] || parent[1] || parent[0])
      && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }

  return this;
}

function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/root.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/root.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this._root;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/size.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/size.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do ++size; while (node = node.next)
  });
  return size;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/visit.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-quadtree/src/visit.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "./node_modules/d3-quadtree/src/quad.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {
  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
  if (node) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, y0, xm, ym));
    }
  }
  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/visitAfter.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-quadtree/src/visitAfter.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "./node_modules/d3-quadtree/src/quad.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/x.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-quadtree/src/x.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultX: () => (/* binding */ defaultX)
/* harmony export */ });
function defaultX(d) {
  return d[0];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/y.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-quadtree/src/y.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultY: () => (/* binding */ defaultY)
/* harmony export */ });
function defaultY(d) {
  return d[1];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}


/***/ }),

/***/ "./node_modules/d3-timer/src/timer.js":
/*!********************************************!*\
  !*** ./node_modules/d3-timer/src/timer.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Timer: () => (/* binding */ Timer),
/* harmony export */   now: () => (/* binding */ now),
/* harmony export */   timer: () => (/* binding */ timer),
/* harmony export */   timerFlush: () => (/* binding */ timerFlush)
/* harmony export */ });
var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}


/***/ }),

/***/ "./node_modules/dagre-compound/dist/dagre-compound.es5.js":
/*!****************************************************************!*\
  !*** ./node_modules/dagre-compound/dist/dagre-compound.es5.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BRIDGE_GRAPH_NAME: () => (/* binding */ o),
/* harmony export */   GraphType: () => (/* binding */ u),
/* harmony export */   HierarchyNodeType: () => (/* binding */ c),
/* harmony export */   InclusionType: () => (/* binding */ a),
/* harmony export */   LAYOUT_CONFIG: () => (/* binding */ e),
/* harmony export */   NodeType: () => (/* binding */ i),
/* harmony export */   ROOT_NAME: () => (/* binding */ r),
/* harmony export */   buildGraph: () => (/* binding */ rc),
/* harmony export */   flatGraph: () => (/* binding */ oc),
/* harmony export */   getEdges: () => (/* binding */ ic),
/* harmony export */   mergeConfig: () => (/* binding */ n)
/* harmony export */ });
const e={graph:{meta:{rankDir:"TB",nodeSep:50,rankSep:50,edgeSep:5,align:void 0}},subScene:{meta:{paddingTop:20,paddingBottom:20,paddingLeft:20,paddingRight:20,labelHeight:20}},nodeSize:{meta:{width:100,maxLabelWidth:0,height:20},node:{width:80,height:20,labelOffset:10,maxLabelWidth:40},bridge:{width:5,height:5,radius:2,labelOffset:0}}};function n(n={},t=e){var r,o,i,a;const u=JSON.parse(JSON.stringify(t)),c=(null===(r=null==n?void 0:n.graph)||void 0===r?void 0:r.meta)||{},s=(null===(o=null==n?void 0:n.subScene)||void 0===o?void 0:o.meta)||{},d=(null===(i=null==n?void 0:n.nodeSize)||void 0===i?void 0:i.meta)||{},f=(null===(a=null==n?void 0:n.nodeSize)||void 0===a?void 0:a.node)||{},h=u.nodeSize.bridge;return{graph:{meta:Object.assign(u.graph.meta,c)},subScene:{meta:Object.assign(u.subScene.meta,s)},nodeSize:{meta:Object.assign(u.nodeSize.meta,d),node:Object.assign(u.nodeSize.node,f),bridge:h}}}function t(e){return`◬${e}◬`}const r=t("ROOT"),o=t("BRIDGE_GRAPH");var i,a,u,c;!function(e){e[e.META=0]="META",e[e.NODE=1]="NODE",e[e.BRIDGE=2]="BRIDGE"}(i||(i={})),function(e){e[e.INCLUDE=0]="INCLUDE",e[e.EXCLUDE=1]="EXCLUDE",e[e.UNSPECIFIED=2]="UNSPECIFIED"}(a||(a={})),function(e){e[e.META=0]="META",e[e.CORE=1]="CORE",e[e.BRIDGE=2]="BRIDGE"}(u||(u={})),function(e){e[e.META=0]="META",e[e.OP=1]="OP",e[e.SERIES=2]="SERIES"}(c||(c={}));var s="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof __webpack_require__.g?__webpack_require__.g:"undefined"!=typeof self?self:{};function d(e,n){return e(n={exports:{}},n.exports),n.exports}var f=function(){this.__data__=[],this.size=0};var h=function(e,n){return e===n||e!=e&&n!=n};var l=function(e,n){for(var t=e.length;t--;)if(h(e[t][0],n))return t;return-1},v=Array.prototype.splice;var p=function(e){var n=this.__data__,t=l(n,e);return!(t<0)&&(t==n.length-1?n.pop():v.call(n,t,1),--this.size,!0)};var g=function(e){var n=this.__data__,t=l(n,e);return t<0?void 0:n[t][1]};var y=function(e){return l(this.__data__,e)>-1};var b=function(e,n){var t=this.__data__,r=l(t,e);return r<0?(++this.size,t.push([e,n])):t[r][1]=n,this};function m(e){var n=-1,t=null==e?0:e.length;for(this.clear();++n<t;){var r=e[n];this.set(r[0],r[1])}}m.prototype.clear=f,m.prototype.delete=p,m.prototype.get=g,m.prototype.has=y,m.prototype.set=b;var w=m;var E=function(){this.__data__=new w,this.size=0};var _=function(e){var n=this.__data__,t=n.delete(e);return this.size=n.size,t};var j=function(e){return this.__data__.get(e)};var x=function(e){return this.__data__.has(e)},N="object"==typeof s&&s&&s.Object===Object&&s,O="object"==typeof self&&self&&self.Object===Object&&self,k=N||O||Function("return this")(),I=k.Symbol,S=Object.prototype,M=S.hasOwnProperty,C=S.toString,G=I?I.toStringTag:void 0;var B=function(e){var n=M.call(e,G),t=e[G];try{e[G]=void 0;var r=!0}catch(e){}var o=C.call(e);return r&&(n?e[G]=t:delete e[G]),o},A=Object.prototype.toString;var L=function(e){return A.call(e)},R=I?I.toStringTag:void 0;var T=function(e){return null==e?void 0===e?"[object Undefined]":"[object Null]":R&&R in Object(e)?B(e):L(e)};var D=function(e){var n=typeof e;return null!=e&&("object"==n||"function"==n)};var P,z=function(e){if(!D(e))return!1;var n=T(e);return"[object Function]"==n||"[object GeneratorFunction]"==n||"[object AsyncFunction]"==n||"[object Proxy]"==n},F=k["__core-js_shared__"],U=(P=/[^.]+$/.exec(F&&F.keys&&F.keys.IE_PROTO||""))?"Symbol(src)_1."+P:"";var V=function(e){return!!U&&U in e},$=Function.prototype.toString;var H=function(e){if(null!=e){try{return $.call(e)}catch(e){}try{return e+""}catch(e){}}return""},W=/^\[object .+?Constructor\]$/,q=Function.prototype,Y=Object.prototype,J=q.toString,X=Y.hasOwnProperty,K=RegExp("^"+J.call(X).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");var Q=function(e){return!(!D(e)||V(e))&&(z(e)?K:W).test(H(e))};var Z=function(e,n){return null==e?void 0:e[n]};var ee=function(e,n){var t=Z(e,n);return Q(t)?t:void 0},ne=ee(k,"Map"),te=ee(Object,"create");var re=function(){this.__data__=te?te(null):{},this.size=0};var oe=function(e){var n=this.has(e)&&delete this.__data__[e];return this.size-=n?1:0,n},ie=Object.prototype.hasOwnProperty;var ae=function(e){var n=this.__data__;if(te){var t=n[e];return"__lodash_hash_undefined__"===t?void 0:t}return ie.call(n,e)?n[e]:void 0},ue=Object.prototype.hasOwnProperty;var ce=function(e){var n=this.__data__;return te?void 0!==n[e]:ue.call(n,e)};var se=function(e,n){var t=this.__data__;return this.size+=this.has(e)?0:1,t[e]=te&&void 0===n?"__lodash_hash_undefined__":n,this};function de(e){var n=-1,t=null==e?0:e.length;for(this.clear();++n<t;){var r=e[n];this.set(r[0],r[1])}}de.prototype.clear=re,de.prototype.delete=oe,de.prototype.get=ae,de.prototype.has=ce,de.prototype.set=se;var fe=de;var he=function(){this.size=0,this.__data__={hash:new fe,map:new(ne||w),string:new fe}};var le=function(e){var n=typeof e;return"string"==n||"number"==n||"symbol"==n||"boolean"==n?"__proto__"!==e:null===e};var ve=function(e,n){var t=e.__data__;return le(n)?t["string"==typeof n?"string":"hash"]:t.map};var pe=function(e){var n=ve(this,e).delete(e);return this.size-=n?1:0,n};var ge=function(e){return ve(this,e).get(e)};var ye=function(e){return ve(this,e).has(e)};var be=function(e,n){var t=ve(this,e),r=t.size;return t.set(e,n),this.size+=t.size==r?0:1,this};function me(e){var n=-1,t=null==e?0:e.length;for(this.clear();++n<t;){var r=e[n];this.set(r[0],r[1])}}me.prototype.clear=he,me.prototype.delete=pe,me.prototype.get=ge,me.prototype.has=ye,me.prototype.set=be;var we=me;var Ee=function(e,n){var t=this.__data__;if(t instanceof w){var r=t.__data__;if(!ne||r.length<199)return r.push([e,n]),this.size=++t.size,this;t=this.__data__=new we(r)}return t.set(e,n),this.size=t.size,this};function _e(e){var n=this.__data__=new w(e);this.size=n.size}_e.prototype.clear=E,_e.prototype.delete=_,_e.prototype.get=j,_e.prototype.has=x,_e.prototype.set=Ee;var je=_e;var xe=function(e,n){for(var t=-1,r=null==e?0:e.length;++t<r&&!1!==n(e[t],t,e););return e},Ne=function(){try{var e=ee(Object,"defineProperty");return e({},"",{}),e}catch(e){}}();var Oe=function(e,n,t){"__proto__"==n&&Ne?Ne(e,n,{configurable:!0,enumerable:!0,value:t,writable:!0}):e[n]=t},ke=Object.prototype.hasOwnProperty;var Ie=function(e,n,t){var r=e[n];ke.call(e,n)&&h(r,t)&&(void 0!==t||n in e)||Oe(e,n,t)};var Se=function(e,n,t,r){var o=!t;t||(t={});for(var i=-1,a=n.length;++i<a;){var u=n[i],c=r?r(t[u],e[u],u,t,e):void 0;void 0===c&&(c=e[u]),o?Oe(t,u,c):Ie(t,u,c)}return t};var Me=function(e,n){for(var t=-1,r=Array(e);++t<e;)r[t]=n(t);return r};var Ce=function(e){return null!=e&&"object"==typeof e};var Ge=function(e){return Ce(e)&&"[object Arguments]"==T(e)},Be=Object.prototype,Ae=Be.hasOwnProperty,Le=Be.propertyIsEnumerable,Re=Ge(function(){return arguments}())?Ge:function(e){return Ce(e)&&Ae.call(e,"callee")&&!Le.call(e,"callee")},Te=Array.isArray;var De=function(){return!1},Pe=d((function(e,n){var t=n&&!n.nodeType&&n,r=t&&e&&!e.nodeType&&e,o=r&&r.exports===t?k.Buffer:void 0,i=(o?o.isBuffer:void 0)||De;e.exports=i})),ze=/^(?:0|[1-9]\d*)$/;var Fe=function(e,n){var t=typeof e;return!!(n=null==n?9007199254740991:n)&&("number"==t||"symbol"!=t&&ze.test(e))&&e>-1&&e%1==0&&e<n};var Ue=function(e){return"number"==typeof e&&e>-1&&e%1==0&&e<=9007199254740991},Ve={};Ve["[object Float32Array]"]=Ve["[object Float64Array]"]=Ve["[object Int8Array]"]=Ve["[object Int16Array]"]=Ve["[object Int32Array]"]=Ve["[object Uint8Array]"]=Ve["[object Uint8ClampedArray]"]=Ve["[object Uint16Array]"]=Ve["[object Uint32Array]"]=!0,Ve["[object Arguments]"]=Ve["[object Array]"]=Ve["[object ArrayBuffer]"]=Ve["[object Boolean]"]=Ve["[object DataView]"]=Ve["[object Date]"]=Ve["[object Error]"]=Ve["[object Function]"]=Ve["[object Map]"]=Ve["[object Number]"]=Ve["[object Object]"]=Ve["[object RegExp]"]=Ve["[object Set]"]=Ve["[object String]"]=Ve["[object WeakMap]"]=!1;var $e=function(e){return Ce(e)&&Ue(e.length)&&!!Ve[T(e)]};var He=function(e){return function(n){return e(n)}},We=d((function(e,n){var t=n&&!n.nodeType&&n,r=t&&e&&!e.nodeType&&e,o=r&&r.exports===t&&N.process,i=function(){try{var e=r&&r.require&&r.require("util").types;return e||o&&o.binding&&o.binding("util")}catch(e){}}();e.exports=i})),qe=We&&We.isTypedArray,Ye=qe?He(qe):$e,Je=Object.prototype.hasOwnProperty;var Xe=function(e,n){var t=Te(e),r=!t&&Re(e),o=!t&&!r&&Pe(e),i=!t&&!r&&!o&&Ye(e),a=t||r||o||i,u=a?Me(e.length,String):[],c=u.length;for(var s in e)!n&&!Je.call(e,s)||a&&("length"==s||o&&("offset"==s||"parent"==s)||i&&("buffer"==s||"byteLength"==s||"byteOffset"==s)||Fe(s,c))||u.push(s);return u},Ke=Object.prototype;var Qe=function(e){var n=e&&e.constructor;return e===("function"==typeof n&&n.prototype||Ke)};var Ze=function(e,n){return function(t){return e(n(t))}},en=Ze(Object.keys,Object),nn=Object.prototype.hasOwnProperty;var tn=function(e){if(!Qe(e))return en(e);var n=[];for(var t in Object(e))nn.call(e,t)&&"constructor"!=t&&n.push(t);return n};var rn=function(e){return null!=e&&Ue(e.length)&&!z(e)};var on=function(e){return rn(e)?Xe(e):tn(e)};var an=function(e,n){return e&&Se(n,on(n),e)};var un=function(e){var n=[];if(null!=e)for(var t in Object(e))n.push(t);return n},cn=Object.prototype.hasOwnProperty;var sn=function(e){if(!D(e))return un(e);var n=Qe(e),t=[];for(var r in e)("constructor"!=r||!n&&cn.call(e,r))&&t.push(r);return t};var dn=function(e){return rn(e)?Xe(e,!0):sn(e)};var fn=function(e,n){return e&&Se(n,dn(n),e)},hn=d((function(e,n){var t=n&&!n.nodeType&&n,r=t&&e&&!e.nodeType&&e,o=r&&r.exports===t?k.Buffer:void 0,i=o?o.allocUnsafe:void 0;e.exports=function(e,n){if(n)return e.slice();var t=e.length,r=i?i(t):new e.constructor(t);return e.copy(r),r}}));var ln=function(e,n){var t=-1,r=e.length;for(n||(n=Array(r));++t<r;)n[t]=e[t];return n};var vn=function(e,n){for(var t=-1,r=null==e?0:e.length,o=0,i=[];++t<r;){var a=e[t];n(a,t,e)&&(i[o++]=a)}return i};var pn=function(){return[]},gn=Object.prototype.propertyIsEnumerable,yn=Object.getOwnPropertySymbols,bn=yn?function(e){return null==e?[]:(e=Object(e),vn(yn(e),(function(n){return gn.call(e,n)})))}:pn;var mn=function(e,n){return Se(e,bn(e),n)};var wn=function(e,n){for(var t=-1,r=n.length,o=e.length;++t<r;)e[o+t]=n[t];return e},En=Ze(Object.getPrototypeOf,Object),_n=Object.getOwnPropertySymbols?function(e){for(var n=[];e;)wn(n,bn(e)),e=En(e);return n}:pn;var jn=function(e,n){return Se(e,_n(e),n)};var xn=function(e,n,t){var r=n(e);return Te(e)?r:wn(r,t(e))};var Nn=function(e){return xn(e,on,bn)};var On=function(e){return xn(e,dn,_n)},kn=ee(k,"DataView"),In=ee(k,"Promise"),Sn=ee(k,"Set"),Mn=ee(k,"WeakMap"),Cn=H(kn),Gn=H(ne),Bn=H(In),An=H(Sn),Ln=H(Mn),Rn=T;(kn&&"[object DataView]"!=Rn(new kn(new ArrayBuffer(1)))||ne&&"[object Map]"!=Rn(new ne)||In&&"[object Promise]"!=Rn(In.resolve())||Sn&&"[object Set]"!=Rn(new Sn)||Mn&&"[object WeakMap]"!=Rn(new Mn))&&(Rn=function(e){var n=T(e),t="[object Object]"==n?e.constructor:void 0,r=t?H(t):"";if(r)switch(r){case Cn:return"[object DataView]";case Gn:return"[object Map]";case Bn:return"[object Promise]";case An:return"[object Set]";case Ln:return"[object WeakMap]"}return n});var Tn=Rn,Dn=Object.prototype.hasOwnProperty;var Pn=function(e){var n=e.length,t=new e.constructor(n);return n&&"string"==typeof e[0]&&Dn.call(e,"index")&&(t.index=e.index,t.input=e.input),t},zn=k.Uint8Array;var Fn=function(e){var n=new e.constructor(e.byteLength);return new zn(n).set(new zn(e)),n};var Un=function(e,n){var t=n?Fn(e.buffer):e.buffer;return new e.constructor(t,e.byteOffset,e.byteLength)},Vn=/\w*$/;var $n=function(e){var n=new e.constructor(e.source,Vn.exec(e));return n.lastIndex=e.lastIndex,n},Hn=I?I.prototype:void 0,Wn=Hn?Hn.valueOf:void 0;var qn=function(e){return Wn?Object(Wn.call(e)):{}};var Yn=function(e,n){var t=n?Fn(e.buffer):e.buffer;return new e.constructor(t,e.byteOffset,e.length)};var Jn=function(e,n,t){var r=e.constructor;switch(n){case"[object ArrayBuffer]":return Fn(e);case"[object Boolean]":case"[object Date]":return new r(+e);case"[object DataView]":return Un(e,t);case"[object Float32Array]":case"[object Float64Array]":case"[object Int8Array]":case"[object Int16Array]":case"[object Int32Array]":case"[object Uint8Array]":case"[object Uint8ClampedArray]":case"[object Uint16Array]":case"[object Uint32Array]":return Yn(e,t);case"[object Map]":return new r;case"[object Number]":case"[object String]":return new r(e);case"[object RegExp]":return $n(e);case"[object Set]":return new r;case"[object Symbol]":return qn(e)}},Xn=Object.create,Kn=function(){function e(){}return function(n){if(!D(n))return{};if(Xn)return Xn(n);e.prototype=n;var t=new e;return e.prototype=void 0,t}}();var Qn=function(e){return"function"!=typeof e.constructor||Qe(e)?{}:Kn(En(e))};var Zn=function(e){return Ce(e)&&"[object Map]"==Tn(e)},et=We&&We.isMap,nt=et?He(et):Zn;var tt=function(e){return Ce(e)&&"[object Set]"==Tn(e)},rt=We&&We.isSet,ot=rt?He(rt):tt,it={};it["[object Arguments]"]=it["[object Array]"]=it["[object ArrayBuffer]"]=it["[object DataView]"]=it["[object Boolean]"]=it["[object Date]"]=it["[object Float32Array]"]=it["[object Float64Array]"]=it["[object Int8Array]"]=it["[object Int16Array]"]=it["[object Int32Array]"]=it["[object Map]"]=it["[object Number]"]=it["[object Object]"]=it["[object RegExp]"]=it["[object Set]"]=it["[object String]"]=it["[object Symbol]"]=it["[object Uint8Array]"]=it["[object Uint8ClampedArray]"]=it["[object Uint16Array]"]=it["[object Uint32Array]"]=!0,it["[object Error]"]=it["[object Function]"]=it["[object WeakMap]"]=!1;var at=function e(n,t,r,o,i,a){var u,c=1&t,s=2&t,d=4&t;if(r&&(u=i?r(n,o,i,a):r(n)),void 0!==u)return u;if(!D(n))return n;var f=Te(n);if(f){if(u=Pn(n),!c)return ln(n,u)}else{var h=Tn(n),l="[object Function]"==h||"[object GeneratorFunction]"==h;if(Pe(n))return hn(n,c);if("[object Object]"==h||"[object Arguments]"==h||l&&!i){if(u=s||l?{}:Qn(n),!c)return s?jn(n,fn(u,n)):mn(n,an(u,n))}else{if(!it[h])return i?n:{};u=Jn(n,h,c)}}a||(a=new je);var v=a.get(n);if(v)return v;a.set(n,u),ot(n)?n.forEach((function(o){u.add(e(o,t,r,o,n,a))})):nt(n)&&n.forEach((function(o,i){u.set(i,e(o,t,r,i,n,a))}));var p=f?void 0:(d?s?On:Nn:s?dn:on)(n);return xe(p||n,(function(o,i){p&&(o=n[i=o]),Ie(u,i,e(o,t,r,i,n,a))})),u};var ut=function(e){return at(e,4)};var ct=function(e){return function(){return e}};var st=function(e){return function(n,t,r){for(var o=-1,i=Object(n),a=r(n),u=a.length;u--;){var c=a[e?u:++o];if(!1===t(i[c],c,i))break}return n}}();var dt=function(e,n){return e&&st(e,n,on)};var ft=function(e,n){return function(t,r){if(null==t)return t;if(!rn(t))return e(t,r);for(var o=t.length,i=n?o:-1,a=Object(t);(n?i--:++i<o)&&!1!==r(a[i],i,a););return t}}(dt);var ht=function(e){return e};var lt=function(e){return"function"==typeof e?e:ht};var vt=function(e,n){return(Te(e)?xe:ft)(e,lt(n))},pt=vt;var gt=function(e,n){var t=[];return ft(e,(function(e,r,o){n(e,r,o)&&t.push(e)})),t};var yt=function(e){return this.__data__.set(e,"__lodash_hash_undefined__"),this};var bt=function(e){return this.__data__.has(e)};function mt(e){var n=-1,t=null==e?0:e.length;for(this.__data__=new we;++n<t;)this.add(e[n])}mt.prototype.add=mt.prototype.push=yt,mt.prototype.has=bt;var wt=mt;var Et=function(e,n){for(var t=-1,r=null==e?0:e.length;++t<r;)if(n(e[t],t,e))return!0;return!1};var _t=function(e,n){return e.has(n)};var jt=function(e,n,t,r,o,i){var a=1&t,u=e.length,c=n.length;if(u!=c&&!(a&&c>u))return!1;var s=i.get(e),d=i.get(n);if(s&&d)return s==n&&d==e;var f=-1,h=!0,l=2&t?new wt:void 0;for(i.set(e,n),i.set(n,e);++f<u;){var v=e[f],p=n[f];if(r)var g=a?r(p,v,f,n,e,i):r(v,p,f,e,n,i);if(void 0!==g){if(g)continue;h=!1;break}if(l){if(!Et(n,(function(e,n){if(!_t(l,n)&&(v===e||o(v,e,t,r,i)))return l.push(n)}))){h=!1;break}}else if(v!==p&&!o(v,p,t,r,i)){h=!1;break}}return i.delete(e),i.delete(n),h};var xt=function(e){var n=-1,t=Array(e.size);return e.forEach((function(e,r){t[++n]=[r,e]})),t};var Nt=function(e){var n=-1,t=Array(e.size);return e.forEach((function(e){t[++n]=e})),t},Ot=I?I.prototype:void 0,kt=Ot?Ot.valueOf:void 0;var It=function(e,n,t,r,o,i,a){switch(t){case"[object DataView]":if(e.byteLength!=n.byteLength||e.byteOffset!=n.byteOffset)return!1;e=e.buffer,n=n.buffer;case"[object ArrayBuffer]":return!(e.byteLength!=n.byteLength||!i(new zn(e),new zn(n)));case"[object Boolean]":case"[object Date]":case"[object Number]":return h(+e,+n);case"[object Error]":return e.name==n.name&&e.message==n.message;case"[object RegExp]":case"[object String]":return e==n+"";case"[object Map]":var u=xt;case"[object Set]":var c=1&r;if(u||(u=Nt),e.size!=n.size&&!c)return!1;var s=a.get(e);if(s)return s==n;r|=2,a.set(e,n);var d=jt(u(e),u(n),r,o,i,a);return a.delete(e),d;case"[object Symbol]":if(kt)return kt.call(e)==kt.call(n)}return!1},St=Object.prototype.hasOwnProperty;var Mt=function(e,n,t,r,o,i){var a=1&t,u=Nn(e),c=u.length;if(c!=Nn(n).length&&!a)return!1;for(var s=c;s--;){var d=u[s];if(!(a?d in n:St.call(n,d)))return!1}var f=i.get(e),h=i.get(n);if(f&&h)return f==n&&h==e;var l=!0;i.set(e,n),i.set(n,e);for(var v=a;++s<c;){var p=e[d=u[s]],g=n[d];if(r)var y=a?r(g,p,d,n,e,i):r(p,g,d,e,n,i);if(!(void 0===y?p===g||o(p,g,t,r,i):y)){l=!1;break}v||(v="constructor"==d)}if(l&&!v){var b=e.constructor,m=n.constructor;b==m||!("constructor"in e)||!("constructor"in n)||"function"==typeof b&&b instanceof b&&"function"==typeof m&&m instanceof m||(l=!1)}return i.delete(e),i.delete(n),l},Ct=Object.prototype.hasOwnProperty;var Gt=function(e,n,t,r,o,i){var a=Te(e),u=Te(n),c=a?"[object Array]":Tn(e),s=u?"[object Array]":Tn(n),d="[object Object]"==(c="[object Arguments]"==c?"[object Object]":c),f="[object Object]"==(s="[object Arguments]"==s?"[object Object]":s),h=c==s;if(h&&Pe(e)){if(!Pe(n))return!1;a=!0,d=!1}if(h&&!d)return i||(i=new je),a||Ye(e)?jt(e,n,t,r,o,i):It(e,n,c,t,r,o,i);if(!(1&t)){var l=d&&Ct.call(e,"__wrapped__"),v=f&&Ct.call(n,"__wrapped__");if(l||v){var p=l?e.value():e,g=v?n.value():n;return i||(i=new je),o(p,g,t,r,i)}}return!!h&&(i||(i=new je),Mt(e,n,t,r,o,i))};var Bt=function e(n,t,r,o,i){return n===t||(null==n||null==t||!Ce(n)&&!Ce(t)?n!=n&&t!=t:Gt(n,t,r,o,e,i))};var At=function(e,n,t,r){var o=t.length,i=o,a=!r;if(null==e)return!i;for(e=Object(e);o--;){var u=t[o];if(a&&u[2]?u[1]!==e[u[0]]:!(u[0]in e))return!1}for(;++o<i;){var c=(u=t[o])[0],s=e[c],d=u[1];if(a&&u[2]){if(void 0===s&&!(c in e))return!1}else{var f=new je;if(r)var h=r(s,d,c,e,n,f);if(!(void 0===h?Bt(d,s,3,r,f):h))return!1}}return!0};var Lt=function(e){return e==e&&!D(e)};var Rt=function(e){for(var n=on(e),t=n.length;t--;){var r=n[t],o=e[r];n[t]=[r,o,Lt(o)]}return n};var Tt=function(e,n){return function(t){return null!=t&&(t[e]===n&&(void 0!==n||e in Object(t)))}};var Dt=function(e){var n=Rt(e);return 1==n.length&&n[0][2]?Tt(n[0][0],n[0][1]):function(t){return t===e||At(t,e,n)}};var Pt=function(e){return"symbol"==typeof e||Ce(e)&&"[object Symbol]"==T(e)},zt=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,Ft=/^\w*$/;var Ut=function(e,n){if(Te(e))return!1;var t=typeof e;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=e&&!Pt(e))||(Ft.test(e)||!zt.test(e)||null!=n&&e in Object(n))};function Vt(e,n){if("function"!=typeof e||null!=n&&"function"!=typeof n)throw new TypeError("Expected a function");var t=function(){var r=arguments,o=n?n.apply(this,r):r[0],i=t.cache;if(i.has(o))return i.get(o);var a=e.apply(this,r);return t.cache=i.set(o,a)||i,a};return t.cache=new(Vt.Cache||we),t}Vt.Cache=we;var $t=Vt;var Ht=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,Wt=/\\(\\)?/g,qt=function(e){var n=$t(e,(function(e){return 500===t.size&&t.clear(),e})),t=n.cache;return n}((function(e){var n=[];return 46===e.charCodeAt(0)&&n.push(""),e.replace(Ht,(function(e,t,r,o){n.push(r?o.replace(Wt,"$1"):t||e)})),n}));var Yt=function(e,n){for(var t=-1,r=null==e?0:e.length,o=Array(r);++t<r;)o[t]=n(e[t],t,e);return o},Jt=I?I.prototype:void 0,Xt=Jt?Jt.toString:void 0;var Kt=function e(n){if("string"==typeof n)return n;if(Te(n))return Yt(n,e)+"";if(Pt(n))return Xt?Xt.call(n):"";var t=n+"";return"0"==t&&1/n==-Infinity?"-0":t};var Qt=function(e){return null==e?"":Kt(e)};var Zt=function(e,n){return Te(e)?e:Ut(e,n)?[e]:qt(Qt(e))};var er=function(e){if("string"==typeof e||Pt(e))return e;var n=e+"";return"0"==n&&1/e==-Infinity?"-0":n};var nr=function(e,n){for(var t=0,r=(n=Zt(n,e)).length;null!=e&&t<r;)e=e[er(n[t++])];return t&&t==r?e:void 0};var tr=function(e,n,t){var r=null==e?void 0:nr(e,n);return void 0===r?t:r};var rr=function(e,n){return null!=e&&n in Object(e)};var or=function(e,n,t){for(var r=-1,o=(n=Zt(n,e)).length,i=!1;++r<o;){var a=er(n[r]);if(!(i=null!=e&&t(e,a)))break;e=e[a]}return i||++r!=o?i:!!(o=null==e?0:e.length)&&Ue(o)&&Fe(a,o)&&(Te(e)||Re(e))};var ir=function(e,n){return null!=e&&or(e,n,rr)};var ar=function(e,n){return Ut(e)&&Lt(n)?Tt(er(e),n):function(t){var r=tr(t,e);return void 0===r&&r===n?ir(t,e):Bt(n,r,3)}};var ur=function(e){return function(n){return null==n?void 0:n[e]}};var cr=function(e){return function(n){return nr(n,e)}};var sr=function(e){return Ut(e)?ur(er(e)):cr(e)};var dr=function(e){return"function"==typeof e?e:null==e?ht:"object"==typeof e?Te(e)?ar(e[0],e[1]):Dt(e):sr(e)};var fr=function(e,n){return(Te(e)?vn:gt)(e,dr(n))},hr=Object.prototype.hasOwnProperty;var lr=function(e,n){return null!=e&&hr.call(e,n)};var vr=function(e,n){return null!=e&&or(e,n,lr)},pr=Object.prototype.hasOwnProperty;var gr=function(e){if(null==e)return!0;if(rn(e)&&(Te(e)||"string"==typeof e||"function"==typeof e.splice||Pe(e)||Ye(e)||Re(e)))return!e.length;var n=Tn(e);if("[object Map]"==n||"[object Set]"==n)return!e.size;if(Qe(e))return!tn(e).length;for(var t in e)if(pr.call(e,t))return!1;return!0};var yr=function(e){return void 0===e};var br=function(e,n){var t=-1,r=rn(e)?Array(e.length):[];return ft(e,(function(e,o,i){r[++t]=n(e,o,i)})),r};var mr=function(e,n){return(Te(e)?Yt:br)(e,dr(n))};var wr=function(e,n,t,r){var o=-1,i=null==e?0:e.length;for(r&&i&&(t=e[++o]);++o<i;)t=n(t,e[o],o,e);return t};var Er=function(e,n,t,r,o){return o(e,(function(e,o,i){t=r?(r=!1,e):n(t,e,o,i)})),t};var _r=function(e,n,t){var r=Te(e)?wr:Er,o=arguments.length<3;return r(e,dr(n),t,o,ft)};var jr=function(e){return"string"==typeof e||!Te(e)&&Ce(e)&&"[object String]"==T(e)},xr=ur("length"),Nr=RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]");var Or=function(e){return Nr.test(e)},kr="[\\ud800-\\udfff]",Ir="[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]",Sr="\\ud83c[\\udffb-\\udfff]",Mr="[^\\ud800-\\udfff]",Cr="(?:\\ud83c[\\udde6-\\uddff]){2}",Gr="[\\ud800-\\udbff][\\udc00-\\udfff]",Br="(?:"+Ir+"|"+Sr+")"+"?",Ar="[\\ufe0e\\ufe0f]?"+Br+("(?:\\u200d(?:"+[Mr,Cr,Gr].join("|")+")[\\ufe0e\\ufe0f]?"+Br+")*"),Lr="(?:"+[Mr+Ir+"?",Ir,Cr,Gr,kr].join("|")+")",Rr=RegExp(Sr+"(?="+Sr+")|"+Lr+Ar,"g");var Tr=function(e){for(var n=Rr.lastIndex=0;Rr.test(e);)++n;return n};var Dr=function(e){return Or(e)?Tr(e):xr(e)};var Pr=function(e){if(null==e)return 0;if(rn(e))return jr(e)?Dr(e):e.length;var n=Tn(e);return"[object Map]"==n||"[object Set]"==n?e.size:tn(e).length};var zr=function(e,n,t){var r=Te(e),o=r||Pe(e)||Ye(e);if(n=dr(n),null==t){var i=e&&e.constructor;t=o?r?new i:[]:D(e)&&z(i)?Kn(En(e)):{}}return(o?xe:dt)(e,(function(e,r,o){return n(t,e,r,o)})),t},Fr=I?I.isConcatSpreadable:void 0;var Ur=function(e){return Te(e)||Re(e)||!!(Fr&&e&&e[Fr])};var Vr=function e(n,t,r,o,i){var a=-1,u=n.length;for(r||(r=Ur),i||(i=[]);++a<u;){var c=n[a];t>0&&r(c)?t>1?e(c,t-1,r,o,i):wn(i,c):o||(i[i.length]=c)}return i};var $r=function(e,n,t){switch(t.length){case 0:return e.call(n);case 1:return e.call(n,t[0]);case 2:return e.call(n,t[0],t[1]);case 3:return e.call(n,t[0],t[1],t[2])}return e.apply(n,t)},Hr=Math.max;var Wr=function(e,n,t){return n=Hr(void 0===n?e.length-1:n,0),function(){for(var r=arguments,o=-1,i=Hr(r.length-n,0),a=Array(i);++o<i;)a[o]=r[n+o];o=-1;for(var u=Array(n+1);++o<n;)u[o]=r[o];return u[n]=t(a),$r(e,this,u)}},qr=Ne?function(e,n){return Ne(e,"toString",{configurable:!0,enumerable:!1,value:ct(n),writable:!0})}:ht,Yr=Date.now;var Jr=function(e){var n=0,t=0;return function(){var r=Yr(),o=16-(r-t);if(t=r,o>0){if(++n>=800)return arguments[0]}else n=0;return e.apply(void 0,arguments)}}(qr);var Xr=function(e,n){return Jr(Wr(e,n,ht),e+"")};var Kr=function(e,n,t,r){for(var o=e.length,i=t+(r?1:-1);r?i--:++i<o;)if(n(e[i],i,e))return i;return-1};var Qr=function(e){return e!=e};var Zr=function(e,n,t){for(var r=t-1,o=e.length;++r<o;)if(e[r]===n)return r;return-1};var eo=function(e,n,t){return n==n?Zr(e,n,t):Kr(e,Qr,t)};var no=function(e,n){return!!(null==e?0:e.length)&&eo(e,n,0)>-1};var to=function(e,n,t){for(var r=-1,o=null==e?0:e.length;++r<o;)if(t(n,e[r]))return!0;return!1};var ro=function(){},oo=Sn&&1/Nt(new Sn([,-0]))[1]==1/0?function(e){return new Sn(e)}:ro;var io=function(e,n,t){var r=-1,o=no,i=e.length,a=!0,u=[],c=u;if(t)a=!1,o=to;else if(i>=200){var s=n?null:oo(e);if(s)return Nt(s);a=!1,o=_t,c=new wt}else c=n?[]:u;e:for(;++r<i;){var d=e[r],f=n?n(d):d;if(d=t||0!==d?d:0,a&&f==f){for(var h=c.length;h--;)if(c[h]===f)continue e;n&&c.push(f),u.push(d)}else o(c,f,t)||(c!==u&&c.push(f),u.push(d))}return u};var ao=function(e){return Ce(e)&&rn(e)},uo=Xr((function(e){return io(Vr(e,1,ao,!0))}));var co=function(e,n){return Yt(n,(function(n){return e[n]}))};var so,fo=function(e){return null==e?[]:co(e,on(e))};try{so={clone:ut,constant:ct,each:pt,filter:fr,has:vr,isArray:Te,isEmpty:gr,isFunction:z,isUndefined:yr,keys:on,map:mr,reduce:_r,size:Pr,transform:zr,union:uo,values:fo}}catch(e){}so||(so=window._);var ho=so,lo=vo;function vo(e){this._isDirected=!ho.has(e,"directed")||e.directed,this._isMultigraph=!!ho.has(e,"multigraph")&&e.multigraph,this._isCompound=!!ho.has(e,"compound")&&e.compound,this._label=void 0,this._defaultNodeLabelFn=ho.constant(void 0),this._defaultEdgeLabelFn=ho.constant(void 0),this._nodes={},this._isCompound&&(this._parent={},this._children={},this._children["\0"]={}),this._in={},this._preds={},this._out={},this._sucs={},this._edgeObjs={},this._edgeLabels={}}function po(e,n){e[n]?e[n]++:e[n]=1}function go(e,n){--e[n]||delete e[n]}function yo(e,n,t,r){var o=""+n,i=""+t;if(!e&&o>i){var a=o;o=i,i=a}return o+""+i+""+(ho.isUndefined(r)?"\0":r)}function bo(e,n,t,r){var o=""+n,i=""+t;if(!e&&o>i){var a=o;o=i,i=a}var u={v:o,w:i};return r&&(u.name=r),u}function mo(e,n){return yo(e,n.v,n.w,n.name)}vo.prototype._nodeCount=0,vo.prototype._edgeCount=0,vo.prototype.isDirected=function(){return this._isDirected},vo.prototype.isMultigraph=function(){return this._isMultigraph},vo.prototype.isCompound=function(){return this._isCompound},vo.prototype.setGraph=function(e){return this._label=e,this},vo.prototype.graph=function(){return this._label},vo.prototype.setDefaultNodeLabel=function(e){return ho.isFunction(e)||(e=ho.constant(e)),this._defaultNodeLabelFn=e,this},vo.prototype.nodeCount=function(){return this._nodeCount},vo.prototype.nodes=function(){return ho.keys(this._nodes)},vo.prototype.sources=function(){var e=this;return ho.filter(this.nodes(),(function(n){return ho.isEmpty(e._in[n])}))},vo.prototype.sinks=function(){var e=this;return ho.filter(this.nodes(),(function(n){return ho.isEmpty(e._out[n])}))},vo.prototype.setNodes=function(e,n){var t=arguments,r=this;return ho.each(e,(function(e){t.length>1?r.setNode(e,n):r.setNode(e)})),this},vo.prototype.setNode=function(e,n){return ho.has(this._nodes,e)?(arguments.length>1&&(this._nodes[e]=n),this):(this._nodes[e]=arguments.length>1?n:this._defaultNodeLabelFn(e),this._isCompound&&(this._parent[e]="\0",this._children[e]={},this._children["\0"][e]=!0),this._in[e]={},this._preds[e]={},this._out[e]={},this._sucs[e]={},++this._nodeCount,this)},vo.prototype.node=function(e){return this._nodes[e]},vo.prototype.hasNode=function(e){return ho.has(this._nodes,e)},vo.prototype.removeNode=function(e){var n=this;if(ho.has(this._nodes,e)){var t=function(e){n.removeEdge(n._edgeObjs[e])};delete this._nodes[e],this._isCompound&&(this._removeFromParentsChildList(e),delete this._parent[e],ho.each(this.children(e),(function(e){n.setParent(e)})),delete this._children[e]),ho.each(ho.keys(this._in[e]),t),delete this._in[e],delete this._preds[e],ho.each(ho.keys(this._out[e]),t),delete this._out[e],delete this._sucs[e],--this._nodeCount}return this},vo.prototype.setParent=function(e,n){if(!this._isCompound)throw new Error("Cannot set parent in a non-compound graph");if(ho.isUndefined(n))n="\0";else{for(var t=n+="";!ho.isUndefined(t);t=this.parent(t))if(t===e)throw new Error("Setting "+n+" as parent of "+e+" would create a cycle");this.setNode(n)}return this.setNode(e),this._removeFromParentsChildList(e),this._parent[e]=n,this._children[n][e]=!0,this},vo.prototype._removeFromParentsChildList=function(e){delete this._children[this._parent[e]][e]},vo.prototype.parent=function(e){if(this._isCompound){var n=this._parent[e];if("\0"!==n)return n}},vo.prototype.children=function(e){if(ho.isUndefined(e)&&(e="\0"),this._isCompound){var n=this._children[e];if(n)return ho.keys(n)}else{if("\0"===e)return this.nodes();if(this.hasNode(e))return[]}},vo.prototype.predecessors=function(e){var n=this._preds[e];if(n)return ho.keys(n)},vo.prototype.successors=function(e){var n=this._sucs[e];if(n)return ho.keys(n)},vo.prototype.neighbors=function(e){var n=this.predecessors(e);if(n)return ho.union(n,this.successors(e))},vo.prototype.isLeaf=function(e){return 0===(this.isDirected()?this.successors(e):this.neighbors(e)).length},vo.prototype.filterNodes=function(e){var n=new this.constructor({directed:this._isDirected,multigraph:this._isMultigraph,compound:this._isCompound});n.setGraph(this.graph());var t=this;ho.each(this._nodes,(function(t,r){e(r)&&n.setNode(r,t)})),ho.each(this._edgeObjs,(function(e){n.hasNode(e.v)&&n.hasNode(e.w)&&n.setEdge(e,t.edge(e))}));var r={};function o(e){var i=t.parent(e);return void 0===i||n.hasNode(i)?(r[e]=i,i):i in r?r[i]:o(i)}return this._isCompound&&ho.each(n.nodes(),(function(e){n.setParent(e,o(e))})),n},vo.prototype.setDefaultEdgeLabel=function(e){return ho.isFunction(e)||(e=ho.constant(e)),this._defaultEdgeLabelFn=e,this},vo.prototype.edgeCount=function(){return this._edgeCount},vo.prototype.edges=function(){return ho.values(this._edgeObjs)},vo.prototype.setPath=function(e,n){var t=this,r=arguments;return ho.reduce(e,(function(e,o){return r.length>1?t.setEdge(e,o,n):t.setEdge(e,o),o})),this},vo.prototype.setEdge=function(){var e,n,t,r,o=!1,i=arguments[0];"object"==typeof i&&null!==i&&"v"in i?(e=i.v,n=i.w,t=i.name,2===arguments.length&&(r=arguments[1],o=!0)):(e=i,n=arguments[1],t=arguments[3],arguments.length>2&&(r=arguments[2],o=!0)),e=""+e,n=""+n,ho.isUndefined(t)||(t=""+t);var a=yo(this._isDirected,e,n,t);if(ho.has(this._edgeLabels,a))return o&&(this._edgeLabels[a]=r),this;if(!ho.isUndefined(t)&&!this._isMultigraph)throw new Error("Cannot set a named edge when isMultigraph = false");this.setNode(e),this.setNode(n),this._edgeLabels[a]=o?r:this._defaultEdgeLabelFn(e,n,t);var u=bo(this._isDirected,e,n,t);return e=u.v,n=u.w,Object.freeze(u),this._edgeObjs[a]=u,po(this._preds[n],e),po(this._sucs[e],n),this._in[n][a]=u,this._out[e][a]=u,this._edgeCount++,this},vo.prototype.edge=function(e,n,t){var r=1===arguments.length?mo(this._isDirected,arguments[0]):yo(this._isDirected,e,n,t);return this._edgeLabels[r]},vo.prototype.hasEdge=function(e,n,t){var r=1===arguments.length?mo(this._isDirected,arguments[0]):yo(this._isDirected,e,n,t);return ho.has(this._edgeLabels,r)},vo.prototype.removeEdge=function(e,n,t){var r=1===arguments.length?mo(this._isDirected,arguments[0]):yo(this._isDirected,e,n,t),o=this._edgeObjs[r];return o&&(e=o.v,n=o.w,delete this._edgeLabels[r],delete this._edgeObjs[r],go(this._preds[n],e),go(this._sucs[e],n),delete this._in[n][r],delete this._out[e][r],this._edgeCount--),this},vo.prototype.inEdges=function(e,n){var t=this._in[e];if(t){var r=ho.values(t);return n?ho.filter(r,(function(e){return e.v===n})):r}},vo.prototype.outEdges=function(e,n){var t=this._out[e];if(t){var r=ho.values(t);return n?ho.filter(r,(function(e){return e.w===n})):r}},vo.prototype.nodeEdges=function(e,n){var t=this.inEdges(e,n);if(t)return t.concat(this.outEdges(e,n))};var wo={Graph:lo,version:"2.1.8"},Eo={write:function(e){var n={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:_o(e),edges:jo(e)};ho.isUndefined(e.graph())||(n.value=ho.clone(e.graph()));return n},read:function(e){var n=new lo(e.options).setGraph(e.value);return ho.each(e.nodes,(function(e){n.setNode(e.v,e.value),e.parent&&n.setParent(e.v,e.parent)})),ho.each(e.edges,(function(e){n.setEdge({v:e.v,w:e.w,name:e.name},e.value)})),n}};function _o(e){return ho.map(e.nodes(),(function(n){var t=e.node(n),r=e.parent(n),o={v:n};return ho.isUndefined(t)||(o.value=t),ho.isUndefined(r)||(o.parent=r),o}))}function jo(e){return ho.map(e.edges(),(function(n){var t=e.edge(n),r={v:n.v,w:n.w};return ho.isUndefined(n.name)||(r.name=n.name),ho.isUndefined(t)||(r.value=t),r}))}var xo=function(e){var n,t={},r=[];function o(r){ho.has(t,r)||(t[r]=!0,n.push(r),ho.each(e.successors(r),o),ho.each(e.predecessors(r),o))}return ho.each(e.nodes(),(function(e){n=[],o(e),n.length&&r.push(n)})),r};var No=Oo;function Oo(){this._arr=[],this._keyIndices={}}Oo.prototype.size=function(){return this._arr.length},Oo.prototype.keys=function(){return this._arr.map((function(e){return e.key}))},Oo.prototype.has=function(e){return ho.has(this._keyIndices,e)},Oo.prototype.priority=function(e){var n=this._keyIndices[e];if(void 0!==n)return this._arr[n].priority},Oo.prototype.min=function(){if(0===this.size())throw new Error("Queue underflow");return this._arr[0].key},Oo.prototype.add=function(e,n){var t=this._keyIndices;if(e=String(e),!ho.has(t,e)){var r=this._arr,o=r.length;return t[e]=o,r.push({key:e,priority:n}),this._decrease(o),!0}return!1},Oo.prototype.removeMin=function(){this._swap(0,this._arr.length-1);var e=this._arr.pop();return delete this._keyIndices[e.key],this._heapify(0),e.key},Oo.prototype.decrease=function(e,n){var t=this._keyIndices[e];if(n>this._arr[t].priority)throw new Error("New priority is greater than current priority. Key: "+e+" Old: "+this._arr[t].priority+" New: "+n);this._arr[t].priority=n,this._decrease(t)},Oo.prototype._heapify=function(e){var n=this._arr,t=2*e,r=t+1,o=e;t<n.length&&(o=n[t].priority<n[o].priority?t:o,r<n.length&&(o=n[r].priority<n[o].priority?r:o),o!==e&&(this._swap(e,o),this._heapify(o)))},Oo.prototype._decrease=function(e){for(var n,t=this._arr,r=t[e].priority;0!==e&&!(t[n=e>>1].priority<r);)this._swap(e,n),e=n},Oo.prototype._swap=function(e,n){var t=this._arr,r=this._keyIndices,o=t[e],i=t[n];t[e]=i,t[n]=o,r[i.key]=e,r[o.key]=n};var ko=function(e,n,t,r){return function(e,n,t,r){var o,i,a={},u=new No,c=function(e){var n=e.v!==o?e.v:e.w,r=a[n],c=t(e),s=i.distance+c;if(c<0)throw new Error("dijkstra does not allow negative edge weights. Bad edge: "+e+" Weight: "+c);s<r.distance&&(r.distance=s,r.predecessor=o,u.decrease(n,s))};e.nodes().forEach((function(e){var t=e===n?0:Number.POSITIVE_INFINITY;a[e]={distance:t},u.add(e,t)}));for(;u.size()>0&&(o=u.removeMin(),(i=a[o]).distance!==Number.POSITIVE_INFINITY);)r(o).forEach(c);return a}(e,String(n),t||Io,r||function(n){return e.outEdges(n)})},Io=ho.constant(1);var So=function(e,n,t){return ho.transform(e.nodes(),(function(r,o){r[o]=ko(e,o,n,t)}),{})};var Mo=function(e){var n=0,t=[],r={},o=[];function i(a){var u=r[a]={onStack:!0,lowlink:n,index:n++};if(t.push(a),e.successors(a).forEach((function(e){ho.has(r,e)?r[e].onStack&&(u.lowlink=Math.min(u.lowlink,r[e].index)):(i(e),u.lowlink=Math.min(u.lowlink,r[e].lowlink))})),u.lowlink===u.index){var c,s=[];do{c=t.pop(),r[c].onStack=!1,s.push(c)}while(a!==c);o.push(s)}}return e.nodes().forEach((function(e){ho.has(r,e)||i(e)})),o};var Co=function(e){return ho.filter(Mo(e),(function(n){return n.length>1||1===n.length&&e.hasEdge(n[0],n[0])}))};var Go=function(e,n,t){return function(e,n,t){var r={},o=e.nodes();return o.forEach((function(e){r[e]={},r[e][e]={distance:0},o.forEach((function(n){e!==n&&(r[e][n]={distance:Number.POSITIVE_INFINITY})})),t(e).forEach((function(t){var o=t.v===e?t.w:t.v,i=n(t);r[e][o]={distance:i,predecessor:e}}))})),o.forEach((function(e){var n=r[e];o.forEach((function(t){var i=r[t];o.forEach((function(t){var r=i[e],o=n[t],a=i[t],u=r.distance+o.distance;u<a.distance&&(a.distance=u,a.predecessor=o.predecessor)}))}))})),r}(e,n||Bo,t||function(n){return e.outEdges(n)})},Bo=ho.constant(1);var Ao=Lo;function Lo(e){var n={},t={},r=[];if(ho.each(e.sinks(),(function o(i){if(ho.has(t,i))throw new Ro;ho.has(n,i)||(t[i]=!0,n[i]=!0,ho.each(e.predecessors(i),o),delete t[i],r.push(i))})),ho.size(n)!==e.nodeCount())throw new Ro;return r}function Ro(){}Lo.CycleException=Ro,Ro.prototype=new Error;var To=function(e,n,t){ho.isArray(n)||(n=[n]);var r=(e.isDirected()?e.successors:e.neighbors).bind(e),o=[],i={};return ho.each(n,(function(n){if(!e.hasNode(n))throw new Error("Graph does not have node: "+n);Do(e,n,"post"===t,i,r,o)})),o};function Do(e,n,t,r,o,i){ho.has(r,n)||(r[n]=!0,t||i.push(n),ho.each(o(n),(function(n){Do(e,n,t,r,o,i)})),t&&i.push(n))}var Po,zo={Graph:wo.Graph,json:Eo,alg:{components:xo,dijkstra:ko,dijkstraAll:So,findCycles:Co,floydWarshall:Go,isAcyclic:function(e){try{Ao(e)}catch(e){if(e instanceof Ao.CycleException)return!1;throw e}return!0},postorder:function(e,n){return To(e,n,"post")},preorder:function(e,n){return To(e,n,"pre")},prim:function(e,n){var t,r=new lo,o={},i=new No;function a(e){var r=e.v===t?e.w:e.v,a=i.priority(r);if(void 0!==a){var u=n(e);u<a&&(o[r]=t,i.decrease(r,u))}}if(0===e.nodeCount())return r;ho.each(e.nodes(),(function(e){i.add(e,Number.POSITIVE_INFINITY),r.setNode(e)})),i.decrease(e.nodes()[0],0);var u=!1;for(;i.size()>0;){if(t=i.removeMin(),ho.has(o,t))r.setEdge(t,o[t]);else{if(u)throw new Error("Input graph is not connected: "+e);u=!0}e.nodeEdges(t).forEach(a)}return r},tarjan:Mo,topsort:Ao},version:wo.version};try{Po=zo}catch(e){}Po||(Po=window.graphlib);var Fo=Po;var Uo=function(e){return at(e,5)};var Vo=function(e,n,t){if(!D(t))return!1;var r=typeof n;return!!("number"==r?rn(t)&&Fe(n,t.length):"string"==r&&n in t)&&h(t[n],e)},$o=Object.prototype,Ho=$o.hasOwnProperty,Wo=Xr((function(e,n){e=Object(e);var t=-1,r=n.length,o=r>2?n[2]:void 0;for(o&&Vo(n[0],n[1],o)&&(r=1);++t<r;)for(var i=n[t],a=dn(i),u=-1,c=a.length;++u<c;){var s=a[u],d=e[s];(void 0===d||h(d,$o[s])&&!Ho.call(e,s))&&(e[s]=i[s])}return e}));var qo=function(e){return function(n,t,r){var o=Object(n);if(!rn(n)){var i=dr(t);n=on(n),t=function(e){return i(o[e],e,o)}}var a=e(n,t,r);return a>-1?o[i?n[a]:a]:void 0}},Yo=/^\s+|\s+$/g,Jo=/^[-+]0x[0-9a-f]+$/i,Xo=/^0b[01]+$/i,Ko=/^0o[0-7]+$/i,Qo=parseInt;var Zo=function(e){if("number"==typeof e)return e;if(Pt(e))return NaN;if(D(e)){var n="function"==typeof e.valueOf?e.valueOf():e;e=D(n)?n+"":n}if("string"!=typeof e)return 0===e?e:+e;e=e.replace(Yo,"");var t=Xo.test(e);return t||Ko.test(e)?Qo(e.slice(2),t?2:8):Jo.test(e)?NaN:+e};var ei=function(e){return e?Infinity===(e=Zo(e))||-Infinity===e?17976931348623157e292*(e<0?-1:1):e==e?e:0:0===e?e:0};var ni=function(e){var n=ei(e),t=n%1;return n==n?t?n-t:n:0},ti=Math.max;var ri=qo((function(e,n,t){var r=null==e?0:e.length;if(!r)return-1;var o=null==t?0:ni(t);return o<0&&(o=ti(r+o,0)),Kr(e,dr(n),o)}));var oi=function(e){return(null==e?0:e.length)?Vr(e,1):[]};var ii=function(e,n){return null==e?e:st(e,lt(n),dn)};var ai=function(e){var n=null==e?0:e.length;return n?e[n-1]:void 0};var ui=function(e,n){var t={};return n=dr(n),dt(e,(function(e,r,o){Oe(t,r,n(e,r,o))})),t};var ci=function(e,n,t){for(var r=-1,o=e.length;++r<o;){var i=e[r],a=n(i);if(null!=a&&(void 0===u?a==a&&!Pt(a):t(a,u)))var u=a,c=i}return c};var si=function(e,n){return e>n};var di=function(e){return e&&e.length?ci(e,ht,si):void 0};var fi=function(e,n,t){(void 0!==t&&!h(e[n],t)||void 0===t&&!(n in e))&&Oe(e,n,t)},hi=Function.prototype,li=Object.prototype,vi=hi.toString,pi=li.hasOwnProperty,gi=vi.call(Object);var yi=function(e){if(!Ce(e)||"[object Object]"!=T(e))return!1;var n=En(e);if(null===n)return!0;var t=pi.call(n,"constructor")&&n.constructor;return"function"==typeof t&&t instanceof t&&vi.call(t)==gi};var bi=function(e,n){if(("constructor"!==n||"function"!=typeof e[n])&&"__proto__"!=n)return e[n]};var mi=function(e){return Se(e,dn(e))};var wi=function(e,n,t,r,o,i,a){var u=bi(e,t),c=bi(n,t),s=a.get(c);if(s)fi(e,t,s);else{var d=i?i(u,c,t+"",e,n,a):void 0,f=void 0===d;if(f){var h=Te(c),l=!h&&Pe(c),v=!h&&!l&&Ye(c);d=c,h||l||v?Te(u)?d=u:ao(u)?d=ln(u):l?(f=!1,d=hn(c,!0)):v?(f=!1,d=Yn(c,!0)):d=[]:yi(c)||Re(c)?(d=u,Re(u)?d=mi(u):D(u)&&!z(u)||(d=Qn(c))):f=!1}f&&(a.set(c,d),o(d,c,r,i,a),a.delete(c)),fi(e,t,d)}};var Ei=function e(n,t,r,o,i){n!==t&&st(t,(function(a,u){if(i||(i=new je),D(a))wi(n,t,u,r,e,o,i);else{var c=o?o(bi(n,u),a,u+"",n,t,i):void 0;void 0===c&&(c=a),fi(n,u,c)}}),dn)};var _i=function(e){return Xr((function(n,t){var r=-1,o=t.length,i=o>1?t[o-1]:void 0,a=o>2?t[2]:void 0;for(i=e.length>3&&"function"==typeof i?(o--,i):void 0,a&&Vo(t[0],t[1],a)&&(i=o<3?void 0:i,o=1),n=Object(n);++r<o;){var u=t[r];u&&e(n,u,r,i)}return n}))}((function(e,n,t){Ei(e,n,t)}));var ji=function(e,n){return e<n};var xi=function(e){return e&&e.length?ci(e,ht,ji):void 0};var Ni=function(e,n){return e&&e.length?ci(e,dr(n),ji):void 0},Oi=function(){return k.Date.now()};var ki=function(e,n,t,r){if(!D(e))return e;for(var o=-1,i=(n=Zt(n,e)).length,a=i-1,u=e;null!=u&&++o<i;){var c=er(n[o]),s=t;if("__proto__"===c||"constructor"===c||"prototype"===c)return e;if(o!=a){var d=u[c];void 0===(s=r?r(d,c,u):void 0)&&(s=D(d)?d:Fe(n[o+1])?[]:{})}Ie(u,c,s),u=u[c]}return e};var Ii=function(e,n,t){for(var r=-1,o=n.length,i={};++r<o;){var a=n[r],u=nr(e,a);t(u,a)&&ki(i,Zt(a,e),u)}return i};var Si=function(e,n){return Ii(e,n,(function(n,t){return ir(e,t)}))};var Mi=function(e){return Jr(Wr(e,void 0,oi),e+"")}((function(e,n){return null==e?{}:Si(e,n)})),Ci=Math.ceil,Gi=Math.max;var Bi=function(e,n,t,r){for(var o=-1,i=Gi(Ci((n-e)/(t||1)),0),a=Array(i);i--;)a[r?i:++o]=e,e+=t;return a};var Ai=function(e){return function(n,t,r){return r&&"number"!=typeof r&&Vo(n,t,r)&&(t=r=void 0),n=ei(n),void 0===t?(t=n,n=0):t=ei(t),r=void 0===r?n<t?1:-1:ei(r),Bi(n,t,r,e)}}();var Li=function(e,n){var t=e.length;for(e.sort(n);t--;)e[t]=e[t].value;return e};var Ri=function(e,n){if(e!==n){var t=void 0!==e,r=null===e,o=e==e,i=Pt(e),a=void 0!==n,u=null===n,c=n==n,s=Pt(n);if(!u&&!s&&!i&&e>n||i&&a&&c&&!u&&!s||r&&a&&c||!t&&c||!o)return 1;if(!r&&!i&&!s&&e<n||s&&t&&o&&!r&&!i||u&&t&&o||!a&&o||!c)return-1}return 0};var Ti=function(e,n,t){for(var r=-1,o=e.criteria,i=n.criteria,a=o.length,u=t.length;++r<a;){var c=Ri(o[r],i[r]);if(c)return r>=u?c:c*("desc"==t[r]?-1:1)}return e.index-n.index};var Di=function(e,n,t){n=n.length?Yt(n,(function(e){return Te(e)?function(n){return nr(n,1===e.length?e[0]:e)}:e})):[ht];var r=-1;n=Yt(n,He(dr));var o=br(e,(function(e,t,o){return{criteria:Yt(n,(function(n){return n(e)})),index:++r,value:e}}));return Li(o,(function(e,n){return Ti(e,n,t)}))},Pi=Xr((function(e,n){if(null==e)return[];var t=n.length;return t>1&&Vo(e,n[0],n[1])?n=[]:t>2&&Vo(n[0],n[1],n[2])&&(n=[n[0]]),Di(e,Vr(n,1),[])})),zi=0;var Fi=function(e){var n=++zi;return Qt(e)+n};var Ui=function(e,n,t){for(var r=-1,o=e.length,i=n.length,a={};++r<o;){var u=r<i?n[r]:void 0;t(a,e[r],u)}return a};var Vi,$i=function(e,n){return Ui(e||[],n||[],Ie)};try{Vi={cloneDeep:Uo,constant:ct,defaults:Wo,each:pt,filter:fr,find:ri,flatten:oi,forEach:vt,forIn:ii,has:vr,isUndefined:yr,last:ai,map:mr,mapValues:ui,max:di,merge:_i,min:xi,minBy:Ni,now:Oi,pick:Mi,range:Ai,reduce:_r,sortBy:Pi,uniqueId:Fi,values:fo,zipObject:$i}}catch(e){}Vi||(Vi=window._);var Hi=Vi,Wi=qi;function qi(){var e={};e._next=e._prev=e,this._sentinel=e}function Yi(e){e._prev._next=e._next,e._next._prev=e._prev,delete e._next,delete e._prev}function Ji(e,n){if("_next"!==e&&"_prev"!==e)return n}qi.prototype.dequeue=function(){var e=this._sentinel,n=e._prev;if(n!==e)return Yi(n),n},qi.prototype.enqueue=function(e){var n=this._sentinel;e._prev&&e._next&&Yi(e),e._next=n._next,n._next._prev=e,n._next=e,e._prev=n},qi.prototype.toString=function(){for(var e=[],n=this._sentinel,t=n._prev;t!==n;)e.push(JSON.stringify(t,Ji)),t=t._prev;return"["+e.join(", ")+"]"};var Xi=Fo.Graph,Ki=function(e,n){if(e.nodeCount()<=1)return[];var t=function(e,n){var t=new Xi,r=0,o=0;Hi.forEach(e.nodes(),(function(e){t.setNode(e,{v:e,in:0,out:0})})),Hi.forEach(e.edges(),(function(e){var i=t.edge(e.v,e.w)||0,a=n(e),u=i+a;t.setEdge(e.v,e.w,u),o=Math.max(o,t.node(e.v).out+=a),r=Math.max(r,t.node(e.w).in+=a)}));var i=Hi.range(o+r+3).map((function(){return new Wi})),a=r+1;return Hi.forEach(t.nodes(),(function(e){ea(i,a,t.node(e))})),{graph:t,buckets:i,zeroIdx:a}}(e,n||Qi),r=function(e,n,t){var r,o=[],i=n[n.length-1],a=n[0];for(;e.nodeCount();){for(;r=a.dequeue();)Zi(e,n,t,r);for(;r=i.dequeue();)Zi(e,n,t,r);if(e.nodeCount())for(var u=n.length-2;u>0;--u)if(r=n[u].dequeue()){o=o.concat(Zi(e,n,t,r,!0));break}}return o}(t.graph,t.buckets,t.zeroIdx);return Hi.flatten(Hi.map(r,(function(n){return e.outEdges(n.v,n.w)})),!0)},Qi=Hi.constant(1);function Zi(e,n,t,r,o){var i=o?[]:void 0;return Hi.forEach(e.inEdges(r.v),(function(r){var a=e.edge(r),u=e.node(r.v);o&&i.push({v:r.v,w:r.w}),u.out-=a,ea(n,t,u)})),Hi.forEach(e.outEdges(r.v),(function(r){var o=e.edge(r),i=r.w,a=e.node(i);a.in-=o,ea(n,t,a)})),e.removeNode(r.v),i}function ea(e,n,t){t.out?t.in?e[t.out-t.in+n].enqueue(t):e[e.length-1].enqueue(t):e[0].enqueue(t)}var na={run:function(e){var n="greedy"===e.graph().acyclicer?Ki(e,function(e){return function(n){return e.edge(n).weight}}(e)):function(e){var n=[],t={},r={};function o(i){Hi.has(r,i)||(r[i]=!0,t[i]=!0,Hi.forEach(e.outEdges(i),(function(e){Hi.has(t,e.w)?n.push(e):o(e.w)})),delete t[i])}return Hi.forEach(e.nodes(),o),n}(e);Hi.forEach(n,(function(n){var t=e.edge(n);e.removeEdge(n),t.forwardName=n.name,t.reversed=!0,e.setEdge(n.w,n.v,t,Hi.uniqueId("rev"))}))},undo:function(e){Hi.forEach(e.edges(),(function(n){var t=e.edge(n);if(t.reversed){e.removeEdge(n);var r=t.forwardName;delete t.reversed,delete t.forwardName,e.setEdge(n.w,n.v,t,r)}}))}};var ta=Fo.Graph,ra={addDummyNode:oa,simplify:function(e){var n=(new ta).setGraph(e.graph());return Hi.forEach(e.nodes(),(function(t){n.setNode(t,e.node(t))})),Hi.forEach(e.edges(),(function(t){var r=n.edge(t.v,t.w)||{weight:0,minlen:1},o=e.edge(t);n.setEdge(t.v,t.w,{weight:r.weight+o.weight,minlen:Math.max(r.minlen,o.minlen)})})),n},asNonCompoundGraph:function(e){var n=new ta({multigraph:e.isMultigraph()}).setGraph(e.graph());return Hi.forEach(e.nodes(),(function(t){e.children(t).length||n.setNode(t,e.node(t))})),Hi.forEach(e.edges(),(function(t){n.setEdge(t,e.edge(t))})),n},successorWeights:function(e){var n=Hi.map(e.nodes(),(function(n){var t={};return Hi.forEach(e.outEdges(n),(function(n){t[n.w]=(t[n.w]||0)+e.edge(n).weight})),t}));return Hi.zipObject(e.nodes(),n)},predecessorWeights:function(e){var n=Hi.map(e.nodes(),(function(n){var t={};return Hi.forEach(e.inEdges(n),(function(n){t[n.v]=(t[n.v]||0)+e.edge(n).weight})),t}));return Hi.zipObject(e.nodes(),n)},intersectRect:function(e,n){var t,r,o=e.x,i=e.y,a=n.x-o,u=n.y-i,c=e.width/2,s=e.height/2;if(!a&&!u)throw new Error("Not possible to find intersection inside of the rectangle");Math.abs(u)*c>Math.abs(a)*s?(u<0&&(s=-s),t=s*a/u,r=s):(a<0&&(c=-c),t=c,r=c*u/a);return{x:o+t,y:i+r}},buildLayerMatrix:function(e){var n=Hi.map(Hi.range(ia(e)+1),(function(){return[]}));return Hi.forEach(e.nodes(),(function(t){var r=e.node(t),o=r.rank;Hi.isUndefined(o)||(n[o][r.order]=t)})),n},normalizeRanks:function(e){var n=Hi.min(Hi.map(e.nodes(),(function(n){return e.node(n).rank})));Hi.forEach(e.nodes(),(function(t){var r=e.node(t);Hi.has(r,"rank")&&(r.rank-=n)}))},removeEmptyRanks:function(e){var n=Hi.min(Hi.map(e.nodes(),(function(n){return e.node(n).rank}))),t=[];Hi.forEach(e.nodes(),(function(r){var o=e.node(r).rank-n;t[o]||(t[o]=[]),t[o].push(r)}));var r=0,o=e.graph().nodeRankFactor;Hi.forEach(t,(function(n,t){Hi.isUndefined(n)&&t%o!=0?--r:r&&Hi.forEach(n,(function(n){e.node(n).rank+=r}))}))},addBorderNode:function(e,n,t,r){var o={width:0,height:0};arguments.length>=4&&(o.rank=t,o.order=r);return oa(e,"border",o,n)},maxRank:ia,partition:function(e,n){var t={lhs:[],rhs:[]};return Hi.forEach(e,(function(e){n(e)?t.lhs.push(e):t.rhs.push(e)})),t},time:function(e,n){var t=Hi.now();try{return n()}finally{console.log(e+" time: "+(Hi.now()-t)+"ms")}},notime:function(e,n){return n()}};function oa(e,n,t,r){var o;do{o=Hi.uniqueId(r)}while(e.hasNode(o));return t.dummy=n,e.setNode(o,t),o}function ia(e){return Hi.max(Hi.map(e.nodes(),(function(n){var t=e.node(n).rank;if(!Hi.isUndefined(t))return t})))}var aa={run:function(e){e.graph().dummyChains=[],Hi.forEach(e.edges(),(function(n){!function(e,n){var t,r,o,i=n.v,a=e.node(i).rank,u=n.w,c=e.node(u).rank,s=n.name,d=e.edge(n),f=d.labelRank;if(c===a+1)return;for(e.removeEdge(n),o=0,++a;a<c;++o,++a)d.points=[],r={width:0,height:0,edgeLabel:d,edgeObj:n,rank:a},t=ra.addDummyNode(e,"edge",r,"_d"),a===f&&(r.width=d.width,r.height=d.height,r.dummy="edge-label",r.labelpos=d.labelpos),e.setEdge(i,t,{weight:d.weight},s),0===o&&e.graph().dummyChains.push(t),i=t;e.setEdge(i,u,{weight:d.weight},s)}(e,n)}))},undo:function(e){Hi.forEach(e.graph().dummyChains,(function(n){var t,r=e.node(n),o=r.edgeLabel;for(e.setEdge(r.edgeObj,o);r.dummy;)t=e.successors(n)[0],e.removeNode(n),o.points.push({x:r.x,y:r.y}),"edge-label"===r.dummy&&(o.x=r.x,o.y=r.y,o.width=r.width,o.height=r.height),n=t,r=e.node(n)}))}};var ua=function(e){var n={};Hi.forEach(e.sources(),(function t(r){var o=e.node(r);if(Hi.has(n,r))return o.rank;n[r]=!0;var i=Hi.min(Hi.map(e.outEdges(r),(function(n){return t(n.w)-e.edge(n).minlen})));return i!==Number.POSITIVE_INFINITY&&null!=i||(i=0),o.rank=i}))},ca=function(e,n){return e.node(n.w).rank-e.node(n.v).rank-e.edge(n).minlen};var sa=Fo.Graph,da=ca,fa=function(e){var n,t,r=new sa({directed:!1}),o=e.nodes()[0],i=e.nodeCount();r.setNode(o,{});for(;ha(r,e)<i;)n=la(r,e),t=r.hasNode(n.v)?da(e,n):-da(e,n),va(r,e,t);return r};function ha(e,n){return Hi.forEach(e.nodes(),(function t(r){Hi.forEach(n.nodeEdges(r),(function(o){var i=o.v,a=r===i?o.w:i;e.hasNode(a)||da(n,o)||(e.setNode(a,{}),e.setEdge(r,a,{}),t(a))}))})),e.nodeCount()}function la(e,n){return Hi.minBy(n.edges(),(function(t){if(e.hasNode(t.v)!==e.hasNode(t.w))return da(n,t)}))}function va(e,n,t){Hi.forEach(e.nodes(),(function(e){n.node(e).rank+=t}))}var pa=ca,ga=ua,ya=Fo.alg.preorder,ba=Fo.alg.postorder,ma=ra.simplify,wa=Ea;function Ea(e){e=ma(e),ga(e);var n,t=fa(e);for(xa(t),_a(t,e);n=Oa(t);)Ia(t,e,n,ka(t,e,n))}function _a(e,n){var t=ba(e,e.nodes());t=t.slice(0,t.length-1),Hi.forEach(t,(function(t){!function(e,n,t){var r=e.node(t).parent;e.edge(t,r).cutvalue=ja(e,n,t)}(e,n,t)}))}function ja(e,n,t){var r=e.node(t).parent,o=!0,i=n.edge(t,r),a=0;return i||(o=!1,i=n.edge(r,t)),a=i.weight,Hi.forEach(n.nodeEdges(t),(function(i){var u,c,s=i.v===t,d=s?i.w:i.v;if(d!==r){var f=s===o,h=n.edge(i).weight;if(a+=f?h:-h,u=t,c=d,e.hasEdge(u,c)){var l=e.edge(t,d).cutvalue;a+=f?-l:l}}})),a}function xa(e,n){arguments.length<2&&(n=e.nodes()[0]),Na(e,{},1,n)}function Na(e,n,t,r,o){var i=t,a=e.node(r);return n[r]=!0,Hi.forEach(e.neighbors(r),(function(o){Hi.has(n,o)||(t=Na(e,n,t,o,r))})),a.low=i,a.lim=t++,o?a.parent=o:delete a.parent,t}function Oa(e){return Hi.find(e.edges(),(function(n){return e.edge(n).cutvalue<0}))}function ka(e,n,t){var r=t.v,o=t.w;n.hasEdge(r,o)||(r=t.w,o=t.v);var i=e.node(r),a=e.node(o),u=i,c=!1;i.lim>a.lim&&(u=a,c=!0);var s=Hi.filter(n.edges(),(function(n){return c===Sa(e,e.node(n.v),u)&&c!==Sa(e,e.node(n.w),u)}));return Hi.minBy(s,(function(e){return pa(n,e)}))}function Ia(e,n,t,r){var o=t.v,i=t.w;e.removeEdge(o,i),e.setEdge(r.v,r.w,{}),xa(e),_a(e,n),function(e,n){var t=Hi.find(e.nodes(),(function(e){return!n.node(e).parent})),r=ya(e,t);r=r.slice(1),Hi.forEach(r,(function(t){var r=e.node(t).parent,o=n.edge(t,r),i=!1;o||(o=n.edge(r,t),i=!0),n.node(t).rank=n.node(r).rank+(i?o.minlen:-o.minlen)}))}(e,n)}function Sa(e,n,t){return t.low<=n.lim&&n.lim<=t.lim}Ea.initLowLimValues=xa,Ea.initCutValues=_a,Ea.calcCutValue=ja,Ea.leaveEdge=Oa,Ea.enterEdge=ka,Ea.exchangeEdges=Ia;var Ma=ua,Ca=function(e){switch(e.graph().ranker){case"network-simplex":Ba(e);break;case"tight-tree":!function(e){Ma(e),fa(e)}(e);break;case"longest-path":Ga(e);break;default:Ba(e)}};var Ga=Ma;function Ba(e){wa(e)}var Aa=function(e){var n=function(e){var n={},t=0;function r(o){var i=t;Hi.forEach(e.children(o),r),n[o]={low:i,lim:t++}}return Hi.forEach(e.children(),r),n}(e);Hi.forEach(e.graph().dummyChains,(function(t){for(var r=e.node(t),o=r.edgeObj,i=function(e,n,t,r){var o,i,a=[],u=[],c=Math.min(n[t].low,n[r].low),s=Math.max(n[t].lim,n[r].lim);o=t;do{o=e.parent(o),a.push(o)}while(o&&(n[o].low>c||s>n[o].lim));i=o,o=r;for(;(o=e.parent(o))!==i;)u.push(o);return{path:a.concat(u.reverse()),lca:i}}(e,n,o.v,o.w),a=i.path,u=i.lca,c=0,s=a[c],d=!0;t!==o.w;){if(r=e.node(t),d){for(;(s=a[c])!==u&&e.node(s).maxRank<r.rank;)c++;s===u&&(d=!1)}if(!d){for(;c<a.length-1&&e.node(s=a[c+1]).minRank<=r.rank;)c++;s=a[c]}e.setParent(t,s),t=e.successors(t)[0]}}))};var La={run:function(e){var n=ra.addDummyNode(e,"root",{},"_root"),t=function(e){var n={};function t(r,o){var i=e.children(r);i&&i.length&&Hi.forEach(i,(function(e){t(e,o+1)})),n[r]=o}return Hi.forEach(e.children(),(function(e){t(e,1)})),n}(e),r=Hi.max(Hi.values(t))-1,o=2*r+1;e.graph().nestingRoot=n,Hi.forEach(e.edges(),(function(n){e.edge(n).minlen*=o}));var i=function(e){return Hi.reduce(e.edges(),(function(n,t){return n+e.edge(t).weight}),0)}(e)+1;Hi.forEach(e.children(),(function(a){Ra(e,n,o,i,r,t,a)})),e.graph().nodeRankFactor=o},cleanup:function(e){var n=e.graph();e.removeNode(n.nestingRoot),delete n.nestingRoot,Hi.forEach(e.edges(),(function(n){e.edge(n).nestingEdge&&e.removeEdge(n)}))}};function Ra(e,n,t,r,o,i,a){var u=e.children(a);if(u.length){var c=ra.addBorderNode(e,"_bt"),s=ra.addBorderNode(e,"_bb"),d=e.node(a);e.setParent(c,a),d.borderTop=c,e.setParent(s,a),d.borderBottom=s,Hi.forEach(u,(function(u){Ra(e,n,t,r,o,i,u);var d=e.node(u),f=d.borderTop?d.borderTop:u,h=d.borderBottom?d.borderBottom:u,l=d.borderTop?r:2*r,v=f!==h?1:o-i[a]+1;e.setEdge(c,f,{weight:l,minlen:v,nestingEdge:!0}),e.setEdge(h,s,{weight:l,minlen:v,nestingEdge:!0})})),e.parent(a)||e.setEdge(n,c,{weight:0,minlen:o+i[a]})}else a!==n&&e.setEdge(n,a,{weight:0,minlen:t})}var Ta=function(e){Hi.forEach(e.children(),(function n(t){var r=e.children(t),o=e.node(t);if(r.length&&Hi.forEach(r,n),Hi.has(o,"minRank")){o.borderLeft=[],o.borderRight=[];for(var i=o.minRank,a=o.maxRank+1;i<a;++i)Da(e,"borderLeft","_bl",t,o,i),Da(e,"borderRight","_br",t,o,i)}}))};function Da(e,n,t,r,o,i){var a={width:0,height:0,rank:i,borderType:n},u=o[n][i-1],c=ra.addDummyNode(e,"border",a,t);o[n][i]=c,e.setParent(c,r),u&&e.setEdge(u,c,{weight:1})}var Pa={adjust:function(e){var n=e.graph().rankdir.toLowerCase();"lr"!==n&&"rl"!==n||za(e)},undo:function(e){var n=e.graph().rankdir.toLowerCase();"bt"!==n&&"rl"!==n||function(e){Hi.forEach(e.nodes(),(function(n){Ua(e.node(n))})),Hi.forEach(e.edges(),(function(n){var t=e.edge(n);Hi.forEach(t.points,Ua),Hi.has(t,"y")&&Ua(t)}))}(e);"lr"!==n&&"rl"!==n||(!function(e){Hi.forEach(e.nodes(),(function(n){Va(e.node(n))})),Hi.forEach(e.edges(),(function(n){var t=e.edge(n);Hi.forEach(t.points,Va),Hi.has(t,"x")&&Va(t)}))}(e),za(e))}};function za(e){Hi.forEach(e.nodes(),(function(n){Fa(e.node(n))})),Hi.forEach(e.edges(),(function(n){Fa(e.edge(n))}))}function Fa(e){var n=e.width;e.width=e.height,e.height=n}function Ua(e){e.y=-e.y}function Va(e){var n=e.x;e.x=e.y,e.y=n}var $a=function(e){var n={},t=Hi.filter(e.nodes(),(function(n){return!e.children(n).length})),r=Hi.max(Hi.map(t,(function(n){return e.node(n).rank}))),o=Hi.map(Hi.range(r+1),(function(){return[]}));function i(t){if(!Hi.has(n,t)){n[t]=!0;var r=e.node(t);o[r.rank].push(t),Hi.forEach(e.successors(t),i)}}var a=Hi.sortBy(t,(function(n){return e.node(n).rank}));return Hi.forEach(a,i),o};var Ha=function(e,n){for(var t=0,r=1;r<n.length;++r)t+=Wa(e,n[r-1],n[r]);return t};function Wa(e,n,t){for(var r=Hi.zipObject(t,Hi.map(t,(function(e,n){return n}))),o=Hi.flatten(Hi.map(n,(function(n){return Hi.sortBy(Hi.map(e.outEdges(n),(function(n){return{pos:r[n.w],weight:e.edge(n).weight}})),"pos")})),!0),i=1;i<t.length;)i<<=1;var a=2*i-1;i-=1;var u=Hi.map(new Array(a),(function(){return 0})),c=0;return Hi.forEach(o.forEach((function(e){var n=e.pos+i;u[n]+=e.weight;for(var t=0;n>0;)n%2&&(t+=u[n+1]),u[n=n-1>>1]+=e.weight;c+=e.weight*t}))),c}var qa=function(e,n){return Hi.map(n,(function(n){var t=e.inEdges(n);if(t.length){var r=Hi.reduce(t,(function(n,t){var r=e.edge(t),o=e.node(t.v);return{sum:n.sum+r.weight*o.order,weight:n.weight+r.weight}}),{sum:0,weight:0});return{v:n,barycenter:r.sum/r.weight,weight:r.weight}}return{v:n}}))};var Ya=function(e,n){var t={};return Hi.forEach(e,(function(e,n){var r=t[e.v]={indegree:0,in:[],out:[],vs:[e.v],i:n};Hi.isUndefined(e.barycenter)||(r.barycenter=e.barycenter,r.weight=e.weight)})),Hi.forEach(n.edges(),(function(e){var n=t[e.v],r=t[e.w];Hi.isUndefined(n)||Hi.isUndefined(r)||(r.indegree++,n.out.push(t[e.w]))})),function(e){var n=[];function t(e){return function(n){n.merged||(Hi.isUndefined(n.barycenter)||Hi.isUndefined(e.barycenter)||n.barycenter>=e.barycenter)&&function(e,n){var t=0,r=0;e.weight&&(t+=e.barycenter*e.weight,r+=e.weight);n.weight&&(t+=n.barycenter*n.weight,r+=n.weight);e.vs=n.vs.concat(e.vs),e.barycenter=t/r,e.weight=r,e.i=Math.min(n.i,e.i),n.merged=!0}(e,n)}}function r(n){return function(t){t.in.push(n),0==--t.indegree&&e.push(t)}}for(;e.length;){var o=e.pop();n.push(o),Hi.forEach(o.in.reverse(),t(o)),Hi.forEach(o.out,r(o))}return Hi.map(Hi.filter(n,(function(e){return!e.merged})),(function(e){return Hi.pick(e,["vs","i","barycenter","weight"])}))}(Hi.filter(t,(function(e){return!e.indegree})))};var Ja=function(e,n){var t=ra.partition(e,(function(e){return Hi.has(e,"barycenter")})),r=t.lhs,o=Hi.sortBy(t.rhs,(function(e){return-e.i})),i=[],a=0,u=0,c=0;r.sort((s=!!n,function(e,n){return e.barycenter<n.barycenter?-1:e.barycenter>n.barycenter?1:s?n.i-e.i:e.i-n.i})),c=Xa(i,o,c),Hi.forEach(r,(function(e){c+=e.vs.length,i.push(e.vs),a+=e.barycenter*e.weight,u+=e.weight,c=Xa(i,o,c)}));var s;var d={vs:Hi.flatten(i,!0)};u&&(d.barycenter=a/u,d.weight=u);return d};function Xa(e,n,t){for(var r;n.length&&(r=Hi.last(n)).i<=t;)n.pop(),e.push(r.vs),t++;return t}var Ka=function e(n,t,r,o){var i=n.children(t),a=n.node(t),u=a?a.borderLeft:void 0,c=a?a.borderRight:void 0,s={};u&&(i=Hi.filter(i,(function(e){return e!==u&&e!==c})));var d=qa(n,i);Hi.forEach(d,(function(t){if(n.children(t.v).length){var i=e(n,t.v,r,o);s[t.v]=i,Hi.has(i,"barycenter")&&(a=t,u=i,Hi.isUndefined(a.barycenter)?(a.barycenter=u.barycenter,a.weight=u.weight):(a.barycenter=(a.barycenter*a.weight+u.barycenter*u.weight)/(a.weight+u.weight),a.weight+=u.weight))}var a,u}));var f=Ya(d,r);!function(e,n){Hi.forEach(e,(function(e){e.vs=Hi.flatten(e.vs.map((function(e){return n[e]?n[e].vs:e})),!0)}))}(f,s);var h=Ja(f,o);if(u&&(h.vs=Hi.flatten([u,h.vs,c],!0),n.predecessors(u).length)){var l=n.node(n.predecessors(u)[0]),v=n.node(n.predecessors(c)[0]);Hi.has(h,"barycenter")||(h.barycenter=0,h.weight=0),h.barycenter=(h.barycenter*h.weight+l.order+v.order)/(h.weight+2),h.weight+=2}return h};var Qa=Fo.Graph,Za=function(e,n,t){var r=function(e){var n;for(;e.hasNode(n=Hi.uniqueId("_root")););return n}(e),o=new Qa({compound:!0}).setGraph({root:r}).setDefaultNodeLabel((function(n){return e.node(n)}));return Hi.forEach(e.nodes(),(function(i){var a=e.node(i),u=e.parent(i);(a.rank===n||a.minRank<=n&&n<=a.maxRank)&&(o.setNode(i),o.setParent(i,u||r),Hi.forEach(e[t](i),(function(n){var t=n.v===i?n.w:n.v,r=o.edge(t,i),a=Hi.isUndefined(r)?0:r.weight;o.setEdge(t,i,{weight:e.edge(n).weight+a})})),Hi.has(a,"minRank")&&o.setNode(i,{borderLeft:a.borderLeft[n],borderRight:a.borderRight[n]}))})),o};var eu=function(e,n,t){var r,o={};Hi.forEach(t,(function(t){for(var i,a,u=e.parent(t);u;){if((i=e.parent(u))?(a=o[i],o[i]=u):(a=r,r=u),a&&a!==u)return void n.setEdge(a,u);u=i}}))};var nu=Fo.Graph,tu=function(e){var n=ra.maxRank(e),t=ru(e,Hi.range(1,n+1),"inEdges"),r=ru(e,Hi.range(n-1,-1,-1),"outEdges"),o=$a(e);iu(e,o);for(var i,a=Number.POSITIVE_INFINITY,u=0,c=0;c<4;++u,++c){ou(u%2?t:r,u%4>=2),o=ra.buildLayerMatrix(e);var s=Ha(e,o);s<a&&(c=0,i=Hi.cloneDeep(o),a=s)}iu(e,i)};function ru(e,n,t){return Hi.map(n,(function(n){return Za(e,n,t)}))}function ou(e,n){var t=new nu;Hi.forEach(e,(function(e){var r=e.graph().root,o=Ka(e,r,t,n);Hi.forEach(o.vs,(function(n,t){e.node(n).order=t})),eu(e,t,o.vs)}))}function iu(e,n){Hi.forEach(n,(function(n){Hi.forEach(n,(function(n,t){e.node(n).order=t}))}))}var au=Fo.Graph,uu=function(e){var n,t=ra.buildLayerMatrix(e),r=Hi.merge(cu(e,t),su(e,t)),o={};Hi.forEach(["u","d"],(function(i){n="u"===i?t:Hi.values(t).reverse(),Hi.forEach(["l","r"],(function(t){"r"===t&&(n=Hi.map(n,(function(e){return Hi.values(e).reverse()})));var a=("u"===i?e.predecessors:e.successors).bind(e),u=hu(e,n,r,a),c=lu(e,n,u.root,u.align,"r"===t);"r"===t&&(c=Hi.mapValues(c,(function(e){return-e}))),o[i+t]=c}))}));var i=vu(e,o);return pu(o,i),gu(o,e.graph().align)};function cu(e,n){var t={};return Hi.reduce(n,(function(n,r){var o=0,i=0,a=n.length,u=Hi.last(r);return Hi.forEach(r,(function(n,c){var s=function(e,n){if(e.node(n).dummy)return Hi.find(e.predecessors(n),(function(n){return e.node(n).dummy}))}(e,n),d=s?e.node(s).order:a;(s||n===u)&&(Hi.forEach(r.slice(i,c+1),(function(n){Hi.forEach(e.predecessors(n),(function(r){var i=e.node(r),a=i.order;!(a<o||d<a)||i.dummy&&e.node(n).dummy||du(t,r,n)}))})),i=c+1,o=d)})),r})),t}function su(e,n){var t={};function r(n,r,o,i,a){var u;Hi.forEach(Hi.range(r,o),(function(r){u=n[r],e.node(u).dummy&&Hi.forEach(e.predecessors(u),(function(n){var r=e.node(n);r.dummy&&(r.order<i||r.order>a)&&du(t,n,u)}))}))}return Hi.reduce(n,(function(n,t){var o,i=-1,a=0;return Hi.forEach(t,(function(u,c){if("border"===e.node(u).dummy){var s=e.predecessors(u);s.length&&(o=e.node(s[0]).order,r(t,a,c,i,o),a=c,i=o)}r(t,a,t.length,o,n.length)})),t})),t}function du(e,n,t){if(n>t){var r=n;n=t,t=r}var o=e[n];o||(e[n]=o={}),o[t]=!0}function fu(e,n,t){if(n>t){var r=n;n=t,t=r}return Hi.has(e[n],t)}function hu(e,n,t,r){var o={},i={},a={};return Hi.forEach(n,(function(e){Hi.forEach(e,(function(e,n){o[e]=e,i[e]=e,a[e]=n}))})),Hi.forEach(n,(function(e){var n=-1;Hi.forEach(e,(function(e){var u=r(e);if(u.length)for(var c=((u=Hi.sortBy(u,(function(e){return a[e]}))).length-1)/2,s=Math.floor(c),d=Math.ceil(c);s<=d;++s){var f=u[s];i[e]===e&&n<a[f]&&!fu(t,e,f)&&(i[f]=e,i[e]=o[e]=o[f],n=a[f])}}))})),{root:o,align:i}}function lu(e,n,t,r,o){var i={},a=function(e,n,t,r){var o=new au,i=e.graph(),a=function(e,n,t){return function(r,o,i){var a,u=r.node(o),c=r.node(i),s=0;if(s+=u.width/2,Hi.has(u,"labelpos"))switch(u.labelpos.toLowerCase()){case"l":a=-u.width/2;break;case"r":a=u.width/2}if(a&&(s+=t?a:-a),a=0,s+=(u.dummy?n:e)/2,s+=(c.dummy?n:e)/2,s+=c.width/2,Hi.has(c,"labelpos"))switch(c.labelpos.toLowerCase()){case"l":a=c.width/2;break;case"r":a=-c.width/2}return a&&(s+=t?a:-a),a=0,s}}(i.nodesep,i.edgesep,r);return Hi.forEach(n,(function(n){var r;Hi.forEach(n,(function(n){var i=t[n];if(o.setNode(i),r){var u=t[r],c=o.edge(u,i);o.setEdge(u,i,Math.max(a(e,n,r),c||0))}r=n}))})),o}(e,n,t,o),u=o?"borderLeft":"borderRight";function c(e,n){for(var t=a.nodes(),r=t.pop(),o={};r;)o[r]?e(r):(o[r]=!0,t.push(r),t=t.concat(n(r))),r=t.pop()}return c((function(e){i[e]=a.inEdges(e).reduce((function(e,n){return Math.max(e,i[n.v]+a.edge(n))}),0)}),a.predecessors.bind(a)),c((function(n){var t=a.outEdges(n).reduce((function(e,n){return Math.min(e,i[n.w]-a.edge(n))}),Number.POSITIVE_INFINITY),r=e.node(n);t!==Number.POSITIVE_INFINITY&&r.borderType!==u&&(i[n]=Math.max(i[n],t))}),a.successors.bind(a)),Hi.forEach(r,(function(e){i[e]=i[t[e]]})),i}function vu(e,n){return Hi.minBy(Hi.values(n),(function(n){var t=Number.NEGATIVE_INFINITY,r=Number.POSITIVE_INFINITY;return Hi.forIn(n,(function(n,o){var i=function(e,n){return e.node(n).width}(e,o)/2;t=Math.max(n+i,t),r=Math.min(n-i,r)})),t-r}))}function pu(e,n){var t=Hi.values(n),r=Hi.min(t),o=Hi.max(t);Hi.forEach(["u","d"],(function(t){Hi.forEach(["l","r"],(function(i){var a,u=t+i,c=e[u];if(c!==n){var s=Hi.values(c);(a="l"===i?r-Hi.min(s):o-Hi.max(s))&&(e[u]=Hi.mapValues(c,(function(e){return e+a})))}}))}))}function gu(e,n){return Hi.mapValues(e.ul,(function(t,r){if(n)return e[n.toLowerCase()][r];var o=Hi.sortBy(Hi.map(e,r));return(o[1]+o[2])/2}))}var yu=uu,bu=function(e){(function(e){var n=ra.buildLayerMatrix(e),t=e.graph().ranksep,r=0;Hi.forEach(n,(function(n){var o=Hi.max(Hi.map(n,(function(n){return e.node(n).height})));Hi.forEach(n,(function(n){e.node(n).y=r+o/2})),r+=o+t}))})(e=ra.asNonCompoundGraph(e)),Hi.forEach(yu(e),(function(n,t){e.node(t).x=n}))};var mu=ra.normalizeRanks,wu=ra.removeEmptyRanks,Eu=ra,_u=Fo.Graph,ju=function(e,n){var t=n&&n.debugTiming?Eu.time:Eu.notime;t("layout",(function(){var n=t("  buildLayoutGraph",(function(){return function(e){var n=new _u({multigraph:!0,compound:!0}),t=Bu(e.graph());return n.setGraph(Hi.merge({},Nu,Gu(t,xu),Hi.pick(t,Ou))),Hi.forEach(e.nodes(),(function(t){var r=Bu(e.node(t));n.setNode(t,Hi.defaults(Gu(r,ku),Iu)),n.setParent(t,e.parent(t))})),Hi.forEach(e.edges(),(function(t){var r=Bu(e.edge(t));n.setEdge(t,Hi.merge({},Mu,Gu(r,Su),Hi.pick(r,Cu)))})),n}(e)}));t("  runLayout",(function(){!function(e,n){n("    makeSpaceForEdgeLabels",(function(){!function(e){var n=e.graph();n.ranksep/=2,Hi.forEach(e.edges(),(function(t){var r=e.edge(t);r.minlen*=2,"c"!==r.labelpos.toLowerCase()&&("TB"===n.rankdir||"BT"===n.rankdir?r.width+=r.labeloffset:r.height+=r.labeloffset)}))}(e)})),n("    removeSelfEdges",(function(){!function(e){Hi.forEach(e.edges(),(function(n){if(n.v===n.w){var t=e.node(n.v);t.selfEdges||(t.selfEdges=[]),t.selfEdges.push({e:n,label:e.edge(n)}),e.removeEdge(n)}}))}(e)})),n("    acyclic",(function(){na.run(e)})),n("    nestingGraph.run",(function(){La.run(e)})),n("    rank",(function(){Ca(Eu.asNonCompoundGraph(e))})),n("    injectEdgeLabelProxies",(function(){!function(e){Hi.forEach(e.edges(),(function(n){var t=e.edge(n);if(t.width&&t.height){var r=e.node(n.v),o={rank:(e.node(n.w).rank-r.rank)/2+r.rank,e:n};Eu.addDummyNode(e,"edge-proxy",o,"_ep")}}))}(e)})),n("    removeEmptyRanks",(function(){wu(e)})),n("    nestingGraph.cleanup",(function(){La.cleanup(e)})),n("    normalizeRanks",(function(){mu(e)})),n("    assignRankMinMax",(function(){!function(e){var n=0;Hi.forEach(e.nodes(),(function(t){var r=e.node(t);r.borderTop&&(r.minRank=e.node(r.borderTop).rank,r.maxRank=e.node(r.borderBottom).rank,n=Hi.max(n,r.maxRank))})),e.graph().maxRank=n}(e)})),n("    removeEdgeLabelProxies",(function(){!function(e){Hi.forEach(e.nodes(),(function(n){var t=e.node(n);"edge-proxy"===t.dummy&&(e.edge(t.e).labelRank=t.rank,e.removeNode(n))}))}(e)})),n("    normalize.run",(function(){aa.run(e)})),n("    parentDummyChains",(function(){Aa(e)})),n("    addBorderSegments",(function(){Ta(e)})),n("    order",(function(){tu(e)})),n("    insertSelfEdges",(function(){!function(e){var n=Eu.buildLayerMatrix(e);Hi.forEach(n,(function(n){var t=0;Hi.forEach(n,(function(n,r){var o=e.node(n);o.order=r+t,Hi.forEach(o.selfEdges,(function(n){Eu.addDummyNode(e,"selfedge",{width:n.label.width,height:n.label.height,rank:o.rank,order:r+ ++t,e:n.e,label:n.label},"_se")})),delete o.selfEdges}))}))}(e)})),n("    adjustCoordinateSystem",(function(){Pa.adjust(e)})),n("    position",(function(){bu(e)})),n("    positionSelfEdges",(function(){!function(e){Hi.forEach(e.nodes(),(function(n){var t=e.node(n);if("selfedge"===t.dummy){var r=e.node(t.e.v),o=r.x+r.width/2,i=r.y,a=t.x-o,u=r.height/2;e.setEdge(t.e,t.label),e.removeNode(n),t.label.points=[{x:o+2*a/3,y:i-u},{x:o+5*a/6,y:i-u},{x:o+a,y:i},{x:o+5*a/6,y:i+u},{x:o+2*a/3,y:i+u}],t.label.x=t.x,t.label.y=t.y}}))}(e)})),n("    removeBorderNodes",(function(){!function(e){Hi.forEach(e.nodes(),(function(n){if(e.children(n).length){var t=e.node(n),r=e.node(t.borderTop),o=e.node(t.borderBottom),i=e.node(Hi.last(t.borderLeft)),a=e.node(Hi.last(t.borderRight));t.width=Math.abs(a.x-i.x),t.height=Math.abs(o.y-r.y),t.x=i.x+t.width/2,t.y=r.y+t.height/2}})),Hi.forEach(e.nodes(),(function(n){"border"===e.node(n).dummy&&e.removeNode(n)}))}(e)})),n("    normalize.undo",(function(){aa.undo(e)})),n("    fixupEdgeLabelCoords",(function(){!function(e){Hi.forEach(e.edges(),(function(n){var t=e.edge(n);if(Hi.has(t,"x"))switch("l"!==t.labelpos&&"r"!==t.labelpos||(t.width-=t.labeloffset),t.labelpos){case"l":t.x-=t.width/2+t.labeloffset;break;case"r":t.x+=t.width/2+t.labeloffset}}))}(e)})),n("    undoCoordinateSystem",(function(){Pa.undo(e)})),n("    translateGraph",(function(){!function(e){var n=Number.POSITIVE_INFINITY,t=0,r=Number.POSITIVE_INFINITY,o=0,i=e.graph(),a=i.marginx||0,u=i.marginy||0;function c(e){var i=e.x,a=e.y,u=e.width,c=e.height;n=Math.min(n,i-u/2),t=Math.max(t,i+u/2),r=Math.min(r,a-c/2),o=Math.max(o,a+c/2)}Hi.forEach(e.nodes(),(function(n){c(e.node(n))})),Hi.forEach(e.edges(),(function(n){var t=e.edge(n);Hi.has(t,"x")&&c(t)})),n-=a,r-=u,Hi.forEach(e.nodes(),(function(t){var o=e.node(t);o.x-=n,o.y-=r})),Hi.forEach(e.edges(),(function(t){var o=e.edge(t);Hi.forEach(o.points,(function(e){e.x-=n,e.y-=r})),Hi.has(o,"x")&&(o.x-=n),Hi.has(o,"y")&&(o.y-=r)})),i.width=t-n+a,i.height=o-r+u}(e)})),n("    assignNodeIntersects",(function(){!function(e){Hi.forEach(e.edges(),(function(n){var t,r,o=e.edge(n),i=e.node(n.v),a=e.node(n.w);o.points?(t=o.points[0],r=o.points[o.points.length-1]):(o.points=[],t=a,r=i),o.points.unshift(Eu.intersectRect(i,t)),o.points.push(Eu.intersectRect(a,r))}))}(e)})),n("    reversePoints",(function(){!function(e){Hi.forEach(e.edges(),(function(n){var t=e.edge(n);t.reversed&&t.points.reverse()}))}(e)})),n("    acyclic.undo",(function(){na.undo(e)}))}(n,t)})),t("  updateInputGraph",(function(){!function(e,n){Hi.forEach(e.nodes(),(function(t){var r=e.node(t),o=n.node(t);r&&(r.x=o.x,r.y=o.y,n.children(t).length&&(r.width=o.width,r.height=o.height))})),Hi.forEach(e.edges(),(function(t){var r=e.edge(t),o=n.edge(t);r.points=o.points,Hi.has(o,"x")&&(r.x=o.x,r.y=o.y)})),e.graph().width=n.graph().width,e.graph().height=n.graph().height}(e,n)}))}))};var xu=["nodesep","edgesep","ranksep","marginx","marginy"],Nu={ranksep:50,edgesep:20,nodesep:50,rankdir:"tb"},Ou=["acyclicer","ranker","rankdir","align"],ku=["width","height"],Iu={width:0,height:0},Su=["minlen","weight","width","height","labeloffset"],Mu={minlen:1,weight:1,width:0,height:0,labeloffset:10,labelpos:"r"},Cu=["labelpos"];function Gu(e,n){return Hi.mapValues(Hi.pick(e,n),Number)}function Bu(e){var n={};return Hi.forEach(e,(function(e,t){n[t.toLowerCase()]=e})),n}var Au=Fo.Graph;var Lu={graphlib:Fo,layout:ju,debug:{debugOrdering:function(e){var n=ra.buildLayerMatrix(e),t=new Au({compound:!0,multigraph:!0}).setGraph({});return Hi.forEach(e.nodes(),(function(n){t.setNode(n,{label:n}),t.setParent(n,"layer"+e.node(n).rank)})),Hi.forEach(e.edges(),(function(e){t.setEdge(e.v,e.w,{},e.name)})),Hi.forEach(n,(function(e,n){var r="layer"+n;t.setNode(r,{rank:"same"}),Hi.reduce(e,(function(e,n){return t.setEdge(e,n,{style:"invis"}),n}))})),t}},util:{time:ra.time,notime:ra.notime},version:"0.8.5"},Ru=Lu.graphlib,Tu=Lu.layout;class Du{constructor(e){this.cardinality=1,this.include=a.UNSPECIFIED,this.isGroupNode=!1,this.parentNode=null,this.type=i.NODE,this.name=e.name,this.attr=e.attr||{},this.inputs=e.inputs,this.path=e.path||[],this.width=e.width,this.height=e.height}}class Pu{constructor(){this.nodes={},this.edges=[],this.nodes={},this.edges=[]}}function zu(e){const n=new Pu;return e.nodes.map((e=>new Du(e))).forEach((e=>{n.nodes[e.name]=e,e.inputs.forEach((t=>{!function(e,n,t){t.name!==n.name&&e.edges.push(Object.assign(Object.assign({},t.attr),{v:t.name,w:n.name}))}(n,e,t)}))})),n}class Fu{constructor(e,n={}){this.attr=null,this.bridgeGraph=null,this.cardinality=0,this.depth=1,this.include=a.UNSPECIFIED,this.isGroupNode=!0,this.parentNode=null,this.type=i.META,this.path=[],this.name=e,this.metaGraph=Hu(e,u.META,n)}getFirstChild(){return this.metaGraph.node(this.metaGraph.nodes()[0])}getChildren(){return this.metaGraph.nodes().map((e=>this.metaGraph.node(e)))}leaves(){let e,n=[],t=[this];for(;t.length;){let r=t.shift();r.isGroupNode?(e=r.metaGraph,e.nodes().forEach((n=>t.push(e.node(n))))):n.push(r.name)}return n}}class Uu{constructor(e,n){this.v=e,this.w=n,this.baseEdgeList=[],this.inbound=null,this.name=null}addBaseEdge(e,n){this.baseEdgeList.push(e)}}function Vu(e,n={}){return new Fu(e,n)}function $u(e,n){return new Uu(e,n)}function Hu(e,n,t){const r=t||{},o=new Ru.Graph(r);return o.setGraph({name:e,rankdir:r.rankdir,type:n,align:r.align}),o}class Wu{constructor(e={}){this.graphOptions=e,this.index={},this.graphOptions.compound=!0,this.root=Vu(r,this.graphOptions),this.index[r]=this.root}getNodeMap(){return this.index}node(e){return this.index[e]}setNode(e,n){this.index[e]=n}getBridgeGraph(e){const n=this.index[e];if(!n)throw Error("Could not find node in hierarchy: "+e);if(!("metaGraph"in n))return null;const t=n;if(t.bridgeGraph)return t.bridgeGraph;const r=Hu(o,u.BRIDGE,this.graphOptions);if(t.bridgeGraph=r,!n.parentNode||!("metaGraph"in n.parentNode))return r;const i=n.parentNode;return[i.metaGraph,this.getBridgeGraph(i.name)].forEach((n=>{n.edges().filter((n=>n.v===e||n.w===e)).forEach((t=>{const o=t.w===e;n.edge(t).baseEdgeList.forEach((n=>{const[i,a]=o?[n.w,t.v]:[n.v,t.w],u=this.getChildName(e,i),c={v:o?a:u,w:o?u:a};let s=r.edge(c);s||(s=$u(c.v,c.w),s.inbound=o,r.setEdge(c.v,c.w,s)),s.addBaseEdge(n,this)}))}))})),r}getChildName(e,n){let t=this.index[n];for(;t;){if(t.parentNode&&t.parentNode.name===e)return t.name;t=t.parentNode}throw Error("Could not find immediate child for descendant: "+n)}getPredecessors(e){const n=this.index[e];if(!n)throw Error("Could not find node with name: "+e);return this.getOneWayEdges(n,!0)}getSuccessors(e){const n=this.index[e];if(!n)throw Error("Could not find node with name: "+e);return this.getOneWayEdges(n,!1)}getOneWayEdges(e,n){const t=[];if(!e.parentNode||!e.parentNode.isGroupNode)return t;const r=e.parentNode,o=r.metaGraph,i=this.getBridgeGraph(r.name);return Yu(o,e,n,t),Yu(i,e,n,t),t}}function qu(e,n){const{rankDirection:t,align:r}=n,o=new Wu({rankdir:t,align:r});return function(e,n){Object.keys(n.nodes).forEach((t=>{const r=n.nodes[t],o=r.path;let i=e.root;i.depth=Math.max(o.length,i.depth);for(let n=0;n<o.length&&(i.depth=Math.max(i.depth,o.length-n),i.cardinality+=r.cardinality,n!==o.length-1);n++){const t=o[n];let a=e.node(t);a||(a=Vu(t,e.graphOptions),a.path=r.path.slice(0,n+1),a.parentNode=i,e.setNode(t,a),i.metaGraph.setNode(t,a)),i=a}e.setNode(r.name,r),r.parentNode=i,i.metaGraph.setNode(r.name,r)}))}(o,e),function(e,n){const t=e.getNodeMap();let r=[],o=[];const i=(e,n)=>{let t=0;for(;e;)n[t++]=e.name,e=e.parentNode;return t-1};n.edges.forEach((a=>{r=[],o=[];let u=i(n.nodes[a.v],r),c=i(n.nodes[a.w],o);for(;r[u]===o[c];)if(u--,c--,u<0||c<0)throw Error("No difference found between ancestor paths.");const s=t[r[u+1]],d=r[u],f=o[c];let h=s.metaGraph.edge(d,f);h||(h=$u(d,f),s.metaGraph.setEdge(d,f,h)),h.addBaseEdge(a,e)}))}(o,e),o}function Yu(e,n,t,r){(t?e.inEdges(n.name):e.outEdges(n.name)).forEach((n=>{const t=e.edge(n);r.push(t)}))}class Ju{constructor(e){this.hierarchy=e,this.index={},this.hasSubHierarchy={},this.root=new Qu(this.hierarchy.root,this.hierarchy.graphOptions),this.index[e.root.name]=this.root,this.buildSubHierarchy(e.root.name),this.root.expanded=!0}getRenderInfoNodes(){return Object.values(this.index)}getSubHierarchy(){return this.hasSubHierarchy}buildSubHierarchy(e){if(e in this.hasSubHierarchy)return;this.hasSubHierarchy[e]=!0;const n=this.index[e];if(n.node.type!==i.META)return;const t=n,r=t.node.metaGraph,o=t.coreGraph;r.nodes().forEach((e=>{const n=this.getOrCreateRenderNodeByName(e);o.setNode(e,n)})),r.edges().forEach((e=>{const n=r.edge(e),t=new Ku(n);o.setEdge(e.v,e.w,t)}));const u=t.node.parentNode;if(!u)return;const c=this.getRenderNodeByName(u.name),s=(e,...n)=>n.concat([e?"IN":"OUT"]).join("~~"),d=this.hierarchy.getBridgeGraph(e);d.edges().forEach((n=>{const t=d.edge(n),f=!!r.node(n.w),[h,l]=f?[n.w,n.v]:[n.v,n.w],v=n=>{const t=f?{v:n,w:e}:{v:e,w:n};return c.coreGraph.edge(t)};let p=v(l);p||(p=v(s(f,l,u.name)));const g=s(f,e),y=s(f,l,e);let b=o.node(y);if(!b){let e=o.node(g);if(!e){const n={name:g,type:i.BRIDGE,isGroupNode:!1,cardinality:0,parentNode:null,include:a.UNSPECIFIED,inbound:f,attr:{}};e=new Xu(n),this.index[g]=e,o.setNode(g,e)}const n={name:y,type:i.BRIDGE,isGroupNode:!1,cardinality:1,parentNode:null,include:a.UNSPECIFIED,inbound:f,attr:{}};b=new Xu(n),this.index[y]=b,o.setNode(y,b),o.setParent(y,g),e.node.cardinality++}const m=new Ku(t);m.adjoiningMetaEdge=p,f?o.setEdge(y,h,m):o.setEdge(h,y,m)}))}getOrCreateRenderNodeByName(e){if(!e)return null;if(e in this.index)return this.index[e];const n=this.getNodeByName(e);return n?(this.index[e]=n.isGroupNode?new Qu(n,this.hierarchy.graphOptions):new Xu(n),this.index[e]):null}getRenderNodeByName(e){return this.index[e]}getNodeByName(e){return this.hierarchy.node(e)}}class Xu{constructor(e){this.node=e,this.expanded=!1,this.x=0,this.y=0,this.coreBox={width:0,height:0},this.outboxWidth=0,this.labelOffset=0,this.radius=0,this.labelHeight=0,this.paddingTop=0,this.paddingLeft=0,this.paddingRight=0,this.paddingBottom=0,this.width=e.width||0,this.height=e.height||0,this.displayName=e.name,this.attr=e.attr}}class Ku{constructor(e){this.metaEdge=e,this.adjoiningMetaEdge=null,this.weight=1,this.points=[]}}class Qu extends Xu{constructor(e,n){super(e);const t=e.metaGraph.graph();n.compound=!0,this.coreGraph=Hu(t.name,u.CORE,n)}}function Zu(e,t){e.node.isGroupNode&&function(e,t){const r=n(t);e.coreGraph.nodes().map((n=>e.coreGraph.node(n))).forEach((e=>{var n,o,a,u,c,s;const{height:d,width:f}=e;switch(e.node.type){case i.NODE:Object.assign(e,r.nodeSize.node),e.height=d||r.nodeSize.node.height,e.width=f||r.nodeSize.node.width;break;case i.BRIDGE:Object.assign(e,r.nodeSize.bridge);break;case i.META:if(e.expanded){Zu(e,t)}else Object.assign(e,r.nodeSize.meta),e.height=r.nodeSize.meta.height,e.width=r.nodeSize.meta.width;break;default:throw Error("Unrecognized node type: "+e.node.type)}if(!e.expanded){const r=e.attr;!function(e,n=!1){if(e.coreBox.width=e.width,e.coreBox.height=e.height,!n){const n=`${e.displayName}`.length,t=3;e.width=Math.max(e.coreBox.width,n*t)}}(e,t&&(0===e.node.type&&!!(null===(o=null===(n=null==t?void 0:t.nodeSize)||void 0===n?void 0:n.meta)||void 0===o?void 0:o.width)||1===e.node.type&&(!!(null===(u=null===(a=null==t?void 0:t.nodeSize)||void 0===a?void 0:a.node)||void 0===u?void 0:u.width)||!!r.width)||2===e.node.type&&!!(null===(s=null===(c=null==t?void 0:t.nodeSize)||void 0===c?void 0:c.bridge)||void 0===s?void 0:s.width)))}}))}(e,t),e.node.type===i.META&&function(e,t){const r=n(t),o=r.subScene.meta;Object.assign(e,o);const{nodeSep:a,rankSep:u,edgeSep:c,align:s}=r.graph.meta,d={nodesep:a,ranksep:u,edgesep:c,align:s};Object.assign(e.coreBox,function(e,n){const{ranksep:t,nodesep:r,edgesep:o,align:a}=n;Object.assign(e.graph(),{ranksep:t,nodesep:r,edgesep:o,align:a});const u=[];if(e.nodes().forEach((n=>{e.node(n).node.type!==i.BRIDGE&&u.push(n)})),!u.length)return{width:0,height:0};Tu(e);let c=1/0,s=1/0,d=-1/0,f=-1/0;return u.forEach((n=>{const t=e.node(n),r=.5*t.width,o=t.x-r,i=t.x+r;c=o<c?o:c,d=i>d?i:d;const a=.5*t.height,u=t.y-a,h=t.y+a;s=u<s?u:s,f=h>f?h:f})),e.edges().forEach((n=>{const t=e.edge(n),r=e.node(t.metaEdge.v),o=e.node(t.metaEdge.w);if(3===t.points.length&&function(e){let n=ec(e[0],e[1]);for(let t=1;t<e.length-1;t++){const r=ec(e[t],e[t+1]);if(Math.abs(r-n)>1)return!1;n=r}return!0}(t.points)){if(null!=r){const e=r.expanded?r.x:nc(r);t.points[0].x=e}if(null!=o){const e=o.expanded?o.x:nc(o);t.points[2].x=e}t.points=[t.points[0],t.points[1]]}const i=t.points[t.points.length-2];null!=o&&(t.points[t.points.length-1]=tc(i,o));const a=t.points[1];null!=r&&(t.points[0]=tc(a,r)),t.points.forEach((e=>{c=e.x<c?e.x:c,d=e.x>d?e.x:d,s=e.y<s?e.y:s,f=e.y>f?e.y:f}))})),e.nodes().forEach((n=>{const t=e.node(n);t.x-=c,t.y-=s})),e.edges().forEach((n=>{e.edge(n).points.forEach((e=>{e.x-=c,e.y-=s}))})),{width:d-c,height:f-s}}(e.coreGraph,d));let f=0;e.coreGraph.nodeCount()>0&&f++;const h=f<=1?0:f;e.coreBox.width+=h+h,e.coreBox.height=o.labelHeight+e.coreBox.height,e.width=e.coreBox.width+o.paddingLeft+o.paddingRight,e.height=e.paddingTop+e.coreBox.height+e.paddingBottom}(e,t)}function ec(e,n){const t=n.x-e.x,r=n.y-e.y;return 180*Math.atan(r/t)/Math.PI}function nc(e){if(e.expanded)return e.x;return e.x-e.width/2+0+e.coreBox.width/2}function tc(e,n){const t=n.expanded?n.x:nc(n),r=n.y,o=e.x-t,i=e.y-r;let a,u,c=n.expanded?n.width:n.coreBox.width,s=n.expanded?n.height:n.coreBox.height;return Math.abs(i)*c/2>Math.abs(o)*s/2?(i<0&&(s=-s),a=0===i?0:s/2*o/i,u=s/2):(o<0&&(c=-c),a=c/2,u=0===o?0:c/2*i/o),{x:t+a,y:r+u}}function rc(n,t,r){var o,i,a,u;const c=n.nodes.filter(((e,n,t)=>t.findIndex((n=>n.id===e.id))!==n)).map((e=>e.id));if(c.length)throw new Error(`Duplicated ids found: ${c.join(", ")}`);const s=function(e){const n={nodes:[]},t=e.compound,r=Object.keys(t||{}),o=new Map,i=(e,n=[])=>{if(o.has(e))return o.get(e);for(let o=0;o<r.length;o++){let a=r[o];if(t&&-1!==t[a].indexOf(e))return n.unshift(a),i(a,n)}return 0===n.length&&o.set(e,n),n},a=n=>e.edges.filter((e=>e.w===n)).map((e=>({name:e.v})));return e.nodes.forEach((e=>{const t=e.id,r=[...i(t),t];let o=a(t);n.nodes.push({name:t,path:r,inputs:o,width:e.width,height:e.height,attr:Object.assign({},e)})})),n}(n),d=function(e,n){const t=(e,n)=>{for(let t of n.values())if(t.includes(e))return!0;return!1},r=(e,n=[])=>{if(0===Object.keys(e).length)return[...new Set(n)];const o=new Map(Object.keys(e).map((n=>[n,e[n]]))),i={};for(let[e,r]of o)t(e,o)?i[e]=r:n=n.concat(e,r);return r(i,n)};return r(e).filter((e=>n.includes(e)))}(n.compound||{},(null==t?void 0:t.expanded)||[]),f=function(e,n){return function(e){return new Ju(e)}(qu(zu(e),n))}(s,{rankDirection:(null===(i=null===(o=null==r?void 0:r.graph)||void 0===o?void 0:o.meta)||void 0===i?void 0:i.rankDir)||(null==t?void 0:t.rankDirection)||e.graph.meta.rankDir,align:(null===(u=null===(a=null==r?void 0:r.graph)||void 0===a?void 0:a.meta)||void 0===u?void 0:u.align)||e.graph.meta.align});return function(e,n){n.forEach((n=>{const t=e.getRenderInfoNodes().find((e=>e.displayName===n));let r=t&&t.node&&t.node.name||"";const o=e.getRenderNodeByName(r);if(!o)throw new Error(`No nodes found: ${r}`);o.expanded=!0,e.buildSubHierarchy(r)}))}(f,d),Zu(f.root,r),ac(f.root)}function oc(e,n=!1){const t=JSON.parse(JSON.stringify(e)),o={nodes:[t],edges:[...t.edges]};return t.nodes.forEach((function e(n){(0===n.type||1===n.type)&&o.nodes.push(n),0===n.type&&(o.edges=o.edges.concat(n.edges)),Array.isArray(n.nodes)&&n.nodes.forEach(e)})),n&&o.nodes.forEach((e=>{const n=o.nodes.find((n=>n.id===e.parentNodeName));if(n){const t=n.x-n.width/2+n.paddingLeft,o=n.y-n.height/2+n.labelHeight+n.paddingTop;n.id!==r&&(e.x+=t,e.y+=o),0===e.type&&e.edges.forEach((n=>{n.points.forEach((n=>{n.x+=e.x-e.width/2+e.paddingLeft,n.y+=e.y-e.height/2+e.labelHeight+e.paddingTop}))}))}})),o}function ic(e,n,t,o){var i,a;let u=[];const c=(null===(i=t.find((n=>n.id===e)))||void 0===i?void 0:i.path)||[],s=(null===(a=t.find((e=>e.id===n)))||void 0===a?void 0:a.path)||[],d=[r,...c].slice(0,c.length).reverse(),f=[r,...s].slice(0,s.length);return d.forEach((r=>{const i=t.find((e=>e.id===r));u=u.concat(i.edges.filter((t=>t.baseEdgeList.some((t=>t.v===((null==o?void 0:o.v)||e)&&t.w===((null==o?void 0:o.w)||n))))))})),f.filter((e=>!d.includes(e))).forEach((r=>{const i=t.find((e=>e.id===r));u=u.concat(i.edges.filter((t=>t.baseEdgeList.some((t=>t.v===((null==o?void 0:o.v)||e)&&t.w===((null==o?void 0:o.w)||n))))))})),u}function ac(e){const n=e.coreGraph.nodes().map((n=>e.coreGraph.node(n)));return Object.assign(Object.assign({},uc(e)),{expanded:e.expanded,nodes:e.expanded?(t=n,t.map((e=>e.node.type===i.META?ac(e):uc(e)))):[],edges:e.expanded?cc(e):[]});var t}function uc(e){return{id:e.node.name,name:e.node.name,type:e.node.type,cardinality:e.node.cardinality,attr:e.attr,parentNodeName:e.node.parentNode?e.node.parentNode.name:null,coreBox:Object.assign({},e.coreBox),x:e.x,y:e.y,width:e.width,height:e.height,radius:e.radius,labelHeight:e.labelHeight,labelOffset:e.labelOffset,outboxWidth:e.outboxWidth,paddingLeft:e.paddingLeft,paddingTop:e.paddingTop,paddingRight:e.paddingRight,paddingBottom:e.paddingBottom,path:e.node.path}}function cc(e){return e.coreGraph.edges().map((n=>({renderInfoEdge:e.coreGraph.edge(n),edge:n}))).filter((({renderInfoEdge:e})=>e.metaEdge)).map((({edge:n,renderInfoEdge:t})=>{const r=function(e,n){const t=n.points.map((e=>Object.assign({},e)));if(n.adjoiningMetaEdge){const r=n.adjoiningMetaEdge.points,o=n.metaEdge.inbound,i=o?r[r.length-1]:r[0],a=t[o?0:t.length-1],u=e.x-e.width/2,c=e.y-e.height/2,s=i.x-u,d=i.y-c,f=-e.paddingLeft,h=-(e.paddingTop+e.labelHeight);a.x=s+f,a.y=d+h}return t}(e,t);return{adjoiningEdge:t.adjoiningMetaEdge?{w:t.adjoiningMetaEdge.metaEdge.w,v:t.adjoiningMetaEdge.metaEdge.v}:null,inbound:t.metaEdge.inbound,w:n.w,v:n.v,points:r,weight:t.weight,baseEdgeList:t.metaEdge.baseEdgeList,parentNodeName:e.node.name}}))}
//# sourceMappingURL=dagre-compound.es5.js.map


/***/ }),

/***/ "./node_modules/is-any-array/lib-esm/index.js":
/*!****************************************************!*\
  !*** ./node_modules/is-any-array/lib-esm/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isAnyArray: () => (/* binding */ isAnyArray)
/* harmony export */ });
// eslint-disable-next-line @typescript-eslint/unbound-method
const toString = Object.prototype.toString;
/**
 * Checks if an object is an instance of an Array (array or typed array, except those that contain bigint values).
 *
 * @param value - Object to check.
 * @returns True if the object is an array or a typed array.
 */
function isAnyArray(value) {
    const tag = toString.call(value);
    return tag.endsWith('Array]') && !tag.includes('Big');
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/lodash/_Symbol.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_Symbol.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ "./node_modules/lodash/_baseGetTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseGetTag.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    getRawTag = __webpack_require__(/*! ./_getRawTag */ "./node_modules/lodash/_getRawTag.js"),
    objectToString = __webpack_require__(/*! ./_objectToString */ "./node_modules/lodash/_objectToString.js");

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ "./node_modules/lodash/_baseIsTypedArray.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_baseIsTypedArray.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),

/***/ "./node_modules/lodash/_baseUnary.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseUnary.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),

/***/ "./node_modules/lodash/_freeGlobal.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_freeGlobal.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

module.exports = freeGlobal;


/***/ }),

/***/ "./node_modules/lodash/_getPrototype.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getPrototype.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),

/***/ "./node_modules/lodash/_getRawTag.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getRawTag.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ "./node_modules/lodash/_nodeUtil.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_nodeUtil.js ***!
  \******************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;


/***/ }),

/***/ "./node_modules/lodash/_objectToString.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_objectToString.js ***!
  \************************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ "./node_modules/lodash/_overArg.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_overArg.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),

/***/ "./node_modules/lodash/_root.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_root.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ "./node_modules/lodash/isArray.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isArray.js ***!
  \****************************************/
/***/ ((module) => {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),

/***/ "./node_modules/lodash/isLength.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isLength.js ***!
  \*****************************************/
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),

/***/ "./node_modules/lodash/isNumber.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isNumber.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var numberTag = '[object Number]';

/**
 * Checks if `value` is classified as a `Number` primitive or object.
 *
 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
 * classified as numbers, use the `_.isFinite` method.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a number, else `false`.
 * @example
 *
 * _.isNumber(3);
 * // => true
 *
 * _.isNumber(Number.MIN_VALUE);
 * // => true
 *
 * _.isNumber(Infinity);
 * // => true
 *
 * _.isNumber('3');
 * // => false
 */
function isNumber(value) {
  return typeof value == 'number' ||
    (isObjectLike(value) && baseGetTag(value) == numberTag);
}

module.exports = isNumber;


/***/ }),

/***/ "./node_modules/lodash/isObjectLike.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isObjectLike.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ "./node_modules/lodash/isPlainObject.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/isPlainObject.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;


/***/ }),

/***/ "./node_modules/lodash/isTypedArray.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isTypedArray.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsTypedArray = __webpack_require__(/*! ./_baseIsTypedArray */ "./node_modules/lodash/_baseIsTypedArray.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),

/***/ "./node_modules/ml-array-max/lib-es6/index.js":
/*!****************************************************!*\
  !*** ./node_modules/ml-array-max/lib-es6/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ max)
/* harmony export */ });
/* harmony import */ var is_any_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-any-array */ "./node_modules/is-any-array/lib-esm/index.js");


function max(input) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!(0,is_any_array__WEBPACK_IMPORTED_MODULE_0__.isAnyArray)(input)) {
    throw new TypeError('input must be an array');
  }

  if (input.length === 0) {
    throw new TypeError('input must not be empty');
  }

  var _options$fromIndex = options.fromIndex,
      fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex,
      _options$toIndex = options.toIndex,
      toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;

  if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
    throw new Error('fromIndex must be a positive integer smaller than length');
  }

  if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
    throw new Error('toIndex must be an integer greater than fromIndex and at most equal to length');
  }

  var maxValue = input[fromIndex];

  for (var i = fromIndex + 1; i < toIndex; i++) {
    if (input[i] > maxValue) maxValue = input[i];
  }

  return maxValue;
}




/***/ }),

/***/ "./node_modules/ml-array-min/lib-es6/index.js":
/*!****************************************************!*\
  !*** ./node_modules/ml-array-min/lib-es6/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ min)
/* harmony export */ });
/* harmony import */ var is_any_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-any-array */ "./node_modules/is-any-array/lib-esm/index.js");


function min(input) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!(0,is_any_array__WEBPACK_IMPORTED_MODULE_0__.isAnyArray)(input)) {
    throw new TypeError('input must be an array');
  }

  if (input.length === 0) {
    throw new TypeError('input must not be empty');
  }

  var _options$fromIndex = options.fromIndex,
      fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex,
      _options$toIndex = options.toIndex,
      toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;

  if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
    throw new Error('fromIndex must be a positive integer smaller than length');
  }

  if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
    throw new Error('toIndex must be an integer greater than fromIndex and at most equal to length');
  }

  var minValue = input[fromIndex];

  for (var i = fromIndex + 1; i < toIndex; i++) {
    if (input[i] < minValue) minValue = input[i];
  }

  return minValue;
}




/***/ }),

/***/ "./node_modules/ml-array-rescale/lib-es6/index.js":
/*!********************************************************!*\
  !*** ./node_modules/ml-array-rescale/lib-es6/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rescale)
/* harmony export */ });
/* harmony import */ var is_any_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-any-array */ "./node_modules/is-any-array/lib-esm/index.js");
/* harmony import */ var ml_array_max__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ml-array-max */ "./node_modules/ml-array-max/lib-es6/index.js");
/* harmony import */ var ml_array_min__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ml-array-min */ "./node_modules/ml-array-min/lib-es6/index.js");




function rescale(input) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!(0,is_any_array__WEBPACK_IMPORTED_MODULE_0__.isAnyArray)(input)) {
    throw new TypeError('input must be an array');
  } else if (input.length === 0) {
    throw new TypeError('input must not be empty');
  }

  var output;

  if (options.output !== undefined) {
    if (!(0,is_any_array__WEBPACK_IMPORTED_MODULE_0__.isAnyArray)(options.output)) {
      throw new TypeError('output option must be an array if specified');
    }

    output = options.output;
  } else {
    output = new Array(input.length);
  }

  var currentMin = (0,ml_array_min__WEBPACK_IMPORTED_MODULE_2__["default"])(input);
  var currentMax = (0,ml_array_max__WEBPACK_IMPORTED_MODULE_1__["default"])(input);

  if (currentMin === currentMax) {
    throw new RangeError('minimum and maximum input values are equal. Cannot rescale a constant array');
  }

  var _options$min = options.min,
      minValue = _options$min === void 0 ? options.autoMinMax ? currentMin : 0 : _options$min,
      _options$max = options.max,
      maxValue = _options$max === void 0 ? options.autoMinMax ? currentMax : 1 : _options$max;

  if (minValue >= maxValue) {
    throw new RangeError('min option must be smaller than max option');
  }

  var factor = (maxValue - minValue) / (currentMax - currentMin);

  for (var i = 0; i < input.length; i++) {
    output[i] = (input[i] - currentMin) * factor + minValue;
  }

  return output;
}




/***/ }),

/***/ "./node_modules/ml-matrix/src/dc/svd.js":
/*!**********************************************!*\
  !*** ./node_modules/ml-matrix/src/dc/svd.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SingularValueDecomposition)
/* harmony export */ });
/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../matrix */ "./node_modules/ml-matrix/src/matrix.js");
/* harmony import */ var _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../wrap/WrapperMatrix2D */ "./node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./node_modules/ml-matrix/src/dc/util.js");





class SingularValueDecomposition {
  constructor(value, options = {}) {
    value = _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_0__["default"].checkMatrix(value);

    let m = value.rows;
    let n = value.columns;

    const {
      computeLeftSingularVectors = true,
      computeRightSingularVectors = true,
      autoTranspose = false,
    } = options;

    let wantu = Boolean(computeLeftSingularVectors);
    let wantv = Boolean(computeRightSingularVectors);

    let swapped = false;
    let a;
    if (m < n) {
      if (!autoTranspose) {
        a = value.clone();
        // eslint-disable-next-line no-console
        console.warn(
          'Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose',
        );
      } else {
        a = value.transpose();
        m = a.rows;
        n = a.columns;
        swapped = true;
        let aux = wantu;
        wantu = wantv;
        wantv = aux;
      }
    } else {
      a = value.clone();
    }

    let nu = Math.min(m, n);
    let ni = Math.min(m + 1, n);
    let s = new Float64Array(ni);
    let U = new _matrix__WEBPACK_IMPORTED_MODULE_1__["default"](m, nu);
    let V = new _matrix__WEBPACK_IMPORTED_MODULE_1__["default"](n, n);

    let e = new Float64Array(n);
    let work = new Float64Array(m);

    let si = new Float64Array(ni);
    for (let i = 0; i < ni; i++) si[i] = i;

    let nct = Math.min(m - 1, n);
    let nrt = Math.max(0, Math.min(n - 2, m));
    let mrc = Math.max(nct, nrt);

    for (let k = 0; k < mrc; k++) {
      if (k < nct) {
        s[k] = 0;
        for (let i = k; i < m; i++) {
          s[k] = (0,_util__WEBPACK_IMPORTED_MODULE_2__.hypotenuse)(s[k], a.get(i, k));
        }
        if (s[k] !== 0) {
          if (a.get(k, k) < 0) {
            s[k] = -s[k];
          }
          for (let i = k; i < m; i++) {
            a.set(i, k, a.get(i, k) / s[k]);
          }
          a.set(k, k, a.get(k, k) + 1);
        }
        s[k] = -s[k];
      }

      for (let j = k + 1; j < n; j++) {
        if (k < nct && s[k] !== 0) {
          let t = 0;
          for (let i = k; i < m; i++) {
            t += a.get(i, k) * a.get(i, j);
          }
          t = -t / a.get(k, k);
          for (let i = k; i < m; i++) {
            a.set(i, j, a.get(i, j) + t * a.get(i, k));
          }
        }
        e[j] = a.get(k, j);
      }

      if (wantu && k < nct) {
        for (let i = k; i < m; i++) {
          U.set(i, k, a.get(i, k));
        }
      }

      if (k < nrt) {
        e[k] = 0;
        for (let i = k + 1; i < n; i++) {
          e[k] = (0,_util__WEBPACK_IMPORTED_MODULE_2__.hypotenuse)(e[k], e[i]);
        }
        if (e[k] !== 0) {
          if (e[k + 1] < 0) {
            e[k] = 0 - e[k];
          }
          for (let i = k + 1; i < n; i++) {
            e[i] /= e[k];
          }
          e[k + 1] += 1;
        }
        e[k] = -e[k];
        if (k + 1 < m && e[k] !== 0) {
          for (let i = k + 1; i < m; i++) {
            work[i] = 0;
          }
          for (let i = k + 1; i < m; i++) {
            for (let j = k + 1; j < n; j++) {
              work[i] += e[j] * a.get(i, j);
            }
          }
          for (let j = k + 1; j < n; j++) {
            let t = -e[j] / e[k + 1];
            for (let i = k + 1; i < m; i++) {
              a.set(i, j, a.get(i, j) + t * work[i]);
            }
          }
        }
        if (wantv) {
          for (let i = k + 1; i < n; i++) {
            V.set(i, k, e[i]);
          }
        }
      }
    }

    let p = Math.min(n, m + 1);
    if (nct < n) {
      s[nct] = a.get(nct, nct);
    }
    if (m < p) {
      s[p - 1] = 0;
    }
    if (nrt + 1 < p) {
      e[nrt] = a.get(nrt, p - 1);
    }
    e[p - 1] = 0;

    if (wantu) {
      for (let j = nct; j < nu; j++) {
        for (let i = 0; i < m; i++) {
          U.set(i, j, 0);
        }
        U.set(j, j, 1);
      }
      for (let k = nct - 1; k >= 0; k--) {
        if (s[k] !== 0) {
          for (let j = k + 1; j < nu; j++) {
            let t = 0;
            for (let i = k; i < m; i++) {
              t += U.get(i, k) * U.get(i, j);
            }
            t = -t / U.get(k, k);
            for (let i = k; i < m; i++) {
              U.set(i, j, U.get(i, j) + t * U.get(i, k));
            }
          }
          for (let i = k; i < m; i++) {
            U.set(i, k, -U.get(i, k));
          }
          U.set(k, k, 1 + U.get(k, k));
          for (let i = 0; i < k - 1; i++) {
            U.set(i, k, 0);
          }
        } else {
          for (let i = 0; i < m; i++) {
            U.set(i, k, 0);
          }
          U.set(k, k, 1);
        }
      }
    }

    if (wantv) {
      for (let k = n - 1; k >= 0; k--) {
        if (k < nrt && e[k] !== 0) {
          for (let j = k + 1; j < n; j++) {
            let t = 0;
            for (let i = k + 1; i < n; i++) {
              t += V.get(i, k) * V.get(i, j);
            }
            t = -t / V.get(k + 1, k);
            for (let i = k + 1; i < n; i++) {
              V.set(i, j, V.get(i, j) + t * V.get(i, k));
            }
          }
        }
        for (let i = 0; i < n; i++) {
          V.set(i, k, 0);
        }
        V.set(k, k, 1);
      }
    }

    let pp = p - 1;
    let iter = 0;
    let eps = Number.EPSILON;
    while (p > 0) {
      let k, kase;
      for (k = p - 2; k >= -1; k--) {
        if (k === -1) {
          break;
        }
        const alpha =
          Number.MIN_VALUE + eps * Math.abs(s[k] + Math.abs(s[k + 1]));
        if (Math.abs(e[k]) <= alpha || Number.isNaN(e[k])) {
          e[k] = 0;
          break;
        }
      }
      if (k === p - 2) {
        kase = 4;
      } else {
        let ks;
        for (ks = p - 1; ks >= k; ks--) {
          if (ks === k) {
            break;
          }
          let t =
            (ks !== p ? Math.abs(e[ks]) : 0) +
            (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);
          if (Math.abs(s[ks]) <= eps * t) {
            s[ks] = 0;
            break;
          }
        }
        if (ks === k) {
          kase = 3;
        } else if (ks === p - 1) {
          kase = 1;
        } else {
          kase = 2;
          k = ks;
        }
      }

      k++;

      switch (kase) {
        case 1: {
          let f = e[p - 2];
          e[p - 2] = 0;
          for (let j = p - 2; j >= k; j--) {
            let t = (0,_util__WEBPACK_IMPORTED_MODULE_2__.hypotenuse)(s[j], f);
            let cs = s[j] / t;
            let sn = f / t;
            s[j] = t;
            if (j !== k) {
              f = -sn * e[j - 1];
              e[j - 1] = cs * e[j - 1];
            }
            if (wantv) {
              for (let i = 0; i < n; i++) {
                t = cs * V.get(i, j) + sn * V.get(i, p - 1);
                V.set(i, p - 1, -sn * V.get(i, j) + cs * V.get(i, p - 1));
                V.set(i, j, t);
              }
            }
          }
          break;
        }
        case 2: {
          let f = e[k - 1];
          e[k - 1] = 0;
          for (let j = k; j < p; j++) {
            let t = (0,_util__WEBPACK_IMPORTED_MODULE_2__.hypotenuse)(s[j], f);
            let cs = s[j] / t;
            let sn = f / t;
            s[j] = t;
            f = -sn * e[j];
            e[j] = cs * e[j];
            if (wantu) {
              for (let i = 0; i < m; i++) {
                t = cs * U.get(i, j) + sn * U.get(i, k - 1);
                U.set(i, k - 1, -sn * U.get(i, j) + cs * U.get(i, k - 1));
                U.set(i, j, t);
              }
            }
          }
          break;
        }
        case 3: {
          const scale = Math.max(
            Math.abs(s[p - 1]),
            Math.abs(s[p - 2]),
            Math.abs(e[p - 2]),
            Math.abs(s[k]),
            Math.abs(e[k]),
          );
          const sp = s[p - 1] / scale;
          const spm1 = s[p - 2] / scale;
          const epm1 = e[p - 2] / scale;
          const sk = s[k] / scale;
          const ek = e[k] / scale;
          const b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;
          const c = sp * epm1 * (sp * epm1);
          let shift = 0;
          if (b !== 0 || c !== 0) {
            if (b < 0) {
              shift = 0 - Math.sqrt(b * b + c);
            } else {
              shift = Math.sqrt(b * b + c);
            }
            shift = c / (b + shift);
          }
          let f = (sk + sp) * (sk - sp) + shift;
          let g = sk * ek;
          for (let j = k; j < p - 1; j++) {
            let t = (0,_util__WEBPACK_IMPORTED_MODULE_2__.hypotenuse)(f, g);
            if (t === 0) t = Number.MIN_VALUE;
            let cs = f / t;
            let sn = g / t;
            if (j !== k) {
              e[j - 1] = t;
            }
            f = cs * s[j] + sn * e[j];
            e[j] = cs * e[j] - sn * s[j];
            g = sn * s[j + 1];
            s[j + 1] = cs * s[j + 1];
            if (wantv) {
              for (let i = 0; i < n; i++) {
                t = cs * V.get(i, j) + sn * V.get(i, j + 1);
                V.set(i, j + 1, -sn * V.get(i, j) + cs * V.get(i, j + 1));
                V.set(i, j, t);
              }
            }
            t = (0,_util__WEBPACK_IMPORTED_MODULE_2__.hypotenuse)(f, g);
            if (t === 0) t = Number.MIN_VALUE;
            cs = f / t;
            sn = g / t;
            s[j] = t;
            f = cs * e[j] + sn * s[j + 1];
            s[j + 1] = -sn * e[j] + cs * s[j + 1];
            g = sn * e[j + 1];
            e[j + 1] = cs * e[j + 1];
            if (wantu && j < m - 1) {
              for (let i = 0; i < m; i++) {
                t = cs * U.get(i, j) + sn * U.get(i, j + 1);
                U.set(i, j + 1, -sn * U.get(i, j) + cs * U.get(i, j + 1));
                U.set(i, j, t);
              }
            }
          }
          e[p - 2] = f;
          iter = iter + 1;
          break;
        }
        case 4: {
          if (s[k] <= 0) {
            s[k] = s[k] < 0 ? -s[k] : 0;
            if (wantv) {
              for (let i = 0; i <= pp; i++) {
                V.set(i, k, -V.get(i, k));
              }
            }
          }
          while (k < pp) {
            if (s[k] >= s[k + 1]) {
              break;
            }
            let t = s[k];
            s[k] = s[k + 1];
            s[k + 1] = t;
            if (wantv && k < n - 1) {
              for (let i = 0; i < n; i++) {
                t = V.get(i, k + 1);
                V.set(i, k + 1, V.get(i, k));
                V.set(i, k, t);
              }
            }
            if (wantu && k < m - 1) {
              for (let i = 0; i < m; i++) {
                t = U.get(i, k + 1);
                U.set(i, k + 1, U.get(i, k));
                U.set(i, k, t);
              }
            }
            k++;
          }
          iter = 0;
          p--;
          break;
        }
        // no default
      }
    }

    if (swapped) {
      let tmp = V;
      V = U;
      U = tmp;
    }

    this.m = m;
    this.n = n;
    this.s = s;
    this.U = U;
    this.V = V;
  }

  solve(value) {
    let Y = value;
    let e = this.threshold;
    let scols = this.s.length;
    let Ls = _matrix__WEBPACK_IMPORTED_MODULE_1__["default"].zeros(scols, scols);

    for (let i = 0; i < scols; i++) {
      if (Math.abs(this.s[i]) <= e) {
        Ls.set(i, i, 0);
      } else {
        Ls.set(i, i, 1 / this.s[i]);
      }
    }

    let U = this.U;
    let V = this.rightSingularVectors;

    let VL = V.mmul(Ls);
    let vrows = V.rows;
    let urows = U.rows;
    let VLU = _matrix__WEBPACK_IMPORTED_MODULE_1__["default"].zeros(vrows, urows);

    for (let i = 0; i < vrows; i++) {
      for (let j = 0; j < urows; j++) {
        let sum = 0;
        for (let k = 0; k < scols; k++) {
          sum += VL.get(i, k) * U.get(j, k);
        }
        VLU.set(i, j, sum);
      }
    }

    return VLU.mmul(Y);
  }

  solveForDiagonal(value) {
    return this.solve(_matrix__WEBPACK_IMPORTED_MODULE_1__["default"].diag(value));
  }

  inverse() {
    let V = this.V;
    let e = this.threshold;
    let vrows = V.rows;
    let vcols = V.columns;
    let X = new _matrix__WEBPACK_IMPORTED_MODULE_1__["default"](vrows, this.s.length);

    for (let i = 0; i < vrows; i++) {
      for (let j = 0; j < vcols; j++) {
        if (Math.abs(this.s[j]) > e) {
          X.set(i, j, V.get(i, j) / this.s[j]);
        }
      }
    }

    let U = this.U;

    let urows = U.rows;
    let ucols = U.columns;
    let Y = new _matrix__WEBPACK_IMPORTED_MODULE_1__["default"](vrows, urows);

    for (let i = 0; i < vrows; i++) {
      for (let j = 0; j < urows; j++) {
        let sum = 0;
        for (let k = 0; k < ucols; k++) {
          sum += X.get(i, k) * U.get(j, k);
        }
        Y.set(i, j, sum);
      }
    }

    return Y;
  }

  get condition() {
    return this.s[0] / this.s[Math.min(this.m, this.n) - 1];
  }

  get norm2() {
    return this.s[0];
  }

  get rank() {
    let tol = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON;
    let r = 0;
    let s = this.s;
    for (let i = 0, ii = s.length; i < ii; i++) {
      if (s[i] > tol) {
        r++;
      }
    }
    return r;
  }

  get diagonal() {
    return Array.from(this.s);
  }

  get threshold() {
    return (Number.EPSILON / 2) * Math.max(this.m, this.n) * this.s[0];
  }

  get leftSingularVectors() {
    return this.U;
  }

  get rightSingularVectors() {
    return this.V;
  }

  get diagonalMatrix() {
    return _matrix__WEBPACK_IMPORTED_MODULE_1__["default"].diag(this.s);
  }
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/dc/util.js":
/*!***********************************************!*\
  !*** ./node_modules/ml-matrix/src/dc/util.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hypotenuse: () => (/* binding */ hypotenuse)
/* harmony export */ });
function hypotenuse(a, b) {
  let r = 0;
  if (Math.abs(a) > Math.abs(b)) {
    r = b / a;
    return Math.abs(a) * Math.sqrt(1 + r * r);
  }
  if (b !== 0) {
    r = a / b;
    return Math.abs(b) * Math.sqrt(1 + r * r);
  }
  return 0;
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/inspect.js":
/*!***********************************************!*\
  !*** ./node_modules/ml-matrix/src/inspect.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   inspectMatrix: () => (/* binding */ inspectMatrix),
/* harmony export */   inspectMatrixWithOptions: () => (/* binding */ inspectMatrixWithOptions)
/* harmony export */ });
const indent = ' '.repeat(2);
const indentData = ' '.repeat(4);

function inspectMatrix() {
  return inspectMatrixWithOptions(this);
}

function inspectMatrixWithOptions(matrix, options = {}) {
  const { maxRows = 15, maxColumns = 10, maxNumSize = 8 } = options;
  return `${matrix.constructor.name} {
${indent}[
${indentData}${inspectData(matrix, maxRows, maxColumns, maxNumSize)}
${indent}]
${indent}rows: ${matrix.rows}
${indent}columns: ${matrix.columns}
}`;
}

function inspectData(matrix, maxRows, maxColumns, maxNumSize) {
  const { rows, columns } = matrix;
  const maxI = Math.min(rows, maxRows);
  const maxJ = Math.min(columns, maxColumns);
  const result = [];
  for (let i = 0; i < maxI; i++) {
    let line = [];
    for (let j = 0; j < maxJ; j++) {
      line.push(formatNumber(matrix.get(i, j), maxNumSize));
    }
    result.push(`${line.join(' ')}`);
  }
  if (maxJ !== columns) {
    result[result.length - 1] += ` ... ${columns - maxColumns} more columns`;
  }
  if (maxI !== rows) {
    result.push(`... ${rows - maxRows} more rows`);
  }
  return result.join(`\n${indentData}`);
}

function formatNumber(num, maxNumSize) {
  const numStr = String(num);
  if (numStr.length <= maxNumSize) {
    return numStr.padEnd(maxNumSize, ' ');
  }
  const precise = num.toPrecision(maxNumSize - 2);
  if (precise.length <= maxNumSize) {
    return precise;
  }
  const exponential = num.toExponential(maxNumSize - 2);
  const eIndex = exponential.indexOf('e');
  const e = exponential.slice(eIndex);
  return exponential.slice(0, maxNumSize - e.length) + e;
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/mathOperations.js":
/*!******************************************************!*\
  !*** ./node_modules/ml-matrix/src/mathOperations.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   installMathOperations: () => (/* binding */ installMathOperations)
/* harmony export */ });
function installMathOperations(AbstractMatrix, Matrix) {
  AbstractMatrix.prototype.add = function add(value) {
    if (typeof value === 'number') return this.addS(value);
    return this.addM(value);
  };

  AbstractMatrix.prototype.addS = function addS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) + value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.addM = function addM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) + matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.add = function add(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.add(value);
  };

  AbstractMatrix.prototype.sub = function sub(value) {
    if (typeof value === 'number') return this.subS(value);
    return this.subM(value);
  };

  AbstractMatrix.prototype.subS = function subS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) - value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.subM = function subM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) - matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.sub = function sub(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.sub(value);
  };
  AbstractMatrix.prototype.subtract = AbstractMatrix.prototype.sub;
  AbstractMatrix.prototype.subtractS = AbstractMatrix.prototype.subS;
  AbstractMatrix.prototype.subtractM = AbstractMatrix.prototype.subM;
  AbstractMatrix.subtract = AbstractMatrix.sub;

  AbstractMatrix.prototype.mul = function mul(value) {
    if (typeof value === 'number') return this.mulS(value);
    return this.mulM(value);
  };

  AbstractMatrix.prototype.mulS = function mulS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) * value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.mulM = function mulM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) * matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.mul = function mul(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.mul(value);
  };
  AbstractMatrix.prototype.multiply = AbstractMatrix.prototype.mul;
  AbstractMatrix.prototype.multiplyS = AbstractMatrix.prototype.mulS;
  AbstractMatrix.prototype.multiplyM = AbstractMatrix.prototype.mulM;
  AbstractMatrix.multiply = AbstractMatrix.mul;

  AbstractMatrix.prototype.div = function div(value) {
    if (typeof value === 'number') return this.divS(value);
    return this.divM(value);
  };

  AbstractMatrix.prototype.divS = function divS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) / value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.divM = function divM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) / matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.div = function div(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.div(value);
  };
  AbstractMatrix.prototype.divide = AbstractMatrix.prototype.div;
  AbstractMatrix.prototype.divideS = AbstractMatrix.prototype.divS;
  AbstractMatrix.prototype.divideM = AbstractMatrix.prototype.divM;
  AbstractMatrix.divide = AbstractMatrix.div;

  AbstractMatrix.prototype.mod = function mod(value) {
    if (typeof value === 'number') return this.modS(value);
    return this.modM(value);
  };

  AbstractMatrix.prototype.modS = function modS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) % value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.modM = function modM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) % matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.mod = function mod(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.mod(value);
  };
  AbstractMatrix.prototype.modulus = AbstractMatrix.prototype.mod;
  AbstractMatrix.prototype.modulusS = AbstractMatrix.prototype.modS;
  AbstractMatrix.prototype.modulusM = AbstractMatrix.prototype.modM;
  AbstractMatrix.modulus = AbstractMatrix.mod;

  AbstractMatrix.prototype.and = function and(value) {
    if (typeof value === 'number') return this.andS(value);
    return this.andM(value);
  };

  AbstractMatrix.prototype.andS = function andS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) & value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.andM = function andM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) & matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.and = function and(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.and(value);
  };

  AbstractMatrix.prototype.or = function or(value) {
    if (typeof value === 'number') return this.orS(value);
    return this.orM(value);
  };

  AbstractMatrix.prototype.orS = function orS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) | value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.orM = function orM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) | matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.or = function or(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.or(value);
  };

  AbstractMatrix.prototype.xor = function xor(value) {
    if (typeof value === 'number') return this.xorS(value);
    return this.xorM(value);
  };

  AbstractMatrix.prototype.xorS = function xorS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) ^ value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.xorM = function xorM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) ^ matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.xor = function xor(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.xor(value);
  };

  AbstractMatrix.prototype.leftShift = function leftShift(value) {
    if (typeof value === 'number') return this.leftShiftS(value);
    return this.leftShiftM(value);
  };

  AbstractMatrix.prototype.leftShiftS = function leftShiftS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) << value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.leftShiftM = function leftShiftM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) << matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.leftShift = function leftShift(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.leftShift(value);
  };

  AbstractMatrix.prototype.signPropagatingRightShift = function signPropagatingRightShift(value) {
    if (typeof value === 'number') return this.signPropagatingRightShiftS(value);
    return this.signPropagatingRightShiftM(value);
  };

  AbstractMatrix.prototype.signPropagatingRightShiftS = function signPropagatingRightShiftS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) >> value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.signPropagatingRightShiftM = function signPropagatingRightShiftM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) >> matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.signPropagatingRightShift = function signPropagatingRightShift(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.signPropagatingRightShift(value);
  };

  AbstractMatrix.prototype.rightShift = function rightShift(value) {
    if (typeof value === 'number') return this.rightShiftS(value);
    return this.rightShiftM(value);
  };

  AbstractMatrix.prototype.rightShiftS = function rightShiftS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) >>> value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.rightShiftM = function rightShiftM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) >>> matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.rightShift = function rightShift(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.rightShift(value);
  };
  AbstractMatrix.prototype.zeroFillRightShift = AbstractMatrix.prototype.rightShift;
  AbstractMatrix.prototype.zeroFillRightShiftS = AbstractMatrix.prototype.rightShiftS;
  AbstractMatrix.prototype.zeroFillRightShiftM = AbstractMatrix.prototype.rightShiftM;
  AbstractMatrix.zeroFillRightShift = AbstractMatrix.rightShift;

  AbstractMatrix.prototype.not = function not() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, ~(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.not = function not(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.not();
  };

  AbstractMatrix.prototype.abs = function abs() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.abs(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.abs = function abs(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.abs();
  };

  AbstractMatrix.prototype.acos = function acos() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.acos(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.acos = function acos(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.acos();
  };

  AbstractMatrix.prototype.acosh = function acosh() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.acosh(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.acosh = function acosh(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.acosh();
  };

  AbstractMatrix.prototype.asin = function asin() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.asin(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.asin = function asin(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.asin();
  };

  AbstractMatrix.prototype.asinh = function asinh() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.asinh(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.asinh = function asinh(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.asinh();
  };

  AbstractMatrix.prototype.atan = function atan() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.atan(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.atan = function atan(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.atan();
  };

  AbstractMatrix.prototype.atanh = function atanh() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.atanh(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.atanh = function atanh(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.atanh();
  };

  AbstractMatrix.prototype.cbrt = function cbrt() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.cbrt(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.cbrt = function cbrt(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.cbrt();
  };

  AbstractMatrix.prototype.ceil = function ceil() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.ceil(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.ceil = function ceil(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.ceil();
  };

  AbstractMatrix.prototype.clz32 = function clz32() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.clz32(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.clz32 = function clz32(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.clz32();
  };

  AbstractMatrix.prototype.cos = function cos() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.cos(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.cos = function cos(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.cos();
  };

  AbstractMatrix.prototype.cosh = function cosh() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.cosh(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.cosh = function cosh(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.cosh();
  };

  AbstractMatrix.prototype.exp = function exp() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.exp(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.exp = function exp(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.exp();
  };

  AbstractMatrix.prototype.expm1 = function expm1() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.expm1(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.expm1 = function expm1(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.expm1();
  };

  AbstractMatrix.prototype.floor = function floor() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.floor(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.floor = function floor(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.floor();
  };

  AbstractMatrix.prototype.fround = function fround() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.fround(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.fround = function fround(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.fround();
  };

  AbstractMatrix.prototype.log = function log() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.log(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.log = function log(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.log();
  };

  AbstractMatrix.prototype.log1p = function log1p() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.log1p(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.log1p = function log1p(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.log1p();
  };

  AbstractMatrix.prototype.log10 = function log10() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.log10(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.log10 = function log10(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.log10();
  };

  AbstractMatrix.prototype.log2 = function log2() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.log2(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.log2 = function log2(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.log2();
  };

  AbstractMatrix.prototype.round = function round() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.round(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.round = function round(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.round();
  };

  AbstractMatrix.prototype.sign = function sign() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.sign(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.sign = function sign(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.sign();
  };

  AbstractMatrix.prototype.sin = function sin() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.sin(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.sin = function sin(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.sin();
  };

  AbstractMatrix.prototype.sinh = function sinh() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.sinh(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.sinh = function sinh(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.sinh();
  };

  AbstractMatrix.prototype.sqrt = function sqrt() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.sqrt(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.sqrt = function sqrt(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.sqrt();
  };

  AbstractMatrix.prototype.tan = function tan() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.tan(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.tan = function tan(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.tan();
  };

  AbstractMatrix.prototype.tanh = function tanh() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.tanh(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.tanh = function tanh(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.tanh();
  };

  AbstractMatrix.prototype.trunc = function trunc() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.trunc(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.trunc = function trunc(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.trunc();
  };

  AbstractMatrix.pow = function pow(matrix, arg0) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.pow(arg0);
  };

  AbstractMatrix.prototype.pow = function pow(value) {
    if (typeof value === 'number') return this.powS(value);
    return this.powM(value);
  };

  AbstractMatrix.prototype.powS = function powS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.pow(this.get(i, j), value));
      }
    }
    return this;
  };

  AbstractMatrix.prototype.powM = function powM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.pow(this.get(i, j), matrix.get(i, j)));
      }
    }
    return this;
  };
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/matrix.js":
/*!**********************************************!*\
  !*** ./node_modules/ml-matrix/src/matrix.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractMatrix: () => (/* binding */ AbstractMatrix),
/* harmony export */   "default": () => (/* binding */ Matrix)
/* harmony export */ });
/* harmony import */ var ml_array_rescale__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ml-array-rescale */ "./node_modules/ml-array-rescale/lib-es6/index.js");
/* harmony import */ var _inspect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./inspect */ "./node_modules/ml-matrix/src/inspect.js");
/* harmony import */ var _mathOperations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mathOperations */ "./node_modules/ml-matrix/src/mathOperations.js");
/* harmony import */ var _stat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stat */ "./node_modules/ml-matrix/src/stat.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./node_modules/ml-matrix/src/util.js");







class AbstractMatrix {
  static from1DArray(newRows, newColumns, newData) {
    let length = newRows * newColumns;
    if (length !== newData.length) {
      throw new RangeError('data length does not match given dimensions');
    }
    let newMatrix = new Matrix(newRows, newColumns);
    for (let row = 0; row < newRows; row++) {
      for (let column = 0; column < newColumns; column++) {
        newMatrix.set(row, column, newData[row * newColumns + column]);
      }
    }
    return newMatrix;
  }

  static rowVector(newData) {
    let vector = new Matrix(1, newData.length);
    for (let i = 0; i < newData.length; i++) {
      vector.set(0, i, newData[i]);
    }
    return vector;
  }

  static columnVector(newData) {
    let vector = new Matrix(newData.length, 1);
    for (let i = 0; i < newData.length; i++) {
      vector.set(i, 0, newData[i]);
    }
    return vector;
  }

  static zeros(rows, columns) {
    return new Matrix(rows, columns);
  }

  static ones(rows, columns) {
    return new Matrix(rows, columns).fill(1);
  }

  static rand(rows, columns, options = {}) {
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }
    const { random = Math.random } = options;
    let matrix = new Matrix(rows, columns);
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < columns; j++) {
        matrix.set(i, j, random());
      }
    }
    return matrix;
  }

  static randInt(rows, columns, options = {}) {
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }
    const { min = 0, max = 1000, random = Math.random } = options;
    if (!Number.isInteger(min)) throw new TypeError('min must be an integer');
    if (!Number.isInteger(max)) throw new TypeError('max must be an integer');
    if (min >= max) throw new RangeError('min must be smaller than max');
    let interval = max - min;
    let matrix = new Matrix(rows, columns);
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < columns; j++) {
        let value = min + Math.round(random() * interval);
        matrix.set(i, j, value);
      }
    }
    return matrix;
  }

  static eye(rows, columns, value) {
    if (columns === undefined) columns = rows;
    if (value === undefined) value = 1;
    let min = Math.min(rows, columns);
    let matrix = this.zeros(rows, columns);
    for (let i = 0; i < min; i++) {
      matrix.set(i, i, value);
    }
    return matrix;
  }

  static diag(data, rows, columns) {
    let l = data.length;
    if (rows === undefined) rows = l;
    if (columns === undefined) columns = rows;
    let min = Math.min(l, rows, columns);
    let matrix = this.zeros(rows, columns);
    for (let i = 0; i < min; i++) {
      matrix.set(i, i, data[i]);
    }
    return matrix;
  }

  static min(matrix1, matrix2) {
    matrix1 = this.checkMatrix(matrix1);
    matrix2 = this.checkMatrix(matrix2);
    let rows = matrix1.rows;
    let columns = matrix1.columns;
    let result = new Matrix(rows, columns);
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < columns; j++) {
        result.set(i, j, Math.min(matrix1.get(i, j), matrix2.get(i, j)));
      }
    }
    return result;
  }

  static max(matrix1, matrix2) {
    matrix1 = this.checkMatrix(matrix1);
    matrix2 = this.checkMatrix(matrix2);
    let rows = matrix1.rows;
    let columns = matrix1.columns;
    let result = new this(rows, columns);
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < columns; j++) {
        result.set(i, j, Math.max(matrix1.get(i, j), matrix2.get(i, j)));
      }
    }
    return result;
  }

  static checkMatrix(value) {
    return AbstractMatrix.isMatrix(value) ? value : new Matrix(value);
  }

  static isMatrix(value) {
    return value != null && value.klass === 'Matrix';
  }

  get size() {
    return this.rows * this.columns;
  }

  apply(callback) {
    if (typeof callback !== 'function') {
      throw new TypeError('callback must be a function');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        callback.call(this, i, j);
      }
    }
    return this;
  }

  to1DArray() {
    let array = [];
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        array.push(this.get(i, j));
      }
    }
    return array;
  }

  to2DArray() {
    let copy = [];
    for (let i = 0; i < this.rows; i++) {
      copy.push([]);
      for (let j = 0; j < this.columns; j++) {
        copy[i].push(this.get(i, j));
      }
    }
    return copy;
  }

  toJSON() {
    return this.to2DArray();
  }

  isRowVector() {
    return this.rows === 1;
  }

  isColumnVector() {
    return this.columns === 1;
  }

  isVector() {
    return this.rows === 1 || this.columns === 1;
  }

  isSquare() {
    return this.rows === this.columns;
  }

  isSymmetric() {
    if (this.isSquare()) {
      for (let i = 0; i < this.rows; i++) {
        for (let j = 0; j <= i; j++) {
          if (this.get(i, j) !== this.get(j, i)) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  }

  isEchelonForm() {
    let i = 0;
    let j = 0;
    let previousColumn = -1;
    let isEchelonForm = true;
    let checked = false;
    while (i < this.rows && isEchelonForm) {
      j = 0;
      checked = false;
      while (j < this.columns && checked === false) {
        if (this.get(i, j) === 0) {
          j++;
        } else if (this.get(i, j) === 1 && j > previousColumn) {
          checked = true;
          previousColumn = j;
        } else {
          isEchelonForm = false;
          checked = true;
        }
      }
      i++;
    }
    return isEchelonForm;
  }

  isReducedEchelonForm() {
    let i = 0;
    let j = 0;
    let previousColumn = -1;
    let isReducedEchelonForm = true;
    let checked = false;
    while (i < this.rows && isReducedEchelonForm) {
      j = 0;
      checked = false;
      while (j < this.columns && checked === false) {
        if (this.get(i, j) === 0) {
          j++;
        } else if (this.get(i, j) === 1 && j > previousColumn) {
          checked = true;
          previousColumn = j;
        } else {
          isReducedEchelonForm = false;
          checked = true;
        }
      }
      for (let k = j + 1; k < this.rows; k++) {
        if (this.get(i, k) !== 0) {
          isReducedEchelonForm = false;
        }
      }
      i++;
    }
    return isReducedEchelonForm;
  }

  echelonForm() {
    let result = this.clone();
    let h = 0;
    let k = 0;
    while (h < result.rows && k < result.columns) {
      let iMax = h;
      for (let i = h; i < result.rows; i++) {
        if (result.get(i, k) > result.get(iMax, k)) {
          iMax = i;
        }
      }
      if (result.get(iMax, k) === 0) {
        k++;
      } else {
        result.swapRows(h, iMax);
        let tmp = result.get(h, k);
        for (let j = k; j < result.columns; j++) {
          result.set(h, j, result.get(h, j) / tmp);
        }
        for (let i = h + 1; i < result.rows; i++) {
          let factor = result.get(i, k) / result.get(h, k);
          result.set(i, k, 0);
          for (let j = k + 1; j < result.columns; j++) {
            result.set(i, j, result.get(i, j) - result.get(h, j) * factor);
          }
        }
        h++;
        k++;
      }
    }
    return result;
  }

  reducedEchelonForm() {
    let result = this.echelonForm();
    let m = result.columns;
    let n = result.rows;
    let h = n - 1;
    while (h >= 0) {
      if (result.maxRow(h) === 0) {
        h--;
      } else {
        let p = 0;
        let pivot = false;
        while (p < n && pivot === false) {
          if (result.get(h, p) === 1) {
            pivot = true;
          } else {
            p++;
          }
        }
        for (let i = 0; i < h; i++) {
          let factor = result.get(i, p);
          for (let j = p; j < m; j++) {
            let tmp = result.get(i, j) - factor * result.get(h, j);
            result.set(i, j, tmp);
          }
        }
        h--;
      }
    }
    return result;
  }

  set() {
    throw new Error('set method is unimplemented');
  }

  get() {
    throw new Error('get method is unimplemented');
  }

  repeat(options = {}) {
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }
    const { rows = 1, columns = 1 } = options;
    if (!Number.isInteger(rows) || rows <= 0) {
      throw new TypeError('rows must be a positive integer');
    }
    if (!Number.isInteger(columns) || columns <= 0) {
      throw new TypeError('columns must be a positive integer');
    }
    let matrix = new Matrix(this.rows * rows, this.columns * columns);
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < columns; j++) {
        matrix.setSubMatrix(this, this.rows * i, this.columns * j);
      }
    }
    return matrix;
  }

  fill(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, value);
      }
    }
    return this;
  }

  neg() {
    return this.mulS(-1);
  }

  getRow(index) {
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowIndex)(this, index);
    let row = [];
    for (let i = 0; i < this.columns; i++) {
      row.push(this.get(index, i));
    }
    return row;
  }

  getRowVector(index) {
    return Matrix.rowVector(this.getRow(index));
  }

  setRow(index, array) {
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowIndex)(this, index);
    array = (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowVector)(this, array);
    for (let i = 0; i < this.columns; i++) {
      this.set(index, i, array[i]);
    }
    return this;
  }

  swapRows(row1, row2) {
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowIndex)(this, row1);
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowIndex)(this, row2);
    for (let i = 0; i < this.columns; i++) {
      let temp = this.get(row1, i);
      this.set(row1, i, this.get(row2, i));
      this.set(row2, i, temp);
    }
    return this;
  }

  getColumn(index) {
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnIndex)(this, index);
    let column = [];
    for (let i = 0; i < this.rows; i++) {
      column.push(this.get(i, index));
    }
    return column;
  }

  getColumnVector(index) {
    return Matrix.columnVector(this.getColumn(index));
  }

  setColumn(index, array) {
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnIndex)(this, index);
    array = (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnVector)(this, array);
    for (let i = 0; i < this.rows; i++) {
      this.set(i, index, array[i]);
    }
    return this;
  }

  swapColumns(column1, column2) {
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnIndex)(this, column1);
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnIndex)(this, column2);
    for (let i = 0; i < this.rows; i++) {
      let temp = this.get(i, column1);
      this.set(i, column1, this.get(i, column2));
      this.set(i, column2, temp);
    }
    return this;
  }

  addRowVector(vector) {
    vector = (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowVector)(this, vector);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) + vector[j]);
      }
    }
    return this;
  }

  subRowVector(vector) {
    vector = (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowVector)(this, vector);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) - vector[j]);
      }
    }
    return this;
  }

  mulRowVector(vector) {
    vector = (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowVector)(this, vector);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) * vector[j]);
      }
    }
    return this;
  }

  divRowVector(vector) {
    vector = (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowVector)(this, vector);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) / vector[j]);
      }
    }
    return this;
  }

  addColumnVector(vector) {
    vector = (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnVector)(this, vector);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) + vector[i]);
      }
    }
    return this;
  }

  subColumnVector(vector) {
    vector = (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnVector)(this, vector);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) - vector[i]);
      }
    }
    return this;
  }

  mulColumnVector(vector) {
    vector = (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnVector)(this, vector);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) * vector[i]);
      }
    }
    return this;
  }

  divColumnVector(vector) {
    vector = (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnVector)(this, vector);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) / vector[i]);
      }
    }
    return this;
  }

  mulRow(index, value) {
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowIndex)(this, index);
    for (let i = 0; i < this.columns; i++) {
      this.set(index, i, this.get(index, i) * value);
    }
    return this;
  }

  mulColumn(index, value) {
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnIndex)(this, index);
    for (let i = 0; i < this.rows; i++) {
      this.set(i, index, this.get(i, index) * value);
    }
    return this;
  }

  max() {
    let v = this.get(0, 0);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        if (this.get(i, j) > v) {
          v = this.get(i, j);
        }
      }
    }
    return v;
  }

  maxIndex() {
    let v = this.get(0, 0);
    let idx = [0, 0];
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        if (this.get(i, j) > v) {
          v = this.get(i, j);
          idx[0] = i;
          idx[1] = j;
        }
      }
    }
    return idx;
  }

  min() {
    let v = this.get(0, 0);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        if (this.get(i, j) < v) {
          v = this.get(i, j);
        }
      }
    }
    return v;
  }

  minIndex() {
    let v = this.get(0, 0);
    let idx = [0, 0];
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        if (this.get(i, j) < v) {
          v = this.get(i, j);
          idx[0] = i;
          idx[1] = j;
        }
      }
    }
    return idx;
  }

  maxRow(row) {
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowIndex)(this, row);
    let v = this.get(row, 0);
    for (let i = 1; i < this.columns; i++) {
      if (this.get(row, i) > v) {
        v = this.get(row, i);
      }
    }
    return v;
  }

  maxRowIndex(row) {
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowIndex)(this, row);
    let v = this.get(row, 0);
    let idx = [row, 0];
    for (let i = 1; i < this.columns; i++) {
      if (this.get(row, i) > v) {
        v = this.get(row, i);
        idx[1] = i;
      }
    }
    return idx;
  }

  minRow(row) {
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowIndex)(this, row);
    let v = this.get(row, 0);
    for (let i = 1; i < this.columns; i++) {
      if (this.get(row, i) < v) {
        v = this.get(row, i);
      }
    }
    return v;
  }

  minRowIndex(row) {
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowIndex)(this, row);
    let v = this.get(row, 0);
    let idx = [row, 0];
    for (let i = 1; i < this.columns; i++) {
      if (this.get(row, i) < v) {
        v = this.get(row, i);
        idx[1] = i;
      }
    }
    return idx;
  }

  maxColumn(column) {
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnIndex)(this, column);
    let v = this.get(0, column);
    for (let i = 1; i < this.rows; i++) {
      if (this.get(i, column) > v) {
        v = this.get(i, column);
      }
    }
    return v;
  }

  maxColumnIndex(column) {
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnIndex)(this, column);
    let v = this.get(0, column);
    let idx = [0, column];
    for (let i = 1; i < this.rows; i++) {
      if (this.get(i, column) > v) {
        v = this.get(i, column);
        idx[0] = i;
      }
    }
    return idx;
  }

  minColumn(column) {
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnIndex)(this, column);
    let v = this.get(0, column);
    for (let i = 1; i < this.rows; i++) {
      if (this.get(i, column) < v) {
        v = this.get(i, column);
      }
    }
    return v;
  }

  minColumnIndex(column) {
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnIndex)(this, column);
    let v = this.get(0, column);
    let idx = [0, column];
    for (let i = 1; i < this.rows; i++) {
      if (this.get(i, column) < v) {
        v = this.get(i, column);
        idx[0] = i;
      }
    }
    return idx;
  }

  diag() {
    let min = Math.min(this.rows, this.columns);
    let diag = [];
    for (let i = 0; i < min; i++) {
      diag.push(this.get(i, i));
    }
    return diag;
  }

  norm(type = 'frobenius') {
    let result = 0;
    if (type === 'max') {
      return this.max();
    } else if (type === 'frobenius') {
      for (let i = 0; i < this.rows; i++) {
        for (let j = 0; j < this.columns; j++) {
          result = result + this.get(i, j) * this.get(i, j);
        }
      }
      return Math.sqrt(result);
    } else {
      throw new RangeError(`unknown norm type: ${type}`);
    }
  }

  cumulativeSum() {
    let sum = 0;
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        sum += this.get(i, j);
        this.set(i, j, sum);
      }
    }
    return this;
  }

  dot(vector2) {
    if (AbstractMatrix.isMatrix(vector2)) vector2 = vector2.to1DArray();
    let vector1 = this.to1DArray();
    if (vector1.length !== vector2.length) {
      throw new RangeError('vectors do not have the same size');
    }
    let dot = 0;
    for (let i = 0; i < vector1.length; i++) {
      dot += vector1[i] * vector2[i];
    }
    return dot;
  }

  mmul(other) {
    other = Matrix.checkMatrix(other);

    let m = this.rows;
    let n = this.columns;
    let p = other.columns;

    let result = new Matrix(m, p);

    let Bcolj = new Float64Array(n);
    for (let j = 0; j < p; j++) {
      for (let k = 0; k < n; k++) {
        Bcolj[k] = other.get(k, j);
      }

      for (let i = 0; i < m; i++) {
        let s = 0;
        for (let k = 0; k < n; k++) {
          s += this.get(i, k) * Bcolj[k];
        }

        result.set(i, j, s);
      }
    }
    return result;
  }

  strassen2x2(other) {
    other = Matrix.checkMatrix(other);
    let result = new Matrix(2, 2);
    const a11 = this.get(0, 0);
    const b11 = other.get(0, 0);
    const a12 = this.get(0, 1);
    const b12 = other.get(0, 1);
    const a21 = this.get(1, 0);
    const b21 = other.get(1, 0);
    const a22 = this.get(1, 1);
    const b22 = other.get(1, 1);

    // Compute intermediate values.
    const m1 = (a11 + a22) * (b11 + b22);
    const m2 = (a21 + a22) * b11;
    const m3 = a11 * (b12 - b22);
    const m4 = a22 * (b21 - b11);
    const m5 = (a11 + a12) * b22;
    const m6 = (a21 - a11) * (b11 + b12);
    const m7 = (a12 - a22) * (b21 + b22);

    // Combine intermediate values into the output.
    const c00 = m1 + m4 - m5 + m7;
    const c01 = m3 + m5;
    const c10 = m2 + m4;
    const c11 = m1 - m2 + m3 + m6;

    result.set(0, 0, c00);
    result.set(0, 1, c01);
    result.set(1, 0, c10);
    result.set(1, 1, c11);
    return result;
  }

  strassen3x3(other) {
    other = Matrix.checkMatrix(other);
    let result = new Matrix(3, 3);

    const a00 = this.get(0, 0);
    const a01 = this.get(0, 1);
    const a02 = this.get(0, 2);
    const a10 = this.get(1, 0);
    const a11 = this.get(1, 1);
    const a12 = this.get(1, 2);
    const a20 = this.get(2, 0);
    const a21 = this.get(2, 1);
    const a22 = this.get(2, 2);

    const b00 = other.get(0, 0);
    const b01 = other.get(0, 1);
    const b02 = other.get(0, 2);
    const b10 = other.get(1, 0);
    const b11 = other.get(1, 1);
    const b12 = other.get(1, 2);
    const b20 = other.get(2, 0);
    const b21 = other.get(2, 1);
    const b22 = other.get(2, 2);

    const m1 = (a00 + a01 + a02 - a10 - a11 - a21 - a22) * b11;
    const m2 = (a00 - a10) * (-b01 + b11);
    const m3 = a11 * (-b00 + b01 + b10 - b11 - b12 - b20 + b22);
    const m4 = (-a00 + a10 + a11) * (b00 - b01 + b11);
    const m5 = (a10 + a11) * (-b00 + b01);
    const m6 = a00 * b00;
    const m7 = (-a00 + a20 + a21) * (b00 - b02 + b12);
    const m8 = (-a00 + a20) * (b02 - b12);
    const m9 = (a20 + a21) * (-b00 + b02);
    const m10 = (a00 + a01 + a02 - a11 - a12 - a20 - a21) * b12;
    const m11 = a21 * (-b00 + b02 + b10 - b11 - b12 - b20 + b21);
    const m12 = (-a02 + a21 + a22) * (b11 + b20 - b21);
    const m13 = (a02 - a22) * (b11 - b21);
    const m14 = a02 * b20;
    const m15 = (a21 + a22) * (-b20 + b21);
    const m16 = (-a02 + a11 + a12) * (b12 + b20 - b22);
    const m17 = (a02 - a12) * (b12 - b22);
    const m18 = (a11 + a12) * (-b20 + b22);
    const m19 = a01 * b10;
    const m20 = a12 * b21;
    const m21 = a10 * b02;
    const m22 = a20 * b01;
    const m23 = a22 * b22;

    const c00 = m6 + m14 + m19;
    const c01 = m1 + m4 + m5 + m6 + m12 + m14 + m15;
    const c02 = m6 + m7 + m9 + m10 + m14 + m16 + m18;
    const c10 = m2 + m3 + m4 + m6 + m14 + m16 + m17;
    const c11 = m2 + m4 + m5 + m6 + m20;
    const c12 = m14 + m16 + m17 + m18 + m21;
    const c20 = m6 + m7 + m8 + m11 + m12 + m13 + m14;
    const c21 = m12 + m13 + m14 + m15 + m22;
    const c22 = m6 + m7 + m8 + m9 + m23;

    result.set(0, 0, c00);
    result.set(0, 1, c01);
    result.set(0, 2, c02);
    result.set(1, 0, c10);
    result.set(1, 1, c11);
    result.set(1, 2, c12);
    result.set(2, 0, c20);
    result.set(2, 1, c21);
    result.set(2, 2, c22);
    return result;
  }

  mmulStrassen(y) {
    y = Matrix.checkMatrix(y);
    let x = this.clone();
    let r1 = x.rows;
    let c1 = x.columns;
    let r2 = y.rows;
    let c2 = y.columns;
    if (c1 !== r2) {
      // eslint-disable-next-line no-console
      console.warn(
        `Multiplying ${r1} x ${c1} and ${r2} x ${c2} matrix: dimensions do not match.`,
      );
    }

    // Put a matrix into the top left of a matrix of zeros.
    // `rows` and `cols` are the dimensions of the output matrix.
    function embed(mat, rows, cols) {
      let r = mat.rows;
      let c = mat.columns;
      if (r === rows && c === cols) {
        return mat;
      } else {
        let resultat = AbstractMatrix.zeros(rows, cols);
        resultat = resultat.setSubMatrix(mat, 0, 0);
        return resultat;
      }
    }

    // Make sure both matrices are the same size.
    // This is exclusively for simplicity:
    // this algorithm can be implemented with matrices of different sizes.

    let r = Math.max(r1, r2);
    let c = Math.max(c1, c2);
    x = embed(x, r, c);
    y = embed(y, r, c);

    // Our recursive multiplication function.
    function blockMult(a, b, rows, cols) {
      // For small matrices, resort to naive multiplication.
      if (rows <= 512 || cols <= 512) {
        return a.mmul(b); // a is equivalent to this
      }

      // Apply dynamic padding.
      if (rows % 2 === 1 && cols % 2 === 1) {
        a = embed(a, rows + 1, cols + 1);
        b = embed(b, rows + 1, cols + 1);
      } else if (rows % 2 === 1) {
        a = embed(a, rows + 1, cols);
        b = embed(b, rows + 1, cols);
      } else if (cols % 2 === 1) {
        a = embed(a, rows, cols + 1);
        b = embed(b, rows, cols + 1);
      }

      let halfRows = parseInt(a.rows / 2, 10);
      let halfCols = parseInt(a.columns / 2, 10);
      // Subdivide input matrices.
      let a11 = a.subMatrix(0, halfRows - 1, 0, halfCols - 1);
      let b11 = b.subMatrix(0, halfRows - 1, 0, halfCols - 1);

      let a12 = a.subMatrix(0, halfRows - 1, halfCols, a.columns - 1);
      let b12 = b.subMatrix(0, halfRows - 1, halfCols, b.columns - 1);

      let a21 = a.subMatrix(halfRows, a.rows - 1, 0, halfCols - 1);
      let b21 = b.subMatrix(halfRows, b.rows - 1, 0, halfCols - 1);

      let a22 = a.subMatrix(halfRows, a.rows - 1, halfCols, a.columns - 1);
      let b22 = b.subMatrix(halfRows, b.rows - 1, halfCols, b.columns - 1);

      // Compute intermediate values.
      let m1 = blockMult(
        AbstractMatrix.add(a11, a22),
        AbstractMatrix.add(b11, b22),
        halfRows,
        halfCols,
      );
      let m2 = blockMult(AbstractMatrix.add(a21, a22), b11, halfRows, halfCols);
      let m3 = blockMult(a11, AbstractMatrix.sub(b12, b22), halfRows, halfCols);
      let m4 = blockMult(a22, AbstractMatrix.sub(b21, b11), halfRows, halfCols);
      let m5 = blockMult(AbstractMatrix.add(a11, a12), b22, halfRows, halfCols);
      let m6 = blockMult(
        AbstractMatrix.sub(a21, a11),
        AbstractMatrix.add(b11, b12),
        halfRows,
        halfCols,
      );
      let m7 = blockMult(
        AbstractMatrix.sub(a12, a22),
        AbstractMatrix.add(b21, b22),
        halfRows,
        halfCols,
      );

      // Combine intermediate values into the output.
      let c11 = AbstractMatrix.add(m1, m4);
      c11.sub(m5);
      c11.add(m7);
      let c12 = AbstractMatrix.add(m3, m5);
      let c21 = AbstractMatrix.add(m2, m4);
      let c22 = AbstractMatrix.sub(m1, m2);
      c22.add(m3);
      c22.add(m6);

      // Crop output to the desired size (undo dynamic padding).
      let resultat = AbstractMatrix.zeros(2 * c11.rows, 2 * c11.columns);
      resultat = resultat.setSubMatrix(c11, 0, 0);
      resultat = resultat.setSubMatrix(c12, c11.rows, 0);
      resultat = resultat.setSubMatrix(c21, 0, c11.columns);
      resultat = resultat.setSubMatrix(c22, c11.rows, c11.columns);
      return resultat.subMatrix(0, rows - 1, 0, cols - 1);
    }
    return blockMult(x, y, r, c);
  }

  scaleRows(options = {}) {
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }
    const { min = 0, max = 1 } = options;
    if (!Number.isFinite(min)) throw new TypeError('min must be a number');
    if (!Number.isFinite(max)) throw new TypeError('max must be a number');
    if (min >= max) throw new RangeError('min must be smaller than max');
    let newMatrix = new Matrix(this.rows, this.columns);
    for (let i = 0; i < this.rows; i++) {
      const row = this.getRow(i);
      (0,ml_array_rescale__WEBPACK_IMPORTED_MODULE_0__["default"])(row, { min, max, output: row });
      newMatrix.setRow(i, row);
    }
    return newMatrix;
  }

  scaleColumns(options = {}) {
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }
    const { min = 0, max = 1 } = options;
    if (!Number.isFinite(min)) throw new TypeError('min must be a number');
    if (!Number.isFinite(max)) throw new TypeError('max must be a number');
    if (min >= max) throw new RangeError('min must be smaller than max');
    let newMatrix = new Matrix(this.rows, this.columns);
    for (let i = 0; i < this.columns; i++) {
      const column = this.getColumn(i);
      (0,ml_array_rescale__WEBPACK_IMPORTED_MODULE_0__["default"])(column, {
        min: min,
        max: max,
        output: column,
      });
      newMatrix.setColumn(i, column);
    }
    return newMatrix;
  }

  flipRows() {
    const middle = Math.ceil(this.columns / 2);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < middle; j++) {
        let first = this.get(i, j);
        let last = this.get(i, this.columns - 1 - j);
        this.set(i, j, last);
        this.set(i, this.columns - 1 - j, first);
      }
    }
    return this;
  }

  flipColumns() {
    const middle = Math.ceil(this.rows / 2);
    for (let j = 0; j < this.columns; j++) {
      for (let i = 0; i < middle; i++) {
        let first = this.get(i, j);
        let last = this.get(this.rows - 1 - i, j);
        this.set(i, j, last);
        this.set(this.rows - 1 - i, j, first);
      }
    }
    return this;
  }

  kroneckerProduct(other) {
    other = Matrix.checkMatrix(other);

    let m = this.rows;
    let n = this.columns;
    let p = other.rows;
    let q = other.columns;

    let result = new Matrix(m * p, n * q);
    for (let i = 0; i < m; i++) {
      for (let j = 0; j < n; j++) {
        for (let k = 0; k < p; k++) {
          for (let l = 0; l < q; l++) {
            result.set(p * i + k, q * j + l, this.get(i, j) * other.get(k, l));
          }
        }
      }
    }
    return result;
  }

  transpose() {
    let result = new Matrix(this.columns, this.rows);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        result.set(j, i, this.get(i, j));
      }
    }
    return result;
  }

  sortRows(compareFunction = compareNumbers) {
    for (let i = 0; i < this.rows; i++) {
      this.setRow(i, this.getRow(i).sort(compareFunction));
    }
    return this;
  }

  sortColumns(compareFunction = compareNumbers) {
    for (let i = 0; i < this.columns; i++) {
      this.setColumn(i, this.getColumn(i).sort(compareFunction));
    }
    return this;
  }

  subMatrix(startRow, endRow, startColumn, endColumn) {
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRange)(this, startRow, endRow, startColumn, endColumn);
    let newMatrix = new Matrix(
      endRow - startRow + 1,
      endColumn - startColumn + 1,
    );
    for (let i = startRow; i <= endRow; i++) {
      for (let j = startColumn; j <= endColumn; j++) {
        newMatrix.set(i - startRow, j - startColumn, this.get(i, j));
      }
    }
    return newMatrix;
  }

  subMatrixRow(indices, startColumn, endColumn) {
    if (startColumn === undefined) startColumn = 0;
    if (endColumn === undefined) endColumn = this.columns - 1;
    if (
      startColumn > endColumn ||
      startColumn < 0 ||
      startColumn >= this.columns ||
      endColumn < 0 ||
      endColumn >= this.columns
    ) {
      throw new RangeError('Argument out of range');
    }

    let newMatrix = new Matrix(indices.length, endColumn - startColumn + 1);
    for (let i = 0; i < indices.length; i++) {
      for (let j = startColumn; j <= endColumn; j++) {
        if (indices[i] < 0 || indices[i] >= this.rows) {
          throw new RangeError(`Row index out of range: ${indices[i]}`);
        }
        newMatrix.set(i, j - startColumn, this.get(indices[i], j));
      }
    }
    return newMatrix;
  }

  subMatrixColumn(indices, startRow, endRow) {
    if (startRow === undefined) startRow = 0;
    if (endRow === undefined) endRow = this.rows - 1;
    if (
      startRow > endRow ||
      startRow < 0 ||
      startRow >= this.rows ||
      endRow < 0 ||
      endRow >= this.rows
    ) {
      throw new RangeError('Argument out of range');
    }

    let newMatrix = new Matrix(endRow - startRow + 1, indices.length);
    for (let i = 0; i < indices.length; i++) {
      for (let j = startRow; j <= endRow; j++) {
        if (indices[i] < 0 || indices[i] >= this.columns) {
          throw new RangeError(`Column index out of range: ${indices[i]}`);
        }
        newMatrix.set(j - startRow, i, this.get(j, indices[i]));
      }
    }
    return newMatrix;
  }

  setSubMatrix(matrix, startRow, startColumn) {
    matrix = Matrix.checkMatrix(matrix);
    let endRow = startRow + matrix.rows - 1;
    let endColumn = startColumn + matrix.columns - 1;
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRange)(this, startRow, endRow, startColumn, endColumn);
    for (let i = 0; i < matrix.rows; i++) {
      for (let j = 0; j < matrix.columns; j++) {
        this.set(startRow + i, startColumn + j, matrix.get(i, j));
      }
    }
    return this;
  }

  selection(rowIndices, columnIndices) {
    let indices = (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkIndices)(this, rowIndices, columnIndices);
    let newMatrix = new Matrix(rowIndices.length, columnIndices.length);
    for (let i = 0; i < indices.row.length; i++) {
      let rowIndex = indices.row[i];
      for (let j = 0; j < indices.column.length; j++) {
        let columnIndex = indices.column[j];
        newMatrix.set(i, j, this.get(rowIndex, columnIndex));
      }
    }
    return newMatrix;
  }

  trace() {
    let min = Math.min(this.rows, this.columns);
    let trace = 0;
    for (let i = 0; i < min; i++) {
      trace += this.get(i, i);
    }
    return trace;
  }

  clone() {
    let newMatrix = new Matrix(this.rows, this.columns);
    for (let row = 0; row < this.rows; row++) {
      for (let column = 0; column < this.columns; column++) {
        newMatrix.set(row, column, this.get(row, column));
      }
    }
    return newMatrix;
  }

  sum(by) {
    switch (by) {
      case 'row':
        return (0,_stat__WEBPACK_IMPORTED_MODULE_2__.sumByRow)(this);
      case 'column':
        return (0,_stat__WEBPACK_IMPORTED_MODULE_2__.sumByColumn)(this);
      case undefined:
        return (0,_stat__WEBPACK_IMPORTED_MODULE_2__.sumAll)(this);
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }

  product(by) {
    switch (by) {
      case 'row':
        return (0,_stat__WEBPACK_IMPORTED_MODULE_2__.productByRow)(this);
      case 'column':
        return (0,_stat__WEBPACK_IMPORTED_MODULE_2__.productByColumn)(this);
      case undefined:
        return (0,_stat__WEBPACK_IMPORTED_MODULE_2__.productAll)(this);
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }

  mean(by) {
    const sum = this.sum(by);
    switch (by) {
      case 'row': {
        for (let i = 0; i < this.rows; i++) {
          sum[i] /= this.columns;
        }
        return sum;
      }
      case 'column': {
        for (let i = 0; i < this.columns; i++) {
          sum[i] /= this.rows;
        }
        return sum;
      }
      case undefined:
        return sum / this.size;
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }

  variance(by, options = {}) {
    if (typeof by === 'object') {
      options = by;
      by = undefined;
    }
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }
    const { unbiased = true, mean = this.mean(by) } = options;
    if (typeof unbiased !== 'boolean') {
      throw new TypeError('unbiased must be a boolean');
    }
    switch (by) {
      case 'row': {
        if (!Array.isArray(mean)) {
          throw new TypeError('mean must be an array');
        }
        return (0,_stat__WEBPACK_IMPORTED_MODULE_2__.varianceByRow)(this, unbiased, mean);
      }
      case 'column': {
        if (!Array.isArray(mean)) {
          throw new TypeError('mean must be an array');
        }
        return (0,_stat__WEBPACK_IMPORTED_MODULE_2__.varianceByColumn)(this, unbiased, mean);
      }
      case undefined: {
        if (typeof mean !== 'number') {
          throw new TypeError('mean must be a number');
        }
        return (0,_stat__WEBPACK_IMPORTED_MODULE_2__.varianceAll)(this, unbiased, mean);
      }
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }

  standardDeviation(by, options) {
    if (typeof by === 'object') {
      options = by;
      by = undefined;
    }
    const variance = this.variance(by, options);
    if (by === undefined) {
      return Math.sqrt(variance);
    } else {
      for (let i = 0; i < variance.length; i++) {
        variance[i] = Math.sqrt(variance[i]);
      }
      return variance;
    }
  }

  center(by, options = {}) {
    if (typeof by === 'object') {
      options = by;
      by = undefined;
    }
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }
    const { center = this.mean(by) } = options;
    switch (by) {
      case 'row': {
        if (!Array.isArray(center)) {
          throw new TypeError('center must be an array');
        }
        (0,_stat__WEBPACK_IMPORTED_MODULE_2__.centerByRow)(this, center);
        return this;
      }
      case 'column': {
        if (!Array.isArray(center)) {
          throw new TypeError('center must be an array');
        }
        (0,_stat__WEBPACK_IMPORTED_MODULE_2__.centerByColumn)(this, center);
        return this;
      }
      case undefined: {
        if (typeof center !== 'number') {
          throw new TypeError('center must be a number');
        }
        (0,_stat__WEBPACK_IMPORTED_MODULE_2__.centerAll)(this, center);
        return this;
      }
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }

  scale(by, options = {}) {
    if (typeof by === 'object') {
      options = by;
      by = undefined;
    }
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }
    let scale = options.scale;
    switch (by) {
      case 'row': {
        if (scale === undefined) {
          scale = (0,_stat__WEBPACK_IMPORTED_MODULE_2__.getScaleByRow)(this);
        } else if (!Array.isArray(scale)) {
          throw new TypeError('scale must be an array');
        }
        (0,_stat__WEBPACK_IMPORTED_MODULE_2__.scaleByRow)(this, scale);
        return this;
      }
      case 'column': {
        if (scale === undefined) {
          scale = (0,_stat__WEBPACK_IMPORTED_MODULE_2__.getScaleByColumn)(this);
        } else if (!Array.isArray(scale)) {
          throw new TypeError('scale must be an array');
        }
        (0,_stat__WEBPACK_IMPORTED_MODULE_2__.scaleByColumn)(this, scale);
        return this;
      }
      case undefined: {
        if (scale === undefined) {
          scale = (0,_stat__WEBPACK_IMPORTED_MODULE_2__.getScaleAll)(this);
        } else if (typeof scale !== 'number') {
          throw new TypeError('scale must be a number');
        }
        (0,_stat__WEBPACK_IMPORTED_MODULE_2__.scaleAll)(this, scale);
        return this;
      }
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }

  toString(options) {
    return (0,_inspect__WEBPACK_IMPORTED_MODULE_3__.inspectMatrixWithOptions)(this, options);
  }
}

AbstractMatrix.prototype.klass = 'Matrix';
if (typeof Symbol !== 'undefined') {
  AbstractMatrix.prototype[
    Symbol.for('nodejs.util.inspect.custom')
  ] = _inspect__WEBPACK_IMPORTED_MODULE_3__.inspectMatrix;
}

function compareNumbers(a, b) {
  return a - b;
}

// Synonyms
AbstractMatrix.random = AbstractMatrix.rand;
AbstractMatrix.randomInt = AbstractMatrix.randInt;
AbstractMatrix.diagonal = AbstractMatrix.diag;
AbstractMatrix.prototype.diagonal = AbstractMatrix.prototype.diag;
AbstractMatrix.identity = AbstractMatrix.eye;
AbstractMatrix.prototype.negate = AbstractMatrix.prototype.neg;
AbstractMatrix.prototype.tensorProduct =
  AbstractMatrix.prototype.kroneckerProduct;

class Matrix extends AbstractMatrix {
  constructor(nRows, nColumns) {
    super();
    if (Matrix.isMatrix(nRows)) {
      return nRows.clone();
    } else if (Number.isInteger(nRows) && nRows > 0) {
      // Create an empty matrix
      this.data = [];
      if (Number.isInteger(nColumns) && nColumns > 0) {
        for (let i = 0; i < nRows; i++) {
          this.data.push(new Float64Array(nColumns));
        }
      } else {
        throw new TypeError('nColumns must be a positive integer');
      }
    } else if (Array.isArray(nRows)) {
      // Copy the values from the 2D array
      const arrayData = nRows;
      nRows = arrayData.length;
      nColumns = arrayData[0].length;
      if (typeof nColumns !== 'number' || nColumns === 0) {
        throw new TypeError(
          'Data must be a 2D array with at least one element',
        );
      }
      this.data = [];
      for (let i = 0; i < nRows; i++) {
        if (arrayData[i].length !== nColumns) {
          throw new RangeError('Inconsistent array dimensions');
        }
        this.data.push(Float64Array.from(arrayData[i]));
      }
    } else {
      throw new TypeError(
        'First argument must be a positive number or an array',
      );
    }
    this.rows = nRows;
    this.columns = nColumns;
    return this;
  }

  set(rowIndex, columnIndex, value) {
    this.data[rowIndex][columnIndex] = value;
    return this;
  }

  get(rowIndex, columnIndex) {
    return this.data[rowIndex][columnIndex];
  }

  removeRow(index) {
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowIndex)(this, index);
    if (this.rows === 1) {
      throw new RangeError('A matrix cannot have less than one row');
    }
    this.data.splice(index, 1);
    this.rows -= 1;
    return this;
  }

  addRow(index, array) {
    if (array === undefined) {
      array = index;
      index = this.rows;
    }
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowIndex)(this, index, true);
    array = Float64Array.from((0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowVector)(this, array, true));
    this.data.splice(index, 0, array);
    this.rows += 1;
    return this;
  }

  removeColumn(index) {
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnIndex)(this, index);
    if (this.columns === 1) {
      throw new RangeError('A matrix cannot have less than one column');
    }
    for (let i = 0; i < this.rows; i++) {
      const newRow = new Float64Array(this.columns - 1);
      for (let j = 0; j < index; j++) {
        newRow[j] = this.data[i][j];
      }
      for (let j = index + 1; j < this.columns; j++) {
        newRow[j - 1] = this.data[i][j];
      }
      this.data[i] = newRow;
    }
    this.columns -= 1;
    return this;
  }

  addColumn(index, array) {
    if (typeof array === 'undefined') {
      array = index;
      index = this.columns;
    }
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnIndex)(this, index, true);
    array = (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnVector)(this, array);
    for (let i = 0; i < this.rows; i++) {
      const newRow = new Float64Array(this.columns + 1);
      let j = 0;
      for (; j < index; j++) {
        newRow[j] = this.data[i][j];
      }
      newRow[j++] = array[i];
      for (; j < this.columns + 1; j++) {
        newRow[j] = this.data[i][j - 1];
      }
      this.data[i] = newRow;
    }
    this.columns += 1;
    return this;
  }
}

(0,_mathOperations__WEBPACK_IMPORTED_MODULE_4__.installMathOperations)(AbstractMatrix, Matrix);


/***/ }),

/***/ "./node_modules/ml-matrix/src/stat.js":
/*!********************************************!*\
  !*** ./node_modules/ml-matrix/src/stat.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   centerAll: () => (/* binding */ centerAll),
/* harmony export */   centerByColumn: () => (/* binding */ centerByColumn),
/* harmony export */   centerByRow: () => (/* binding */ centerByRow),
/* harmony export */   getScaleAll: () => (/* binding */ getScaleAll),
/* harmony export */   getScaleByColumn: () => (/* binding */ getScaleByColumn),
/* harmony export */   getScaleByRow: () => (/* binding */ getScaleByRow),
/* harmony export */   productAll: () => (/* binding */ productAll),
/* harmony export */   productByColumn: () => (/* binding */ productByColumn),
/* harmony export */   productByRow: () => (/* binding */ productByRow),
/* harmony export */   scaleAll: () => (/* binding */ scaleAll),
/* harmony export */   scaleByColumn: () => (/* binding */ scaleByColumn),
/* harmony export */   scaleByRow: () => (/* binding */ scaleByRow),
/* harmony export */   sumAll: () => (/* binding */ sumAll),
/* harmony export */   sumByColumn: () => (/* binding */ sumByColumn),
/* harmony export */   sumByRow: () => (/* binding */ sumByRow),
/* harmony export */   varianceAll: () => (/* binding */ varianceAll),
/* harmony export */   varianceByColumn: () => (/* binding */ varianceByColumn),
/* harmony export */   varianceByRow: () => (/* binding */ varianceByRow)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/ml-matrix/src/util.js");


function sumByRow(matrix) {
  let sum = (0,_util__WEBPACK_IMPORTED_MODULE_0__.newArray)(matrix.rows);
  for (let i = 0; i < matrix.rows; ++i) {
    for (let j = 0; j < matrix.columns; ++j) {
      sum[i] += matrix.get(i, j);
    }
  }
  return sum;
}

function sumByColumn(matrix) {
  let sum = (0,_util__WEBPACK_IMPORTED_MODULE_0__.newArray)(matrix.columns);
  for (let i = 0; i < matrix.rows; ++i) {
    for (let j = 0; j < matrix.columns; ++j) {
      sum[j] += matrix.get(i, j);
    }
  }
  return sum;
}

function sumAll(matrix) {
  let v = 0;
  for (let i = 0; i < matrix.rows; i++) {
    for (let j = 0; j < matrix.columns; j++) {
      v += matrix.get(i, j);
    }
  }
  return v;
}

function productByRow(matrix) {
  let sum = (0,_util__WEBPACK_IMPORTED_MODULE_0__.newArray)(matrix.rows, 1);
  for (let i = 0; i < matrix.rows; ++i) {
    for (let j = 0; j < matrix.columns; ++j) {
      sum[i] *= matrix.get(i, j);
    }
  }
  return sum;
}

function productByColumn(matrix) {
  let sum = (0,_util__WEBPACK_IMPORTED_MODULE_0__.newArray)(matrix.columns, 1);
  for (let i = 0; i < matrix.rows; ++i) {
    for (let j = 0; j < matrix.columns; ++j) {
      sum[j] *= matrix.get(i, j);
    }
  }
  return sum;
}

function productAll(matrix) {
  let v = 1;
  for (let i = 0; i < matrix.rows; i++) {
    for (let j = 0; j < matrix.columns; j++) {
      v *= matrix.get(i, j);
    }
  }
  return v;
}

function varianceByRow(matrix, unbiased, mean) {
  const rows = matrix.rows;
  const cols = matrix.columns;
  const variance = [];

  for (let i = 0; i < rows; i++) {
    let sum1 = 0;
    let sum2 = 0;
    let x = 0;
    for (let j = 0; j < cols; j++) {
      x = matrix.get(i, j) - mean[i];
      sum1 += x;
      sum2 += x * x;
    }
    if (unbiased) {
      variance.push((sum2 - (sum1 * sum1) / cols) / (cols - 1));
    } else {
      variance.push((sum2 - (sum1 * sum1) / cols) / cols);
    }
  }
  return variance;
}

function varianceByColumn(matrix, unbiased, mean) {
  const rows = matrix.rows;
  const cols = matrix.columns;
  const variance = [];

  for (let j = 0; j < cols; j++) {
    let sum1 = 0;
    let sum2 = 0;
    let x = 0;
    for (let i = 0; i < rows; i++) {
      x = matrix.get(i, j) - mean[j];
      sum1 += x;
      sum2 += x * x;
    }
    if (unbiased) {
      variance.push((sum2 - (sum1 * sum1) / rows) / (rows - 1));
    } else {
      variance.push((sum2 - (sum1 * sum1) / rows) / rows);
    }
  }
  return variance;
}

function varianceAll(matrix, unbiased, mean) {
  const rows = matrix.rows;
  const cols = matrix.columns;
  const size = rows * cols;

  let sum1 = 0;
  let sum2 = 0;
  let x = 0;
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      x = matrix.get(i, j) - mean;
      sum1 += x;
      sum2 += x * x;
    }
  }
  if (unbiased) {
    return (sum2 - (sum1 * sum1) / size) / (size - 1);
  } else {
    return (sum2 - (sum1 * sum1) / size) / size;
  }
}

function centerByRow(matrix, mean) {
  for (let i = 0; i < matrix.rows; i++) {
    for (let j = 0; j < matrix.columns; j++) {
      matrix.set(i, j, matrix.get(i, j) - mean[i]);
    }
  }
}

function centerByColumn(matrix, mean) {
  for (let i = 0; i < matrix.rows; i++) {
    for (let j = 0; j < matrix.columns; j++) {
      matrix.set(i, j, matrix.get(i, j) - mean[j]);
    }
  }
}

function centerAll(matrix, mean) {
  for (let i = 0; i < matrix.rows; i++) {
    for (let j = 0; j < matrix.columns; j++) {
      matrix.set(i, j, matrix.get(i, j) - mean);
    }
  }
}

function getScaleByRow(matrix) {
  const scale = [];
  for (let i = 0; i < matrix.rows; i++) {
    let sum = 0;
    for (let j = 0; j < matrix.columns; j++) {
      sum += Math.pow(matrix.get(i, j), 2) / (matrix.columns - 1);
    }
    scale.push(Math.sqrt(sum));
  }
  return scale;
}

function scaleByRow(matrix, scale) {
  for (let i = 0; i < matrix.rows; i++) {
    for (let j = 0; j < matrix.columns; j++) {
      matrix.set(i, j, matrix.get(i, j) / scale[i]);
    }
  }
}

function getScaleByColumn(matrix) {
  const scale = [];
  for (let j = 0; j < matrix.columns; j++) {
    let sum = 0;
    for (let i = 0; i < matrix.rows; i++) {
      sum += Math.pow(matrix.get(i, j), 2) / (matrix.rows - 1);
    }
    scale.push(Math.sqrt(sum));
  }
  return scale;
}

function scaleByColumn(matrix, scale) {
  for (let i = 0; i < matrix.rows; i++) {
    for (let j = 0; j < matrix.columns; j++) {
      matrix.set(i, j, matrix.get(i, j) / scale[j]);
    }
  }
}

function getScaleAll(matrix) {
  const divider = matrix.size - 1;
  let sum = 0;
  for (let j = 0; j < matrix.columns; j++) {
    for (let i = 0; i < matrix.rows; i++) {
      sum += Math.pow(matrix.get(i, j), 2) / divider;
    }
  }
  return Math.sqrt(sum);
}

function scaleAll(matrix, scale) {
  for (let i = 0; i < matrix.rows; i++) {
    for (let j = 0; j < matrix.columns; j++) {
      matrix.set(i, j, matrix.get(i, j) / scale);
    }
  }
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/util.js":
/*!********************************************!*\
  !*** ./node_modules/ml-matrix/src/util.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkColumnIndex: () => (/* binding */ checkColumnIndex),
/* harmony export */   checkColumnIndices: () => (/* binding */ checkColumnIndices),
/* harmony export */   checkColumnVector: () => (/* binding */ checkColumnVector),
/* harmony export */   checkIndices: () => (/* binding */ checkIndices),
/* harmony export */   checkRange: () => (/* binding */ checkRange),
/* harmony export */   checkRowIndex: () => (/* binding */ checkRowIndex),
/* harmony export */   checkRowIndices: () => (/* binding */ checkRowIndices),
/* harmony export */   checkRowVector: () => (/* binding */ checkRowVector),
/* harmony export */   newArray: () => (/* binding */ newArray)
/* harmony export */ });
/**
 * @private
 * Check that a row index is not out of bounds
 * @param {Matrix} matrix
 * @param {number} index
 * @param {boolean} [outer]
 */
function checkRowIndex(matrix, index, outer) {
  let max = outer ? matrix.rows : matrix.rows - 1;
  if (index < 0 || index > max) {
    throw new RangeError('Row index out of range');
  }
}

/**
 * @private
 * Check that a column index is not out of bounds
 * @param {Matrix} matrix
 * @param {number} index
 * @param {boolean} [outer]
 */
function checkColumnIndex(matrix, index, outer) {
  let max = outer ? matrix.columns : matrix.columns - 1;
  if (index < 0 || index > max) {
    throw new RangeError('Column index out of range');
  }
}

/**
 * @private
 * Check that the provided vector is an array with the right length
 * @param {Matrix} matrix
 * @param {Array|Matrix} vector
 * @return {Array}
 * @throws {RangeError}
 */
function checkRowVector(matrix, vector) {
  if (vector.to1DArray) {
    vector = vector.to1DArray();
  }
  if (vector.length !== matrix.columns) {
    throw new RangeError(
      'vector size must be the same as the number of columns',
    );
  }
  return vector;
}

/**
 * @private
 * Check that the provided vector is an array with the right length
 * @param {Matrix} matrix
 * @param {Array|Matrix} vector
 * @return {Array}
 * @throws {RangeError}
 */
function checkColumnVector(matrix, vector) {
  if (vector.to1DArray) {
    vector = vector.to1DArray();
  }
  if (vector.length !== matrix.rows) {
    throw new RangeError('vector size must be the same as the number of rows');
  }
  return vector;
}

function checkIndices(matrix, rowIndices, columnIndices) {
  return {
    row: checkRowIndices(matrix, rowIndices),
    column: checkColumnIndices(matrix, columnIndices),
  };
}

function checkRowIndices(matrix, rowIndices) {
  if (typeof rowIndices !== 'object') {
    throw new TypeError('unexpected type for row indices');
  }

  let rowOut = rowIndices.some((r) => {
    return r < 0 || r >= matrix.rows;
  });

  if (rowOut) {
    throw new RangeError('row indices are out of range');
  }

  if (!Array.isArray(rowIndices)) rowIndices = Array.from(rowIndices);

  return rowIndices;
}

function checkColumnIndices(matrix, columnIndices) {
  if (typeof columnIndices !== 'object') {
    throw new TypeError('unexpected type for column indices');
  }

  let columnOut = columnIndices.some((c) => {
    return c < 0 || c >= matrix.columns;
  });

  if (columnOut) {
    throw new RangeError('column indices are out of range');
  }
  if (!Array.isArray(columnIndices)) columnIndices = Array.from(columnIndices);

  return columnIndices;
}

function checkRange(matrix, startRow, endRow, startColumn, endColumn) {
  if (arguments.length !== 5) {
    throw new RangeError('expected 4 arguments');
  }
  checkNumber('startRow', startRow);
  checkNumber('endRow', endRow);
  checkNumber('startColumn', startColumn);
  checkNumber('endColumn', endColumn);
  if (
    startRow > endRow ||
    startColumn > endColumn ||
    startRow < 0 ||
    startRow >= matrix.rows ||
    endRow < 0 ||
    endRow >= matrix.rows ||
    startColumn < 0 ||
    startColumn >= matrix.columns ||
    endColumn < 0 ||
    endColumn >= matrix.columns
  ) {
    throw new RangeError('Submatrix indices are out of range');
  }
}

function newArray(length, value = 0) {
  let array = [];
  for (let i = 0; i < length; i++) {
    array.push(value);
  }
  return array;
}

function checkNumber(name, value) {
  if (typeof value !== 'number') {
    throw new TypeError(`${name} must be a number`);
  }
}


/***/ }),

/***/ "./node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js":
/*!************************************************************!*\
  !*** ./node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WrapperMatrix2D)
/* harmony export */ });
/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matrix */ "./node_modules/ml-matrix/src/matrix.js");


class WrapperMatrix2D extends _matrix__WEBPACK_IMPORTED_MODULE_0__.AbstractMatrix {
  constructor(data) {
    super();
    this.data = data;
    this.rows = data.length;
    this.columns = data[0].length;
  }

  set(rowIndex, columnIndex, value) {
    this.data[rowIndex][columnIndex] = value;
    return this;
  }

  get(rowIndex, columnIndex) {
    return this.data[rowIndex][columnIndex];
  }
}


/***/ }),

/***/ "./node_modules/mousetrap/mousetrap.js":
/*!*********************************************!*\
  !*** ./node_modules/mousetrap/mousetrap.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_RESULT__;/*global define:false */
/**
 * Copyright 2012-2017 Craig Campbell
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Mousetrap is a simple keyboard shortcut library for Javascript with
 * no external dependencies
 *
 * @version 1.6.5
 * @url craig.is/killing/mice
 */
(function(window, document, undefined) {

    // Check if mousetrap is used inside browser, if not, return
    if (!window) {
        return;
    }

    /**
     * mapping of special keycodes to their corresponding keys
     *
     * everything in this dictionary cannot use keypress events
     * so it has to be here to map to the correct keycodes for
     * keyup/keydown events
     *
     * @type {Object}
     */
    var _MAP = {
        8: 'backspace',
        9: 'tab',
        13: 'enter',
        16: 'shift',
        17: 'ctrl',
        18: 'alt',
        20: 'capslock',
        27: 'esc',
        32: 'space',
        33: 'pageup',
        34: 'pagedown',
        35: 'end',
        36: 'home',
        37: 'left',
        38: 'up',
        39: 'right',
        40: 'down',
        45: 'ins',
        46: 'del',
        91: 'meta',
        93: 'meta',
        224: 'meta'
    };

    /**
     * mapping for special characters so they can support
     *
     * this dictionary is only used incase you want to bind a
     * keyup or keydown event to one of these keys
     *
     * @type {Object}
     */
    var _KEYCODE_MAP = {
        106: '*',
        107: '+',
        109: '-',
        110: '.',
        111 : '/',
        186: ';',
        187: '=',
        188: ',',
        189: '-',
        190: '.',
        191: '/',
        192: '`',
        219: '[',
        220: '\\',
        221: ']',
        222: '\''
    };

    /**
     * this is a mapping of keys that require shift on a US keypad
     * back to the non shift equivelents
     *
     * this is so you can use keyup events with these keys
     *
     * note that this will only work reliably on US keyboards
     *
     * @type {Object}
     */
    var _SHIFT_MAP = {
        '~': '`',
        '!': '1',
        '@': '2',
        '#': '3',
        '$': '4',
        '%': '5',
        '^': '6',
        '&': '7',
        '*': '8',
        '(': '9',
        ')': '0',
        '_': '-',
        '+': '=',
        ':': ';',
        '\"': '\'',
        '<': ',',
        '>': '.',
        '?': '/',
        '|': '\\'
    };

    /**
     * this is a list of special strings you can use to map
     * to modifier keys when you specify your keyboard shortcuts
     *
     * @type {Object}
     */
    var _SPECIAL_ALIASES = {
        'option': 'alt',
        'command': 'meta',
        'return': 'enter',
        'escape': 'esc',
        'plus': '+',
        'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'
    };

    /**
     * variable to store the flipped version of _MAP from above
     * needed to check if we should use keypress or not when no action
     * is specified
     *
     * @type {Object|undefined}
     */
    var _REVERSE_MAP;

    /**
     * loop through the f keys, f1 to f19 and add them to the map
     * programatically
     */
    for (var i = 1; i < 20; ++i) {
        _MAP[111 + i] = 'f' + i;
    }

    /**
     * loop through to map numbers on the numeric keypad
     */
    for (i = 0; i <= 9; ++i) {

        // This needs to use a string cause otherwise since 0 is falsey
        // mousetrap will never fire for numpad 0 pressed as part of a keydown
        // event.
        //
        // @see https://github.com/ccampbell/mousetrap/pull/258
        _MAP[i + 96] = i.toString();
    }

    /**
     * cross browser add event method
     *
     * @param {Element|HTMLDocument} object
     * @param {string} type
     * @param {Function} callback
     * @returns void
     */
    function _addEvent(object, type, callback) {
        if (object.addEventListener) {
            object.addEventListener(type, callback, false);
            return;
        }

        object.attachEvent('on' + type, callback);
    }

    /**
     * takes the event and returns the key character
     *
     * @param {Event} e
     * @return {string}
     */
    function _characterFromEvent(e) {

        // for keypress events we should return the character as is
        if (e.type == 'keypress') {
            var character = String.fromCharCode(e.which);

            // if the shift key is not pressed then it is safe to assume
            // that we want the character to be lowercase.  this means if
            // you accidentally have caps lock on then your key bindings
            // will continue to work
            //
            // the only side effect that might not be desired is if you
            // bind something like 'A' cause you want to trigger an
            // event when capital A is pressed caps lock will no longer
            // trigger the event.  shift+a will though.
            if (!e.shiftKey) {
                character = character.toLowerCase();
            }

            return character;
        }

        // for non keypress events the special maps are needed
        if (_MAP[e.which]) {
            return _MAP[e.which];
        }

        if (_KEYCODE_MAP[e.which]) {
            return _KEYCODE_MAP[e.which];
        }

        // if it is not in the special map

        // with keydown and keyup events the character seems to always
        // come in as an uppercase character whether you are pressing shift
        // or not.  we should make sure it is always lowercase for comparisons
        return String.fromCharCode(e.which).toLowerCase();
    }

    /**
     * checks if two arrays are equal
     *
     * @param {Array} modifiers1
     * @param {Array} modifiers2
     * @returns {boolean}
     */
    function _modifiersMatch(modifiers1, modifiers2) {
        return modifiers1.sort().join(',') === modifiers2.sort().join(',');
    }

    /**
     * takes a key event and figures out what the modifiers are
     *
     * @param {Event} e
     * @returns {Array}
     */
    function _eventModifiers(e) {
        var modifiers = [];

        if (e.shiftKey) {
            modifiers.push('shift');
        }

        if (e.altKey) {
            modifiers.push('alt');
        }

        if (e.ctrlKey) {
            modifiers.push('ctrl');
        }

        if (e.metaKey) {
            modifiers.push('meta');
        }

        return modifiers;
    }

    /**
     * prevents default for this event
     *
     * @param {Event} e
     * @returns void
     */
    function _preventDefault(e) {
        if (e.preventDefault) {
            e.preventDefault();
            return;
        }

        e.returnValue = false;
    }

    /**
     * stops propogation for this event
     *
     * @param {Event} e
     * @returns void
     */
    function _stopPropagation(e) {
        if (e.stopPropagation) {
            e.stopPropagation();
            return;
        }

        e.cancelBubble = true;
    }

    /**
     * determines if the keycode specified is a modifier key or not
     *
     * @param {string} key
     * @returns {boolean}
     */
    function _isModifier(key) {
        return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';
    }

    /**
     * reverses the map lookup so that we can look for specific keys
     * to see what can and can't use keypress
     *
     * @return {Object}
     */
    function _getReverseMap() {
        if (!_REVERSE_MAP) {
            _REVERSE_MAP = {};
            for (var key in _MAP) {

                // pull out the numeric keypad from here cause keypress should
                // be able to detect the keys from the character
                if (key > 95 && key < 112) {
                    continue;
                }

                if (_MAP.hasOwnProperty(key)) {
                    _REVERSE_MAP[_MAP[key]] = key;
                }
            }
        }
        return _REVERSE_MAP;
    }

    /**
     * picks the best action based on the key combination
     *
     * @param {string} key - character for key
     * @param {Array} modifiers
     * @param {string=} action passed in
     */
    function _pickBestAction(key, modifiers, action) {

        // if no action was picked in we should try to pick the one
        // that we think would work best for this key
        if (!action) {
            action = _getReverseMap()[key] ? 'keydown' : 'keypress';
        }

        // modifier keys don't work as expected with keypress,
        // switch to keydown
        if (action == 'keypress' && modifiers.length) {
            action = 'keydown';
        }

        return action;
    }

    /**
     * Converts from a string key combination to an array
     *
     * @param  {string} combination like "command+shift+l"
     * @return {Array}
     */
    function _keysFromString(combination) {
        if (combination === '+') {
            return ['+'];
        }

        combination = combination.replace(/\+{2}/g, '+plus');
        return combination.split('+');
    }

    /**
     * Gets info for a specific key combination
     *
     * @param  {string} combination key combination ("command+s" or "a" or "*")
     * @param  {string=} action
     * @returns {Object}
     */
    function _getKeyInfo(combination, action) {
        var keys;
        var key;
        var i;
        var modifiers = [];

        // take the keys from this pattern and figure out what the actual
        // pattern is all about
        keys = _keysFromString(combination);

        for (i = 0; i < keys.length; ++i) {
            key = keys[i];

            // normalize key names
            if (_SPECIAL_ALIASES[key]) {
                key = _SPECIAL_ALIASES[key];
            }

            // if this is not a keypress event then we should
            // be smart about using shift keys
            // this will only work for US keyboards however
            if (action && action != 'keypress' && _SHIFT_MAP[key]) {
                key = _SHIFT_MAP[key];
                modifiers.push('shift');
            }

            // if this key is a modifier then add it to the list of modifiers
            if (_isModifier(key)) {
                modifiers.push(key);
            }
        }

        // depending on what the key combination is
        // we will try to pick the best event for it
        action = _pickBestAction(key, modifiers, action);

        return {
            key: key,
            modifiers: modifiers,
            action: action
        };
    }

    function _belongsTo(element, ancestor) {
        if (element === null || element === document) {
            return false;
        }

        if (element === ancestor) {
            return true;
        }

        return _belongsTo(element.parentNode, ancestor);
    }

    function Mousetrap(targetElement) {
        var self = this;

        targetElement = targetElement || document;

        if (!(self instanceof Mousetrap)) {
            return new Mousetrap(targetElement);
        }

        /**
         * element to attach key events to
         *
         * @type {Element}
         */
        self.target = targetElement;

        /**
         * a list of all the callbacks setup via Mousetrap.bind()
         *
         * @type {Object}
         */
        self._callbacks = {};

        /**
         * direct map of string combinations to callbacks used for trigger()
         *
         * @type {Object}
         */
        self._directMap = {};

        /**
         * keeps track of what level each sequence is at since multiple
         * sequences can start out with the same sequence
         *
         * @type {Object}
         */
        var _sequenceLevels = {};

        /**
         * variable to store the setTimeout call
         *
         * @type {null|number}
         */
        var _resetTimer;

        /**
         * temporary state where we will ignore the next keyup
         *
         * @type {boolean|string}
         */
        var _ignoreNextKeyup = false;

        /**
         * temporary state where we will ignore the next keypress
         *
         * @type {boolean}
         */
        var _ignoreNextKeypress = false;

        /**
         * are we currently inside of a sequence?
         * type of action ("keyup" or "keydown" or "keypress") or false
         *
         * @type {boolean|string}
         */
        var _nextExpectedAction = false;

        /**
         * resets all sequence counters except for the ones passed in
         *
         * @param {Object} doNotReset
         * @returns void
         */
        function _resetSequences(doNotReset) {
            doNotReset = doNotReset || {};

            var activeSequences = false,
                key;

            for (key in _sequenceLevels) {
                if (doNotReset[key]) {
                    activeSequences = true;
                    continue;
                }
                _sequenceLevels[key] = 0;
            }

            if (!activeSequences) {
                _nextExpectedAction = false;
            }
        }

        /**
         * finds all callbacks that match based on the keycode, modifiers,
         * and action
         *
         * @param {string} character
         * @param {Array} modifiers
         * @param {Event|Object} e
         * @param {string=} sequenceName - name of the sequence we are looking for
         * @param {string=} combination
         * @param {number=} level
         * @returns {Array}
         */
        function _getMatches(character, modifiers, e, sequenceName, combination, level) {
            var i;
            var callback;
            var matches = [];
            var action = e.type;

            // if there are no events related to this keycode
            if (!self._callbacks[character]) {
                return [];
            }

            // if a modifier key is coming up on its own we should allow it
            if (action == 'keyup' && _isModifier(character)) {
                modifiers = [character];
            }

            // loop through all callbacks for the key that was pressed
            // and see if any of them match
            for (i = 0; i < self._callbacks[character].length; ++i) {
                callback = self._callbacks[character][i];

                // if a sequence name is not specified, but this is a sequence at
                // the wrong level then move onto the next match
                if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {
                    continue;
                }

                // if the action we are looking for doesn't match the action we got
                // then we should keep going
                if (action != callback.action) {
                    continue;
                }

                // if this is a keypress event and the meta key and control key
                // are not pressed that means that we need to only look at the
                // character, otherwise check the modifiers as well
                //
                // chrome will not fire a keypress if meta or control is down
                // safari will fire a keypress if meta or meta+shift is down
                // firefox will fire a keypress if meta or control is down
                if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {

                    // when you bind a combination or sequence a second time it
                    // should overwrite the first one.  if a sequenceName or
                    // combination is specified in this call it does just that
                    //
                    // @todo make deleting its own method?
                    var deleteCombo = !sequenceName && callback.combo == combination;
                    var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;
                    if (deleteCombo || deleteSequence) {
                        self._callbacks[character].splice(i, 1);
                    }

                    matches.push(callback);
                }
            }

            return matches;
        }

        /**
         * actually calls the callback function
         *
         * if your callback function returns false this will use the jquery
         * convention - prevent default and stop propogation on the event
         *
         * @param {Function} callback
         * @param {Event} e
         * @returns void
         */
        function _fireCallback(callback, e, combo, sequence) {

            // if this event should not happen stop here
            if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {
                return;
            }

            if (callback(e, combo) === false) {
                _preventDefault(e);
                _stopPropagation(e);
            }
        }

        /**
         * handles a character key event
         *
         * @param {string} character
         * @param {Array} modifiers
         * @param {Event} e
         * @returns void
         */
        self._handleKey = function(character, modifiers, e) {
            var callbacks = _getMatches(character, modifiers, e);
            var i;
            var doNotReset = {};
            var maxLevel = 0;
            var processedSequenceCallback = false;

            // Calculate the maxLevel for sequences so we can only execute the longest callback sequence
            for (i = 0; i < callbacks.length; ++i) {
                if (callbacks[i].seq) {
                    maxLevel = Math.max(maxLevel, callbacks[i].level);
                }
            }

            // loop through matching callbacks for this key event
            for (i = 0; i < callbacks.length; ++i) {

                // fire for all sequence callbacks
                // this is because if for example you have multiple sequences
                // bound such as "g i" and "g t" they both need to fire the
                // callback for matching g cause otherwise you can only ever
                // match the first one
                if (callbacks[i].seq) {

                    // only fire callbacks for the maxLevel to prevent
                    // subsequences from also firing
                    //
                    // for example 'a option b' should not cause 'option b' to fire
                    // even though 'option b' is part of the other sequence
                    //
                    // any sequences that do not match here will be discarded
                    // below by the _resetSequences call
                    if (callbacks[i].level != maxLevel) {
                        continue;
                    }

                    processedSequenceCallback = true;

                    // keep a list of which sequences were matches for later
                    doNotReset[callbacks[i].seq] = 1;
                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);
                    continue;
                }

                // if there were no sequence matches but we are still here
                // that means this is a regular match so we should fire that
                if (!processedSequenceCallback) {
                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo);
                }
            }

            // if the key you pressed matches the type of sequence without
            // being a modifier (ie "keyup" or "keypress") then we should
            // reset all sequences that were not matched by this event
            //
            // this is so, for example, if you have the sequence "h a t" and you
            // type "h e a r t" it does not match.  in this case the "e" will
            // cause the sequence to reset
            //
            // modifier keys are ignored because you can have a sequence
            // that contains modifiers such as "enter ctrl+space" and in most
            // cases the modifier key will be pressed before the next key
            //
            // also if you have a sequence such as "ctrl+b a" then pressing the
            // "b" key will trigger a "keypress" and a "keydown"
            //
            // the "keydown" is expected when there is a modifier, but the
            // "keypress" ends up matching the _nextExpectedAction since it occurs
            // after and that causes the sequence to reset
            //
            // we ignore keypresses in a sequence that directly follow a keydown
            // for the same character
            var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;
            if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {
                _resetSequences(doNotReset);
            }

            _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';
        };

        /**
         * handles a keydown event
         *
         * @param {Event} e
         * @returns void
         */
        function _handleKeyEvent(e) {

            // normalize e.which for key events
            // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion
            if (typeof e.which !== 'number') {
                e.which = e.keyCode;
            }

            var character = _characterFromEvent(e);

            // no character found then stop
            if (!character) {
                return;
            }

            // need to use === for the character check because the character can be 0
            if (e.type == 'keyup' && _ignoreNextKeyup === character) {
                _ignoreNextKeyup = false;
                return;
            }

            self.handleKey(character, _eventModifiers(e), e);
        }

        /**
         * called to set a 1 second timeout on the specified sequence
         *
         * this is so after each key press in the sequence you have 1 second
         * to press the next key before you have to start over
         *
         * @returns void
         */
        function _resetSequenceTimer() {
            clearTimeout(_resetTimer);
            _resetTimer = setTimeout(_resetSequences, 1000);
        }

        /**
         * binds a key sequence to an event
         *
         * @param {string} combo - combo specified in bind call
         * @param {Array} keys
         * @param {Function} callback
         * @param {string=} action
         * @returns void
         */
        function _bindSequence(combo, keys, callback, action) {

            // start off by adding a sequence level record for this combination
            // and setting the level to 0
            _sequenceLevels[combo] = 0;

            /**
             * callback to increase the sequence level for this sequence and reset
             * all other sequences that were active
             *
             * @param {string} nextAction
             * @returns {Function}
             */
            function _increaseSequence(nextAction) {
                return function() {
                    _nextExpectedAction = nextAction;
                    ++_sequenceLevels[combo];
                    _resetSequenceTimer();
                };
            }

            /**
             * wraps the specified callback inside of another function in order
             * to reset all sequence counters as soon as this sequence is done
             *
             * @param {Event} e
             * @returns void
             */
            function _callbackAndReset(e) {
                _fireCallback(callback, e, combo);

                // we should ignore the next key up if the action is key down
                // or keypress.  this is so if you finish a sequence and
                // release the key the final key will not trigger a keyup
                if (action !== 'keyup') {
                    _ignoreNextKeyup = _characterFromEvent(e);
                }

                // weird race condition if a sequence ends with the key
                // another sequence begins with
                setTimeout(_resetSequences, 10);
            }

            // loop through keys one at a time and bind the appropriate callback
            // function.  for any key leading up to the final one it should
            // increase the sequence. after the final, it should reset all sequences
            //
            // if an action is specified in the original bind call then that will
            // be used throughout.  otherwise we will pass the action that the
            // next key in the sequence should match.  this allows a sequence
            // to mix and match keypress and keydown events depending on which
            // ones are better suited to the key provided
            for (var i = 0; i < keys.length; ++i) {
                var isFinal = i + 1 === keys.length;
                var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);
                _bindSingle(keys[i], wrappedCallback, action, combo, i);
            }
        }

        /**
         * binds a single keyboard combination
         *
         * @param {string} combination
         * @param {Function} callback
         * @param {string=} action
         * @param {string=} sequenceName - name of sequence if part of sequence
         * @param {number=} level - what part of the sequence the command is
         * @returns void
         */
        function _bindSingle(combination, callback, action, sequenceName, level) {

            // store a direct mapped reference for use with Mousetrap.trigger
            self._directMap[combination + ':' + action] = callback;

            // make sure multiple spaces in a row become a single space
            combination = combination.replace(/\s+/g, ' ');

            var sequence = combination.split(' ');
            var info;

            // if this pattern is a sequence of keys then run through this method
            // to reprocess each pattern one key at a time
            if (sequence.length > 1) {
                _bindSequence(combination, sequence, callback, action);
                return;
            }

            info = _getKeyInfo(combination, action);

            // make sure to initialize array if this is the first time
            // a callback is added for this key
            self._callbacks[info.key] = self._callbacks[info.key] || [];

            // remove an existing match if there is one
            _getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level);

            // add this call back to the array
            // if it is a sequence put it at the beginning
            // if not put it at the end
            //
            // this is important because the way these are processed expects
            // the sequence ones to come first
            self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({
                callback: callback,
                modifiers: info.modifiers,
                action: info.action,
                seq: sequenceName,
                level: level,
                combo: combination
            });
        }

        /**
         * binds multiple combinations to the same callback
         *
         * @param {Array} combinations
         * @param {Function} callback
         * @param {string|undefined} action
         * @returns void
         */
        self._bindMultiple = function(combinations, callback, action) {
            for (var i = 0; i < combinations.length; ++i) {
                _bindSingle(combinations[i], callback, action);
            }
        };

        // start!
        _addEvent(targetElement, 'keypress', _handleKeyEvent);
        _addEvent(targetElement, 'keydown', _handleKeyEvent);
        _addEvent(targetElement, 'keyup', _handleKeyEvent);
    }

    /**
     * binds an event to mousetrap
     *
     * can be a single key, a combination of keys separated with +,
     * an array of keys, or a sequence of keys separated by spaces
     *
     * be sure to list the modifier keys first to make sure that the
     * correct key ends up getting bound (the last key in the pattern)
     *
     * @param {string|Array} keys
     * @param {Function} callback
     * @param {string=} action - 'keypress', 'keydown', or 'keyup'
     * @returns void
     */
    Mousetrap.prototype.bind = function(keys, callback, action) {
        var self = this;
        keys = keys instanceof Array ? keys : [keys];
        self._bindMultiple.call(self, keys, callback, action);
        return self;
    };

    /**
     * unbinds an event to mousetrap
     *
     * the unbinding sets the callback function of the specified key combo
     * to an empty function and deletes the corresponding key in the
     * _directMap dict.
     *
     * TODO: actually remove this from the _callbacks dictionary instead
     * of binding an empty function
     *
     * the keycombo+action has to be exactly the same as
     * it was defined in the bind method
     *
     * @param {string|Array} keys
     * @param {string} action
     * @returns void
     */
    Mousetrap.prototype.unbind = function(keys, action) {
        var self = this;
        return self.bind.call(self, keys, function() {}, action);
    };

    /**
     * triggers an event that has already been bound
     *
     * @param {string} keys
     * @param {string=} action
     * @returns void
     */
    Mousetrap.prototype.trigger = function(keys, action) {
        var self = this;
        if (self._directMap[keys + ':' + action]) {
            self._directMap[keys + ':' + action]({}, keys);
        }
        return self;
    };

    /**
     * resets the library back to its initial state.  this is useful
     * if you want to clear out the current keyboard shortcuts and bind
     * new ones - for example if you switch to another page
     *
     * @returns void
     */
    Mousetrap.prototype.reset = function() {
        var self = this;
        self._callbacks = {};
        self._directMap = {};
        return self;
    };

    /**
     * should we stop this event before firing off callbacks
     *
     * @param {Event} e
     * @param {Element} element
     * @return {boolean}
     */
    Mousetrap.prototype.stopCallback = function(e, element) {
        var self = this;

        // if the element has the class "mousetrap" then no need to stop
        if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {
            return false;
        }

        if (_belongsTo(element, self.target)) {
            return false;
        }

        // Events originating from a shadow DOM are re-targetted and `e.target` is the shadow host,
        // not the initial event target in the shadow tree. Note that not all events cross the
        // shadow boundary.
        // For shadow trees with `mode: 'open'`, the initial event target is the first element in
        // the event’s composed path. For shadow trees with `mode: 'closed'`, the initial event
        // target cannot be obtained.
        if ('composedPath' in e && typeof e.composedPath === 'function') {
            // For open shadow trees, update `element` so that the following check works.
            var initialEventTarget = e.composedPath()[0];
            if (initialEventTarget !== e.target) {
                element = initialEventTarget;
            }
        }

        // stop for input, select, and textarea
        return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;
    };

    /**
     * exposes _handleKey publicly so it can be overwritten by extensions
     */
    Mousetrap.prototype.handleKey = function() {
        var self = this;
        return self._handleKey.apply(self, arguments);
    };

    /**
     * allow custom key mappings
     */
    Mousetrap.addKeycodes = function(object) {
        for (var key in object) {
            if (object.hasOwnProperty(key)) {
                _MAP[key] = object[key];
            }
        }
        _REVERSE_MAP = null;
    };

    /**
     * Init the global mousetrap functions
     *
     * This method is needed to allow the global mousetrap functions to work
     * now that mousetrap is a constructor function.
     */
    Mousetrap.init = function() {
        var documentMousetrap = Mousetrap(document);
        for (var method in documentMousetrap) {
            if (method.charAt(0) !== '_') {
                Mousetrap[method] = (function(method) {
                    return function() {
                        return documentMousetrap[method].apply(documentMousetrap, arguments);
                    };
                } (method));
            }
        }
    };

    Mousetrap.init();

    // expose mousetrap to the global object
    window.Mousetrap = Mousetrap;

    // expose as a common js module
    if ( true && module.exports) {
        module.exports = Mousetrap;
    }

    // expose mousetrap as an AMD module
    if (true) {
        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
            return Mousetrap;
        }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
}) (typeof window !== 'undefined' ? window : null, typeof  window !== 'undefined' ? document : null);


/***/ }),

/***/ "./node_modules/regl/dist/regl.js":
/*!****************************************!*\
  !*** ./node_modules/regl/dist/regl.js ***!
  \****************************************/
/***/ (function(module) {

(function (global, factory) {
     true ? module.exports = factory() :
    0;
}(this, (function () { 'use strict';

var isTypedArray = function (x) {
  return (
    x instanceof Uint8Array ||
    x instanceof Uint16Array ||
    x instanceof Uint32Array ||
    x instanceof Int8Array ||
    x instanceof Int16Array ||
    x instanceof Int32Array ||
    x instanceof Float32Array ||
    x instanceof Float64Array ||
    x instanceof Uint8ClampedArray
  )
}

var extend = function (base, opts) {
  var keys = Object.keys(opts)
  for (var i = 0; i < keys.length; ++i) {
    base[keys[i]] = opts[keys[i]]
  }
  return base
}

// Error checking and parameter validation.
//
// Statements for the form `check.someProcedure(...)` get removed by
// a browserify transform for optimized/minified bundles.
//
/* globals atob */
var endl = '\n'

// only used for extracting shader names.  if atob not present, then errors
// will be slightly crappier
function decodeB64 (str) {
  if (typeof atob !== 'undefined') {
    return atob(str)
  }
  return 'base64:' + str
}

function raise (message) {
  var error = new Error('(regl) ' + message)
  console.error(error)
  throw error
}

function check (pred, message) {
  if (!pred) {
    raise(message)
  }
}

function encolon (message) {
  if (message) {
    return ': ' + message
  }
  return ''
}

function checkParameter (param, possibilities, message) {
  if (!(param in possibilities)) {
    raise('unknown parameter (' + param + ')' + encolon(message) +
          '. possible values: ' + Object.keys(possibilities).join())
  }
}

function checkIsTypedArray (data, message) {
  if (!isTypedArray(data)) {
    raise(
      'invalid parameter type' + encolon(message) +
      '. must be a typed array')
  }
}

function standardTypeEh (value, type) {
  switch (type) {
    case 'number': return typeof value === 'number'
    case 'object': return typeof value === 'object'
    case 'string': return typeof value === 'string'
    case 'boolean': return typeof value === 'boolean'
    case 'function': return typeof value === 'function'
    case 'undefined': return typeof value === 'undefined'
    case 'symbol': return typeof value === 'symbol'
  }
}

function checkTypeOf (value, type, message) {
  if (!standardTypeEh(value, type)) {
    raise(
      'invalid parameter type' + encolon(message) +
      '. expected ' + type + ', got ' + (typeof value))
  }
}

function checkNonNegativeInt (value, message) {
  if (!((value >= 0) &&
        ((value | 0) === value))) {
    raise('invalid parameter type, (' + value + ')' + encolon(message) +
          '. must be a nonnegative integer')
  }
}

function checkOneOf (value, list, message) {
  if (list.indexOf(value) < 0) {
    raise('invalid value' + encolon(message) + '. must be one of: ' + list)
  }
}

var constructorKeys = [
  'gl',
  'canvas',
  'container',
  'attributes',
  'pixelRatio',
  'extensions',
  'optionalExtensions',
  'profile',
  'onDone'
]

function checkConstructor (obj) {
  Object.keys(obj).forEach(function (key) {
    if (constructorKeys.indexOf(key) < 0) {
      raise('invalid regl constructor argument "' + key + '". must be one of ' + constructorKeys)
    }
  })
}

function leftPad (str, n) {
  str = str + ''
  while (str.length < n) {
    str = ' ' + str
  }
  return str
}

function ShaderFile () {
  this.name = 'unknown'
  this.lines = []
  this.index = {}
  this.hasErrors = false
}

function ShaderLine (number, line) {
  this.number = number
  this.line = line
  this.errors = []
}

function ShaderError (fileNumber, lineNumber, message) {
  this.file = fileNumber
  this.line = lineNumber
  this.message = message
}

function guessCommand () {
  var error = new Error()
  var stack = (error.stack || error).toString()
  var pat = /compileProcedure.*\n\s*at.*\((.*)\)/.exec(stack)
  if (pat) {
    return pat[1]
  }
  var pat2 = /compileProcedure.*\n\s*at\s+(.*)(\n|$)/.exec(stack)
  if (pat2) {
    return pat2[1]
  }
  return 'unknown'
}

function guessCallSite () {
  var error = new Error()
  var stack = (error.stack || error).toString()
  var pat = /at REGLCommand.*\n\s+at.*\((.*)\)/.exec(stack)
  if (pat) {
    return pat[1]
  }
  var pat2 = /at REGLCommand.*\n\s+at\s+(.*)\n/.exec(stack)
  if (pat2) {
    return pat2[1]
  }
  return 'unknown'
}

function parseSource (source, command) {
  var lines = source.split('\n')
  var lineNumber = 1
  var fileNumber = 0
  var files = {
    unknown: new ShaderFile(),
    0: new ShaderFile()
  }
  files.unknown.name = files[0].name = command || guessCommand()
  files.unknown.lines.push(new ShaderLine(0, ''))
  for (var i = 0; i < lines.length; ++i) {
    var line = lines[i]
    var parts = /^\s*#\s*(\w+)\s+(.+)\s*$/.exec(line)
    if (parts) {
      switch (parts[1]) {
        case 'line':
          var lineNumberInfo = /(\d+)(\s+\d+)?/.exec(parts[2])
          if (lineNumberInfo) {
            lineNumber = lineNumberInfo[1] | 0
            if (lineNumberInfo[2]) {
              fileNumber = lineNumberInfo[2] | 0
              if (!(fileNumber in files)) {
                files[fileNumber] = new ShaderFile()
              }
            }
          }
          break
        case 'define':
          var nameInfo = /SHADER_NAME(_B64)?\s+(.*)$/.exec(parts[2])
          if (nameInfo) {
            files[fileNumber].name = (nameInfo[1]
              ? decodeB64(nameInfo[2])
              : nameInfo[2])
          }
          break
      }
    }
    files[fileNumber].lines.push(new ShaderLine(lineNumber++, line))
  }
  Object.keys(files).forEach(function (fileNumber) {
    var file = files[fileNumber]
    file.lines.forEach(function (line) {
      file.index[line.number] = line
    })
  })
  return files
}

function parseErrorLog (errLog) {
  var result = []
  errLog.split('\n').forEach(function (errMsg) {
    if (errMsg.length < 5) {
      return
    }
    var parts = /^ERROR:\s+(\d+):(\d+):\s*(.*)$/.exec(errMsg)
    if (parts) {
      result.push(new ShaderError(
        parts[1] | 0,
        parts[2] | 0,
        parts[3].trim()))
    } else if (errMsg.length > 0) {
      result.push(new ShaderError('unknown', 0, errMsg))
    }
  })
  return result
}

function annotateFiles (files, errors) {
  errors.forEach(function (error) {
    var file = files[error.file]
    if (file) {
      var line = file.index[error.line]
      if (line) {
        line.errors.push(error)
        file.hasErrors = true
        return
      }
    }
    files.unknown.hasErrors = true
    files.unknown.lines[0].errors.push(error)
  })
}

function checkShaderError (gl, shader, source, type, command) {
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    var errLog = gl.getShaderInfoLog(shader)
    var typeName = type === gl.FRAGMENT_SHADER ? 'fragment' : 'vertex'
    checkCommandType(source, 'string', typeName + ' shader source must be a string', command)
    var files = parseSource(source, command)
    var errors = parseErrorLog(errLog)
    annotateFiles(files, errors)

    Object.keys(files).forEach(function (fileNumber) {
      var file = files[fileNumber]
      if (!file.hasErrors) {
        return
      }

      var strings = ['']
      var styles = ['']

      function push (str, style) {
        strings.push(str)
        styles.push(style || '')
      }

      push('file number ' + fileNumber + ': ' + file.name + '\n', 'color:red;text-decoration:underline;font-weight:bold')

      file.lines.forEach(function (line) {
        if (line.errors.length > 0) {
          push(leftPad(line.number, 4) + '|  ', 'background-color:yellow; font-weight:bold')
          push(line.line + endl, 'color:red; background-color:yellow; font-weight:bold')

          // try to guess token
          var offset = 0
          line.errors.forEach(function (error) {
            var message = error.message
            var token = /^\s*'(.*)'\s*:\s*(.*)$/.exec(message)
            if (token) {
              var tokenPat = token[1]
              message = token[2]
              switch (tokenPat) {
                case 'assign':
                  tokenPat = '='
                  break
              }
              offset = Math.max(line.line.indexOf(tokenPat, offset), 0)
            } else {
              offset = 0
            }

            push(leftPad('| ', 6))
            push(leftPad('^^^', offset + 3) + endl, 'font-weight:bold')
            push(leftPad('| ', 6))
            push(message + endl, 'font-weight:bold')
          })
          push(leftPad('| ', 6) + endl)
        } else {
          push(leftPad(line.number, 4) + '|  ')
          push(line.line + endl, 'color:red')
        }
      })
      if (typeof document !== 'undefined' && !window.chrome) {
        styles[0] = strings.join('%c')
        console.log.apply(console, styles)
      } else {
        console.log(strings.join(''))
      }
    })

    check.raise('Error compiling ' + typeName + ' shader, ' + files[0].name)
  }
}

function checkLinkError (gl, program, fragShader, vertShader, command) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    var errLog = gl.getProgramInfoLog(program)
    var fragParse = parseSource(fragShader, command)
    var vertParse = parseSource(vertShader, command)

    var header = 'Error linking program with vertex shader, "' +
      vertParse[0].name + '", and fragment shader "' + fragParse[0].name + '"'

    if (typeof document !== 'undefined') {
      console.log('%c' + header + endl + '%c' + errLog,
        'color:red;text-decoration:underline;font-weight:bold',
        'color:red')
    } else {
      console.log(header + endl + errLog)
    }
    check.raise(header)
  }
}

function saveCommandRef (object) {
  object._commandRef = guessCommand()
}

function saveDrawCommandInfo (opts, uniforms, attributes, stringStore) {
  saveCommandRef(opts)

  function id (str) {
    if (str) {
      return stringStore.id(str)
    }
    return 0
  }
  opts._fragId = id(opts.static.frag)
  opts._vertId = id(opts.static.vert)

  function addProps (dict, set) {
    Object.keys(set).forEach(function (u) {
      dict[stringStore.id(u)] = true
    })
  }

  var uniformSet = opts._uniformSet = {}
  addProps(uniformSet, uniforms.static)
  addProps(uniformSet, uniforms.dynamic)

  var attributeSet = opts._attributeSet = {}
  addProps(attributeSet, attributes.static)
  addProps(attributeSet, attributes.dynamic)

  opts._hasCount = (
    'count' in opts.static ||
    'count' in opts.dynamic ||
    'elements' in opts.static ||
    'elements' in opts.dynamic)
}

function commandRaise (message, command) {
  var callSite = guessCallSite()
  raise(message +
    ' in command ' + (command || guessCommand()) +
    (callSite === 'unknown' ? '' : ' called from ' + callSite))
}

function checkCommand (pred, message, command) {
  if (!pred) {
    commandRaise(message, command || guessCommand())
  }
}

function checkParameterCommand (param, possibilities, message, command) {
  if (!(param in possibilities)) {
    commandRaise(
      'unknown parameter (' + param + ')' + encolon(message) +
      '. possible values: ' + Object.keys(possibilities).join(),
      command || guessCommand())
  }
}

function checkCommandType (value, type, message, command) {
  if (!standardTypeEh(value, type)) {
    commandRaise(
      'invalid parameter type' + encolon(message) +
      '. expected ' + type + ', got ' + (typeof value),
      command || guessCommand())
  }
}

function checkOptional (block) {
  block()
}

function checkFramebufferFormat (attachment, texFormats, rbFormats) {
  if (attachment.texture) {
    checkOneOf(
      attachment.texture._texture.internalformat,
      texFormats,
      'unsupported texture format for attachment')
  } else {
    checkOneOf(
      attachment.renderbuffer._renderbuffer.format,
      rbFormats,
      'unsupported renderbuffer format for attachment')
  }
}

var GL_CLAMP_TO_EDGE = 0x812F

var GL_NEAREST = 0x2600
var GL_NEAREST_MIPMAP_NEAREST = 0x2700
var GL_LINEAR_MIPMAP_NEAREST = 0x2701
var GL_NEAREST_MIPMAP_LINEAR = 0x2702
var GL_LINEAR_MIPMAP_LINEAR = 0x2703

var GL_BYTE = 5120
var GL_UNSIGNED_BYTE = 5121
var GL_SHORT = 5122
var GL_UNSIGNED_SHORT = 5123
var GL_INT = 5124
var GL_UNSIGNED_INT = 5125
var GL_FLOAT = 5126

var GL_UNSIGNED_SHORT_4_4_4_4 = 0x8033
var GL_UNSIGNED_SHORT_5_5_5_1 = 0x8034
var GL_UNSIGNED_SHORT_5_6_5 = 0x8363
var GL_UNSIGNED_INT_24_8_WEBGL = 0x84FA

var GL_HALF_FLOAT_OES = 0x8D61

var TYPE_SIZE = {}

TYPE_SIZE[GL_BYTE] =
TYPE_SIZE[GL_UNSIGNED_BYTE] = 1

TYPE_SIZE[GL_SHORT] =
TYPE_SIZE[GL_UNSIGNED_SHORT] =
TYPE_SIZE[GL_HALF_FLOAT_OES] =
TYPE_SIZE[GL_UNSIGNED_SHORT_5_6_5] =
TYPE_SIZE[GL_UNSIGNED_SHORT_4_4_4_4] =
TYPE_SIZE[GL_UNSIGNED_SHORT_5_5_5_1] = 2

TYPE_SIZE[GL_INT] =
TYPE_SIZE[GL_UNSIGNED_INT] =
TYPE_SIZE[GL_FLOAT] =
TYPE_SIZE[GL_UNSIGNED_INT_24_8_WEBGL] = 4

function pixelSize (type, channels) {
  if (type === GL_UNSIGNED_SHORT_5_5_5_1 ||
      type === GL_UNSIGNED_SHORT_4_4_4_4 ||
      type === GL_UNSIGNED_SHORT_5_6_5) {
    return 2
  } else if (type === GL_UNSIGNED_INT_24_8_WEBGL) {
    return 4
  } else {
    return TYPE_SIZE[type] * channels
  }
}

function isPow2 (v) {
  return !(v & (v - 1)) && (!!v)
}

function checkTexture2D (info, mipData, limits) {
  var i
  var w = mipData.width
  var h = mipData.height
  var c = mipData.channels

  // Check texture shape
  check(w > 0 && w <= limits.maxTextureSize &&
        h > 0 && h <= limits.maxTextureSize,
  'invalid texture shape')

  // check wrap mode
  if (info.wrapS !== GL_CLAMP_TO_EDGE || info.wrapT !== GL_CLAMP_TO_EDGE) {
    check(isPow2(w) && isPow2(h),
      'incompatible wrap mode for texture, both width and height must be power of 2')
  }

  if (mipData.mipmask === 1) {
    if (w !== 1 && h !== 1) {
      check(
        info.minFilter !== GL_NEAREST_MIPMAP_NEAREST &&
        info.minFilter !== GL_NEAREST_MIPMAP_LINEAR &&
        info.minFilter !== GL_LINEAR_MIPMAP_NEAREST &&
        info.minFilter !== GL_LINEAR_MIPMAP_LINEAR,
        'min filter requires mipmap')
    }
  } else {
    // texture must be power of 2
    check(isPow2(w) && isPow2(h),
      'texture must be a square power of 2 to support mipmapping')
    check(mipData.mipmask === (w << 1) - 1,
      'missing or incomplete mipmap data')
  }

  if (mipData.type === GL_FLOAT) {
    if (limits.extensions.indexOf('oes_texture_float_linear') < 0) {
      check(info.minFilter === GL_NEAREST && info.magFilter === GL_NEAREST,
        'filter not supported, must enable oes_texture_float_linear')
    }
    check(!info.genMipmaps,
      'mipmap generation not supported with float textures')
  }

  // check image complete
  var mipimages = mipData.images
  for (i = 0; i < 16; ++i) {
    if (mipimages[i]) {
      var mw = w >> i
      var mh = h >> i
      check(mipData.mipmask & (1 << i), 'missing mipmap data')

      var img = mipimages[i]

      check(
        img.width === mw &&
        img.height === mh,
        'invalid shape for mip images')

      check(
        img.format === mipData.format &&
        img.internalformat === mipData.internalformat &&
        img.type === mipData.type,
        'incompatible type for mip image')

      if (img.compressed) {
        // TODO: check size for compressed images
      } else if (img.data) {
        // check(img.data.byteLength === mw * mh *
        // Math.max(pixelSize(img.type, c), img.unpackAlignment),
        var rowSize = Math.ceil(pixelSize(img.type, c) * mw / img.unpackAlignment) * img.unpackAlignment
        check(img.data.byteLength === rowSize * mh,
          'invalid data for image, buffer size is inconsistent with image format')
      } else if (img.element) {
        // TODO: check element can be loaded
      } else if (img.copy) {
        // TODO: check compatible format and type
      }
    } else if (!info.genMipmaps) {
      check((mipData.mipmask & (1 << i)) === 0, 'extra mipmap data')
    }
  }

  if (mipData.compressed) {
    check(!info.genMipmaps,
      'mipmap generation for compressed images not supported')
  }
}

function checkTextureCube (texture, info, faces, limits) {
  var w = texture.width
  var h = texture.height
  var c = texture.channels

  // Check texture shape
  check(
    w > 0 && w <= limits.maxTextureSize && h > 0 && h <= limits.maxTextureSize,
    'invalid texture shape')
  check(
    w === h,
    'cube map must be square')
  check(
    info.wrapS === GL_CLAMP_TO_EDGE && info.wrapT === GL_CLAMP_TO_EDGE,
    'wrap mode not supported by cube map')

  for (var i = 0; i < faces.length; ++i) {
    var face = faces[i]
    check(
      face.width === w && face.height === h,
      'inconsistent cube map face shape')

    if (info.genMipmaps) {
      check(!face.compressed,
        'can not generate mipmap for compressed textures')
      check(face.mipmask === 1,
        'can not specify mipmaps and generate mipmaps')
    } else {
      // TODO: check mip and filter mode
    }

    var mipmaps = face.images
    for (var j = 0; j < 16; ++j) {
      var img = mipmaps[j]
      if (img) {
        var mw = w >> j
        var mh = h >> j
        check(face.mipmask & (1 << j), 'missing mipmap data')
        check(
          img.width === mw &&
          img.height === mh,
          'invalid shape for mip images')
        check(
          img.format === texture.format &&
          img.internalformat === texture.internalformat &&
          img.type === texture.type,
          'incompatible type for mip image')

        if (img.compressed) {
          // TODO: check size for compressed images
        } else if (img.data) {
          check(img.data.byteLength === mw * mh *
            Math.max(pixelSize(img.type, c), img.unpackAlignment),
          'invalid data for image, buffer size is inconsistent with image format')
        } else if (img.element) {
          // TODO: check element can be loaded
        } else if (img.copy) {
          // TODO: check compatible format and type
        }
      }
    }
  }
}

var check$1 = extend(check, {
  optional: checkOptional,
  raise: raise,
  commandRaise: commandRaise,
  command: checkCommand,
  parameter: checkParameter,
  commandParameter: checkParameterCommand,
  constructor: checkConstructor,
  type: checkTypeOf,
  commandType: checkCommandType,
  isTypedArray: checkIsTypedArray,
  nni: checkNonNegativeInt,
  oneOf: checkOneOf,
  shaderError: checkShaderError,
  linkError: checkLinkError,
  callSite: guessCallSite,
  saveCommandRef: saveCommandRef,
  saveDrawInfo: saveDrawCommandInfo,
  framebufferFormat: checkFramebufferFormat,
  guessCommand: guessCommand,
  texture2D: checkTexture2D,
  textureCube: checkTextureCube
});

var VARIABLE_COUNTER = 0

var DYN_FUNC = 0
var DYN_CONSTANT = 5
var DYN_ARRAY = 6

function DynamicVariable (type, data) {
  this.id = (VARIABLE_COUNTER++)
  this.type = type
  this.data = data
}

function escapeStr (str) {
  return str.replace(/\\/g, '\\\\').replace(/"/g, '\\"')
}

function splitParts (str) {
  if (str.length === 0) {
    return []
  }

  var firstChar = str.charAt(0)
  var lastChar = str.charAt(str.length - 1)

  if (str.length > 1 &&
      firstChar === lastChar &&
      (firstChar === '"' || firstChar === "'")) {
    return ['"' + escapeStr(str.substr(1, str.length - 2)) + '"']
  }

  var parts = /\[(false|true|null|\d+|'[^']*'|"[^"]*")\]/.exec(str)
  if (parts) {
    return (
      splitParts(str.substr(0, parts.index))
        .concat(splitParts(parts[1]))
        .concat(splitParts(str.substr(parts.index + parts[0].length)))
    )
  }

  var subparts = str.split('.')
  if (subparts.length === 1) {
    return ['"' + escapeStr(str) + '"']
  }

  var result = []
  for (var i = 0; i < subparts.length; ++i) {
    result = result.concat(splitParts(subparts[i]))
  }
  return result
}

function toAccessorString (str) {
  return '[' + splitParts(str).join('][') + ']'
}

function defineDynamic (type, data) {
  return new DynamicVariable(type, toAccessorString(data + ''))
}

function isDynamic (x) {
  return (typeof x === 'function' && !x._reglType) || (x instanceof DynamicVariable)
}

function unbox (x, path) {
  if (typeof x === 'function') {
    return new DynamicVariable(DYN_FUNC, x)
  } else if (typeof x === 'number' || typeof x === 'boolean') {
    return new DynamicVariable(DYN_CONSTANT, x)
  } else if (Array.isArray(x)) {
    return new DynamicVariable(DYN_ARRAY, x.map((y, i) => unbox(y, path + '[' + i + ']')))
  } else if (x instanceof DynamicVariable) {
    return x
  }
  check$1(false, 'invalid option type in uniform ' + path)
}

var dynamic = {
  DynamicVariable: DynamicVariable,
  define: defineDynamic,
  isDynamic: isDynamic,
  unbox: unbox,
  accessor: toAccessorString
};

/* globals requestAnimationFrame, cancelAnimationFrame */
var raf = {
  next: typeof requestAnimationFrame === 'function'
    ? function (cb) { return requestAnimationFrame(cb) }
    : function (cb) { return setTimeout(cb, 16) },
  cancel: typeof cancelAnimationFrame === 'function'
    ? function (raf) { return cancelAnimationFrame(raf) }
    : clearTimeout
};

/* globals performance */
var clock = (typeof performance !== 'undefined' && performance.now)
    ? function () { return performance.now() }
    : function () { return +(new Date()) };

function createStringStore () {
  var stringIds = { '': 0 }
  var stringValues = ['']
  return {
    id: function (str) {
      var result = stringIds[str]
      if (result) {
        return result
      }
      result = stringIds[str] = stringValues.length
      stringValues.push(str)
      return result
    },

    str: function (id) {
      return stringValues[id]
    }
  }
}

// Context and canvas creation helper functions
function createCanvas (element, onDone, pixelRatio) {
  var canvas = document.createElement('canvas')
  extend(canvas.style, {
    border: 0,
    margin: 0,
    padding: 0,
    top: 0,
    left: 0
  })
  element.appendChild(canvas)

  if (element === document.body) {
    canvas.style.position = 'absolute'
    extend(element.style, {
      margin: 0,
      padding: 0
    })
  }

  function resize () {
    var w = window.innerWidth
    var h = window.innerHeight
    if (element !== document.body) {
      var bounds = element.getBoundingClientRect()
      w = bounds.right - bounds.left
      h = bounds.bottom - bounds.top
    }
    canvas.width = pixelRatio * w
    canvas.height = pixelRatio * h
    extend(canvas.style, {
      width: w + 'px',
      height: h + 'px'
    })
  }

  var resizeObserver
  if (element !== document.body && typeof ResizeObserver === 'function') {
    // ignore 'ResizeObserver' is not defined
    // eslint-disable-next-line
    resizeObserver = new ResizeObserver(function () {
      // setTimeout to avoid flicker
      setTimeout(resize)
    })
    resizeObserver.observe(element)
  } else {
    window.addEventListener('resize', resize, false)
  }

  function onDestroy () {
    if (resizeObserver) {
      resizeObserver.disconnect()
    } else {
      window.removeEventListener('resize', resize)
    }
    element.removeChild(canvas)
  }

  resize()

  return {
    canvas: canvas,
    onDestroy: onDestroy
  }
}

function createContext (canvas, contextAttributes) {
  function get (name) {
    try {
      return canvas.getContext(name, contextAttributes)
    } catch (e) {
      return null
    }
  }
  return (
    get('webgl') ||
    get('experimental-webgl') ||
    get('webgl-experimental')
  )
}

function isHTMLElement (obj) {
  return (
    typeof obj.nodeName === 'string' &&
    typeof obj.appendChild === 'function' &&
    typeof obj.getBoundingClientRect === 'function'
  )
}

function isWebGLContext (obj) {
  return (
    typeof obj.drawArrays === 'function' ||
    typeof obj.drawElements === 'function'
  )
}

function parseExtensions (input) {
  if (typeof input === 'string') {
    return input.split()
  }
  check$1(Array.isArray(input), 'invalid extension array')
  return input
}

function getElement (desc) {
  if (typeof desc === 'string') {
    check$1(typeof document !== 'undefined', 'not supported outside of DOM')
    return document.querySelector(desc)
  }
  return desc
}

function parseArgs (args_) {
  var args = args_ || {}
  var element, container, canvas, gl
  var contextAttributes = {}
  var extensions = []
  var optionalExtensions = []
  var pixelRatio = (typeof window === 'undefined' ? 1 : window.devicePixelRatio)
  var profile = false
  var onDone = function (err) {
    if (err) {
      check$1.raise(err)
    }
  }
  var onDestroy = function () {}
  if (typeof args === 'string') {
    check$1(
      typeof document !== 'undefined',
      'selector queries only supported in DOM enviroments')
    element = document.querySelector(args)
    check$1(element, 'invalid query string for element')
  } else if (typeof args === 'object') {
    if (isHTMLElement(args)) {
      element = args
    } else if (isWebGLContext(args)) {
      gl = args
      canvas = gl.canvas
    } else {
      check$1.constructor(args)
      if ('gl' in args) {
        gl = args.gl
      } else if ('canvas' in args) {
        canvas = getElement(args.canvas)
      } else if ('container' in args) {
        container = getElement(args.container)
      }
      if ('attributes' in args) {
        contextAttributes = args.attributes
        check$1.type(contextAttributes, 'object', 'invalid context attributes')
      }
      if ('extensions' in args) {
        extensions = parseExtensions(args.extensions)
      }
      if ('optionalExtensions' in args) {
        optionalExtensions = parseExtensions(args.optionalExtensions)
      }
      if ('onDone' in args) {
        check$1.type(
          args.onDone, 'function',
          'invalid or missing onDone callback')
        onDone = args.onDone
      }
      if ('profile' in args) {
        profile = !!args.profile
      }
      if ('pixelRatio' in args) {
        pixelRatio = +args.pixelRatio
        check$1(pixelRatio > 0, 'invalid pixel ratio')
      }
    }
  } else {
    check$1.raise('invalid arguments to regl')
  }

  if (element) {
    if (element.nodeName.toLowerCase() === 'canvas') {
      canvas = element
    } else {
      container = element
    }
  }

  if (!gl) {
    if (!canvas) {
      check$1(
        typeof document !== 'undefined',
        'must manually specify webgl context outside of DOM environments')
      var result = createCanvas(container || document.body, onDone, pixelRatio)
      if (!result) {
        return null
      }
      canvas = result.canvas
      onDestroy = result.onDestroy
    }
    // workaround for chromium bug, premultiplied alpha value is platform dependent
    if (contextAttributes.premultipliedAlpha === undefined) contextAttributes.premultipliedAlpha = true
    gl = createContext(canvas, contextAttributes)
  }

  if (!gl) {
    onDestroy()
    onDone('webgl not supported, try upgrading your browser or graphics drivers http://get.webgl.org')
    return null
  }

  return {
    gl: gl,
    canvas: canvas,
    container: container,
    extensions: extensions,
    optionalExtensions: optionalExtensions,
    pixelRatio: pixelRatio,
    profile: profile,
    onDone: onDone,
    onDestroy: onDestroy
  }
}

function createExtensionCache (gl, config) {
  var extensions = {}

  function tryLoadExtension (name_) {
    check$1.type(name_, 'string', 'extension name must be string')
    var name = name_.toLowerCase()
    var ext
    try {
      ext = extensions[name] = gl.getExtension(name)
    } catch (e) {}
    return !!ext
  }

  for (var i = 0; i < config.extensions.length; ++i) {
    var name = config.extensions[i]
    if (!tryLoadExtension(name)) {
      config.onDestroy()
      config.onDone('"' + name + '" extension is not supported by the current WebGL context, try upgrading your system or a different browser')
      return null
    }
  }

  config.optionalExtensions.forEach(tryLoadExtension)

  return {
    extensions: extensions,
    restore: function () {
      Object.keys(extensions).forEach(function (name) {
        if (extensions[name] && !tryLoadExtension(name)) {
          throw new Error('(regl): error restoring extension ' + name)
        }
      })
    }
  }
}

function loop (n, f) {
  var result = Array(n)
  for (var i = 0; i < n; ++i) {
    result[i] = f(i)
  }
  return result
}

var GL_BYTE$1 = 5120
var GL_UNSIGNED_BYTE$2 = 5121
var GL_SHORT$1 = 5122
var GL_UNSIGNED_SHORT$1 = 5123
var GL_INT$1 = 5124
var GL_UNSIGNED_INT$1 = 5125
var GL_FLOAT$2 = 5126

function nextPow16 (v) {
  for (var i = 16; i <= (1 << 28); i *= 16) {
    if (v <= i) {
      return i
    }
  }
  return 0
}

function log2 (v) {
  var r, shift
  r = (v > 0xFFFF) << 4
  v >>>= r
  shift = (v > 0xFF) << 3
  v >>>= shift; r |= shift
  shift = (v > 0xF) << 2
  v >>>= shift; r |= shift
  shift = (v > 0x3) << 1
  v >>>= shift; r |= shift
  return r | (v >> 1)
}

function createPool () {
  var bufferPool = loop(8, function () {
    return []
  })

  function alloc (n) {
    var sz = nextPow16(n)
    var bin = bufferPool[log2(sz) >> 2]
    if (bin.length > 0) {
      return bin.pop()
    }
    return new ArrayBuffer(sz)
  }

  function free (buf) {
    bufferPool[log2(buf.byteLength) >> 2].push(buf)
  }

  function allocType (type, n) {
    var result = null
    switch (type) {
      case GL_BYTE$1:
        result = new Int8Array(alloc(n), 0, n)
        break
      case GL_UNSIGNED_BYTE$2:
        result = new Uint8Array(alloc(n), 0, n)
        break
      case GL_SHORT$1:
        result = new Int16Array(alloc(2 * n), 0, n)
        break
      case GL_UNSIGNED_SHORT$1:
        result = new Uint16Array(alloc(2 * n), 0, n)
        break
      case GL_INT$1:
        result = new Int32Array(alloc(4 * n), 0, n)
        break
      case GL_UNSIGNED_INT$1:
        result = new Uint32Array(alloc(4 * n), 0, n)
        break
      case GL_FLOAT$2:
        result = new Float32Array(alloc(4 * n), 0, n)
        break
      default:
        return null
    }
    if (result.length !== n) {
      return result.subarray(0, n)
    }
    return result
  }

  function freeType (array) {
    free(array.buffer)
  }

  return {
    alloc: alloc,
    free: free,
    allocType: allocType,
    freeType: freeType
  }
}

var pool = createPool()

// zero pool for initial zero data
pool.zero = createPool()

var GL_SUBPIXEL_BITS = 0x0D50
var GL_RED_BITS = 0x0D52
var GL_GREEN_BITS = 0x0D53
var GL_BLUE_BITS = 0x0D54
var GL_ALPHA_BITS = 0x0D55
var GL_DEPTH_BITS = 0x0D56
var GL_STENCIL_BITS = 0x0D57

var GL_ALIASED_POINT_SIZE_RANGE = 0x846D
var GL_ALIASED_LINE_WIDTH_RANGE = 0x846E

var GL_MAX_TEXTURE_SIZE = 0x0D33
var GL_MAX_VIEWPORT_DIMS = 0x0D3A
var GL_MAX_VERTEX_ATTRIBS = 0x8869
var GL_MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB
var GL_MAX_VARYING_VECTORS = 0x8DFC
var GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D
var GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C
var GL_MAX_TEXTURE_IMAGE_UNITS = 0x8872
var GL_MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD
var GL_MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C
var GL_MAX_RENDERBUFFER_SIZE = 0x84E8

var GL_VENDOR = 0x1F00
var GL_RENDERER = 0x1F01
var GL_VERSION = 0x1F02
var GL_SHADING_LANGUAGE_VERSION = 0x8B8C

var GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FF

var GL_MAX_COLOR_ATTACHMENTS_WEBGL = 0x8CDF
var GL_MAX_DRAW_BUFFERS_WEBGL = 0x8824

var GL_TEXTURE_2D = 0x0DE1
var GL_TEXTURE_CUBE_MAP = 0x8513
var GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515
var GL_TEXTURE0 = 0x84C0
var GL_RGBA = 0x1908
var GL_FLOAT$1 = 0x1406
var GL_UNSIGNED_BYTE$1 = 0x1401
var GL_FRAMEBUFFER = 0x8D40
var GL_FRAMEBUFFER_COMPLETE = 0x8CD5
var GL_COLOR_ATTACHMENT0 = 0x8CE0
var GL_COLOR_BUFFER_BIT$1 = 0x4000

var wrapLimits = function (gl, extensions) {
  var maxAnisotropic = 1
  if (extensions.ext_texture_filter_anisotropic) {
    maxAnisotropic = gl.getParameter(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT)
  }

  var maxDrawbuffers = 1
  var maxColorAttachments = 1
  if (extensions.webgl_draw_buffers) {
    maxDrawbuffers = gl.getParameter(GL_MAX_DRAW_BUFFERS_WEBGL)
    maxColorAttachments = gl.getParameter(GL_MAX_COLOR_ATTACHMENTS_WEBGL)
  }

  // detect if reading float textures is available (Safari doesn't support)
  var readFloat = !!extensions.oes_texture_float
  if (readFloat) {
    var readFloatTexture = gl.createTexture()
    gl.bindTexture(GL_TEXTURE_2D, readFloatTexture)
    gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 1, 1, 0, GL_RGBA, GL_FLOAT$1, null)

    var fbo = gl.createFramebuffer()
    gl.bindFramebuffer(GL_FRAMEBUFFER, fbo)
    gl.framebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, readFloatTexture, 0)
    gl.bindTexture(GL_TEXTURE_2D, null)

    if (gl.checkFramebufferStatus(GL_FRAMEBUFFER) !== GL_FRAMEBUFFER_COMPLETE) readFloat = false

    else {
      gl.viewport(0, 0, 1, 1)
      gl.clearColor(1.0, 0.0, 0.0, 1.0)
      gl.clear(GL_COLOR_BUFFER_BIT$1)
      var pixels = pool.allocType(GL_FLOAT$1, 4)
      gl.readPixels(0, 0, 1, 1, GL_RGBA, GL_FLOAT$1, pixels)

      if (gl.getError()) readFloat = false
      else {
        gl.deleteFramebuffer(fbo)
        gl.deleteTexture(readFloatTexture)

        readFloat = pixels[0] === 1.0
      }

      pool.freeType(pixels)
    }
  }

  // detect non power of two cube textures support (IE doesn't support)
  var isIE = typeof navigator !== 'undefined' && (/MSIE/.test(navigator.userAgent) || /Trident\//.test(navigator.appVersion) || /Edge/.test(navigator.userAgent))

  var npotTextureCube = true

  if (!isIE) {
    var cubeTexture = gl.createTexture()
    var data = pool.allocType(GL_UNSIGNED_BYTE$1, 36)
    gl.activeTexture(GL_TEXTURE0)
    gl.bindTexture(GL_TEXTURE_CUBE_MAP, cubeTexture)
    gl.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, GL_RGBA, 3, 3, 0, GL_RGBA, GL_UNSIGNED_BYTE$1, data)
    pool.freeType(data)
    gl.bindTexture(GL_TEXTURE_CUBE_MAP, null)
    gl.deleteTexture(cubeTexture)
    npotTextureCube = !gl.getError()
  }

  return {
    // drawing buffer bit depth
    colorBits: [
      gl.getParameter(GL_RED_BITS),
      gl.getParameter(GL_GREEN_BITS),
      gl.getParameter(GL_BLUE_BITS),
      gl.getParameter(GL_ALPHA_BITS)
    ],
    depthBits: gl.getParameter(GL_DEPTH_BITS),
    stencilBits: gl.getParameter(GL_STENCIL_BITS),
    subpixelBits: gl.getParameter(GL_SUBPIXEL_BITS),

    // supported extensions
    extensions: Object.keys(extensions).filter(function (ext) {
      return !!extensions[ext]
    }),

    // max aniso samples
    maxAnisotropic: maxAnisotropic,

    // max draw buffers
    maxDrawbuffers: maxDrawbuffers,
    maxColorAttachments: maxColorAttachments,

    // point and line size ranges
    pointSizeDims: gl.getParameter(GL_ALIASED_POINT_SIZE_RANGE),
    lineWidthDims: gl.getParameter(GL_ALIASED_LINE_WIDTH_RANGE),
    maxViewportDims: gl.getParameter(GL_MAX_VIEWPORT_DIMS),
    maxCombinedTextureUnits: gl.getParameter(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS),
    maxCubeMapSize: gl.getParameter(GL_MAX_CUBE_MAP_TEXTURE_SIZE),
    maxRenderbufferSize: gl.getParameter(GL_MAX_RENDERBUFFER_SIZE),
    maxTextureUnits: gl.getParameter(GL_MAX_TEXTURE_IMAGE_UNITS),
    maxTextureSize: gl.getParameter(GL_MAX_TEXTURE_SIZE),
    maxAttributes: gl.getParameter(GL_MAX_VERTEX_ATTRIBS),
    maxVertexUniforms: gl.getParameter(GL_MAX_VERTEX_UNIFORM_VECTORS),
    maxVertexTextureUnits: gl.getParameter(GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    maxVaryingVectors: gl.getParameter(GL_MAX_VARYING_VECTORS),
    maxFragmentUniforms: gl.getParameter(GL_MAX_FRAGMENT_UNIFORM_VECTORS),

    // vendor info
    glsl: gl.getParameter(GL_SHADING_LANGUAGE_VERSION),
    renderer: gl.getParameter(GL_RENDERER),
    vendor: gl.getParameter(GL_VENDOR),
    version: gl.getParameter(GL_VERSION),

    // quirks
    readFloat: readFloat,
    npotTextureCube: npotTextureCube
  }
}

function isNDArrayLike (obj) {
  return (
    !!obj &&
    typeof obj === 'object' &&
    Array.isArray(obj.shape) &&
    Array.isArray(obj.stride) &&
    typeof obj.offset === 'number' &&
    obj.shape.length === obj.stride.length &&
    (Array.isArray(obj.data) ||
      isTypedArray(obj.data)))
}

var values = function (obj) {
  return Object.keys(obj).map(function (key) { return obj[key] })
}

var flattenUtils = {
  shape: arrayShape$1,
  flatten: flattenArray
};

function flatten1D (array, nx, out) {
  for (var i = 0; i < nx; ++i) {
    out[i] = array[i]
  }
}

function flatten2D (array, nx, ny, out) {
  var ptr = 0
  for (var i = 0; i < nx; ++i) {
    var row = array[i]
    for (var j = 0; j < ny; ++j) {
      out[ptr++] = row[j]
    }
  }
}

function flatten3D (array, nx, ny, nz, out, ptr_) {
  var ptr = ptr_
  for (var i = 0; i < nx; ++i) {
    var row = array[i]
    for (var j = 0; j < ny; ++j) {
      var col = row[j]
      for (var k = 0; k < nz; ++k) {
        out[ptr++] = col[k]
      }
    }
  }
}

function flattenRec (array, shape, level, out, ptr) {
  var stride = 1
  for (var i = level + 1; i < shape.length; ++i) {
    stride *= shape[i]
  }
  var n = shape[level]
  if (shape.length - level === 4) {
    var nx = shape[level + 1]
    var ny = shape[level + 2]
    var nz = shape[level + 3]
    for (i = 0; i < n; ++i) {
      flatten3D(array[i], nx, ny, nz, out, ptr)
      ptr += stride
    }
  } else {
    for (i = 0; i < n; ++i) {
      flattenRec(array[i], shape, level + 1, out, ptr)
      ptr += stride
    }
  }
}

function flattenArray (array, shape, type, out_) {
  var sz = 1
  if (shape.length) {
    for (var i = 0; i < shape.length; ++i) {
      sz *= shape[i]
    }
  } else {
    sz = 0
  }
  var out = out_ || pool.allocType(type, sz)
  switch (shape.length) {
    case 0:
      break
    case 1:
      flatten1D(array, shape[0], out)
      break
    case 2:
      flatten2D(array, shape[0], shape[1], out)
      break
    case 3:
      flatten3D(array, shape[0], shape[1], shape[2], out, 0)
      break
    default:
      flattenRec(array, shape, 0, out, 0)
  }
  return out
}

function arrayShape$1 (array_) {
  var shape = []
  for (var array = array_; array.length; array = array[0]) {
    shape.push(array.length)
  }
  return shape
}

var arrayTypes =  {
	"[object Int8Array]": 5120,
	"[object Int16Array]": 5122,
	"[object Int32Array]": 5124,
	"[object Uint8Array]": 5121,
	"[object Uint8ClampedArray]": 5121,
	"[object Uint16Array]": 5123,
	"[object Uint32Array]": 5125,
	"[object Float32Array]": 5126,
	"[object Float64Array]": 5121,
	"[object ArrayBuffer]": 5121
};

var int8 = 5120;
var int16 = 5122;
var int32 = 5124;
var uint8 = 5121;
var uint16 = 5123;
var uint32 = 5125;
var float = 5126;
var float32 = 5126;
var glTypes = {
	int8: int8,
	int16: int16,
	int32: int32,
	uint8: uint8,
	uint16: uint16,
	uint32: uint32,
	float: float,
	float32: float32
};

var dynamic$1 = 35048;
var stream = 35040;
var usageTypes = {
	dynamic: dynamic$1,
	stream: stream,
	"static": 35044
};

var arrayFlatten = flattenUtils.flatten
var arrayShape = flattenUtils.shape

var GL_STATIC_DRAW = 0x88E4
var GL_STREAM_DRAW = 0x88E0

var GL_UNSIGNED_BYTE$3 = 5121
var GL_FLOAT$3 = 5126

var DTYPES_SIZES = []
DTYPES_SIZES[5120] = 1 // int8
DTYPES_SIZES[5122] = 2 // int16
DTYPES_SIZES[5124] = 4 // int32
DTYPES_SIZES[5121] = 1 // uint8
DTYPES_SIZES[5123] = 2 // uint16
DTYPES_SIZES[5125] = 4 // uint32
DTYPES_SIZES[5126] = 4 // float32

function typedArrayCode (data) {
  return arrayTypes[Object.prototype.toString.call(data)] | 0
}

function copyArray (out, inp) {
  for (var i = 0; i < inp.length; ++i) {
    out[i] = inp[i]
  }
}

function transpose (
  result, data, shapeX, shapeY, strideX, strideY, offset) {
  var ptr = 0
  for (var i = 0; i < shapeX; ++i) {
    for (var j = 0; j < shapeY; ++j) {
      result[ptr++] = data[strideX * i + strideY * j + offset]
    }
  }
}

function wrapBufferState (gl, stats, config, destroyBuffer) {
  var bufferCount = 0
  var bufferSet = {}

  function REGLBuffer (type) {
    this.id = bufferCount++
    this.buffer = gl.createBuffer()
    this.type = type
    this.usage = GL_STATIC_DRAW
    this.byteLength = 0
    this.dimension = 1
    this.dtype = GL_UNSIGNED_BYTE$3

    this.persistentData = null

    if (config.profile) {
      this.stats = { size: 0 }
    }
  }

  REGLBuffer.prototype.bind = function () {
    gl.bindBuffer(this.type, this.buffer)
  }

  REGLBuffer.prototype.destroy = function () {
    destroy(this)
  }

  var streamPool = []

  function createStream (type, data) {
    var buffer = streamPool.pop()
    if (!buffer) {
      buffer = new REGLBuffer(type)
    }
    buffer.bind()
    initBufferFromData(buffer, data, GL_STREAM_DRAW, 0, 1, false)
    return buffer
  }

  function destroyStream (stream$$1) {
    streamPool.push(stream$$1)
  }

  function initBufferFromTypedArray (buffer, data, usage) {
    buffer.byteLength = data.byteLength
    gl.bufferData(buffer.type, data, usage)
  }

  function initBufferFromData (buffer, data, usage, dtype, dimension, persist) {
    var shape
    buffer.usage = usage
    if (Array.isArray(data)) {
      buffer.dtype = dtype || GL_FLOAT$3
      if (data.length > 0) {
        var flatData
        if (Array.isArray(data[0])) {
          shape = arrayShape(data)
          var dim = 1
          for (var i = 1; i < shape.length; ++i) {
            dim *= shape[i]
          }
          buffer.dimension = dim
          flatData = arrayFlatten(data, shape, buffer.dtype)
          initBufferFromTypedArray(buffer, flatData, usage)
          if (persist) {
            buffer.persistentData = flatData
          } else {
            pool.freeType(flatData)
          }
        } else if (typeof data[0] === 'number') {
          buffer.dimension = dimension
          var typedData = pool.allocType(buffer.dtype, data.length)
          copyArray(typedData, data)
          initBufferFromTypedArray(buffer, typedData, usage)
          if (persist) {
            buffer.persistentData = typedData
          } else {
            pool.freeType(typedData)
          }
        } else if (isTypedArray(data[0])) {
          buffer.dimension = data[0].length
          buffer.dtype = dtype || typedArrayCode(data[0]) || GL_FLOAT$3
          flatData = arrayFlatten(
            data,
            [data.length, data[0].length],
            buffer.dtype)
          initBufferFromTypedArray(buffer, flatData, usage)
          if (persist) {
            buffer.persistentData = flatData
          } else {
            pool.freeType(flatData)
          }
        } else {
          check$1.raise('invalid buffer data')
        }
      }
    } else if (isTypedArray(data)) {
      buffer.dtype = dtype || typedArrayCode(data)
      buffer.dimension = dimension
      initBufferFromTypedArray(buffer, data, usage)
      if (persist) {
        buffer.persistentData = new Uint8Array(new Uint8Array(data.buffer))
      }
    } else if (isNDArrayLike(data)) {
      shape = data.shape
      var stride = data.stride
      var offset = data.offset

      var shapeX = 0
      var shapeY = 0
      var strideX = 0
      var strideY = 0
      if (shape.length === 1) {
        shapeX = shape[0]
        shapeY = 1
        strideX = stride[0]
        strideY = 0
      } else if (shape.length === 2) {
        shapeX = shape[0]
        shapeY = shape[1]
        strideX = stride[0]
        strideY = stride[1]
      } else {
        check$1.raise('invalid shape')
      }

      buffer.dtype = dtype || typedArrayCode(data.data) || GL_FLOAT$3
      buffer.dimension = shapeY

      var transposeData = pool.allocType(buffer.dtype, shapeX * shapeY)
      transpose(transposeData,
        data.data,
        shapeX, shapeY,
        strideX, strideY,
        offset)
      initBufferFromTypedArray(buffer, transposeData, usage)
      if (persist) {
        buffer.persistentData = transposeData
      } else {
        pool.freeType(transposeData)
      }
    } else if (data instanceof ArrayBuffer) {
      buffer.dtype = GL_UNSIGNED_BYTE$3
      buffer.dimension = dimension
      initBufferFromTypedArray(buffer, data, usage)
      if (persist) {
        buffer.persistentData = new Uint8Array(new Uint8Array(data))
      }
    } else {
      check$1.raise('invalid buffer data')
    }
  }

  function destroy (buffer) {
    stats.bufferCount--

    // remove attribute link
    destroyBuffer(buffer)

    var handle = buffer.buffer
    check$1(handle, 'buffer must not be deleted already')
    gl.deleteBuffer(handle)
    buffer.buffer = null
    delete bufferSet[buffer.id]
  }

  function createBuffer (options, type, deferInit, persistent) {
    stats.bufferCount++

    var buffer = new REGLBuffer(type)
    bufferSet[buffer.id] = buffer

    function reglBuffer (options) {
      var usage = GL_STATIC_DRAW
      var data = null
      var byteLength = 0
      var dtype = 0
      var dimension = 1
      if (Array.isArray(options) ||
          isTypedArray(options) ||
          isNDArrayLike(options) ||
          options instanceof ArrayBuffer) {
        data = options
      } else if (typeof options === 'number') {
        byteLength = options | 0
      } else if (options) {
        check$1.type(
          options, 'object',
          'buffer arguments must be an object, a number or an array')

        if ('data' in options) {
          check$1(
            data === null ||
            Array.isArray(data) ||
            isTypedArray(data) ||
            isNDArrayLike(data),
            'invalid data for buffer')
          data = options.data
        }

        if ('usage' in options) {
          check$1.parameter(options.usage, usageTypes, 'invalid buffer usage')
          usage = usageTypes[options.usage]
        }

        if ('type' in options) {
          check$1.parameter(options.type, glTypes, 'invalid buffer type')
          dtype = glTypes[options.type]
        }

        if ('dimension' in options) {
          check$1.type(options.dimension, 'number', 'invalid dimension')
          dimension = options.dimension | 0
        }

        if ('length' in options) {
          check$1.nni(byteLength, 'buffer length must be a nonnegative integer')
          byteLength = options.length | 0
        }
      }

      buffer.bind()
      if (!data) {
        // #475
        if (byteLength) gl.bufferData(buffer.type, byteLength, usage)
        buffer.dtype = dtype || GL_UNSIGNED_BYTE$3
        buffer.usage = usage
        buffer.dimension = dimension
        buffer.byteLength = byteLength
      } else {
        initBufferFromData(buffer, data, usage, dtype, dimension, persistent)
      }

      if (config.profile) {
        buffer.stats.size = buffer.byteLength * DTYPES_SIZES[buffer.dtype]
      }

      return reglBuffer
    }

    function setSubData (data, offset) {
      check$1(offset + data.byteLength <= buffer.byteLength,
        'invalid buffer subdata call, buffer is too small. ' + ' Can\'t write data of size ' + data.byteLength + ' starting from offset ' + offset + ' to a buffer of size ' + buffer.byteLength)

      gl.bufferSubData(buffer.type, offset, data)
    }

    function subdata (data, offset_) {
      var offset = (offset_ || 0) | 0
      var shape
      buffer.bind()
      if (isTypedArray(data) || data instanceof ArrayBuffer) {
        setSubData(data, offset)
      } else if (Array.isArray(data)) {
        if (data.length > 0) {
          if (typeof data[0] === 'number') {
            var converted = pool.allocType(buffer.dtype, data.length)
            copyArray(converted, data)
            setSubData(converted, offset)
            pool.freeType(converted)
          } else if (Array.isArray(data[0]) || isTypedArray(data[0])) {
            shape = arrayShape(data)
            var flatData = arrayFlatten(data, shape, buffer.dtype)
            setSubData(flatData, offset)
            pool.freeType(flatData)
          } else {
            check$1.raise('invalid buffer data')
          }
        }
      } else if (isNDArrayLike(data)) {
        shape = data.shape
        var stride = data.stride

        var shapeX = 0
        var shapeY = 0
        var strideX = 0
        var strideY = 0
        if (shape.length === 1) {
          shapeX = shape[0]
          shapeY = 1
          strideX = stride[0]
          strideY = 0
        } else if (shape.length === 2) {
          shapeX = shape[0]
          shapeY = shape[1]
          strideX = stride[0]
          strideY = stride[1]
        } else {
          check$1.raise('invalid shape')
        }
        var dtype = Array.isArray(data.data)
          ? buffer.dtype
          : typedArrayCode(data.data)

        var transposeData = pool.allocType(dtype, shapeX * shapeY)
        transpose(transposeData,
          data.data,
          shapeX, shapeY,
          strideX, strideY,
          data.offset)
        setSubData(transposeData, offset)
        pool.freeType(transposeData)
      } else {
        check$1.raise('invalid data for buffer subdata')
      }
      return reglBuffer
    }

    if (!deferInit) {
      reglBuffer(options)
    }

    reglBuffer._reglType = 'buffer'
    reglBuffer._buffer = buffer
    reglBuffer.subdata = subdata
    if (config.profile) {
      reglBuffer.stats = buffer.stats
    }
    reglBuffer.destroy = function () { destroy(buffer) }

    return reglBuffer
  }

  function restoreBuffers () {
    values(bufferSet).forEach(function (buffer) {
      buffer.buffer = gl.createBuffer()
      gl.bindBuffer(buffer.type, buffer.buffer)
      gl.bufferData(
        buffer.type, buffer.persistentData || buffer.byteLength, buffer.usage)
    })
  }

  if (config.profile) {
    stats.getTotalBufferSize = function () {
      var total = 0
      // TODO: Right now, the streams are not part of the total count.
      Object.keys(bufferSet).forEach(function (key) {
        total += bufferSet[key].stats.size
      })
      return total
    }
  }

  return {
    create: createBuffer,

    createStream: createStream,
    destroyStream: destroyStream,

    clear: function () {
      values(bufferSet).forEach(destroy)
      streamPool.forEach(destroy)
    },

    getBuffer: function (wrapper) {
      if (wrapper && wrapper._buffer instanceof REGLBuffer) {
        return wrapper._buffer
      }
      return null
    },

    restore: restoreBuffers,

    _initBuffer: initBufferFromData
  }
}

var points = 0;
var point = 0;
var lines = 1;
var line = 1;
var triangles = 4;
var triangle = 4;
var primTypes = {
	points: points,
	point: point,
	lines: lines,
	line: line,
	triangles: triangles,
	triangle: triangle,
	"line loop": 2,
	"line strip": 3,
	"triangle strip": 5,
	"triangle fan": 6
};

var GL_POINTS = 0
var GL_LINES = 1
var GL_TRIANGLES = 4

var GL_BYTE$2 = 5120
var GL_UNSIGNED_BYTE$4 = 5121
var GL_SHORT$2 = 5122
var GL_UNSIGNED_SHORT$2 = 5123
var GL_INT$2 = 5124
var GL_UNSIGNED_INT$2 = 5125

var GL_ELEMENT_ARRAY_BUFFER = 34963

var GL_STREAM_DRAW$1 = 0x88E0
var GL_STATIC_DRAW$1 = 0x88E4

function wrapElementsState (gl, extensions, bufferState, stats) {
  var elementSet = {}
  var elementCount = 0

  var elementTypes = {
    'uint8': GL_UNSIGNED_BYTE$4,
    'uint16': GL_UNSIGNED_SHORT$2
  }

  if (extensions.oes_element_index_uint) {
    elementTypes.uint32 = GL_UNSIGNED_INT$2
  }

  function REGLElementBuffer (buffer) {
    this.id = elementCount++
    elementSet[this.id] = this
    this.buffer = buffer
    this.primType = GL_TRIANGLES
    this.vertCount = 0
    this.type = 0
  }

  REGLElementBuffer.prototype.bind = function () {
    this.buffer.bind()
  }

  var bufferPool = []

  function createElementStream (data) {
    var result = bufferPool.pop()
    if (!result) {
      result = new REGLElementBuffer(bufferState.create(
        null,
        GL_ELEMENT_ARRAY_BUFFER,
        true,
        false)._buffer)
    }
    initElements(result, data, GL_STREAM_DRAW$1, -1, -1, 0, 0)
    return result
  }

  function destroyElementStream (elements) {
    bufferPool.push(elements)
  }

  function initElements (
    elements,
    data,
    usage,
    prim,
    count,
    byteLength,
    type) {
    elements.buffer.bind()
    var dtype
    if (data) {
      var predictedType = type
      if (!type && (
        !isTypedArray(data) ||
         (isNDArrayLike(data) && !isTypedArray(data.data)))) {
        predictedType = extensions.oes_element_index_uint
          ? GL_UNSIGNED_INT$2
          : GL_UNSIGNED_SHORT$2
      }
      bufferState._initBuffer(
        elements.buffer,
        data,
        usage,
        predictedType,
        3)
    } else {
      gl.bufferData(GL_ELEMENT_ARRAY_BUFFER, byteLength, usage)
      elements.buffer.dtype = dtype || GL_UNSIGNED_BYTE$4
      elements.buffer.usage = usage
      elements.buffer.dimension = 3
      elements.buffer.byteLength = byteLength
    }

    dtype = type
    if (!type) {
      switch (elements.buffer.dtype) {
        case GL_UNSIGNED_BYTE$4:
        case GL_BYTE$2:
          dtype = GL_UNSIGNED_BYTE$4
          break

        case GL_UNSIGNED_SHORT$2:
        case GL_SHORT$2:
          dtype = GL_UNSIGNED_SHORT$2
          break

        case GL_UNSIGNED_INT$2:
        case GL_INT$2:
          dtype = GL_UNSIGNED_INT$2
          break

        default:
          check$1.raise('unsupported type for element array')
      }
      elements.buffer.dtype = dtype
    }
    elements.type = dtype

    // Check oes_element_index_uint extension
    check$1(
      dtype !== GL_UNSIGNED_INT$2 ||
      !!extensions.oes_element_index_uint,
      '32 bit element buffers not supported, enable oes_element_index_uint first')

    // try to guess default primitive type and arguments
    var vertCount = count
    if (vertCount < 0) {
      vertCount = elements.buffer.byteLength
      if (dtype === GL_UNSIGNED_SHORT$2) {
        vertCount >>= 1
      } else if (dtype === GL_UNSIGNED_INT$2) {
        vertCount >>= 2
      }
    }
    elements.vertCount = vertCount

    // try to guess primitive type from cell dimension
    var primType = prim
    if (prim < 0) {
      primType = GL_TRIANGLES
      var dimension = elements.buffer.dimension
      if (dimension === 1) primType = GL_POINTS
      if (dimension === 2) primType = GL_LINES
      if (dimension === 3) primType = GL_TRIANGLES
    }
    elements.primType = primType
  }

  function destroyElements (elements) {
    stats.elementsCount--

    check$1(elements.buffer !== null, 'must not double destroy elements')
    delete elementSet[elements.id]
    elements.buffer.destroy()
    elements.buffer = null
  }

  function createElements (options, persistent) {
    var buffer = bufferState.create(null, GL_ELEMENT_ARRAY_BUFFER, true)
    var elements = new REGLElementBuffer(buffer._buffer)
    stats.elementsCount++

    function reglElements (options) {
      if (!options) {
        buffer()
        elements.primType = GL_TRIANGLES
        elements.vertCount = 0
        elements.type = GL_UNSIGNED_BYTE$4
      } else if (typeof options === 'number') {
        buffer(options)
        elements.primType = GL_TRIANGLES
        elements.vertCount = options | 0
        elements.type = GL_UNSIGNED_BYTE$4
      } else {
        var data = null
        var usage = GL_STATIC_DRAW$1
        var primType = -1
        var vertCount = -1
        var byteLength = 0
        var dtype = 0
        if (Array.isArray(options) ||
            isTypedArray(options) ||
            isNDArrayLike(options)) {
          data = options
        } else {
          check$1.type(options, 'object', 'invalid arguments for elements')
          if ('data' in options) {
            data = options.data
            check$1(
              Array.isArray(data) ||
                isTypedArray(data) ||
                isNDArrayLike(data),
              'invalid data for element buffer')
          }
          if ('usage' in options) {
            check$1.parameter(
              options.usage,
              usageTypes,
              'invalid element buffer usage')
            usage = usageTypes[options.usage]
          }
          if ('primitive' in options) {
            check$1.parameter(
              options.primitive,
              primTypes,
              'invalid element buffer primitive')
            primType = primTypes[options.primitive]
          }
          if ('count' in options) {
            check$1(
              typeof options.count === 'number' && options.count >= 0,
              'invalid vertex count for elements')
            vertCount = options.count | 0
          }
          if ('type' in options) {
            check$1.parameter(
              options.type,
              elementTypes,
              'invalid buffer type')
            dtype = elementTypes[options.type]
          }
          if ('length' in options) {
            byteLength = options.length | 0
          } else {
            byteLength = vertCount
            if (dtype === GL_UNSIGNED_SHORT$2 || dtype === GL_SHORT$2) {
              byteLength *= 2
            } else if (dtype === GL_UNSIGNED_INT$2 || dtype === GL_INT$2) {
              byteLength *= 4
            }
          }
        }
        initElements(
          elements,
          data,
          usage,
          primType,
          vertCount,
          byteLength,
          dtype)
      }

      return reglElements
    }

    reglElements(options)

    reglElements._reglType = 'elements'
    reglElements._elements = elements
    reglElements.subdata = function (data, offset) {
      buffer.subdata(data, offset)
      return reglElements
    }
    reglElements.destroy = function () {
      destroyElements(elements)
    }

    return reglElements
  }

  return {
    create: createElements,
    createStream: createElementStream,
    destroyStream: destroyElementStream,
    getElements: function (elements) {
      if (typeof elements === 'function' &&
          elements._elements instanceof REGLElementBuffer) {
        return elements._elements
      }
      return null
    },
    clear: function () {
      values(elementSet).forEach(destroyElements)
    }
  }
}

var FLOAT = new Float32Array(1)
var INT = new Uint32Array(FLOAT.buffer)

var GL_UNSIGNED_SHORT$4 = 5123

function convertToHalfFloat (array) {
  var ushorts = pool.allocType(GL_UNSIGNED_SHORT$4, array.length)

  for (var i = 0; i < array.length; ++i) {
    if (isNaN(array[i])) {
      ushorts[i] = 0xffff
    } else if (array[i] === Infinity) {
      ushorts[i] = 0x7c00
    } else if (array[i] === -Infinity) {
      ushorts[i] = 0xfc00
    } else {
      FLOAT[0] = array[i]
      var x = INT[0]

      var sgn = (x >>> 31) << 15
      var exp = ((x << 1) >>> 24) - 127
      var frac = (x >> 13) & ((1 << 10) - 1)

      if (exp < -24) {
        // round non-representable denormals to 0
        ushorts[i] = sgn
      } else if (exp < -14) {
        // handle denormals
        var s = -14 - exp
        ushorts[i] = sgn + ((frac + (1 << 10)) >> s)
      } else if (exp > 15) {
        // round overflow to +/- Infinity
        ushorts[i] = sgn + 0x7c00
      } else {
        // otherwise convert directly
        ushorts[i] = sgn + ((exp + 15) << 10) + frac
      }
    }
  }

  return ushorts
}

function isArrayLike (s) {
  return Array.isArray(s) || isTypedArray(s)
}

var isPow2$1 = function (v) {
  return !(v & (v - 1)) && (!!v)
}

var GL_COMPRESSED_TEXTURE_FORMATS = 0x86A3

var GL_TEXTURE_2D$1 = 0x0DE1
var GL_TEXTURE_CUBE_MAP$1 = 0x8513
var GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 = 0x8515

var GL_RGBA$1 = 0x1908
var GL_ALPHA = 0x1906
var GL_RGB = 0x1907
var GL_LUMINANCE = 0x1909
var GL_LUMINANCE_ALPHA = 0x190A

var GL_RGBA4 = 0x8056
var GL_RGB5_A1 = 0x8057
var GL_RGB565 = 0x8D62

var GL_UNSIGNED_SHORT_4_4_4_4$1 = 0x8033
var GL_UNSIGNED_SHORT_5_5_5_1$1 = 0x8034
var GL_UNSIGNED_SHORT_5_6_5$1 = 0x8363
var GL_UNSIGNED_INT_24_8_WEBGL$1 = 0x84FA

var GL_DEPTH_COMPONENT = 0x1902
var GL_DEPTH_STENCIL = 0x84F9

var GL_SRGB_EXT = 0x8C40
var GL_SRGB_ALPHA_EXT = 0x8C42

var GL_HALF_FLOAT_OES$1 = 0x8D61

var GL_COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0
var GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1
var GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2
var GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3

var GL_COMPRESSED_RGB_ATC_WEBGL = 0x8C92
var GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 0x8C93
var GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 0x87EE

var GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8C00
var GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 0x8C01
var GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02
var GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03

var GL_COMPRESSED_RGB_ETC1_WEBGL = 0x8D64

var GL_UNSIGNED_BYTE$5 = 0x1401
var GL_UNSIGNED_SHORT$3 = 0x1403
var GL_UNSIGNED_INT$3 = 0x1405
var GL_FLOAT$4 = 0x1406

var GL_TEXTURE_WRAP_S = 0x2802
var GL_TEXTURE_WRAP_T = 0x2803

var GL_REPEAT = 0x2901
var GL_CLAMP_TO_EDGE$1 = 0x812F
var GL_MIRRORED_REPEAT = 0x8370

var GL_TEXTURE_MAG_FILTER = 0x2800
var GL_TEXTURE_MIN_FILTER = 0x2801

var GL_NEAREST$1 = 0x2600
var GL_LINEAR = 0x2601
var GL_NEAREST_MIPMAP_NEAREST$1 = 0x2700
var GL_LINEAR_MIPMAP_NEAREST$1 = 0x2701
var GL_NEAREST_MIPMAP_LINEAR$1 = 0x2702
var GL_LINEAR_MIPMAP_LINEAR$1 = 0x2703

var GL_GENERATE_MIPMAP_HINT = 0x8192
var GL_DONT_CARE = 0x1100
var GL_FASTEST = 0x1101
var GL_NICEST = 0x1102

var GL_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FE

var GL_UNPACK_ALIGNMENT = 0x0CF5
var GL_UNPACK_FLIP_Y_WEBGL = 0x9240
var GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241
var GL_UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243

var GL_BROWSER_DEFAULT_WEBGL = 0x9244

var GL_TEXTURE0$1 = 0x84C0

var MIPMAP_FILTERS = [
  GL_NEAREST_MIPMAP_NEAREST$1,
  GL_NEAREST_MIPMAP_LINEAR$1,
  GL_LINEAR_MIPMAP_NEAREST$1,
  GL_LINEAR_MIPMAP_LINEAR$1
]

var CHANNELS_FORMAT = [
  0,
  GL_LUMINANCE,
  GL_LUMINANCE_ALPHA,
  GL_RGB,
  GL_RGBA$1
]

var FORMAT_CHANNELS = {}
FORMAT_CHANNELS[GL_LUMINANCE] =
FORMAT_CHANNELS[GL_ALPHA] =
FORMAT_CHANNELS[GL_DEPTH_COMPONENT] = 1
FORMAT_CHANNELS[GL_DEPTH_STENCIL] =
FORMAT_CHANNELS[GL_LUMINANCE_ALPHA] = 2
FORMAT_CHANNELS[GL_RGB] =
FORMAT_CHANNELS[GL_SRGB_EXT] = 3
FORMAT_CHANNELS[GL_RGBA$1] =
FORMAT_CHANNELS[GL_SRGB_ALPHA_EXT] = 4

function objectName (str) {
  return '[object ' + str + ']'
}

var CANVAS_CLASS = objectName('HTMLCanvasElement')
var OFFSCREENCANVAS_CLASS = objectName('OffscreenCanvas')
var CONTEXT2D_CLASS = objectName('CanvasRenderingContext2D')
var BITMAP_CLASS = objectName('ImageBitmap')
var IMAGE_CLASS = objectName('HTMLImageElement')
var VIDEO_CLASS = objectName('HTMLVideoElement')

var PIXEL_CLASSES = Object.keys(arrayTypes).concat([
  CANVAS_CLASS,
  OFFSCREENCANVAS_CLASS,
  CONTEXT2D_CLASS,
  BITMAP_CLASS,
  IMAGE_CLASS,
  VIDEO_CLASS
])

// for every texture type, store
// the size in bytes.
var TYPE_SIZES = []
TYPE_SIZES[GL_UNSIGNED_BYTE$5] = 1
TYPE_SIZES[GL_FLOAT$4] = 4
TYPE_SIZES[GL_HALF_FLOAT_OES$1] = 2

TYPE_SIZES[GL_UNSIGNED_SHORT$3] = 2
TYPE_SIZES[GL_UNSIGNED_INT$3] = 4

var FORMAT_SIZES_SPECIAL = []
FORMAT_SIZES_SPECIAL[GL_RGBA4] = 2
FORMAT_SIZES_SPECIAL[GL_RGB5_A1] = 2
FORMAT_SIZES_SPECIAL[GL_RGB565] = 2
FORMAT_SIZES_SPECIAL[GL_DEPTH_STENCIL] = 4

FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1

FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ATC_WEBGL] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1

FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25

FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ETC1_WEBGL] = 0.5

function isNumericArray (arr) {
  return (
    Array.isArray(arr) &&
    (arr.length === 0 ||
    typeof arr[0] === 'number'))
}

function isRectArray (arr) {
  if (!Array.isArray(arr)) {
    return false
  }
  var width = arr.length
  if (width === 0 || !isArrayLike(arr[0])) {
    return false
  }
  return true
}

function classString (x) {
  return Object.prototype.toString.call(x)
}

function isCanvasElement (object) {
  return classString(object) === CANVAS_CLASS
}

function isOffscreenCanvas (object) {
  return classString(object) === OFFSCREENCANVAS_CLASS
}

function isContext2D (object) {
  return classString(object) === CONTEXT2D_CLASS
}

function isBitmap (object) {
  return classString(object) === BITMAP_CLASS
}

function isImageElement (object) {
  return classString(object) === IMAGE_CLASS
}

function isVideoElement (object) {
  return classString(object) === VIDEO_CLASS
}

function isPixelData (object) {
  if (!object) {
    return false
  }
  var className = classString(object)
  if (PIXEL_CLASSES.indexOf(className) >= 0) {
    return true
  }
  return (
    isNumericArray(object) ||
    isRectArray(object) ||
    isNDArrayLike(object))
}

function typedArrayCode$1 (data) {
  return arrayTypes[Object.prototype.toString.call(data)] | 0
}

function convertData (result, data) {
  var n = data.length
  switch (result.type) {
    case GL_UNSIGNED_BYTE$5:
    case GL_UNSIGNED_SHORT$3:
    case GL_UNSIGNED_INT$3:
    case GL_FLOAT$4:
      var converted = pool.allocType(result.type, n)
      converted.set(data)
      result.data = converted
      break

    case GL_HALF_FLOAT_OES$1:
      result.data = convertToHalfFloat(data)
      break

    default:
      check$1.raise('unsupported texture type, must specify a typed array')
  }
}

function preConvert (image, n) {
  return pool.allocType(
    image.type === GL_HALF_FLOAT_OES$1
      ? GL_FLOAT$4
      : image.type, n)
}

function postConvert (image, data) {
  if (image.type === GL_HALF_FLOAT_OES$1) {
    image.data = convertToHalfFloat(data)
    pool.freeType(data)
  } else {
    image.data = data
  }
}

function transposeData (image, array, strideX, strideY, strideC, offset) {
  var w = image.width
  var h = image.height
  var c = image.channels
  var n = w * h * c
  var data = preConvert(image, n)

  var p = 0
  for (var i = 0; i < h; ++i) {
    for (var j = 0; j < w; ++j) {
      for (var k = 0; k < c; ++k) {
        data[p++] = array[strideX * j + strideY * i + strideC * k + offset]
      }
    }
  }

  postConvert(image, data)
}

function getTextureSize (format, type, width, height, isMipmap, isCube) {
  var s
  if (typeof FORMAT_SIZES_SPECIAL[format] !== 'undefined') {
    // we have a special array for dealing with weird color formats such as RGB5A1
    s = FORMAT_SIZES_SPECIAL[format]
  } else {
    s = FORMAT_CHANNELS[format] * TYPE_SIZES[type]
  }

  if (isCube) {
    s *= 6
  }

  if (isMipmap) {
    // compute the total size of all the mipmaps.
    var total = 0

    var w = width
    while (w >= 1) {
      // we can only use mipmaps on a square image,
      // so we can simply use the width and ignore the height:
      total += s * w * w
      w /= 2
    }
    return total
  } else {
    return s * width * height
  }
}

function createTextureSet (
  gl, extensions, limits, reglPoll, contextState, stats, config) {
  // -------------------------------------------------------
  // Initialize constants and parameter tables here
  // -------------------------------------------------------
  var mipmapHint = {
    "don't care": GL_DONT_CARE,
    'dont care': GL_DONT_CARE,
    'nice': GL_NICEST,
    'fast': GL_FASTEST
  }

  var wrapModes = {
    'repeat': GL_REPEAT,
    'clamp': GL_CLAMP_TO_EDGE$1,
    'mirror': GL_MIRRORED_REPEAT
  }

  var magFilters = {
    'nearest': GL_NEAREST$1,
    'linear': GL_LINEAR
  }

  var minFilters = extend({
    'mipmap': GL_LINEAR_MIPMAP_LINEAR$1,
    'nearest mipmap nearest': GL_NEAREST_MIPMAP_NEAREST$1,
    'linear mipmap nearest': GL_LINEAR_MIPMAP_NEAREST$1,
    'nearest mipmap linear': GL_NEAREST_MIPMAP_LINEAR$1,
    'linear mipmap linear': GL_LINEAR_MIPMAP_LINEAR$1
  }, magFilters)

  var colorSpace = {
    'none': 0,
    'browser': GL_BROWSER_DEFAULT_WEBGL
  }

  var textureTypes = {
    'uint8': GL_UNSIGNED_BYTE$5,
    'rgba4': GL_UNSIGNED_SHORT_4_4_4_4$1,
    'rgb565': GL_UNSIGNED_SHORT_5_6_5$1,
    'rgb5 a1': GL_UNSIGNED_SHORT_5_5_5_1$1
  }

  var textureFormats = {
    'alpha': GL_ALPHA,
    'luminance': GL_LUMINANCE,
    'luminance alpha': GL_LUMINANCE_ALPHA,
    'rgb': GL_RGB,
    'rgba': GL_RGBA$1,
    'rgba4': GL_RGBA4,
    'rgb5 a1': GL_RGB5_A1,
    'rgb565': GL_RGB565
  }

  var compressedTextureFormats = {}

  if (extensions.ext_srgb) {
    textureFormats.srgb = GL_SRGB_EXT
    textureFormats.srgba = GL_SRGB_ALPHA_EXT
  }

  if (extensions.oes_texture_float) {
    textureTypes.float32 = textureTypes.float = GL_FLOAT$4
  }

  if (extensions.oes_texture_half_float) {
    textureTypes['float16'] = textureTypes['half float'] = GL_HALF_FLOAT_OES$1
  }

  if (extensions.webgl_depth_texture) {
    extend(textureFormats, {
      'depth': GL_DEPTH_COMPONENT,
      'depth stencil': GL_DEPTH_STENCIL
    })

    extend(textureTypes, {
      'uint16': GL_UNSIGNED_SHORT$3,
      'uint32': GL_UNSIGNED_INT$3,
      'depth stencil': GL_UNSIGNED_INT_24_8_WEBGL$1
    })
  }

  if (extensions.webgl_compressed_texture_s3tc) {
    extend(compressedTextureFormats, {
      'rgb s3tc dxt1': GL_COMPRESSED_RGB_S3TC_DXT1_EXT,
      'rgba s3tc dxt1': GL_COMPRESSED_RGBA_S3TC_DXT1_EXT,
      'rgba s3tc dxt3': GL_COMPRESSED_RGBA_S3TC_DXT3_EXT,
      'rgba s3tc dxt5': GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
    })
  }

  if (extensions.webgl_compressed_texture_atc) {
    extend(compressedTextureFormats, {
      'rgb atc': GL_COMPRESSED_RGB_ATC_WEBGL,
      'rgba atc explicit alpha': GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,
      'rgba atc interpolated alpha': GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL
    })
  }

  if (extensions.webgl_compressed_texture_pvrtc) {
    extend(compressedTextureFormats, {
      'rgb pvrtc 4bppv1': GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG,
      'rgb pvrtc 2bppv1': GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG,
      'rgba pvrtc 4bppv1': GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
      'rgba pvrtc 2bppv1': GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
    })
  }

  if (extensions.webgl_compressed_texture_etc1) {
    compressedTextureFormats['rgb etc1'] = GL_COMPRESSED_RGB_ETC1_WEBGL
  }

  // Copy over all texture formats
  var supportedCompressedFormats = Array.prototype.slice.call(
    gl.getParameter(GL_COMPRESSED_TEXTURE_FORMATS))
  Object.keys(compressedTextureFormats).forEach(function (name) {
    var format = compressedTextureFormats[name]
    if (supportedCompressedFormats.indexOf(format) >= 0) {
      textureFormats[name] = format
    }
  })

  var supportedFormats = Object.keys(textureFormats)
  limits.textureFormats = supportedFormats

  // associate with every format string its
  // corresponding GL-value.
  var textureFormatsInvert = []
  Object.keys(textureFormats).forEach(function (key) {
    var val = textureFormats[key]
    textureFormatsInvert[val] = key
  })

  // associate with every type string its
  // corresponding GL-value.
  var textureTypesInvert = []
  Object.keys(textureTypes).forEach(function (key) {
    var val = textureTypes[key]
    textureTypesInvert[val] = key
  })

  var magFiltersInvert = []
  Object.keys(magFilters).forEach(function (key) {
    var val = magFilters[key]
    magFiltersInvert[val] = key
  })

  var minFiltersInvert = []
  Object.keys(minFilters).forEach(function (key) {
    var val = minFilters[key]
    minFiltersInvert[val] = key
  })

  var wrapModesInvert = []
  Object.keys(wrapModes).forEach(function (key) {
    var val = wrapModes[key]
    wrapModesInvert[val] = key
  })

  // colorFormats[] gives the format (channels) associated to an
  // internalformat
  var colorFormats = supportedFormats.reduce(function (color, key) {
    var glenum = textureFormats[key]
    if (glenum === GL_LUMINANCE ||
        glenum === GL_ALPHA ||
        glenum === GL_LUMINANCE ||
        glenum === GL_LUMINANCE_ALPHA ||
        glenum === GL_DEPTH_COMPONENT ||
        glenum === GL_DEPTH_STENCIL ||
        (extensions.ext_srgb &&
                (glenum === GL_SRGB_EXT ||
                 glenum === GL_SRGB_ALPHA_EXT))) {
      color[glenum] = glenum
    } else if (glenum === GL_RGB5_A1 || key.indexOf('rgba') >= 0) {
      color[glenum] = GL_RGBA$1
    } else {
      color[glenum] = GL_RGB
    }
    return color
  }, {})

  function TexFlags () {
    // format info
    this.internalformat = GL_RGBA$1
    this.format = GL_RGBA$1
    this.type = GL_UNSIGNED_BYTE$5
    this.compressed = false

    // pixel storage
    this.premultiplyAlpha = false
    this.flipY = false
    this.unpackAlignment = 1
    this.colorSpace = GL_BROWSER_DEFAULT_WEBGL

    // shape info
    this.width = 0
    this.height = 0
    this.channels = 0
  }

  function copyFlags (result, other) {
    result.internalformat = other.internalformat
    result.format = other.format
    result.type = other.type
    result.compressed = other.compressed

    result.premultiplyAlpha = other.premultiplyAlpha
    result.flipY = other.flipY
    result.unpackAlignment = other.unpackAlignment
    result.colorSpace = other.colorSpace

    result.width = other.width
    result.height = other.height
    result.channels = other.channels
  }

  function parseFlags (flags, options) {
    if (typeof options !== 'object' || !options) {
      return
    }

    if ('premultiplyAlpha' in options) {
      check$1.type(options.premultiplyAlpha, 'boolean',
        'invalid premultiplyAlpha')
      flags.premultiplyAlpha = options.premultiplyAlpha
    }

    if ('flipY' in options) {
      check$1.type(options.flipY, 'boolean',
        'invalid texture flip')
      flags.flipY = options.flipY
    }

    if ('alignment' in options) {
      check$1.oneOf(options.alignment, [1, 2, 4, 8],
        'invalid texture unpack alignment')
      flags.unpackAlignment = options.alignment
    }

    if ('colorSpace' in options) {
      check$1.parameter(options.colorSpace, colorSpace,
        'invalid colorSpace')
      flags.colorSpace = colorSpace[options.colorSpace]
    }

    if ('type' in options) {
      var type = options.type
      check$1(extensions.oes_texture_float ||
        !(type === 'float' || type === 'float32'),
      'you must enable the OES_texture_float extension in order to use floating point textures.')
      check$1(extensions.oes_texture_half_float ||
        !(type === 'half float' || type === 'float16'),
      'you must enable the OES_texture_half_float extension in order to use 16-bit floating point textures.')
      check$1(extensions.webgl_depth_texture ||
        !(type === 'uint16' || type === 'uint32' || type === 'depth stencil'),
      'you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures.')
      check$1.parameter(type, textureTypes,
        'invalid texture type')
      flags.type = textureTypes[type]
    }

    var w = flags.width
    var h = flags.height
    var c = flags.channels
    var hasChannels = false
    if ('shape' in options) {
      check$1(Array.isArray(options.shape) && options.shape.length >= 2,
        'shape must be an array')
      w = options.shape[0]
      h = options.shape[1]
      if (options.shape.length === 3) {
        c = options.shape[2]
        check$1(c > 0 && c <= 4, 'invalid number of channels')
        hasChannels = true
      }
      check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid width')
      check$1(h >= 0 && h <= limits.maxTextureSize, 'invalid height')
    } else {
      if ('radius' in options) {
        w = h = options.radius
        check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid radius')
      }
      if ('width' in options) {
        w = options.width
        check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid width')
      }
      if ('height' in options) {
        h = options.height
        check$1(h >= 0 && h <= limits.maxTextureSize, 'invalid height')
      }
      if ('channels' in options) {
        c = options.channels
        check$1(c > 0 && c <= 4, 'invalid number of channels')
        hasChannels = true
      }
    }
    flags.width = w | 0
    flags.height = h | 0
    flags.channels = c | 0

    var hasFormat = false
    if ('format' in options) {
      var formatStr = options.format
      check$1(extensions.webgl_depth_texture ||
        !(formatStr === 'depth' || formatStr === 'depth stencil'),
      'you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures.')
      check$1.parameter(formatStr, textureFormats,
        'invalid texture format')
      var internalformat = flags.internalformat = textureFormats[formatStr]
      flags.format = colorFormats[internalformat]
      if (formatStr in textureTypes) {
        if (!('type' in options)) {
          flags.type = textureTypes[formatStr]
        }
      }
      if (formatStr in compressedTextureFormats) {
        flags.compressed = true
      }
      hasFormat = true
    }

    // Reconcile channels and format
    if (!hasChannels && hasFormat) {
      flags.channels = FORMAT_CHANNELS[flags.format]
    } else if (hasChannels && !hasFormat) {
      if (flags.channels !== CHANNELS_FORMAT[flags.format]) {
        flags.format = flags.internalformat = CHANNELS_FORMAT[flags.channels]
      }
    } else if (hasFormat && hasChannels) {
      check$1(
        flags.channels === FORMAT_CHANNELS[flags.format],
        'number of channels inconsistent with specified format')
    }
  }

  function setFlags (flags) {
    gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, flags.flipY)
    gl.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, flags.premultiplyAlpha)
    gl.pixelStorei(GL_UNPACK_COLORSPACE_CONVERSION_WEBGL, flags.colorSpace)
    gl.pixelStorei(GL_UNPACK_ALIGNMENT, flags.unpackAlignment)
  }

  // -------------------------------------------------------
  // Tex image data
  // -------------------------------------------------------
  function TexImage () {
    TexFlags.call(this)

    this.xOffset = 0
    this.yOffset = 0

    // data
    this.data = null
    this.needsFree = false

    // html element
    this.element = null

    // copyTexImage info
    this.needsCopy = false
  }

  function parseImage (image, options) {
    var data = null
    if (isPixelData(options)) {
      data = options
    } else if (options) {
      check$1.type(options, 'object', 'invalid pixel data type')
      parseFlags(image, options)
      if ('x' in options) {
        image.xOffset = options.x | 0
      }
      if ('y' in options) {
        image.yOffset = options.y | 0
      }
      if (isPixelData(options.data)) {
        data = options.data
      }
    }

    check$1(
      !image.compressed ||
      data instanceof Uint8Array,
      'compressed texture data must be stored in a uint8array')

    if (options.copy) {
      check$1(!data, 'can not specify copy and data field for the same texture')
      var viewW = contextState.viewportWidth
      var viewH = contextState.viewportHeight
      image.width = image.width || (viewW - image.xOffset)
      image.height = image.height || (viewH - image.yOffset)
      image.needsCopy = true
      check$1(image.xOffset >= 0 && image.xOffset < viewW &&
            image.yOffset >= 0 && image.yOffset < viewH &&
            image.width > 0 && image.width <= viewW &&
            image.height > 0 && image.height <= viewH,
      'copy texture read out of bounds')
    } else if (!data) {
      image.width = image.width || 1
      image.height = image.height || 1
      image.channels = image.channels || 4
    } else if (isTypedArray(data)) {
      image.channels = image.channels || 4
      image.data = data
      if (!('type' in options) && image.type === GL_UNSIGNED_BYTE$5) {
        image.type = typedArrayCode$1(data)
      }
    } else if (isNumericArray(data)) {
      image.channels = image.channels || 4
      convertData(image, data)
      image.alignment = 1
      image.needsFree = true
    } else if (isNDArrayLike(data)) {
      var array = data.data
      if (!Array.isArray(array) && image.type === GL_UNSIGNED_BYTE$5) {
        image.type = typedArrayCode$1(array)
      }
      var shape = data.shape
      var stride = data.stride
      var shapeX, shapeY, shapeC, strideX, strideY, strideC
      if (shape.length === 3) {
        shapeC = shape[2]
        strideC = stride[2]
      } else {
        check$1(shape.length === 2, 'invalid ndarray pixel data, must be 2 or 3D')
        shapeC = 1
        strideC = 1
      }
      shapeX = shape[0]
      shapeY = shape[1]
      strideX = stride[0]
      strideY = stride[1]
      image.alignment = 1
      image.width = shapeX
      image.height = shapeY
      image.channels = shapeC
      image.format = image.internalformat = CHANNELS_FORMAT[shapeC]
      image.needsFree = true
      transposeData(image, array, strideX, strideY, strideC, data.offset)
    } else if (isCanvasElement(data) || isOffscreenCanvas(data) || isContext2D(data)) {
      if (isCanvasElement(data) || isOffscreenCanvas(data)) {
        image.element = data
      } else {
        image.element = data.canvas
      }
      image.width = image.element.width
      image.height = image.element.height
      image.channels = 4
    } else if (isBitmap(data)) {
      image.element = data
      image.width = data.width
      image.height = data.height
      image.channels = 4
    } else if (isImageElement(data)) {
      image.element = data
      image.width = data.naturalWidth
      image.height = data.naturalHeight
      image.channels = 4
    } else if (isVideoElement(data)) {
      image.element = data
      image.width = data.videoWidth
      image.height = data.videoHeight
      image.channels = 4
    } else if (isRectArray(data)) {
      var w = image.width || data[0].length
      var h = image.height || data.length
      var c = image.channels
      if (isArrayLike(data[0][0])) {
        c = c || data[0][0].length
      } else {
        c = c || 1
      }
      var arrayShape = flattenUtils.shape(data)
      var n = 1
      for (var dd = 0; dd < arrayShape.length; ++dd) {
        n *= arrayShape[dd]
      }
      var allocData = preConvert(image, n)
      flattenUtils.flatten(data, arrayShape, '', allocData)
      postConvert(image, allocData)
      image.alignment = 1
      image.width = w
      image.height = h
      image.channels = c
      image.format = image.internalformat = CHANNELS_FORMAT[c]
      image.needsFree = true
    }

    if (image.type === GL_FLOAT$4) {
      check$1(limits.extensions.indexOf('oes_texture_float') >= 0,
        'oes_texture_float extension not enabled')
    } else if (image.type === GL_HALF_FLOAT_OES$1) {
      check$1(limits.extensions.indexOf('oes_texture_half_float') >= 0,
        'oes_texture_half_float extension not enabled')
    }

    // do compressed texture  validation here.
  }

  function setImage (info, target, miplevel) {
    var element = info.element
    var data = info.data
    var internalformat = info.internalformat
    var format = info.format
    var type = info.type
    var width = info.width
    var height = info.height

    setFlags(info)

    if (element) {
      gl.texImage2D(target, miplevel, format, format, type, element)
    } else if (info.compressed) {
      gl.compressedTexImage2D(target, miplevel, internalformat, width, height, 0, data)
    } else if (info.needsCopy) {
      reglPoll()
      gl.copyTexImage2D(
        target, miplevel, format, info.xOffset, info.yOffset, width, height, 0)
    } else {
      gl.texImage2D(target, miplevel, format, width, height, 0, format, type, data || null)
    }
  }

  function setSubImage (info, target, x, y, miplevel) {
    var element = info.element
    var data = info.data
    var internalformat = info.internalformat
    var format = info.format
    var type = info.type
    var width = info.width
    var height = info.height

    setFlags(info)

    if (element) {
      gl.texSubImage2D(
        target, miplevel, x, y, format, type, element)
    } else if (info.compressed) {
      gl.compressedTexSubImage2D(
        target, miplevel, x, y, internalformat, width, height, data)
    } else if (info.needsCopy) {
      reglPoll()
      gl.copyTexSubImage2D(
        target, miplevel, x, y, info.xOffset, info.yOffset, width, height)
    } else {
      gl.texSubImage2D(
        target, miplevel, x, y, width, height, format, type, data)
    }
  }

  // texImage pool
  var imagePool = []

  function allocImage () {
    return imagePool.pop() || new TexImage()
  }

  function freeImage (image) {
    if (image.needsFree) {
      pool.freeType(image.data)
    }
    TexImage.call(image)
    imagePool.push(image)
  }

  // -------------------------------------------------------
  // Mip map
  // -------------------------------------------------------
  function MipMap () {
    TexFlags.call(this)

    this.genMipmaps = false
    this.mipmapHint = GL_DONT_CARE
    this.mipmask = 0
    this.images = Array(16)
  }

  function parseMipMapFromShape (mipmap, width, height) {
    var img = mipmap.images[0] = allocImage()
    mipmap.mipmask = 1
    img.width = mipmap.width = width
    img.height = mipmap.height = height
    img.channels = mipmap.channels = 4
  }

  function parseMipMapFromObject (mipmap, options) {
    var imgData = null
    if (isPixelData(options)) {
      imgData = mipmap.images[0] = allocImage()
      copyFlags(imgData, mipmap)
      parseImage(imgData, options)
      mipmap.mipmask = 1
    } else {
      parseFlags(mipmap, options)
      if (Array.isArray(options.mipmap)) {
        var mipData = options.mipmap
        for (var i = 0; i < mipData.length; ++i) {
          imgData = mipmap.images[i] = allocImage()
          copyFlags(imgData, mipmap)
          imgData.width >>= i
          imgData.height >>= i
          parseImage(imgData, mipData[i])
          mipmap.mipmask |= (1 << i)
        }
      } else {
        imgData = mipmap.images[0] = allocImage()
        copyFlags(imgData, mipmap)
        parseImage(imgData, options)
        mipmap.mipmask = 1
      }
    }
    copyFlags(mipmap, mipmap.images[0])

    // For textures of the compressed format WEBGL_compressed_texture_s3tc
    // we must have that
    //
    // "When level equals zero width and height must be a multiple of 4.
    // When level is greater than 0 width and height must be 0, 1, 2 or a multiple of 4. "
    //
    // but we do not yet support having multiple mipmap levels for compressed textures,
    // so we only test for level zero.

    if (
      mipmap.compressed &&
      (
        mipmap.internalformat === GL_COMPRESSED_RGB_S3TC_DXT1_EXT ||
        mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT1_EXT ||
        mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT3_EXT ||
        mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
      )
    ) {
      check$1(mipmap.width % 4 === 0 && mipmap.height % 4 === 0,
        'for compressed texture formats, mipmap level 0 must have width and height that are a multiple of 4')
    }
  }

  function setMipMap (mipmap, target) {
    var images = mipmap.images
    for (var i = 0; i < images.length; ++i) {
      if (!images[i]) {
        return
      }
      setImage(images[i], target, i)
    }
  }

  var mipPool = []

  function allocMipMap () {
    var result = mipPool.pop() || new MipMap()
    TexFlags.call(result)
    result.mipmask = 0
    for (var i = 0; i < 16; ++i) {
      result.images[i] = null
    }
    return result
  }

  function freeMipMap (mipmap) {
    var images = mipmap.images
    for (var i = 0; i < images.length; ++i) {
      if (images[i]) {
        freeImage(images[i])
      }
      images[i] = null
    }
    mipPool.push(mipmap)
  }

  // -------------------------------------------------------
  // Tex info
  // -------------------------------------------------------
  function TexInfo () {
    this.minFilter = GL_NEAREST$1
    this.magFilter = GL_NEAREST$1

    this.wrapS = GL_CLAMP_TO_EDGE$1
    this.wrapT = GL_CLAMP_TO_EDGE$1

    this.anisotropic = 1

    this.genMipmaps = false
    this.mipmapHint = GL_DONT_CARE
  }

  function parseTexInfo (info, options) {
    if ('min' in options) {
      var minFilter = options.min
      check$1.parameter(minFilter, minFilters)
      info.minFilter = minFilters[minFilter]
      if (MIPMAP_FILTERS.indexOf(info.minFilter) >= 0 && !('faces' in options)) {
        info.genMipmaps = true
      }
    }

    if ('mag' in options) {
      var magFilter = options.mag
      check$1.parameter(magFilter, magFilters)
      info.magFilter = magFilters[magFilter]
    }

    var wrapS = info.wrapS
    var wrapT = info.wrapT
    if ('wrap' in options) {
      var wrap = options.wrap
      if (typeof wrap === 'string') {
        check$1.parameter(wrap, wrapModes)
        wrapS = wrapT = wrapModes[wrap]
      } else if (Array.isArray(wrap)) {
        check$1.parameter(wrap[0], wrapModes)
        check$1.parameter(wrap[1], wrapModes)
        wrapS = wrapModes[wrap[0]]
        wrapT = wrapModes[wrap[1]]
      }
    } else {
      if ('wrapS' in options) {
        var optWrapS = options.wrapS
        check$1.parameter(optWrapS, wrapModes)
        wrapS = wrapModes[optWrapS]
      }
      if ('wrapT' in options) {
        var optWrapT = options.wrapT
        check$1.parameter(optWrapT, wrapModes)
        wrapT = wrapModes[optWrapT]
      }
    }
    info.wrapS = wrapS
    info.wrapT = wrapT

    if ('anisotropic' in options) {
      var anisotropic = options.anisotropic
      check$1(typeof anisotropic === 'number' &&
         anisotropic >= 1 && anisotropic <= limits.maxAnisotropic,
      'aniso samples must be between 1 and ')
      info.anisotropic = options.anisotropic
    }

    if ('mipmap' in options) {
      var hasMipMap = false
      switch (typeof options.mipmap) {
        case 'string':
          check$1.parameter(options.mipmap, mipmapHint,
            'invalid mipmap hint')
          info.mipmapHint = mipmapHint[options.mipmap]
          info.genMipmaps = true
          hasMipMap = true
          break

        case 'boolean':
          hasMipMap = info.genMipmaps = options.mipmap
          break

        case 'object':
          check$1(Array.isArray(options.mipmap), 'invalid mipmap type')
          info.genMipmaps = false
          hasMipMap = true
          break

        default:
          check$1.raise('invalid mipmap type')
      }
      if (hasMipMap && !('min' in options)) {
        info.minFilter = GL_NEAREST_MIPMAP_NEAREST$1
      }
    }
  }

  function setTexInfo (info, target) {
    gl.texParameteri(target, GL_TEXTURE_MIN_FILTER, info.minFilter)
    gl.texParameteri(target, GL_TEXTURE_MAG_FILTER, info.magFilter)
    gl.texParameteri(target, GL_TEXTURE_WRAP_S, info.wrapS)
    gl.texParameteri(target, GL_TEXTURE_WRAP_T, info.wrapT)
    if (extensions.ext_texture_filter_anisotropic) {
      gl.texParameteri(target, GL_TEXTURE_MAX_ANISOTROPY_EXT, info.anisotropic)
    }
    if (info.genMipmaps) {
      gl.hint(GL_GENERATE_MIPMAP_HINT, info.mipmapHint)
      gl.generateMipmap(target)
    }
  }

  // -------------------------------------------------------
  // Full texture object
  // -------------------------------------------------------
  var textureCount = 0
  var textureSet = {}
  var numTexUnits = limits.maxTextureUnits
  var textureUnits = Array(numTexUnits).map(function () {
    return null
  })

  function REGLTexture (target) {
    TexFlags.call(this)
    this.mipmask = 0
    this.internalformat = GL_RGBA$1

    this.id = textureCount++

    this.refCount = 1

    this.target = target
    this.texture = gl.createTexture()

    this.unit = -1
    this.bindCount = 0

    this.texInfo = new TexInfo()

    if (config.profile) {
      this.stats = { size: 0 }
    }
  }

  function tempBind (texture) {
    gl.activeTexture(GL_TEXTURE0$1)
    gl.bindTexture(texture.target, texture.texture)
  }

  function tempRestore () {
    var prev = textureUnits[0]
    if (prev) {
      gl.bindTexture(prev.target, prev.texture)
    } else {
      gl.bindTexture(GL_TEXTURE_2D$1, null)
    }
  }

  function destroy (texture) {
    var handle = texture.texture
    check$1(handle, 'must not double destroy texture')
    var unit = texture.unit
    var target = texture.target
    if (unit >= 0) {
      gl.activeTexture(GL_TEXTURE0$1 + unit)
      gl.bindTexture(target, null)
      textureUnits[unit] = null
    }
    gl.deleteTexture(handle)
    texture.texture = null
    texture.params = null
    texture.pixels = null
    texture.refCount = 0
    delete textureSet[texture.id]
    stats.textureCount--
  }

  extend(REGLTexture.prototype, {
    bind: function () {
      var texture = this
      texture.bindCount += 1
      var unit = texture.unit
      if (unit < 0) {
        for (var i = 0; i < numTexUnits; ++i) {
          var other = textureUnits[i]
          if (other) {
            if (other.bindCount > 0) {
              continue
            }
            other.unit = -1
          }
          textureUnits[i] = texture
          unit = i
          break
        }
        if (unit >= numTexUnits) {
          check$1.raise('insufficient number of texture units')
        }
        if (config.profile && stats.maxTextureUnits < (unit + 1)) {
          stats.maxTextureUnits = unit + 1 // +1, since the units are zero-based
        }
        texture.unit = unit
        gl.activeTexture(GL_TEXTURE0$1 + unit)
        gl.bindTexture(texture.target, texture.texture)
      }
      return unit
    },

    unbind: function () {
      this.bindCount -= 1
    },

    decRef: function () {
      if (--this.refCount <= 0) {
        destroy(this)
      }
    }
  })

  function createTexture2D (a, b) {
    var texture = new REGLTexture(GL_TEXTURE_2D$1)
    textureSet[texture.id] = texture
    stats.textureCount++

    function reglTexture2D (a, b) {
      var texInfo = texture.texInfo
      TexInfo.call(texInfo)
      var mipData = allocMipMap()

      if (typeof a === 'number') {
        if (typeof b === 'number') {
          parseMipMapFromShape(mipData, a | 0, b | 0)
        } else {
          parseMipMapFromShape(mipData, a | 0, a | 0)
        }
      } else if (a) {
        check$1.type(a, 'object', 'invalid arguments to regl.texture')
        parseTexInfo(texInfo, a)
        parseMipMapFromObject(mipData, a)
      } else {
        // empty textures get assigned a default shape of 1x1
        parseMipMapFromShape(mipData, 1, 1)
      }

      if (texInfo.genMipmaps) {
        mipData.mipmask = (mipData.width << 1) - 1
      }
      texture.mipmask = mipData.mipmask

      copyFlags(texture, mipData)

      check$1.texture2D(texInfo, mipData, limits)
      texture.internalformat = mipData.internalformat

      reglTexture2D.width = mipData.width
      reglTexture2D.height = mipData.height

      tempBind(texture)
      setMipMap(mipData, GL_TEXTURE_2D$1)
      setTexInfo(texInfo, GL_TEXTURE_2D$1)
      tempRestore()

      freeMipMap(mipData)

      if (config.profile) {
        texture.stats.size = getTextureSize(
          texture.internalformat,
          texture.type,
          mipData.width,
          mipData.height,
          texInfo.genMipmaps,
          false)
      }
      reglTexture2D.format = textureFormatsInvert[texture.internalformat]
      reglTexture2D.type = textureTypesInvert[texture.type]

      reglTexture2D.mag = magFiltersInvert[texInfo.magFilter]
      reglTexture2D.min = minFiltersInvert[texInfo.minFilter]

      reglTexture2D.wrapS = wrapModesInvert[texInfo.wrapS]
      reglTexture2D.wrapT = wrapModesInvert[texInfo.wrapT]

      return reglTexture2D
    }

    function subimage (image, x_, y_, level_) {
      check$1(!!image, 'must specify image data')

      var x = x_ | 0
      var y = y_ | 0
      var level = level_ | 0

      var imageData = allocImage()
      copyFlags(imageData, texture)
      imageData.width = 0
      imageData.height = 0
      parseImage(imageData, image)
      imageData.width = imageData.width || ((texture.width >> level) - x)
      imageData.height = imageData.height || ((texture.height >> level) - y)

      check$1(
        texture.type === imageData.type &&
        texture.format === imageData.format &&
        texture.internalformat === imageData.internalformat,
        'incompatible format for texture.subimage')
      check$1(
        x >= 0 && y >= 0 &&
        x + imageData.width <= texture.width &&
        y + imageData.height <= texture.height,
        'texture.subimage write out of bounds')
      check$1(
        texture.mipmask & (1 << level),
        'missing mipmap data')
      check$1(
        imageData.data || imageData.element || imageData.needsCopy,
        'missing image data')

      tempBind(texture)
      setSubImage(imageData, GL_TEXTURE_2D$1, x, y, level)
      tempRestore()

      freeImage(imageData)

      return reglTexture2D
    }

    function resize (w_, h_) {
      var w = w_ | 0
      var h = (h_ | 0) || w
      if (w === texture.width && h === texture.height) {
        return reglTexture2D
      }

      reglTexture2D.width = texture.width = w
      reglTexture2D.height = texture.height = h

      tempBind(texture)

      for (var i = 0; texture.mipmask >> i; ++i) {
        var _w = w >> i
        var _h = h >> i
        if (!_w || !_h) break
        gl.texImage2D(
          GL_TEXTURE_2D$1,
          i,
          texture.format,
          _w,
          _h,
          0,
          texture.format,
          texture.type,
          null)
      }
      tempRestore()

      // also, recompute the texture size.
      if (config.profile) {
        texture.stats.size = getTextureSize(
          texture.internalformat,
          texture.type,
          w,
          h,
          false,
          false)
      }

      return reglTexture2D
    }

    reglTexture2D(a, b)

    reglTexture2D.subimage = subimage
    reglTexture2D.resize = resize
    reglTexture2D._reglType = 'texture2d'
    reglTexture2D._texture = texture
    if (config.profile) {
      reglTexture2D.stats = texture.stats
    }
    reglTexture2D.destroy = function () {
      texture.decRef()
    }

    return reglTexture2D
  }

  function createTextureCube (a0, a1, a2, a3, a4, a5) {
    var texture = new REGLTexture(GL_TEXTURE_CUBE_MAP$1)
    textureSet[texture.id] = texture
    stats.cubeCount++

    var faces = new Array(6)

    function reglTextureCube (a0, a1, a2, a3, a4, a5) {
      var i
      var texInfo = texture.texInfo
      TexInfo.call(texInfo)
      for (i = 0; i < 6; ++i) {
        faces[i] = allocMipMap()
      }

      if (typeof a0 === 'number' || !a0) {
        var s = (a0 | 0) || 1
        for (i = 0; i < 6; ++i) {
          parseMipMapFromShape(faces[i], s, s)
        }
      } else if (typeof a0 === 'object') {
        if (a1) {
          parseMipMapFromObject(faces[0], a0)
          parseMipMapFromObject(faces[1], a1)
          parseMipMapFromObject(faces[2], a2)
          parseMipMapFromObject(faces[3], a3)
          parseMipMapFromObject(faces[4], a4)
          parseMipMapFromObject(faces[5], a5)
        } else {
          parseTexInfo(texInfo, a0)
          parseFlags(texture, a0)
          if ('faces' in a0) {
            var faceInput = a0.faces
            check$1(Array.isArray(faceInput) && faceInput.length === 6,
              'cube faces must be a length 6 array')
            for (i = 0; i < 6; ++i) {
              check$1(typeof faceInput[i] === 'object' && !!faceInput[i],
                'invalid input for cube map face')
              copyFlags(faces[i], texture)
              parseMipMapFromObject(faces[i], faceInput[i])
            }
          } else {
            for (i = 0; i < 6; ++i) {
              parseMipMapFromObject(faces[i], a0)
            }
          }
        }
      } else {
        check$1.raise('invalid arguments to cube map')
      }

      copyFlags(texture, faces[0])

      if (!limits.npotTextureCube) {
        check$1(isPow2$1(texture.width) && isPow2$1(texture.height), 'your browser does not support non power or two texture dimensions')
      }

      if (texInfo.genMipmaps) {
        texture.mipmask = (faces[0].width << 1) - 1
      } else {
        texture.mipmask = faces[0].mipmask
      }

      check$1.textureCube(texture, texInfo, faces, limits)
      texture.internalformat = faces[0].internalformat

      reglTextureCube.width = faces[0].width
      reglTextureCube.height = faces[0].height

      tempBind(texture)
      for (i = 0; i < 6; ++i) {
        setMipMap(faces[i], GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i)
      }
      setTexInfo(texInfo, GL_TEXTURE_CUBE_MAP$1)
      tempRestore()

      if (config.profile) {
        texture.stats.size = getTextureSize(
          texture.internalformat,
          texture.type,
          reglTextureCube.width,
          reglTextureCube.height,
          texInfo.genMipmaps,
          true)
      }

      reglTextureCube.format = textureFormatsInvert[texture.internalformat]
      reglTextureCube.type = textureTypesInvert[texture.type]

      reglTextureCube.mag = magFiltersInvert[texInfo.magFilter]
      reglTextureCube.min = minFiltersInvert[texInfo.minFilter]

      reglTextureCube.wrapS = wrapModesInvert[texInfo.wrapS]
      reglTextureCube.wrapT = wrapModesInvert[texInfo.wrapT]

      for (i = 0; i < 6; ++i) {
        freeMipMap(faces[i])
      }

      return reglTextureCube
    }

    function subimage (face, image, x_, y_, level_) {
      check$1(!!image, 'must specify image data')
      check$1(typeof face === 'number' && face === (face | 0) &&
        face >= 0 && face < 6, 'invalid face')

      var x = x_ | 0
      var y = y_ | 0
      var level = level_ | 0

      var imageData = allocImage()
      copyFlags(imageData, texture)
      imageData.width = 0
      imageData.height = 0
      parseImage(imageData, image)
      imageData.width = imageData.width || ((texture.width >> level) - x)
      imageData.height = imageData.height || ((texture.height >> level) - y)

      check$1(
        texture.type === imageData.type &&
        texture.format === imageData.format &&
        texture.internalformat === imageData.internalformat,
        'incompatible format for texture.subimage')
      check$1(
        x >= 0 && y >= 0 &&
        x + imageData.width <= texture.width &&
        y + imageData.height <= texture.height,
        'texture.subimage write out of bounds')
      check$1(
        texture.mipmask & (1 << level),
        'missing mipmap data')
      check$1(
        imageData.data || imageData.element || imageData.needsCopy,
        'missing image data')

      tempBind(texture)
      setSubImage(imageData, GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + face, x, y, level)
      tempRestore()

      freeImage(imageData)

      return reglTextureCube
    }

    function resize (radius_) {
      var radius = radius_ | 0
      if (radius === texture.width) {
        return
      }

      reglTextureCube.width = texture.width = radius
      reglTextureCube.height = texture.height = radius

      tempBind(texture)
      for (var i = 0; i < 6; ++i) {
        for (var j = 0; texture.mipmask >> j; ++j) {
          gl.texImage2D(
            GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i,
            j,
            texture.format,
            radius >> j,
            radius >> j,
            0,
            texture.format,
            texture.type,
            null)
        }
      }
      tempRestore()

      if (config.profile) {
        texture.stats.size = getTextureSize(
          texture.internalformat,
          texture.type,
          reglTextureCube.width,
          reglTextureCube.height,
          false,
          true)
      }

      return reglTextureCube
    }

    reglTextureCube(a0, a1, a2, a3, a4, a5)

    reglTextureCube.subimage = subimage
    reglTextureCube.resize = resize
    reglTextureCube._reglType = 'textureCube'
    reglTextureCube._texture = texture
    if (config.profile) {
      reglTextureCube.stats = texture.stats
    }
    reglTextureCube.destroy = function () {
      texture.decRef()
    }

    return reglTextureCube
  }

  // Called when regl is destroyed
  function destroyTextures () {
    for (var i = 0; i < numTexUnits; ++i) {
      gl.activeTexture(GL_TEXTURE0$1 + i)
      gl.bindTexture(GL_TEXTURE_2D$1, null)
      textureUnits[i] = null
    }
    values(textureSet).forEach(destroy)

    stats.cubeCount = 0
    stats.textureCount = 0
  }

  if (config.profile) {
    stats.getTotalTextureSize = function () {
      var total = 0
      Object.keys(textureSet).forEach(function (key) {
        total += textureSet[key].stats.size
      })
      return total
    }
  }

  function restoreTextures () {
    for (var i = 0; i < numTexUnits; ++i) {
      var tex = textureUnits[i]
      if (tex) {
        tex.bindCount = 0
        tex.unit = -1
        textureUnits[i] = null
      }
    }

    values(textureSet).forEach(function (texture) {
      texture.texture = gl.createTexture()
      gl.bindTexture(texture.target, texture.texture)
      for (var i = 0; i < 32; ++i) {
        if ((texture.mipmask & (1 << i)) === 0) {
          continue
        }
        if (texture.target === GL_TEXTURE_2D$1) {
          gl.texImage2D(GL_TEXTURE_2D$1,
            i,
            texture.internalformat,
            texture.width >> i,
            texture.height >> i,
            0,
            texture.internalformat,
            texture.type,
            null)
        } else {
          for (var j = 0; j < 6; ++j) {
            gl.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + j,
              i,
              texture.internalformat,
              texture.width >> i,
              texture.height >> i,
              0,
              texture.internalformat,
              texture.type,
              null)
          }
        }
      }
      setTexInfo(texture.texInfo, texture.target)
    })
  }

  function refreshTextures () {
    for (var i = 0; i < numTexUnits; ++i) {
      var tex = textureUnits[i]
      if (tex) {
        tex.bindCount = 0
        tex.unit = -1
        textureUnits[i] = null
      }
      gl.activeTexture(GL_TEXTURE0$1 + i)
      gl.bindTexture(GL_TEXTURE_2D$1, null)
      gl.bindTexture(GL_TEXTURE_CUBE_MAP$1, null)
    }
  }

  return {
    create2D: createTexture2D,
    createCube: createTextureCube,
    clear: destroyTextures,
    getTexture: function (wrapper) {
      return null
    },
    restore: restoreTextures,
    refresh: refreshTextures
  }
}

var GL_RENDERBUFFER = 0x8D41

var GL_RGBA4$1 = 0x8056
var GL_RGB5_A1$1 = 0x8057
var GL_RGB565$1 = 0x8D62
var GL_DEPTH_COMPONENT16 = 0x81A5
var GL_STENCIL_INDEX8 = 0x8D48
var GL_DEPTH_STENCIL$1 = 0x84F9

var GL_SRGB8_ALPHA8_EXT = 0x8C43

var GL_RGBA32F_EXT = 0x8814

var GL_RGBA16F_EXT = 0x881A
var GL_RGB16F_EXT = 0x881B

var FORMAT_SIZES = []

FORMAT_SIZES[GL_RGBA4$1] = 2
FORMAT_SIZES[GL_RGB5_A1$1] = 2
FORMAT_SIZES[GL_RGB565$1] = 2

FORMAT_SIZES[GL_DEPTH_COMPONENT16] = 2
FORMAT_SIZES[GL_STENCIL_INDEX8] = 1
FORMAT_SIZES[GL_DEPTH_STENCIL$1] = 4

FORMAT_SIZES[GL_SRGB8_ALPHA8_EXT] = 4
FORMAT_SIZES[GL_RGBA32F_EXT] = 16
FORMAT_SIZES[GL_RGBA16F_EXT] = 8
FORMAT_SIZES[GL_RGB16F_EXT] = 6

function getRenderbufferSize (format, width, height) {
  return FORMAT_SIZES[format] * width * height
}

var wrapRenderbuffers = function (gl, extensions, limits, stats, config) {
  var formatTypes = {
    'rgba4': GL_RGBA4$1,
    'rgb565': GL_RGB565$1,
    'rgb5 a1': GL_RGB5_A1$1,
    'depth': GL_DEPTH_COMPONENT16,
    'stencil': GL_STENCIL_INDEX8,
    'depth stencil': GL_DEPTH_STENCIL$1
  }

  if (extensions.ext_srgb) {
    formatTypes['srgba'] = GL_SRGB8_ALPHA8_EXT
  }

  if (extensions.ext_color_buffer_half_float) {
    formatTypes['rgba16f'] = GL_RGBA16F_EXT
    formatTypes['rgb16f'] = GL_RGB16F_EXT
  }

  if (extensions.webgl_color_buffer_float) {
    formatTypes['rgba32f'] = GL_RGBA32F_EXT
  }

  var formatTypesInvert = []
  Object.keys(formatTypes).forEach(function (key) {
    var val = formatTypes[key]
    formatTypesInvert[val] = key
  })

  var renderbufferCount = 0
  var renderbufferSet = {}

  function REGLRenderbuffer (renderbuffer) {
    this.id = renderbufferCount++
    this.refCount = 1

    this.renderbuffer = renderbuffer

    this.format = GL_RGBA4$1
    this.width = 0
    this.height = 0

    if (config.profile) {
      this.stats = { size: 0 }
    }
  }

  REGLRenderbuffer.prototype.decRef = function () {
    if (--this.refCount <= 0) {
      destroy(this)
    }
  }

  function destroy (rb) {
    var handle = rb.renderbuffer
    check$1(handle, 'must not double destroy renderbuffer')
    gl.bindRenderbuffer(GL_RENDERBUFFER, null)
    gl.deleteRenderbuffer(handle)
    rb.renderbuffer = null
    rb.refCount = 0
    delete renderbufferSet[rb.id]
    stats.renderbufferCount--
  }

  function createRenderbuffer (a, b) {
    var renderbuffer = new REGLRenderbuffer(gl.createRenderbuffer())
    renderbufferSet[renderbuffer.id] = renderbuffer
    stats.renderbufferCount++

    function reglRenderbuffer (a, b) {
      var w = 0
      var h = 0
      var format = GL_RGBA4$1

      if (typeof a === 'object' && a) {
        var options = a
        if ('shape' in options) {
          var shape = options.shape
          check$1(Array.isArray(shape) && shape.length >= 2,
            'invalid renderbuffer shape')
          w = shape[0] | 0
          h = shape[1] | 0
        } else {
          if ('radius' in options) {
            w = h = options.radius | 0
          }
          if ('width' in options) {
            w = options.width | 0
          }
          if ('height' in options) {
            h = options.height | 0
          }
        }
        if ('format' in options) {
          check$1.parameter(options.format, formatTypes,
            'invalid renderbuffer format')
          format = formatTypes[options.format]
        }
      } else if (typeof a === 'number') {
        w = a | 0
        if (typeof b === 'number') {
          h = b | 0
        } else {
          h = w
        }
      } else if (!a) {
        w = h = 1
      } else {
        check$1.raise('invalid arguments to renderbuffer constructor')
      }

      // check shape
      check$1(
        w > 0 && h > 0 &&
        w <= limits.maxRenderbufferSize && h <= limits.maxRenderbufferSize,
        'invalid renderbuffer size')

      if (w === renderbuffer.width &&
          h === renderbuffer.height &&
          format === renderbuffer.format) {
        return
      }

      reglRenderbuffer.width = renderbuffer.width = w
      reglRenderbuffer.height = renderbuffer.height = h
      renderbuffer.format = format

      gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer)
      gl.renderbufferStorage(GL_RENDERBUFFER, format, w, h)

      check$1(
        gl.getError() === 0,
        'invalid render buffer format')

      if (config.profile) {
        renderbuffer.stats.size = getRenderbufferSize(renderbuffer.format, renderbuffer.width, renderbuffer.height)
      }
      reglRenderbuffer.format = formatTypesInvert[renderbuffer.format]

      return reglRenderbuffer
    }

    function resize (w_, h_) {
      var w = w_ | 0
      var h = (h_ | 0) || w

      if (w === renderbuffer.width && h === renderbuffer.height) {
        return reglRenderbuffer
      }

      // check shape
      check$1(
        w > 0 && h > 0 &&
        w <= limits.maxRenderbufferSize && h <= limits.maxRenderbufferSize,
        'invalid renderbuffer size')

      reglRenderbuffer.width = renderbuffer.width = w
      reglRenderbuffer.height = renderbuffer.height = h

      gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer)
      gl.renderbufferStorage(GL_RENDERBUFFER, renderbuffer.format, w, h)

      check$1(
        gl.getError() === 0,
        'invalid render buffer format')

      // also, recompute size.
      if (config.profile) {
        renderbuffer.stats.size = getRenderbufferSize(
          renderbuffer.format, renderbuffer.width, renderbuffer.height)
      }

      return reglRenderbuffer
    }

    reglRenderbuffer(a, b)

    reglRenderbuffer.resize = resize
    reglRenderbuffer._reglType = 'renderbuffer'
    reglRenderbuffer._renderbuffer = renderbuffer
    if (config.profile) {
      reglRenderbuffer.stats = renderbuffer.stats
    }
    reglRenderbuffer.destroy = function () {
      renderbuffer.decRef()
    }

    return reglRenderbuffer
  }

  if (config.profile) {
    stats.getTotalRenderbufferSize = function () {
      var total = 0
      Object.keys(renderbufferSet).forEach(function (key) {
        total += renderbufferSet[key].stats.size
      })
      return total
    }
  }

  function restoreRenderbuffers () {
    values(renderbufferSet).forEach(function (rb) {
      rb.renderbuffer = gl.createRenderbuffer()
      gl.bindRenderbuffer(GL_RENDERBUFFER, rb.renderbuffer)
      gl.renderbufferStorage(GL_RENDERBUFFER, rb.format, rb.width, rb.height)
    })
    gl.bindRenderbuffer(GL_RENDERBUFFER, null)
  }

  return {
    create: createRenderbuffer,
    clear: function () {
      values(renderbufferSet).forEach(destroy)
    },
    restore: restoreRenderbuffers
  }
}

// We store these constants so that the minifier can inline them
var GL_FRAMEBUFFER$1 = 0x8D40
var GL_RENDERBUFFER$1 = 0x8D41

var GL_TEXTURE_2D$2 = 0x0DE1
var GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 = 0x8515

var GL_COLOR_ATTACHMENT0$1 = 0x8CE0
var GL_DEPTH_ATTACHMENT = 0x8D00
var GL_STENCIL_ATTACHMENT = 0x8D20
var GL_DEPTH_STENCIL_ATTACHMENT = 0x821A

var GL_FRAMEBUFFER_COMPLETE$1 = 0x8CD5
var GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6
var GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7
var GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9
var GL_FRAMEBUFFER_UNSUPPORTED = 0x8CDD

var GL_HALF_FLOAT_OES$2 = 0x8D61
var GL_UNSIGNED_BYTE$6 = 0x1401
var GL_FLOAT$5 = 0x1406

var GL_RGB$1 = 0x1907
var GL_RGBA$2 = 0x1908

var GL_DEPTH_COMPONENT$1 = 0x1902

var colorTextureFormatEnums = [
  GL_RGB$1,
  GL_RGBA$2
]

// for every texture format, store
// the number of channels
var textureFormatChannels = []
textureFormatChannels[GL_RGBA$2] = 4
textureFormatChannels[GL_RGB$1] = 3

// for every texture type, store
// the size in bytes.
var textureTypeSizes = []
textureTypeSizes[GL_UNSIGNED_BYTE$6] = 1
textureTypeSizes[GL_FLOAT$5] = 4
textureTypeSizes[GL_HALF_FLOAT_OES$2] = 2

var GL_RGBA4$2 = 0x8056
var GL_RGB5_A1$2 = 0x8057
var GL_RGB565$2 = 0x8D62
var GL_DEPTH_COMPONENT16$1 = 0x81A5
var GL_STENCIL_INDEX8$1 = 0x8D48
var GL_DEPTH_STENCIL$2 = 0x84F9

var GL_SRGB8_ALPHA8_EXT$1 = 0x8C43

var GL_RGBA32F_EXT$1 = 0x8814

var GL_RGBA16F_EXT$1 = 0x881A
var GL_RGB16F_EXT$1 = 0x881B

var colorRenderbufferFormatEnums = [
  GL_RGBA4$2,
  GL_RGB5_A1$2,
  GL_RGB565$2,
  GL_SRGB8_ALPHA8_EXT$1,
  GL_RGBA16F_EXT$1,
  GL_RGB16F_EXT$1,
  GL_RGBA32F_EXT$1
]

var statusCode = {}
statusCode[GL_FRAMEBUFFER_COMPLETE$1] = 'complete'
statusCode[GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT] = 'incomplete attachment'
statusCode[GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS] = 'incomplete dimensions'
statusCode[GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT] = 'incomplete, missing attachment'
statusCode[GL_FRAMEBUFFER_UNSUPPORTED] = 'unsupported'

function wrapFBOState (
  gl,
  extensions,
  limits,
  textureState,
  renderbufferState,
  stats) {
  var framebufferState = {
    cur: null,
    next: null,
    dirty: false,
    setFBO: null
  }

  var colorTextureFormats = ['rgba']
  var colorRenderbufferFormats = ['rgba4', 'rgb565', 'rgb5 a1']

  if (extensions.ext_srgb) {
    colorRenderbufferFormats.push('srgba')
  }

  if (extensions.ext_color_buffer_half_float) {
    colorRenderbufferFormats.push('rgba16f', 'rgb16f')
  }

  if (extensions.webgl_color_buffer_float) {
    colorRenderbufferFormats.push('rgba32f')
  }

  var colorTypes = ['uint8']
  if (extensions.oes_texture_half_float) {
    colorTypes.push('half float', 'float16')
  }
  if (extensions.oes_texture_float) {
    colorTypes.push('float', 'float32')
  }

  function FramebufferAttachment (target, texture, renderbuffer) {
    this.target = target
    this.texture = texture
    this.renderbuffer = renderbuffer

    var w = 0
    var h = 0
    if (texture) {
      w = texture.width
      h = texture.height
    } else if (renderbuffer) {
      w = renderbuffer.width
      h = renderbuffer.height
    }
    this.width = w
    this.height = h
  }

  function decRef (attachment) {
    if (attachment) {
      if (attachment.texture) {
        attachment.texture._texture.decRef()
      }
      if (attachment.renderbuffer) {
        attachment.renderbuffer._renderbuffer.decRef()
      }
    }
  }

  function incRefAndCheckShape (attachment, width, height) {
    if (!attachment) {
      return
    }
    if (attachment.texture) {
      var texture = attachment.texture._texture
      var tw = Math.max(1, texture.width)
      var th = Math.max(1, texture.height)
      check$1(tw === width && th === height,
        'inconsistent width/height for supplied texture')
      texture.refCount += 1
    } else {
      var renderbuffer = attachment.renderbuffer._renderbuffer
      check$1(
        renderbuffer.width === width && renderbuffer.height === height,
        'inconsistent width/height for renderbuffer')
      renderbuffer.refCount += 1
    }
  }

  function attach (location, attachment) {
    if (attachment) {
      if (attachment.texture) {
        gl.framebufferTexture2D(
          GL_FRAMEBUFFER$1,
          location,
          attachment.target,
          attachment.texture._texture.texture,
          0)
      } else {
        gl.framebufferRenderbuffer(
          GL_FRAMEBUFFER$1,
          location,
          GL_RENDERBUFFER$1,
          attachment.renderbuffer._renderbuffer.renderbuffer)
      }
    }
  }

  function parseAttachment (attachment) {
    var target = GL_TEXTURE_2D$2
    var texture = null
    var renderbuffer = null

    var data = attachment
    if (typeof attachment === 'object') {
      data = attachment.data
      if ('target' in attachment) {
        target = attachment.target | 0
      }
    }

    check$1.type(data, 'function', 'invalid attachment data')

    var type = data._reglType
    if (type === 'texture2d') {
      texture = data
      check$1(target === GL_TEXTURE_2D$2)
    } else if (type === 'textureCube') {
      texture = data
      check$1(
        target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 &&
        target < GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 + 6,
        'invalid cube map target')
    } else if (type === 'renderbuffer') {
      renderbuffer = data
      target = GL_RENDERBUFFER$1
    } else {
      check$1.raise('invalid regl object for attachment')
    }

    return new FramebufferAttachment(target, texture, renderbuffer)
  }

  function allocAttachment (
    width,
    height,
    isTexture,
    format,
    type) {
    if (isTexture) {
      var texture = textureState.create2D({
        width: width,
        height: height,
        format: format,
        type: type
      })
      texture._texture.refCount = 0
      return new FramebufferAttachment(GL_TEXTURE_2D$2, texture, null)
    } else {
      var rb = renderbufferState.create({
        width: width,
        height: height,
        format: format
      })
      rb._renderbuffer.refCount = 0
      return new FramebufferAttachment(GL_RENDERBUFFER$1, null, rb)
    }
  }

  function unwrapAttachment (attachment) {
    return attachment && (attachment.texture || attachment.renderbuffer)
  }

  function resizeAttachment (attachment, w, h) {
    if (attachment) {
      if (attachment.texture) {
        attachment.texture.resize(w, h)
      } else if (attachment.renderbuffer) {
        attachment.renderbuffer.resize(w, h)
      }
      attachment.width = w
      attachment.height = h
    }
  }

  var framebufferCount = 0
  var framebufferSet = {}

  function REGLFramebuffer () {
    this.id = framebufferCount++
    framebufferSet[this.id] = this

    this.framebuffer = gl.createFramebuffer()
    this.width = 0
    this.height = 0

    this.colorAttachments = []
    this.depthAttachment = null
    this.stencilAttachment = null
    this.depthStencilAttachment = null
  }

  function decFBORefs (framebuffer) {
    framebuffer.colorAttachments.forEach(decRef)
    decRef(framebuffer.depthAttachment)
    decRef(framebuffer.stencilAttachment)
    decRef(framebuffer.depthStencilAttachment)
  }

  function destroy (framebuffer) {
    var handle = framebuffer.framebuffer
    check$1(handle, 'must not double destroy framebuffer')
    gl.deleteFramebuffer(handle)
    framebuffer.framebuffer = null
    stats.framebufferCount--
    delete framebufferSet[framebuffer.id]
  }

  function updateFramebuffer (framebuffer) {
    var i

    gl.bindFramebuffer(GL_FRAMEBUFFER$1, framebuffer.framebuffer)
    var colorAttachments = framebuffer.colorAttachments
    for (i = 0; i < colorAttachments.length; ++i) {
      attach(GL_COLOR_ATTACHMENT0$1 + i, colorAttachments[i])
    }
    for (i = colorAttachments.length; i < limits.maxColorAttachments; ++i) {
      gl.framebufferTexture2D(
        GL_FRAMEBUFFER$1,
        GL_COLOR_ATTACHMENT0$1 + i,
        GL_TEXTURE_2D$2,
        null,
        0)
    }

    gl.framebufferTexture2D(
      GL_FRAMEBUFFER$1,
      GL_DEPTH_STENCIL_ATTACHMENT,
      GL_TEXTURE_2D$2,
      null,
      0)
    gl.framebufferTexture2D(
      GL_FRAMEBUFFER$1,
      GL_DEPTH_ATTACHMENT,
      GL_TEXTURE_2D$2,
      null,
      0)
    gl.framebufferTexture2D(
      GL_FRAMEBUFFER$1,
      GL_STENCIL_ATTACHMENT,
      GL_TEXTURE_2D$2,
      null,
      0)

    attach(GL_DEPTH_ATTACHMENT, framebuffer.depthAttachment)
    attach(GL_STENCIL_ATTACHMENT, framebuffer.stencilAttachment)
    attach(GL_DEPTH_STENCIL_ATTACHMENT, framebuffer.depthStencilAttachment)

    // Check status code
    var status = gl.checkFramebufferStatus(GL_FRAMEBUFFER$1)
    if (!gl.isContextLost() && status !== GL_FRAMEBUFFER_COMPLETE$1) {
      check$1.raise('framebuffer configuration not supported, status = ' +
        statusCode[status])
    }

    gl.bindFramebuffer(GL_FRAMEBUFFER$1, framebufferState.next ? framebufferState.next.framebuffer : null)
    framebufferState.cur = framebufferState.next

    // FIXME: Clear error code here.  This is a work around for a bug in
    // headless-gl
    gl.getError()
  }

  function createFBO (a0, a1) {
    var framebuffer = new REGLFramebuffer()
    stats.framebufferCount++

    function reglFramebuffer (a, b) {
      var i

      check$1(framebufferState.next !== framebuffer,
        'can not update framebuffer which is currently in use')

      var width = 0
      var height = 0

      var needsDepth = true
      var needsStencil = true

      var colorBuffer = null
      var colorTexture = true
      var colorFormat = 'rgba'
      var colorType = 'uint8'
      var colorCount = 1

      var depthBuffer = null
      var stencilBuffer = null
      var depthStencilBuffer = null
      var depthStencilTexture = false

      if (typeof a === 'number') {
        width = a | 0
        height = (b | 0) || width
      } else if (!a) {
        width = height = 1
      } else {
        check$1.type(a, 'object', 'invalid arguments for framebuffer')
        var options = a

        if ('shape' in options) {
          var shape = options.shape
          check$1(Array.isArray(shape) && shape.length >= 2,
            'invalid shape for framebuffer')
          width = shape[0]
          height = shape[1]
        } else {
          if ('radius' in options) {
            width = height = options.radius
          }
          if ('width' in options) {
            width = options.width
          }
          if ('height' in options) {
            height = options.height
          }
        }

        if ('color' in options ||
            'colors' in options) {
          colorBuffer =
            options.color ||
            options.colors
          if (Array.isArray(colorBuffer)) {
            check$1(
              colorBuffer.length === 1 || extensions.webgl_draw_buffers,
              'multiple render targets not supported')
          }
        }

        if (!colorBuffer) {
          if ('colorCount' in options) {
            colorCount = options.colorCount | 0
            check$1(colorCount > 0, 'invalid color buffer count')
          }

          if ('colorTexture' in options) {
            colorTexture = !!options.colorTexture
            colorFormat = 'rgba4'
          }

          if ('colorType' in options) {
            colorType = options.colorType
            if (!colorTexture) {
              if (colorType === 'half float' || colorType === 'float16') {
                check$1(extensions.ext_color_buffer_half_float,
                  'you must enable EXT_color_buffer_half_float to use 16-bit render buffers')
                colorFormat = 'rgba16f'
              } else if (colorType === 'float' || colorType === 'float32') {
                check$1(extensions.webgl_color_buffer_float,
                  'you must enable WEBGL_color_buffer_float in order to use 32-bit floating point renderbuffers')
                colorFormat = 'rgba32f'
              }
            } else {
              check$1(extensions.oes_texture_float ||
                !(colorType === 'float' || colorType === 'float32'),
              'you must enable OES_texture_float in order to use floating point framebuffer objects')
              check$1(extensions.oes_texture_half_float ||
                !(colorType === 'half float' || colorType === 'float16'),
              'you must enable OES_texture_half_float in order to use 16-bit floating point framebuffer objects')
            }
            check$1.oneOf(colorType, colorTypes, 'invalid color type')
          }

          if ('colorFormat' in options) {
            colorFormat = options.colorFormat
            if (colorTextureFormats.indexOf(colorFormat) >= 0) {
              colorTexture = true
            } else if (colorRenderbufferFormats.indexOf(colorFormat) >= 0) {
              colorTexture = false
            } else {
              if (colorTexture) {
                check$1.oneOf(
                  options.colorFormat, colorTextureFormats,
                  'invalid color format for texture')
              } else {
                check$1.oneOf(
                  options.colorFormat, colorRenderbufferFormats,
                  'invalid color format for renderbuffer')
              }
            }
          }
        }

        if ('depthTexture' in options || 'depthStencilTexture' in options) {
          depthStencilTexture = !!(options.depthTexture ||
            options.depthStencilTexture)
          check$1(!depthStencilTexture || extensions.webgl_depth_texture,
            'webgl_depth_texture extension not supported')
        }

        if ('depth' in options) {
          if (typeof options.depth === 'boolean') {
            needsDepth = options.depth
          } else {
            depthBuffer = options.depth
            needsStencil = false
          }
        }

        if ('stencil' in options) {
          if (typeof options.stencil === 'boolean') {
            needsStencil = options.stencil
          } else {
            stencilBuffer = options.stencil
            needsDepth = false
          }
        }

        if ('depthStencil' in options) {
          if (typeof options.depthStencil === 'boolean') {
            needsDepth = needsStencil = options.depthStencil
          } else {
            depthStencilBuffer = options.depthStencil
            needsDepth = false
            needsStencil = false
          }
        }
      }

      // parse attachments
      var colorAttachments = null
      var depthAttachment = null
      var stencilAttachment = null
      var depthStencilAttachment = null

      // Set up color attachments
      if (Array.isArray(colorBuffer)) {
        colorAttachments = colorBuffer.map(parseAttachment)
      } else if (colorBuffer) {
        colorAttachments = [parseAttachment(colorBuffer)]
      } else {
        colorAttachments = new Array(colorCount)
        for (i = 0; i < colorCount; ++i) {
          colorAttachments[i] = allocAttachment(
            width,
            height,
            colorTexture,
            colorFormat,
            colorType)
        }
      }

      check$1(extensions.webgl_draw_buffers || colorAttachments.length <= 1,
        'you must enable the WEBGL_draw_buffers extension in order to use multiple color buffers.')
      check$1(colorAttachments.length <= limits.maxColorAttachments,
        'too many color attachments, not supported')

      width = width || colorAttachments[0].width
      height = height || colorAttachments[0].height

      if (depthBuffer) {
        depthAttachment = parseAttachment(depthBuffer)
      } else if (needsDepth && !needsStencil) {
        depthAttachment = allocAttachment(
          width,
          height,
          depthStencilTexture,
          'depth',
          'uint32')
      }

      if (stencilBuffer) {
        stencilAttachment = parseAttachment(stencilBuffer)
      } else if (needsStencil && !needsDepth) {
        stencilAttachment = allocAttachment(
          width,
          height,
          false,
          'stencil',
          'uint8')
      }

      if (depthStencilBuffer) {
        depthStencilAttachment = parseAttachment(depthStencilBuffer)
      } else if (!depthBuffer && !stencilBuffer && needsStencil && needsDepth) {
        depthStencilAttachment = allocAttachment(
          width,
          height,
          depthStencilTexture,
          'depth stencil',
          'depth stencil')
      }

      check$1(
        (!!depthBuffer) + (!!stencilBuffer) + (!!depthStencilBuffer) <= 1,
        'invalid framebuffer configuration, can specify exactly one depth/stencil attachment')

      var commonColorAttachmentSize = null

      for (i = 0; i < colorAttachments.length; ++i) {
        incRefAndCheckShape(colorAttachments[i], width, height)
        check$1(!colorAttachments[i] ||
          (colorAttachments[i].texture &&
            colorTextureFormatEnums.indexOf(colorAttachments[i].texture._texture.format) >= 0) ||
          (colorAttachments[i].renderbuffer &&
            colorRenderbufferFormatEnums.indexOf(colorAttachments[i].renderbuffer._renderbuffer.format) >= 0),
        'framebuffer color attachment ' + i + ' is invalid')

        if (colorAttachments[i] && colorAttachments[i].texture) {
          var colorAttachmentSize =
              textureFormatChannels[colorAttachments[i].texture._texture.format] *
              textureTypeSizes[colorAttachments[i].texture._texture.type]

          if (commonColorAttachmentSize === null) {
            commonColorAttachmentSize = colorAttachmentSize
          } else {
            // We need to make sure that all color attachments have the same number of bitplanes
            // (that is, the same numer of bits per pixel)
            // This is required by the GLES2.0 standard. See the beginning of Chapter 4 in that document.
            check$1(commonColorAttachmentSize === colorAttachmentSize,
              'all color attachments much have the same number of bits per pixel.')
          }
        }
      }
      incRefAndCheckShape(depthAttachment, width, height)
      check$1(!depthAttachment ||
        (depthAttachment.texture &&
          depthAttachment.texture._texture.format === GL_DEPTH_COMPONENT$1) ||
        (depthAttachment.renderbuffer &&
          depthAttachment.renderbuffer._renderbuffer.format === GL_DEPTH_COMPONENT16$1),
      'invalid depth attachment for framebuffer object')
      incRefAndCheckShape(stencilAttachment, width, height)
      check$1(!stencilAttachment ||
        (stencilAttachment.renderbuffer &&
          stencilAttachment.renderbuffer._renderbuffer.format === GL_STENCIL_INDEX8$1),
      'invalid stencil attachment for framebuffer object')
      incRefAndCheckShape(depthStencilAttachment, width, height)
      check$1(!depthStencilAttachment ||
        (depthStencilAttachment.texture &&
          depthStencilAttachment.texture._texture.format === GL_DEPTH_STENCIL$2) ||
        (depthStencilAttachment.renderbuffer &&
          depthStencilAttachment.renderbuffer._renderbuffer.format === GL_DEPTH_STENCIL$2),
      'invalid depth-stencil attachment for framebuffer object')

      // decrement references
      decFBORefs(framebuffer)

      framebuffer.width = width
      framebuffer.height = height

      framebuffer.colorAttachments = colorAttachments
      framebuffer.depthAttachment = depthAttachment
      framebuffer.stencilAttachment = stencilAttachment
      framebuffer.depthStencilAttachment = depthStencilAttachment

      reglFramebuffer.color = colorAttachments.map(unwrapAttachment)
      reglFramebuffer.depth = unwrapAttachment(depthAttachment)
      reglFramebuffer.stencil = unwrapAttachment(stencilAttachment)
      reglFramebuffer.depthStencil = unwrapAttachment(depthStencilAttachment)

      reglFramebuffer.width = framebuffer.width
      reglFramebuffer.height = framebuffer.height

      updateFramebuffer(framebuffer)

      return reglFramebuffer
    }

    function resize (w_, h_) {
      check$1(framebufferState.next !== framebuffer,
        'can not resize a framebuffer which is currently in use')

      var w = Math.max(w_ | 0, 1)
      var h = Math.max((h_ | 0) || w, 1)
      if (w === framebuffer.width && h === framebuffer.height) {
        return reglFramebuffer
      }

      // resize all buffers
      var colorAttachments = framebuffer.colorAttachments
      for (var i = 0; i < colorAttachments.length; ++i) {
        resizeAttachment(colorAttachments[i], w, h)
      }
      resizeAttachment(framebuffer.depthAttachment, w, h)
      resizeAttachment(framebuffer.stencilAttachment, w, h)
      resizeAttachment(framebuffer.depthStencilAttachment, w, h)

      framebuffer.width = reglFramebuffer.width = w
      framebuffer.height = reglFramebuffer.height = h

      updateFramebuffer(framebuffer)

      return reglFramebuffer
    }

    reglFramebuffer(a0, a1)

    return extend(reglFramebuffer, {
      resize: resize,
      _reglType: 'framebuffer',
      _framebuffer: framebuffer,
      destroy: function () {
        destroy(framebuffer)
        decFBORefs(framebuffer)
      },
      use: function (block) {
        framebufferState.setFBO({
          framebuffer: reglFramebuffer
        }, block)
      }
    })
  }

  function createCubeFBO (options) {
    var faces = Array(6)

    function reglFramebufferCube (a) {
      var i

      check$1(faces.indexOf(framebufferState.next) < 0,
        'can not update framebuffer which is currently in use')

      var params = {
        color: null
      }

      var radius = 0

      var colorBuffer = null
      var colorFormat = 'rgba'
      var colorType = 'uint8'
      var colorCount = 1

      if (typeof a === 'number') {
        radius = a | 0
      } else if (!a) {
        radius = 1
      } else {
        check$1.type(a, 'object', 'invalid arguments for framebuffer')
        var options = a

        if ('shape' in options) {
          var shape = options.shape
          check$1(
            Array.isArray(shape) && shape.length >= 2,
            'invalid shape for framebuffer')
          check$1(
            shape[0] === shape[1],
            'cube framebuffer must be square')
          radius = shape[0]
        } else {
          if ('radius' in options) {
            radius = options.radius | 0
          }
          if ('width' in options) {
            radius = options.width | 0
            if ('height' in options) {
              check$1(options.height === radius, 'must be square')
            }
          } else if ('height' in options) {
            radius = options.height | 0
          }
        }

        if ('color' in options ||
            'colors' in options) {
          colorBuffer =
            options.color ||
            options.colors
          if (Array.isArray(colorBuffer)) {
            check$1(
              colorBuffer.length === 1 || extensions.webgl_draw_buffers,
              'multiple render targets not supported')
          }
        }

        if (!colorBuffer) {
          if ('colorCount' in options) {
            colorCount = options.colorCount | 0
            check$1(colorCount > 0, 'invalid color buffer count')
          }

          if ('colorType' in options) {
            check$1.oneOf(
              options.colorType, colorTypes,
              'invalid color type')
            colorType = options.colorType
          }

          if ('colorFormat' in options) {
            colorFormat = options.colorFormat
            check$1.oneOf(
              options.colorFormat, colorTextureFormats,
              'invalid color format for texture')
          }
        }

        if ('depth' in options) {
          params.depth = options.depth
        }

        if ('stencil' in options) {
          params.stencil = options.stencil
        }

        if ('depthStencil' in options) {
          params.depthStencil = options.depthStencil
        }
      }

      var colorCubes
      if (colorBuffer) {
        if (Array.isArray(colorBuffer)) {
          colorCubes = []
          for (i = 0; i < colorBuffer.length; ++i) {
            colorCubes[i] = colorBuffer[i]
          }
        } else {
          colorCubes = [ colorBuffer ]
        }
      } else {
        colorCubes = Array(colorCount)
        var cubeMapParams = {
          radius: radius,
          format: colorFormat,
          type: colorType
        }
        for (i = 0; i < colorCount; ++i) {
          colorCubes[i] = textureState.createCube(cubeMapParams)
        }
      }

      // Check color cubes
      params.color = Array(colorCubes.length)
      for (i = 0; i < colorCubes.length; ++i) {
        var cube = colorCubes[i]
        check$1(
          typeof cube === 'function' && cube._reglType === 'textureCube',
          'invalid cube map')
        radius = radius || cube.width
        check$1(
          cube.width === radius && cube.height === radius,
          'invalid cube map shape')
        params.color[i] = {
          target: GL_TEXTURE_CUBE_MAP_POSITIVE_X$2,
          data: colorCubes[i]
        }
      }

      for (i = 0; i < 6; ++i) {
        for (var j = 0; j < colorCubes.length; ++j) {
          params.color[j].target = GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 + i
        }
        // reuse depth-stencil attachments across all cube maps
        if (i > 0) {
          params.depth = faces[0].depth
          params.stencil = faces[0].stencil
          params.depthStencil = faces[0].depthStencil
        }
        if (faces[i]) {
          (faces[i])(params)
        } else {
          faces[i] = createFBO(params)
        }
      }

      return extend(reglFramebufferCube, {
        width: radius,
        height: radius,
        color: colorCubes
      })
    }

    function resize (radius_) {
      var i
      var radius = radius_ | 0
      check$1(radius > 0 && radius <= limits.maxCubeMapSize,
        'invalid radius for cube fbo')

      if (radius === reglFramebufferCube.width) {
        return reglFramebufferCube
      }

      var colors = reglFramebufferCube.color
      for (i = 0; i < colors.length; ++i) {
        colors[i].resize(radius)
      }

      for (i = 0; i < 6; ++i) {
        faces[i].resize(radius)
      }

      reglFramebufferCube.width = reglFramebufferCube.height = radius

      return reglFramebufferCube
    }

    reglFramebufferCube(options)

    return extend(reglFramebufferCube, {
      faces: faces,
      resize: resize,
      _reglType: 'framebufferCube',
      destroy: function () {
        faces.forEach(function (f) {
          f.destroy()
        })
      }
    })
  }

  function restoreFramebuffers () {
    framebufferState.cur = null
    framebufferState.next = null
    framebufferState.dirty = true
    values(framebufferSet).forEach(function (fb) {
      fb.framebuffer = gl.createFramebuffer()
      updateFramebuffer(fb)
    })
  }

  return extend(framebufferState, {
    getFramebuffer: function (object) {
      if (typeof object === 'function' && object._reglType === 'framebuffer') {
        var fbo = object._framebuffer
        if (fbo instanceof REGLFramebuffer) {
          return fbo
        }
      }
      return null
    },
    create: createFBO,
    createCube: createCubeFBO,
    clear: function () {
      values(framebufferSet).forEach(destroy)
    },
    restore: restoreFramebuffers
  })
}

var GL_FLOAT$6 = 5126
var GL_ARRAY_BUFFER$1 = 34962

function AttributeRecord () {
  this.state = 0

  this.x = 0.0
  this.y = 0.0
  this.z = 0.0
  this.w = 0.0

  this.buffer = null
  this.size = 0
  this.normalized = false
  this.type = GL_FLOAT$6
  this.offset = 0
  this.stride = 0
  this.divisor = 0
}

function wrapAttributeState (
  gl,
  extensions,
  limits,
  stats,
  bufferState) {
  var NUM_ATTRIBUTES = limits.maxAttributes
  var attributeBindings = new Array(NUM_ATTRIBUTES)
  for (var i = 0; i < NUM_ATTRIBUTES; ++i) {
    attributeBindings[i] = new AttributeRecord()
  }
  var vaoCount = 0
  var vaoSet = {}

  var state = {
    Record: AttributeRecord,
    scope: {},
    state: attributeBindings,
    currentVAO: null,
    targetVAO: null,
    restore: extVAO() ? restoreVAO : function () {},
    createVAO: createVAO,
    getVAO: getVAO,
    destroyBuffer: destroyBuffer,
    setVAO: extVAO() ? setVAOEXT : setVAOEmulated,
    clear: extVAO() ? destroyVAOEXT : function () {}
  }

  function destroyBuffer (buffer) {
    for (var i = 0; i < attributeBindings.length; ++i) {
      var record = attributeBindings[i]
      if (record.buffer === buffer) {
        gl.disableVertexAttribArray(i)
        record.buffer = null
      }
    }
  }

  function extVAO () {
    return extensions.oes_vertex_array_object
  }

  function extInstanced () {
    return extensions.angle_instanced_arrays
  }

  function getVAO (vao) {
    if (typeof vao === 'function' && vao._vao) {
      return vao._vao
    }
    return null
  }

  function setVAOEXT (vao) {
    if (vao === state.currentVAO) {
      return
    }
    var ext = extVAO()
    if (vao) {
      ext.bindVertexArrayOES(vao.vao)
    } else {
      ext.bindVertexArrayOES(null)
    }
    state.currentVAO = vao
  }

  function setVAOEmulated (vao) {
    if (vao === state.currentVAO) {
      return
    }
    if (vao) {
      vao.bindAttrs()
    } else {
      var exti = extInstanced()
      for (var i = 0; i < attributeBindings.length; ++i) {
        var binding = attributeBindings[i]
        if (binding.buffer) {
          gl.enableVertexAttribArray(i)
          gl.vertexAttribPointer(i, binding.size, binding.type, binding.normalized, binding.stride, binding.offfset)
          if (exti && binding.divisor) {
            exti.vertexAttribDivisorANGLE(i, binding.divisor)
          }
        } else {
          gl.disableVertexAttribArray(i)
          gl.vertexAttrib4f(i, binding.x, binding.y, binding.z, binding.w)
        }
      }
    }
    state.currentVAO = vao
  }

  function destroyVAOEXT () {
    values(vaoSet).forEach(function (vao) {
      vao.destroy()
    })
  }

  function REGLVAO () {
    this.id = ++vaoCount
    this.attributes = []
    var extension = extVAO()
    if (extension) {
      this.vao = extension.createVertexArrayOES()
    } else {
      this.vao = null
    }
    vaoSet[this.id] = this
    this.buffers = []
  }

  REGLVAO.prototype.bindAttrs = function () {
    var exti = extInstanced()
    var attributes = this.attributes
    for (var i = 0; i < attributes.length; ++i) {
      var attr = attributes[i]
      if (attr.buffer) {
        gl.enableVertexAttribArray(i)
        gl.bindBuffer(GL_ARRAY_BUFFER$1, attr.buffer.buffer)
        gl.vertexAttribPointer(i, attr.size, attr.type, attr.normalized, attr.stride, attr.offset)
        if (exti && attr.divisor) {
          exti.vertexAttribDivisorANGLE(i, attr.divisor)
        }
      } else {
        gl.disableVertexAttribArray(i)
        gl.vertexAttrib4f(i, attr.x, attr.y, attr.z, attr.w)
      }
    }
    for (var j = attributes.length; j < NUM_ATTRIBUTES; ++j) {
      gl.disableVertexAttribArray(j)
    }
  }

  REGLVAO.prototype.refresh = function () {
    var ext = extVAO()
    if (ext) {
      ext.bindVertexArrayOES(this.vao)
      this.bindAttrs()
      state.currentVAO = this
    }
  }

  REGLVAO.prototype.destroy = function () {
    if (this.vao) {
      var extension = extVAO()
      if (this === state.currentVAO) {
        state.currentVAO = null
        extension.bindVertexArrayOES(null)
      }
      extension.deleteVertexArrayOES(this.vao)
      this.vao = null
    }
    if (vaoSet[this.id]) {
      delete vaoSet[this.id]
      stats.vaoCount -= 1
    }
  }

  function restoreVAO () {
    var ext = extVAO()
    if (ext) {
      values(vaoSet).forEach(function (vao) {
        vao.refresh()
      })
    }
  }

  function createVAO (_attr) {
    var vao = new REGLVAO()
    stats.vaoCount += 1

    function updateVAO (attributes) {
      check$1(Array.isArray(attributes), 'arguments to vertex array constructor must be an array')
      check$1(attributes.length < NUM_ATTRIBUTES, 'too many attributes')
      check$1(attributes.length > 0, 'must specify at least one attribute')

      var bufUpdated = {}
      var nattributes = vao.attributes
      nattributes.length = attributes.length
      for (var i = 0; i < attributes.length; ++i) {
        var spec = attributes[i]
        var rec = nattributes[i] = new AttributeRecord()
        var data = spec.data || spec
        if (Array.isArray(data) || isTypedArray(data) || isNDArrayLike(data)) {
          var buf
          if (vao.buffers[i]) {
            buf = vao.buffers[i]
            if (isTypedArray(data) && buf._buffer.byteLength >= data.byteLength) {
              buf.subdata(data)
            } else {
              buf.destroy()
              vao.buffers[i] = null
            }
          }
          if (!vao.buffers[i]) {
            buf = vao.buffers[i] = bufferState.create(spec, GL_ARRAY_BUFFER$1, false, true)
          }
          rec.buffer = bufferState.getBuffer(buf)
          rec.size = rec.buffer.dimension | 0
          rec.normalized = false
          rec.type = rec.buffer.dtype
          rec.offset = 0
          rec.stride = 0
          rec.divisor = 0
          rec.state = 1
          bufUpdated[i] = 1
        } else if (bufferState.getBuffer(spec)) {
          rec.buffer = bufferState.getBuffer(spec)
          rec.size = rec.buffer.dimension | 0
          rec.normalized = false
          rec.type = rec.buffer.dtype
          rec.offset = 0
          rec.stride = 0
          rec.divisor = 0
          rec.state = 1
        } else if (bufferState.getBuffer(spec.buffer)) {
          rec.buffer = bufferState.getBuffer(spec.buffer)
          rec.size = ((+spec.size) || rec.buffer.dimension) | 0
          rec.normalized = !!spec.normalized || false
          if ('type' in spec) {
            check$1.parameter(spec.type, glTypes, 'invalid buffer type')
            rec.type = glTypes[spec.type]
          } else {
            rec.type = rec.buffer.dtype
          }
          rec.offset = (spec.offset || 0) | 0
          rec.stride = (spec.stride || 0) | 0
          rec.divisor = (spec.divisor || 0) | 0
          rec.state = 1

          check$1(rec.size >= 1 && rec.size <= 4, 'size must be between 1 and 4')
          check$1(rec.offset >= 0, 'invalid offset')
          check$1(rec.stride >= 0 && rec.stride <= 255, 'stride must be between 0 and 255')
          check$1(rec.divisor >= 0, 'divisor must be positive')
          check$1(!rec.divisor || !!extensions.angle_instanced_arrays, 'ANGLE_instanced_arrays must be enabled to use divisor')
        } else if ('x' in spec) {
          check$1(i > 0, 'first attribute must not be a constant')
          rec.x = +spec.x || 0
          rec.y = +spec.y || 0
          rec.z = +spec.z || 0
          rec.w = +spec.w || 0
          rec.state = 2
        } else {
          check$1(false, 'invalid attribute spec for location ' + i)
        }
      }

      // retire unused buffers
      for (var j = 0; j < vao.buffers.length; ++j) {
        if (!bufUpdated[j] && vao.buffers[j]) {
          vao.buffers[j].destroy()
          vao.buffers[j] = null
        }
      }

      vao.refresh()
      return updateVAO
    }

    updateVAO.destroy = function () {
      for (var j = 0; j < vao.buffers.length; ++j) {
        if (vao.buffers[j]) {
          vao.buffers[j].destroy()
        }
      }
      vao.buffers.length = 0
      vao.destroy()
    }

    updateVAO._vao = vao
    updateVAO._reglType = 'vao'

    return updateVAO(_attr)
  }

  return state
}

var GL_FRAGMENT_SHADER = 35632
var GL_VERTEX_SHADER = 35633

var GL_ACTIVE_UNIFORMS = 0x8B86
var GL_ACTIVE_ATTRIBUTES = 0x8B89

function wrapShaderState (gl, stringStore, stats, config) {
  // ===================================================
  // glsl compilation and linking
  // ===================================================
  var fragShaders = {}
  var vertShaders = {}

  function ActiveInfo (name, id, location, info) {
    this.name = name
    this.id = id
    this.location = location
    this.info = info
  }

  function insertActiveInfo (list, info) {
    for (var i = 0; i < list.length; ++i) {
      if (list[i].id === info.id) {
        list[i].location = info.location
        return
      }
    }
    list.push(info)
  }

  function getShader (type, id, command) {
    var cache = type === GL_FRAGMENT_SHADER ? fragShaders : vertShaders
    var shader = cache[id]

    if (!shader) {
      var source = stringStore.str(id)
      shader = gl.createShader(type)
      gl.shaderSource(shader, source)
      gl.compileShader(shader)
      check$1.shaderError(gl, shader, source, type, command)
      cache[id] = shader
    }

    return shader
  }

  // ===================================================
  // program linking
  // ===================================================
  var programCache = {}
  var programList = []

  var PROGRAM_COUNTER = 0

  function REGLProgram (fragId, vertId) {
    this.id = PROGRAM_COUNTER++
    this.fragId = fragId
    this.vertId = vertId
    this.program = null
    this.uniforms = []
    this.attributes = []
    this.refCount = 1

    if (config.profile) {
      this.stats = {
        uniformsCount: 0,
        attributesCount: 0
      }
    }
  }

  function linkProgram (desc, command, attributeLocations) {
    var i, info

    // -------------------------------
    // compile & link
    // -------------------------------
    var fragShader = getShader(GL_FRAGMENT_SHADER, desc.fragId)
    var vertShader = getShader(GL_VERTEX_SHADER, desc.vertId)

    var program = desc.program = gl.createProgram()
    gl.attachShader(program, fragShader)
    gl.attachShader(program, vertShader)
    if (attributeLocations) {
      for (i = 0; i < attributeLocations.length; ++i) {
        var binding = attributeLocations[i]
        gl.bindAttribLocation(program, binding[0], binding[1])
      }
    }

    gl.linkProgram(program)
    check$1.linkError(
      gl,
      program,
      stringStore.str(desc.fragId),
      stringStore.str(desc.vertId),
      command)

    // -------------------------------
    // grab uniforms
    // -------------------------------
    var numUniforms = gl.getProgramParameter(program, GL_ACTIVE_UNIFORMS)
    if (config.profile) {
      desc.stats.uniformsCount = numUniforms
    }
    var uniforms = desc.uniforms
    for (i = 0; i < numUniforms; ++i) {
      info = gl.getActiveUniform(program, i)
      if (info) {
        if (info.size > 1) {
          for (var j = 0; j < info.size; ++j) {
            var name = info.name.replace('[0]', '[' + j + ']')
            insertActiveInfo(uniforms, new ActiveInfo(
              name,
              stringStore.id(name),
              gl.getUniformLocation(program, name),
              info))
          }
        } else {
          insertActiveInfo(uniforms, new ActiveInfo(
            info.name,
            stringStore.id(info.name),
            gl.getUniformLocation(program, info.name),
            info))
        }
      }
    }

    // -------------------------------
    // grab attributes
    // -------------------------------
    var numAttributes = gl.getProgramParameter(program, GL_ACTIVE_ATTRIBUTES)
    if (config.profile) {
      desc.stats.attributesCount = numAttributes
    }

    var attributes = desc.attributes
    for (i = 0; i < numAttributes; ++i) {
      info = gl.getActiveAttrib(program, i)
      if (info) {
        insertActiveInfo(attributes, new ActiveInfo(
          info.name,
          stringStore.id(info.name),
          gl.getAttribLocation(program, info.name),
          info))
      }
    }
  }

  if (config.profile) {
    stats.getMaxUniformsCount = function () {
      var m = 0
      programList.forEach(function (desc) {
        if (desc.stats.uniformsCount > m) {
          m = desc.stats.uniformsCount
        }
      })
      return m
    }

    stats.getMaxAttributesCount = function () {
      var m = 0
      programList.forEach(function (desc) {
        if (desc.stats.attributesCount > m) {
          m = desc.stats.attributesCount
        }
      })
      return m
    }
  }

  function restoreShaders () {
    fragShaders = {}
    vertShaders = {}
    for (var i = 0; i < programList.length; ++i) {
      linkProgram(programList[i], null, programList[i].attributes.map(function (info) {
        return [info.location, info.name]
      }))
    }
  }

  return {
    clear: function () {
      var deleteShader = gl.deleteShader.bind(gl)
      values(fragShaders).forEach(deleteShader)
      fragShaders = {}
      values(vertShaders).forEach(deleteShader)
      vertShaders = {}

      programList.forEach(function (desc) {
        gl.deleteProgram(desc.program)
      })
      programList.length = 0
      programCache = {}

      stats.shaderCount = 0
    },

    program: function (vertId, fragId, command, attribLocations) {
      check$1.command(vertId >= 0, 'missing vertex shader', command)
      check$1.command(fragId >= 0, 'missing fragment shader', command)

      var cache = programCache[fragId]
      if (!cache) {
        cache = programCache[fragId] = {}
      }
      var prevProgram = cache[vertId]
      if (prevProgram) {
        prevProgram.refCount++
        if (!attribLocations) {
          return prevProgram
        }
      }
      var program = new REGLProgram(fragId, vertId)
      stats.shaderCount++
      linkProgram(program, command, attribLocations)
      if (!prevProgram) {
        cache[vertId] = program
      }
      programList.push(program)
      return extend(program, {
        destroy: function () {
          program.refCount--
          if (program.refCount <= 0) {
            gl.deleteProgram(program.program)
            var idx = programList.indexOf(program)
            programList.splice(idx, 1)
            stats.shaderCount--
          }
          // no program is linked to this vert anymore
          if (cache[program.vertId].refCount <= 0) {
            gl.deleteShader(vertShaders[program.vertId])
            delete vertShaders[program.vertId]
            delete programCache[program.fragId][program.vertId]
          }
          // no program is linked to this frag anymore
          if (!Object.keys(programCache[program.fragId]).length) {
            gl.deleteShader(fragShaders[program.fragId])
            delete fragShaders[program.fragId]
            delete programCache[program.fragId]
          }
        }
      })
    },

    restore: restoreShaders,

    shader: getShader,

    frag: -1,
    vert: -1
  }
}

var GL_RGBA$3 = 6408
var GL_UNSIGNED_BYTE$7 = 5121
var GL_PACK_ALIGNMENT = 0x0D05
var GL_FLOAT$7 = 0x1406 // 5126

function wrapReadPixels (
  gl,
  framebufferState,
  reglPoll,
  context,
  glAttributes,
  extensions,
  limits) {
  function readPixelsImpl (input) {
    var type
    if (framebufferState.next === null) {
      check$1(
        glAttributes.preserveDrawingBuffer,
        'you must create a webgl context with "preserveDrawingBuffer":true in order to read pixels from the drawing buffer')
      type = GL_UNSIGNED_BYTE$7
    } else {
      check$1(
        framebufferState.next.colorAttachments[0].texture !== null,
        'You cannot read from a renderbuffer')
      type = framebufferState.next.colorAttachments[0].texture._texture.type

      if (extensions.oes_texture_float) {
        check$1(
          type === GL_UNSIGNED_BYTE$7 || type === GL_FLOAT$7,
          'Reading from a framebuffer is only allowed for the types \'uint8\' and \'float\'')

        if (type === GL_FLOAT$7) {
          check$1(limits.readFloat, 'Reading \'float\' values is not permitted in your browser. For a fallback, please see: https://www.npmjs.com/package/glsl-read-float')
        }
      } else {
        check$1(
          type === GL_UNSIGNED_BYTE$7,
          'Reading from a framebuffer is only allowed for the type \'uint8\'')
      }
    }

    var x = 0
    var y = 0
    var width = context.framebufferWidth
    var height = context.framebufferHeight
    var data = null

    if (isTypedArray(input)) {
      data = input
    } else if (input) {
      check$1.type(input, 'object', 'invalid arguments to regl.read()')
      x = input.x | 0
      y = input.y | 0
      check$1(
        x >= 0 && x < context.framebufferWidth,
        'invalid x offset for regl.read')
      check$1(
        y >= 0 && y < context.framebufferHeight,
        'invalid y offset for regl.read')
      width = (input.width || (context.framebufferWidth - x)) | 0
      height = (input.height || (context.framebufferHeight - y)) | 0
      data = input.data || null
    }

    // sanity check input.data
    if (data) {
      if (type === GL_UNSIGNED_BYTE$7) {
        check$1(
          data instanceof Uint8Array,
          'buffer must be \'Uint8Array\' when reading from a framebuffer of type \'uint8\'')
      } else if (type === GL_FLOAT$7) {
        check$1(
          data instanceof Float32Array,
          'buffer must be \'Float32Array\' when reading from a framebuffer of type \'float\'')
      }
    }

    check$1(
      width > 0 && width + x <= context.framebufferWidth,
      'invalid width for read pixels')
    check$1(
      height > 0 && height + y <= context.framebufferHeight,
      'invalid height for read pixels')

    // Update WebGL state
    reglPoll()

    // Compute size
    var size = width * height * 4

    // Allocate data
    if (!data) {
      if (type === GL_UNSIGNED_BYTE$7) {
        data = new Uint8Array(size)
      } else if (type === GL_FLOAT$7) {
        data = data || new Float32Array(size)
      }
    }

    // Type check
    check$1.isTypedArray(data, 'data buffer for regl.read() must be a typedarray')
    check$1(data.byteLength >= size, 'data buffer for regl.read() too small')

    // Run read pixels
    gl.pixelStorei(GL_PACK_ALIGNMENT, 4)
    gl.readPixels(x, y, width, height, GL_RGBA$3,
      type,
      data)

    return data
  }

  function readPixelsFBO (options) {
    var result
    framebufferState.setFBO({
      framebuffer: options.framebuffer
    }, function () {
      result = readPixelsImpl(options)
    })
    return result
  }

  function readPixels (options) {
    if (!options || !('framebuffer' in options)) {
      return readPixelsImpl(options)
    } else {
      return readPixelsFBO(options)
    }
  }

  return readPixels
}

function slice (x) {
  return Array.prototype.slice.call(x)
}

function join (x) {
  return slice(x).join('')
}

function createEnvironment () {
  // Unique variable id counter
  var varCounter = 0

  // Linked values are passed from this scope into the generated code block
  // Calling link() passes a value into the generated scope and returns
  // the variable name which it is bound to
  var linkedNames = []
  var linkedValues = []
  function link (value) {
    for (var i = 0; i < linkedValues.length; ++i) {
      if (linkedValues[i] === value) {
        return linkedNames[i]
      }
    }

    var name = 'g' + (varCounter++)
    linkedNames.push(name)
    linkedValues.push(value)
    return name
  }

  // create a code block
  function block () {
    var code = []
    function push () {
      code.push.apply(code, slice(arguments))
    }

    var vars = []
    function def () {
      var name = 'v' + (varCounter++)
      vars.push(name)

      if (arguments.length > 0) {
        code.push(name, '=')
        code.push.apply(code, slice(arguments))
        code.push(';')
      }

      return name
    }

    return extend(push, {
      def: def,
      toString: function () {
        return join([
          (vars.length > 0 ? 'var ' + vars.join(',') + ';' : ''),
          join(code)
        ])
      }
    })
  }

  function scope () {
    var entry = block()
    var exit = block()

    var entryToString = entry.toString
    var exitToString = exit.toString

    function save (object, prop) {
      exit(object, prop, '=', entry.def(object, prop), ';')
    }

    return extend(function () {
      entry.apply(entry, slice(arguments))
    }, {
      def: entry.def,
      entry: entry,
      exit: exit,
      save: save,
      set: function (object, prop, value) {
        save(object, prop)
        entry(object, prop, '=', value, ';')
      },
      toString: function () {
        return entryToString() + exitToString()
      }
    })
  }

  function conditional () {
    var pred = join(arguments)
    var thenBlock = scope()
    var elseBlock = scope()

    var thenToString = thenBlock.toString
    var elseToString = elseBlock.toString

    return extend(thenBlock, {
      then: function () {
        thenBlock.apply(thenBlock, slice(arguments))
        return this
      },
      else: function () {
        elseBlock.apply(elseBlock, slice(arguments))
        return this
      },
      toString: function () {
        var elseClause = elseToString()
        if (elseClause) {
          elseClause = 'else{' + elseClause + '}'
        }
        return join([
          'if(', pred, '){',
          thenToString(),
          '}', elseClause
        ])
      }
    })
  }

  // procedure list
  var globalBlock = block()
  var procedures = {}
  function proc (name, count) {
    var args = []
    function arg () {
      var name = 'a' + args.length
      args.push(name)
      return name
    }

    count = count || 0
    for (var i = 0; i < count; ++i) {
      arg()
    }

    var body = scope()
    var bodyToString = body.toString

    var result = procedures[name] = extend(body, {
      arg: arg,
      toString: function () {
        return join([
          'function(', args.join(), '){',
          bodyToString(),
          '}'
        ])
      }
    })

    return result
  }

  function compile () {
    var code = ['"use strict";',
      globalBlock,
      'return {']
    Object.keys(procedures).forEach(function (name) {
      code.push('"', name, '":', procedures[name].toString(), ',')
    })
    code.push('}')
    var src = join(code)
      .replace(/;/g, ';\n')
      .replace(/}/g, '}\n')
      .replace(/{/g, '{\n')
    var proc = Function.apply(null, linkedNames.concat(src))
    return proc.apply(null, linkedValues)
  }

  return {
    global: globalBlock,
    link: link,
    block: block,
    proc: proc,
    scope: scope,
    cond: conditional,
    compile: compile
  }
}

// "cute" names for vector components
var CUTE_COMPONENTS = 'xyzw'.split('')

var GL_UNSIGNED_BYTE$8 = 5121

var ATTRIB_STATE_POINTER = 1
var ATTRIB_STATE_CONSTANT = 2

var DYN_FUNC$1 = 0
var DYN_PROP$1 = 1
var DYN_CONTEXT$1 = 2
var DYN_STATE$1 = 3
var DYN_THUNK = 4
var DYN_CONSTANT$1 = 5
var DYN_ARRAY$1 = 6

var S_DITHER = 'dither'
var S_BLEND_ENABLE = 'blend.enable'
var S_BLEND_COLOR = 'blend.color'
var S_BLEND_EQUATION = 'blend.equation'
var S_BLEND_FUNC = 'blend.func'
var S_DEPTH_ENABLE = 'depth.enable'
var S_DEPTH_FUNC = 'depth.func'
var S_DEPTH_RANGE = 'depth.range'
var S_DEPTH_MASK = 'depth.mask'
var S_COLOR_MASK = 'colorMask'
var S_CULL_ENABLE = 'cull.enable'
var S_CULL_FACE = 'cull.face'
var S_FRONT_FACE = 'frontFace'
var S_LINE_WIDTH = 'lineWidth'
var S_POLYGON_OFFSET_ENABLE = 'polygonOffset.enable'
var S_POLYGON_OFFSET_OFFSET = 'polygonOffset.offset'
var S_SAMPLE_ALPHA = 'sample.alpha'
var S_SAMPLE_ENABLE = 'sample.enable'
var S_SAMPLE_COVERAGE = 'sample.coverage'
var S_STENCIL_ENABLE = 'stencil.enable'
var S_STENCIL_MASK = 'stencil.mask'
var S_STENCIL_FUNC = 'stencil.func'
var S_STENCIL_OPFRONT = 'stencil.opFront'
var S_STENCIL_OPBACK = 'stencil.opBack'
var S_SCISSOR_ENABLE = 'scissor.enable'
var S_SCISSOR_BOX = 'scissor.box'
var S_VIEWPORT = 'viewport'

var S_PROFILE = 'profile'

var S_FRAMEBUFFER = 'framebuffer'
var S_VERT = 'vert'
var S_FRAG = 'frag'
var S_ELEMENTS = 'elements'
var S_PRIMITIVE = 'primitive'
var S_COUNT = 'count'
var S_OFFSET = 'offset'
var S_INSTANCES = 'instances'
var S_VAO = 'vao'

var SUFFIX_WIDTH = 'Width'
var SUFFIX_HEIGHT = 'Height'

var S_FRAMEBUFFER_WIDTH = S_FRAMEBUFFER + SUFFIX_WIDTH
var S_FRAMEBUFFER_HEIGHT = S_FRAMEBUFFER + SUFFIX_HEIGHT
var S_VIEWPORT_WIDTH = S_VIEWPORT + SUFFIX_WIDTH
var S_VIEWPORT_HEIGHT = S_VIEWPORT + SUFFIX_HEIGHT
var S_DRAWINGBUFFER = 'drawingBuffer'
var S_DRAWINGBUFFER_WIDTH = S_DRAWINGBUFFER + SUFFIX_WIDTH
var S_DRAWINGBUFFER_HEIGHT = S_DRAWINGBUFFER + SUFFIX_HEIGHT

var NESTED_OPTIONS = [
  S_BLEND_FUNC,
  S_BLEND_EQUATION,
  S_STENCIL_FUNC,
  S_STENCIL_OPFRONT,
  S_STENCIL_OPBACK,
  S_SAMPLE_COVERAGE,
  S_VIEWPORT,
  S_SCISSOR_BOX,
  S_POLYGON_OFFSET_OFFSET
]

var GL_ARRAY_BUFFER$2 = 34962
var GL_ELEMENT_ARRAY_BUFFER$1 = 34963

var GL_FRAGMENT_SHADER$1 = 35632
var GL_VERTEX_SHADER$1 = 35633

var GL_TEXTURE_2D$3 = 0x0DE1
var GL_TEXTURE_CUBE_MAP$2 = 0x8513

var GL_CULL_FACE = 0x0B44
var GL_BLEND = 0x0BE2
var GL_DITHER = 0x0BD0
var GL_STENCIL_TEST = 0x0B90
var GL_DEPTH_TEST = 0x0B71
var GL_SCISSOR_TEST = 0x0C11
var GL_POLYGON_OFFSET_FILL = 0x8037
var GL_SAMPLE_ALPHA_TO_COVERAGE = 0x809E
var GL_SAMPLE_COVERAGE = 0x80A0

var GL_FLOAT$8 = 5126
var GL_FLOAT_VEC2 = 35664
var GL_FLOAT_VEC3 = 35665
var GL_FLOAT_VEC4 = 35666
var GL_INT$3 = 5124
var GL_INT_VEC2 = 35667
var GL_INT_VEC3 = 35668
var GL_INT_VEC4 = 35669
var GL_BOOL = 35670
var GL_BOOL_VEC2 = 35671
var GL_BOOL_VEC3 = 35672
var GL_BOOL_VEC4 = 35673
var GL_FLOAT_MAT2 = 35674
var GL_FLOAT_MAT3 = 35675
var GL_FLOAT_MAT4 = 35676
var GL_SAMPLER_2D = 35678
var GL_SAMPLER_CUBE = 35680

var GL_TRIANGLES$1 = 4

var GL_FRONT = 1028
var GL_BACK = 1029
var GL_CW = 0x0900
var GL_CCW = 0x0901
var GL_MIN_EXT = 0x8007
var GL_MAX_EXT = 0x8008
var GL_ALWAYS = 519
var GL_KEEP = 7680
var GL_ZERO = 0
var GL_ONE = 1
var GL_FUNC_ADD = 0x8006
var GL_LESS = 513

var GL_FRAMEBUFFER$2 = 0x8D40
var GL_COLOR_ATTACHMENT0$2 = 0x8CE0

var blendFuncs = {
  '0': 0,
  '1': 1,
  'zero': 0,
  'one': 1,
  'src color': 768,
  'one minus src color': 769,
  'src alpha': 770,
  'one minus src alpha': 771,
  'dst color': 774,
  'one minus dst color': 775,
  'dst alpha': 772,
  'one minus dst alpha': 773,
  'constant color': 32769,
  'one minus constant color': 32770,
  'constant alpha': 32771,
  'one minus constant alpha': 32772,
  'src alpha saturate': 776
}

// There are invalid values for srcRGB and dstRGB. See:
// https://www.khronos.org/registry/webgl/specs/1.0/#6.13
// https://github.com/KhronosGroup/WebGL/blob/0d3201f5f7ec3c0060bc1f04077461541f1987b9/conformance-suites/1.0.3/conformance/misc/webgl-specific.html#L56
var invalidBlendCombinations = [
  'constant color, constant alpha',
  'one minus constant color, constant alpha',
  'constant color, one minus constant alpha',
  'one minus constant color, one minus constant alpha',
  'constant alpha, constant color',
  'constant alpha, one minus constant color',
  'one minus constant alpha, constant color',
  'one minus constant alpha, one minus constant color'
]

var compareFuncs = {
  'never': 512,
  'less': 513,
  '<': 513,
  'equal': 514,
  '=': 514,
  '==': 514,
  '===': 514,
  'lequal': 515,
  '<=': 515,
  'greater': 516,
  '>': 516,
  'notequal': 517,
  '!=': 517,
  '!==': 517,
  'gequal': 518,
  '>=': 518,
  'always': 519
}

var stencilOps = {
  '0': 0,
  'zero': 0,
  'keep': 7680,
  'replace': 7681,
  'increment': 7682,
  'decrement': 7683,
  'increment wrap': 34055,
  'decrement wrap': 34056,
  'invert': 5386
}

var shaderType = {
  'frag': GL_FRAGMENT_SHADER$1,
  'vert': GL_VERTEX_SHADER$1
}

var orientationType = {
  'cw': GL_CW,
  'ccw': GL_CCW
}

function isBufferArgs (x) {
  return Array.isArray(x) ||
    isTypedArray(x) ||
    isNDArrayLike(x)
}

// Make sure viewport is processed first
function sortState (state) {
  return state.sort(function (a, b) {
    if (a === S_VIEWPORT) {
      return -1
    } else if (b === S_VIEWPORT) {
      return 1
    }
    return (a < b) ? -1 : 1
  })
}

function Declaration (thisDep, contextDep, propDep, append) {
  this.thisDep = thisDep
  this.contextDep = contextDep
  this.propDep = propDep
  this.append = append
}

function isStatic (decl) {
  return decl && !(decl.thisDep || decl.contextDep || decl.propDep)
}

function createStaticDecl (append) {
  return new Declaration(false, false, false, append)
}

function createDynamicDecl (dyn, append) {
  var type = dyn.type
  if (type === DYN_FUNC$1) {
    var numArgs = dyn.data.length
    return new Declaration(
      true,
      numArgs >= 1,
      numArgs >= 2,
      append)
  } else if (type === DYN_THUNK) {
    var data = dyn.data
    return new Declaration(
      data.thisDep,
      data.contextDep,
      data.propDep,
      append)
  } else if (type === DYN_CONSTANT$1) {
    return new Declaration(
      false,
      false,
      false,
      append)
  } else if (type === DYN_ARRAY$1) {
    var thisDep = false
    var contextDep = false
    var propDep = false
    for (var i = 0; i < dyn.data.length; ++i) {
      var subDyn = dyn.data[i]
      if (subDyn.type === DYN_PROP$1) {
        propDep = true
      } else if (subDyn.type === DYN_CONTEXT$1) {
        contextDep = true
      } else if (subDyn.type === DYN_STATE$1) {
        thisDep = true
      } else if (subDyn.type === DYN_FUNC$1) {
        thisDep = true
        var subArgs = subDyn.data
        if (subArgs >= 1) {
          contextDep = true
        }
        if (subArgs >= 2) {
          propDep = true
        }
      } else if (subDyn.type === DYN_THUNK) {
        thisDep = thisDep || subDyn.data.thisDep
        contextDep = contextDep || subDyn.data.contextDep
        propDep = propDep || subDyn.data.propDep
      }
    }
    return new Declaration(
      thisDep,
      contextDep,
      propDep,
      append)
  } else {
    return new Declaration(
      type === DYN_STATE$1,
      type === DYN_CONTEXT$1,
      type === DYN_PROP$1,
      append)
  }
}

var SCOPE_DECL = new Declaration(false, false, false, function () {})

function reglCore (
  gl,
  stringStore,
  extensions,
  limits,
  bufferState,
  elementState,
  textureState,
  framebufferState,
  uniformState,
  attributeState,
  shaderState,
  drawState,
  contextState,
  timer,
  config) {
  var AttributeRecord = attributeState.Record

  var blendEquations = {
    'add': 32774,
    'subtract': 32778,
    'reverse subtract': 32779
  }
  if (extensions.ext_blend_minmax) {
    blendEquations.min = GL_MIN_EXT
    blendEquations.max = GL_MAX_EXT
  }

  var extInstancing = extensions.angle_instanced_arrays
  var extDrawBuffers = extensions.webgl_draw_buffers

  // ===================================================
  // ===================================================
  // WEBGL STATE
  // ===================================================
  // ===================================================
  var currentState = {
    dirty: true,
    profile: config.profile
  }
  var nextState = {}
  var GL_STATE_NAMES = []
  var GL_FLAGS = {}
  var GL_VARIABLES = {}

  function propName (name) {
    return name.replace('.', '_')
  }

  function stateFlag (sname, cap, init) {
    var name = propName(sname)
    GL_STATE_NAMES.push(sname)
    nextState[name] = currentState[name] = !!init
    GL_FLAGS[name] = cap
  }

  function stateVariable (sname, func, init) {
    var name = propName(sname)
    GL_STATE_NAMES.push(sname)
    if (Array.isArray(init)) {
      currentState[name] = init.slice()
      nextState[name] = init.slice()
    } else {
      currentState[name] = nextState[name] = init
    }
    GL_VARIABLES[name] = func
  }

  // Dithering
  stateFlag(S_DITHER, GL_DITHER)

  // Blending
  stateFlag(S_BLEND_ENABLE, GL_BLEND)
  stateVariable(S_BLEND_COLOR, 'blendColor', [0, 0, 0, 0])
  stateVariable(S_BLEND_EQUATION, 'blendEquationSeparate',
    [GL_FUNC_ADD, GL_FUNC_ADD])
  stateVariable(S_BLEND_FUNC, 'blendFuncSeparate',
    [GL_ONE, GL_ZERO, GL_ONE, GL_ZERO])

  // Depth
  stateFlag(S_DEPTH_ENABLE, GL_DEPTH_TEST, true)
  stateVariable(S_DEPTH_FUNC, 'depthFunc', GL_LESS)
  stateVariable(S_DEPTH_RANGE, 'depthRange', [0, 1])
  stateVariable(S_DEPTH_MASK, 'depthMask', true)

  // Color mask
  stateVariable(S_COLOR_MASK, S_COLOR_MASK, [true, true, true, true])

  // Face culling
  stateFlag(S_CULL_ENABLE, GL_CULL_FACE)
  stateVariable(S_CULL_FACE, 'cullFace', GL_BACK)

  // Front face orientation
  stateVariable(S_FRONT_FACE, S_FRONT_FACE, GL_CCW)

  // Line width
  stateVariable(S_LINE_WIDTH, S_LINE_WIDTH, 1)

  // Polygon offset
  stateFlag(S_POLYGON_OFFSET_ENABLE, GL_POLYGON_OFFSET_FILL)
  stateVariable(S_POLYGON_OFFSET_OFFSET, 'polygonOffset', [0, 0])

  // Sample coverage
  stateFlag(S_SAMPLE_ALPHA, GL_SAMPLE_ALPHA_TO_COVERAGE)
  stateFlag(S_SAMPLE_ENABLE, GL_SAMPLE_COVERAGE)
  stateVariable(S_SAMPLE_COVERAGE, 'sampleCoverage', [1, false])

  // Stencil
  stateFlag(S_STENCIL_ENABLE, GL_STENCIL_TEST)
  stateVariable(S_STENCIL_MASK, 'stencilMask', -1)
  stateVariable(S_STENCIL_FUNC, 'stencilFunc', [GL_ALWAYS, 0, -1])
  stateVariable(S_STENCIL_OPFRONT, 'stencilOpSeparate',
    [GL_FRONT, GL_KEEP, GL_KEEP, GL_KEEP])
  stateVariable(S_STENCIL_OPBACK, 'stencilOpSeparate',
    [GL_BACK, GL_KEEP, GL_KEEP, GL_KEEP])

  // Scissor
  stateFlag(S_SCISSOR_ENABLE, GL_SCISSOR_TEST)
  stateVariable(S_SCISSOR_BOX, 'scissor',
    [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight])

  // Viewport
  stateVariable(S_VIEWPORT, S_VIEWPORT,
    [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight])

  // ===================================================
  // ===================================================
  // ENVIRONMENT
  // ===================================================
  // ===================================================
  var sharedState = {
    gl: gl,
    context: contextState,
    strings: stringStore,
    next: nextState,
    current: currentState,
    draw: drawState,
    elements: elementState,
    buffer: bufferState,
    shader: shaderState,
    attributes: attributeState.state,
    vao: attributeState,
    uniforms: uniformState,
    framebuffer: framebufferState,
    extensions: extensions,

    timer: timer,
    isBufferArgs: isBufferArgs
  }

  var sharedConstants = {
    primTypes: primTypes,
    compareFuncs: compareFuncs,
    blendFuncs: blendFuncs,
    blendEquations: blendEquations,
    stencilOps: stencilOps,
    glTypes: glTypes,
    orientationType: orientationType
  }

  check$1.optional(function () {
    sharedState.isArrayLike = isArrayLike
  })

  if (extDrawBuffers) {
    sharedConstants.backBuffer = [GL_BACK]
    sharedConstants.drawBuffer = loop(limits.maxDrawbuffers, function (i) {
      if (i === 0) {
        return [0]
      }
      return loop(i, function (j) {
        return GL_COLOR_ATTACHMENT0$2 + j
      })
    })
  }

  var drawCallCounter = 0
  function createREGLEnvironment () {
    var env = createEnvironment()
    var link = env.link
    var global = env.global
    env.id = drawCallCounter++

    env.batchId = '0'

    // link shared state
    var SHARED = link(sharedState)
    var shared = env.shared = {
      props: 'a0'
    }
    Object.keys(sharedState).forEach(function (prop) {
      shared[prop] = global.def(SHARED, '.', prop)
    })

    // Inject runtime assertion stuff for debug builds
    check$1.optional(function () {
      env.CHECK = link(check$1)
      env.commandStr = check$1.guessCommand()
      env.command = link(env.commandStr)
      env.assert = function (block, pred, message) {
        block(
          'if(!(', pred, '))',
          this.CHECK, '.commandRaise(', link(message), ',', this.command, ');')
      }

      sharedConstants.invalidBlendCombinations = invalidBlendCombinations
    })

    // Copy GL state variables over
    var nextVars = env.next = {}
    var currentVars = env.current = {}
    Object.keys(GL_VARIABLES).forEach(function (variable) {
      if (Array.isArray(currentState[variable])) {
        nextVars[variable] = global.def(shared.next, '.', variable)
        currentVars[variable] = global.def(shared.current, '.', variable)
      }
    })

    // Initialize shared constants
    var constants = env.constants = {}
    Object.keys(sharedConstants).forEach(function (name) {
      constants[name] = global.def(JSON.stringify(sharedConstants[name]))
    })

    // Helper function for calling a block
    env.invoke = function (block, x) {
      switch (x.type) {
        case DYN_FUNC$1:
          var argList = [
            'this',
            shared.context,
            shared.props,
            env.batchId
          ]
          return block.def(
            link(x.data), '.call(',
            argList.slice(0, Math.max(x.data.length + 1, 4)),
            ')')
        case DYN_PROP$1:
          return block.def(shared.props, x.data)
        case DYN_CONTEXT$1:
          return block.def(shared.context, x.data)
        case DYN_STATE$1:
          return block.def('this', x.data)
        case DYN_THUNK:
          x.data.append(env, block)
          return x.data.ref
        case DYN_CONSTANT$1:
          return x.data.toString()
        case DYN_ARRAY$1:
          return x.data.map(function (y) {
            return env.invoke(block, y)
          })
      }
    }

    env.attribCache = {}

    var scopeAttribs = {}
    env.scopeAttrib = function (name) {
      var id = stringStore.id(name)
      if (id in scopeAttribs) {
        return scopeAttribs[id]
      }
      var binding = attributeState.scope[id]
      if (!binding) {
        binding = attributeState.scope[id] = new AttributeRecord()
      }
      var result = scopeAttribs[id] = link(binding)
      return result
    }

    return env
  }

  // ===================================================
  // ===================================================
  // PARSING
  // ===================================================
  // ===================================================
  function parseProfile (options) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    var profileEnable
    if (S_PROFILE in staticOptions) {
      var value = !!staticOptions[S_PROFILE]
      profileEnable = createStaticDecl(function (env, scope) {
        return value
      })
      profileEnable.enable = value
    } else if (S_PROFILE in dynamicOptions) {
      var dyn = dynamicOptions[S_PROFILE]
      profileEnable = createDynamicDecl(dyn, function (env, scope) {
        return env.invoke(scope, dyn)
      })
    }

    return profileEnable
  }

  function parseFramebuffer (options, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    if (S_FRAMEBUFFER in staticOptions) {
      var framebuffer = staticOptions[S_FRAMEBUFFER]
      if (framebuffer) {
        framebuffer = framebufferState.getFramebuffer(framebuffer)
        check$1.command(framebuffer, 'invalid framebuffer object')
        return createStaticDecl(function (env, block) {
          var FRAMEBUFFER = env.link(framebuffer)
          var shared = env.shared
          block.set(
            shared.framebuffer,
            '.next',
            FRAMEBUFFER)
          var CONTEXT = shared.context
          block.set(
            CONTEXT,
            '.' + S_FRAMEBUFFER_WIDTH,
            FRAMEBUFFER + '.width')
          block.set(
            CONTEXT,
            '.' + S_FRAMEBUFFER_HEIGHT,
            FRAMEBUFFER + '.height')
          return FRAMEBUFFER
        })
      } else {
        return createStaticDecl(function (env, scope) {
          var shared = env.shared
          scope.set(
            shared.framebuffer,
            '.next',
            'null')
          var CONTEXT = shared.context
          scope.set(
            CONTEXT,
            '.' + S_FRAMEBUFFER_WIDTH,
            CONTEXT + '.' + S_DRAWINGBUFFER_WIDTH)
          scope.set(
            CONTEXT,
            '.' + S_FRAMEBUFFER_HEIGHT,
            CONTEXT + '.' + S_DRAWINGBUFFER_HEIGHT)
          return 'null'
        })
      }
    } else if (S_FRAMEBUFFER in dynamicOptions) {
      var dyn = dynamicOptions[S_FRAMEBUFFER]
      return createDynamicDecl(dyn, function (env, scope) {
        var FRAMEBUFFER_FUNC = env.invoke(scope, dyn)
        var shared = env.shared
        var FRAMEBUFFER_STATE = shared.framebuffer
        var FRAMEBUFFER = scope.def(
          FRAMEBUFFER_STATE, '.getFramebuffer(', FRAMEBUFFER_FUNC, ')')

        check$1.optional(function () {
          env.assert(scope,
            '!' + FRAMEBUFFER_FUNC + '||' + FRAMEBUFFER,
            'invalid framebuffer object')
        })

        scope.set(
          FRAMEBUFFER_STATE,
          '.next',
          FRAMEBUFFER)
        var CONTEXT = shared.context
        scope.set(
          CONTEXT,
          '.' + S_FRAMEBUFFER_WIDTH,
          FRAMEBUFFER + '?' + FRAMEBUFFER + '.width:' +
          CONTEXT + '.' + S_DRAWINGBUFFER_WIDTH)
        scope.set(
          CONTEXT,
          '.' + S_FRAMEBUFFER_HEIGHT,
          FRAMEBUFFER +
          '?' + FRAMEBUFFER + '.height:' +
          CONTEXT + '.' + S_DRAWINGBUFFER_HEIGHT)
        return FRAMEBUFFER
      })
    } else {
      return null
    }
  }

  function parseViewportScissor (options, framebuffer, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    function parseBox (param) {
      if (param in staticOptions) {
        var box = staticOptions[param]
        check$1.commandType(box, 'object', 'invalid ' + param, env.commandStr)

        var isStatic = true
        var x = box.x | 0
        var y = box.y | 0
        var w, h
        if ('width' in box) {
          w = box.width | 0
          check$1.command(w >= 0, 'invalid ' + param, env.commandStr)
        } else {
          isStatic = false
        }
        if ('height' in box) {
          h = box.height | 0
          check$1.command(h >= 0, 'invalid ' + param, env.commandStr)
        } else {
          isStatic = false
        }

        return new Declaration(
          !isStatic && framebuffer && framebuffer.thisDep,
          !isStatic && framebuffer && framebuffer.contextDep,
          !isStatic && framebuffer && framebuffer.propDep,
          function (env, scope) {
            var CONTEXT = env.shared.context
            var BOX_W = w
            if (!('width' in box)) {
              BOX_W = scope.def(CONTEXT, '.', S_FRAMEBUFFER_WIDTH, '-', x)
            }
            var BOX_H = h
            if (!('height' in box)) {
              BOX_H = scope.def(CONTEXT, '.', S_FRAMEBUFFER_HEIGHT, '-', y)
            }
            return [x, y, BOX_W, BOX_H]
          })
      } else if (param in dynamicOptions) {
        var dynBox = dynamicOptions[param]
        var result = createDynamicDecl(dynBox, function (env, scope) {
          var BOX = env.invoke(scope, dynBox)

          check$1.optional(function () {
            env.assert(scope,
              BOX + '&&typeof ' + BOX + '==="object"',
              'invalid ' + param)
          })

          var CONTEXT = env.shared.context
          var BOX_X = scope.def(BOX, '.x|0')
          var BOX_Y = scope.def(BOX, '.y|0')
          var BOX_W = scope.def(
            '"width" in ', BOX, '?', BOX, '.width|0:',
            '(', CONTEXT, '.', S_FRAMEBUFFER_WIDTH, '-', BOX_X, ')')
          var BOX_H = scope.def(
            '"height" in ', BOX, '?', BOX, '.height|0:',
            '(', CONTEXT, '.', S_FRAMEBUFFER_HEIGHT, '-', BOX_Y, ')')

          check$1.optional(function () {
            env.assert(scope,
              BOX_W + '>=0&&' +
              BOX_H + '>=0',
              'invalid ' + param)
          })

          return [BOX_X, BOX_Y, BOX_W, BOX_H]
        })
        if (framebuffer) {
          result.thisDep = result.thisDep || framebuffer.thisDep
          result.contextDep = result.contextDep || framebuffer.contextDep
          result.propDep = result.propDep || framebuffer.propDep
        }
        return result
      } else if (framebuffer) {
        return new Declaration(
          framebuffer.thisDep,
          framebuffer.contextDep,
          framebuffer.propDep,
          function (env, scope) {
            var CONTEXT = env.shared.context
            return [
              0, 0,
              scope.def(CONTEXT, '.', S_FRAMEBUFFER_WIDTH),
              scope.def(CONTEXT, '.', S_FRAMEBUFFER_HEIGHT)]
          })
      } else {
        return null
      }
    }

    var viewport = parseBox(S_VIEWPORT)

    if (viewport) {
      var prevViewport = viewport
      viewport = new Declaration(
        viewport.thisDep,
        viewport.contextDep,
        viewport.propDep,
        function (env, scope) {
          var VIEWPORT = prevViewport.append(env, scope)
          var CONTEXT = env.shared.context
          scope.set(
            CONTEXT,
            '.' + S_VIEWPORT_WIDTH,
            VIEWPORT[2])
          scope.set(
            CONTEXT,
            '.' + S_VIEWPORT_HEIGHT,
            VIEWPORT[3])
          return VIEWPORT
        })
    }

    return {
      viewport: viewport,
      scissor_box: parseBox(S_SCISSOR_BOX)
    }
  }

  function parseAttribLocations (options, attributes) {
    var staticOptions = options.static
    var staticProgram =
      typeof staticOptions[S_FRAG] === 'string' &&
      typeof staticOptions[S_VERT] === 'string'
    if (staticProgram) {
      if (Object.keys(attributes.dynamic).length > 0) {
        return null
      }
      var staticAttributes = attributes.static
      var sAttributes = Object.keys(staticAttributes)
      if (sAttributes.length > 0 && typeof staticAttributes[sAttributes[0]] === 'number') {
        var bindings = []
        for (var i = 0; i < sAttributes.length; ++i) {
          check$1(typeof staticAttributes[sAttributes[i]] === 'number', 'must specify all vertex attribute locations when using vaos')
          bindings.push([staticAttributes[sAttributes[i]] | 0, sAttributes[i]])
        }
        return bindings
      }
    }
    return null
  }

  function parseProgram (options, env, attribLocations) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    function parseShader (name) {
      if (name in staticOptions) {
        var id = stringStore.id(staticOptions[name])
        check$1.optional(function () {
          shaderState.shader(shaderType[name], id, check$1.guessCommand())
        })
        var result = createStaticDecl(function () {
          return id
        })
        result.id = id
        return result
      } else if (name in dynamicOptions) {
        var dyn = dynamicOptions[name]
        return createDynamicDecl(dyn, function (env, scope) {
          var str = env.invoke(scope, dyn)
          var id = scope.def(env.shared.strings, '.id(', str, ')')
          check$1.optional(function () {
            scope(
              env.shared.shader, '.shader(',
              shaderType[name], ',',
              id, ',',
              env.command, ');')
          })
          return id
        })
      }
      return null
    }

    var frag = parseShader(S_FRAG)
    var vert = parseShader(S_VERT)

    var program = null
    var progVar
    if (isStatic(frag) && isStatic(vert)) {
      program = shaderState.program(vert.id, frag.id, null, attribLocations)
      progVar = createStaticDecl(function (env, scope) {
        return env.link(program)
      })
    } else {
      progVar = new Declaration(
        (frag && frag.thisDep) || (vert && vert.thisDep),
        (frag && frag.contextDep) || (vert && vert.contextDep),
        (frag && frag.propDep) || (vert && vert.propDep),
        function (env, scope) {
          var SHADER_STATE = env.shared.shader
          var fragId
          if (frag) {
            fragId = frag.append(env, scope)
          } else {
            fragId = scope.def(SHADER_STATE, '.', S_FRAG)
          }
          var vertId
          if (vert) {
            vertId = vert.append(env, scope)
          } else {
            vertId = scope.def(SHADER_STATE, '.', S_VERT)
          }
          var progDef = SHADER_STATE + '.program(' + vertId + ',' + fragId
          check$1.optional(function () {
            progDef += ',' + env.command
          })
          return scope.def(progDef + ')')
        })
    }

    return {
      frag: frag,
      vert: vert,
      progVar: progVar,
      program: program
    }
  }

  function parseDraw (options, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    function parseElements () {
      if (S_ELEMENTS in staticOptions) {
        var elements = staticOptions[S_ELEMENTS]
        if (isBufferArgs(elements)) {
          elements = elementState.getElements(elementState.create(elements, true))
        } else if (elements) {
          elements = elementState.getElements(elements)
          check$1.command(elements, 'invalid elements', env.commandStr)
        }
        var result = createStaticDecl(function (env, scope) {
          if (elements) {
            var result = env.link(elements)
            env.ELEMENTS = result
            return result
          }
          env.ELEMENTS = null
          return null
        })
        result.value = elements
        return result
      } else if (S_ELEMENTS in dynamicOptions) {
        var dyn = dynamicOptions[S_ELEMENTS]
        return createDynamicDecl(dyn, function (env, scope) {
          var shared = env.shared

          var IS_BUFFER_ARGS = shared.isBufferArgs
          var ELEMENT_STATE = shared.elements

          var elementDefn = env.invoke(scope, dyn)
          var elements = scope.def('null')
          var elementStream = scope.def(IS_BUFFER_ARGS, '(', elementDefn, ')')

          var ifte = env.cond(elementStream)
            .then(elements, '=', ELEMENT_STATE, '.createStream(', elementDefn, ');')
            .else(elements, '=', ELEMENT_STATE, '.getElements(', elementDefn, ');')

          check$1.optional(function () {
            env.assert(ifte.else,
              '!' + elementDefn + '||' + elements,
              'invalid elements')
          })

          scope.entry(ifte)
          scope.exit(
            env.cond(elementStream)
              .then(ELEMENT_STATE, '.destroyStream(', elements, ');'))

          env.ELEMENTS = elements

          return elements
        })
      }

      return null
    }

    var elements = parseElements()

    function parsePrimitive () {
      if (S_PRIMITIVE in staticOptions) {
        var primitive = staticOptions[S_PRIMITIVE]
        check$1.commandParameter(primitive, primTypes, 'invalid primitve', env.commandStr)
        return createStaticDecl(function (env, scope) {
          return primTypes[primitive]
        })
      } else if (S_PRIMITIVE in dynamicOptions) {
        var dynPrimitive = dynamicOptions[S_PRIMITIVE]
        return createDynamicDecl(dynPrimitive, function (env, scope) {
          var PRIM_TYPES = env.constants.primTypes
          var prim = env.invoke(scope, dynPrimitive)
          check$1.optional(function () {
            env.assert(scope,
              prim + ' in ' + PRIM_TYPES,
              'invalid primitive, must be one of ' + Object.keys(primTypes))
          })
          return scope.def(PRIM_TYPES, '[', prim, ']')
        })
      } else if (elements) {
        if (isStatic(elements)) {
          if (elements.value) {
            return createStaticDecl(function (env, scope) {
              return scope.def(env.ELEMENTS, '.primType')
            })
          } else {
            return createStaticDecl(function () {
              return GL_TRIANGLES$1
            })
          }
        } else {
          return new Declaration(
            elements.thisDep,
            elements.contextDep,
            elements.propDep,
            function (env, scope) {
              var elements = env.ELEMENTS
              return scope.def(elements, '?', elements, '.primType:', GL_TRIANGLES$1)
            })
        }
      }
      return null
    }

    function parseParam (param, isOffset) {
      if (param in staticOptions) {
        var value = staticOptions[param] | 0
        check$1.command(!isOffset || value >= 0, 'invalid ' + param, env.commandStr)
        return createStaticDecl(function (env, scope) {
          if (isOffset) {
            env.OFFSET = value
          }
          return value
        })
      } else if (param in dynamicOptions) {
        var dynValue = dynamicOptions[param]
        return createDynamicDecl(dynValue, function (env, scope) {
          var result = env.invoke(scope, dynValue)
          if (isOffset) {
            env.OFFSET = result
            check$1.optional(function () {
              env.assert(scope,
                result + '>=0',
                'invalid ' + param)
            })
          }
          return result
        })
      } else if (isOffset && elements) {
        return createStaticDecl(function (env, scope) {
          env.OFFSET = '0'
          return 0
        })
      }
      return null
    }

    var OFFSET = parseParam(S_OFFSET, true)

    function parseVertCount () {
      if (S_COUNT in staticOptions) {
        var count = staticOptions[S_COUNT] | 0
        check$1.command(
          typeof count === 'number' && count >= 0, 'invalid vertex count', env.commandStr)
        return createStaticDecl(function () {
          return count
        })
      } else if (S_COUNT in dynamicOptions) {
        var dynCount = dynamicOptions[S_COUNT]
        return createDynamicDecl(dynCount, function (env, scope) {
          var result = env.invoke(scope, dynCount)
          check$1.optional(function () {
            env.assert(scope,
              'typeof ' + result + '==="number"&&' +
              result + '>=0&&' +
              result + '===(' + result + '|0)',
              'invalid vertex count')
          })
          return result
        })
      } else if (elements) {
        if (isStatic(elements)) {
          if (elements) {
            if (OFFSET) {
              return new Declaration(
                OFFSET.thisDep,
                OFFSET.contextDep,
                OFFSET.propDep,
                function (env, scope) {
                  var result = scope.def(
                    env.ELEMENTS, '.vertCount-', env.OFFSET)

                  check$1.optional(function () {
                    env.assert(scope,
                      result + '>=0',
                      'invalid vertex offset/element buffer too small')
                  })

                  return result
                })
            } else {
              return createStaticDecl(function (env, scope) {
                return scope.def(env.ELEMENTS, '.vertCount')
              })
            }
          } else {
            var result = createStaticDecl(function () {
              return -1
            })
            check$1.optional(function () {
              result.MISSING = true
            })
            return result
          }
        } else {
          var variable = new Declaration(
            elements.thisDep || OFFSET.thisDep,
            elements.contextDep || OFFSET.contextDep,
            elements.propDep || OFFSET.propDep,
            function (env, scope) {
              var elements = env.ELEMENTS
              if (env.OFFSET) {
                return scope.def(elements, '?', elements, '.vertCount-',
                  env.OFFSET, ':-1')
              }
              return scope.def(elements, '?', elements, '.vertCount:-1')
            })
          check$1.optional(function () {
            variable.DYNAMIC = true
          })
          return variable
        }
      }
      return null
    }

    return {
      elements: elements,
      primitive: parsePrimitive(),
      count: parseVertCount(),
      instances: parseParam(S_INSTANCES, false),
      offset: OFFSET
    }
  }

  function parseGLState (options, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    var STATE = {}

    GL_STATE_NAMES.forEach(function (prop) {
      var param = propName(prop)

      function parseParam (parseStatic, parseDynamic) {
        if (prop in staticOptions) {
          var value = parseStatic(staticOptions[prop])
          STATE[param] = createStaticDecl(function () {
            return value
          })
        } else if (prop in dynamicOptions) {
          var dyn = dynamicOptions[prop]
          STATE[param] = createDynamicDecl(dyn, function (env, scope) {
            return parseDynamic(env, scope, env.invoke(scope, dyn))
          })
        }
      }

      switch (prop) {
        case S_CULL_ENABLE:
        case S_BLEND_ENABLE:
        case S_DITHER:
        case S_STENCIL_ENABLE:
        case S_DEPTH_ENABLE:
        case S_SCISSOR_ENABLE:
        case S_POLYGON_OFFSET_ENABLE:
        case S_SAMPLE_ALPHA:
        case S_SAMPLE_ENABLE:
        case S_DEPTH_MASK:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'boolean', prop, env.commandStr)
              return value
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  'typeof ' + value + '==="boolean"',
                  'invalid flag ' + prop, env.commandStr)
              })
              return value
            })

        case S_DEPTH_FUNC:
          return parseParam(
            function (value) {
              check$1.commandParameter(value, compareFuncs, 'invalid ' + prop, env.commandStr)
              return compareFuncs[value]
            },
            function (env, scope, value) {
              var COMPARE_FUNCS = env.constants.compareFuncs
              check$1.optional(function () {
                env.assert(scope,
                  value + ' in ' + COMPARE_FUNCS,
                  'invalid ' + prop + ', must be one of ' + Object.keys(compareFuncs))
              })
              return scope.def(COMPARE_FUNCS, '[', value, ']')
            })

        case S_DEPTH_RANGE:
          return parseParam(
            function (value) {
              check$1.command(
                isArrayLike(value) &&
                value.length === 2 &&
                typeof value[0] === 'number' &&
                typeof value[1] === 'number' &&
                value[0] <= value[1],
                'depth range is 2d array',
                env.commandStr)
              return value
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  env.shared.isArrayLike + '(' + value + ')&&' +
                  value + '.length===2&&' +
                  'typeof ' + value + '[0]==="number"&&' +
                  'typeof ' + value + '[1]==="number"&&' +
                  value + '[0]<=' + value + '[1]',
                  'depth range must be a 2d array')
              })

              var Z_NEAR = scope.def('+', value, '[0]')
              var Z_FAR = scope.def('+', value, '[1]')
              return [Z_NEAR, Z_FAR]
            })

        case S_BLEND_FUNC:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'object', 'blend.func', env.commandStr)
              var srcRGB = ('srcRGB' in value ? value.srcRGB : value.src)
              var srcAlpha = ('srcAlpha' in value ? value.srcAlpha : value.src)
              var dstRGB = ('dstRGB' in value ? value.dstRGB : value.dst)
              var dstAlpha = ('dstAlpha' in value ? value.dstAlpha : value.dst)
              check$1.commandParameter(srcRGB, blendFuncs, param + '.srcRGB', env.commandStr)
              check$1.commandParameter(srcAlpha, blendFuncs, param + '.srcAlpha', env.commandStr)
              check$1.commandParameter(dstRGB, blendFuncs, param + '.dstRGB', env.commandStr)
              check$1.commandParameter(dstAlpha, blendFuncs, param + '.dstAlpha', env.commandStr)

              check$1.command(
                (invalidBlendCombinations.indexOf(srcRGB + ', ' + dstRGB) === -1),
                'unallowed blending combination (srcRGB, dstRGB) = (' + srcRGB + ', ' + dstRGB + ')', env.commandStr)

              return [
                blendFuncs[srcRGB],
                blendFuncs[dstRGB],
                blendFuncs[srcAlpha],
                blendFuncs[dstAlpha]
              ]
            },
            function (env, scope, value) {
              var BLEND_FUNCS = env.constants.blendFuncs

              check$1.optional(function () {
                env.assert(scope,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid blend func, must be an object')
              })

              function read (prefix, suffix) {
                var func = scope.def(
                  '"', prefix, suffix, '" in ', value,
                  '?', value, '.', prefix, suffix,
                  ':', value, '.', prefix)

                check$1.optional(function () {
                  env.assert(scope,
                    func + ' in ' + BLEND_FUNCS,
                    'invalid ' + prop + '.' + prefix + suffix + ', must be one of ' + Object.keys(blendFuncs))
                })

                return func
              }

              var srcRGB = read('src', 'RGB')
              var dstRGB = read('dst', 'RGB')

              check$1.optional(function () {
                var INVALID_BLEND_COMBINATIONS = env.constants.invalidBlendCombinations

                env.assert(scope,
                  INVALID_BLEND_COMBINATIONS +
                           '.indexOf(' + srcRGB + '+", "+' + dstRGB + ') === -1 ',
                  'unallowed blending combination for (srcRGB, dstRGB)'
                )
              })

              var SRC_RGB = scope.def(BLEND_FUNCS, '[', srcRGB, ']')
              var SRC_ALPHA = scope.def(BLEND_FUNCS, '[', read('src', 'Alpha'), ']')
              var DST_RGB = scope.def(BLEND_FUNCS, '[', dstRGB, ']')
              var DST_ALPHA = scope.def(BLEND_FUNCS, '[', read('dst', 'Alpha'), ']')

              return [SRC_RGB, DST_RGB, SRC_ALPHA, DST_ALPHA]
            })

        case S_BLEND_EQUATION:
          return parseParam(
            function (value) {
              if (typeof value === 'string') {
                check$1.commandParameter(value, blendEquations, 'invalid ' + prop, env.commandStr)
                return [
                  blendEquations[value],
                  blendEquations[value]
                ]
              } else if (typeof value === 'object') {
                check$1.commandParameter(
                  value.rgb, blendEquations, prop + '.rgb', env.commandStr)
                check$1.commandParameter(
                  value.alpha, blendEquations, prop + '.alpha', env.commandStr)
                return [
                  blendEquations[value.rgb],
                  blendEquations[value.alpha]
                ]
              } else {
                check$1.commandRaise('invalid blend.equation', env.commandStr)
              }
            },
            function (env, scope, value) {
              var BLEND_EQUATIONS = env.constants.blendEquations

              var RGB = scope.def()
              var ALPHA = scope.def()

              var ifte = env.cond('typeof ', value, '==="string"')

              check$1.optional(function () {
                function checkProp (block, name, value) {
                  env.assert(block,
                    value + ' in ' + BLEND_EQUATIONS,
                    'invalid ' + name + ', must be one of ' + Object.keys(blendEquations))
                }
                checkProp(ifte.then, prop, value)

                env.assert(ifte.else,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid ' + prop)
                checkProp(ifte.else, prop + '.rgb', value + '.rgb')
                checkProp(ifte.else, prop + '.alpha', value + '.alpha')
              })

              ifte.then(
                RGB, '=', ALPHA, '=', BLEND_EQUATIONS, '[', value, '];')
              ifte.else(
                RGB, '=', BLEND_EQUATIONS, '[', value, '.rgb];',
                ALPHA, '=', BLEND_EQUATIONS, '[', value, '.alpha];')

              scope(ifte)

              return [RGB, ALPHA]
            })

        case S_BLEND_COLOR:
          return parseParam(
            function (value) {
              check$1.command(
                isArrayLike(value) &&
                value.length === 4,
                'blend.color must be a 4d array', env.commandStr)
              return loop(4, function (i) {
                return +value[i]
              })
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  env.shared.isArrayLike + '(' + value + ')&&' +
                  value + '.length===4',
                  'blend.color must be a 4d array')
              })
              return loop(4, function (i) {
                return scope.def('+', value, '[', i, ']')
              })
            })

        case S_STENCIL_MASK:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'number', param, env.commandStr)
              return value | 0
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  'typeof ' + value + '==="number"',
                  'invalid stencil.mask')
              })
              return scope.def(value, '|0')
            })

        case S_STENCIL_FUNC:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'object', param, env.commandStr)
              var cmp = value.cmp || 'keep'
              var ref = value.ref || 0
              var mask = 'mask' in value ? value.mask : -1
              check$1.commandParameter(cmp, compareFuncs, prop + '.cmp', env.commandStr)
              check$1.commandType(ref, 'number', prop + '.ref', env.commandStr)
              check$1.commandType(mask, 'number', prop + '.mask', env.commandStr)
              return [
                compareFuncs[cmp],
                ref,
                mask
              ]
            },
            function (env, scope, value) {
              var COMPARE_FUNCS = env.constants.compareFuncs
              check$1.optional(function () {
                function assert () {
                  env.assert(scope,
                    Array.prototype.join.call(arguments, ''),
                    'invalid stencil.func')
                }
                assert(value + '&&typeof ', value, '==="object"')
                assert('!("cmp" in ', value, ')||(',
                  value, '.cmp in ', COMPARE_FUNCS, ')')
              })
              var cmp = scope.def(
                '"cmp" in ', value,
                '?', COMPARE_FUNCS, '[', value, '.cmp]',
                ':', GL_KEEP)
              var ref = scope.def(value, '.ref|0')
              var mask = scope.def(
                '"mask" in ', value,
                '?', value, '.mask|0:-1')
              return [cmp, ref, mask]
            })

        case S_STENCIL_OPFRONT:
        case S_STENCIL_OPBACK:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'object', param, env.commandStr)
              var fail = value.fail || 'keep'
              var zfail = value.zfail || 'keep'
              var zpass = value.zpass || 'keep'
              check$1.commandParameter(fail, stencilOps, prop + '.fail', env.commandStr)
              check$1.commandParameter(zfail, stencilOps, prop + '.zfail', env.commandStr)
              check$1.commandParameter(zpass, stencilOps, prop + '.zpass', env.commandStr)
              return [
                prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT,
                stencilOps[fail],
                stencilOps[zfail],
                stencilOps[zpass]
              ]
            },
            function (env, scope, value) {
              var STENCIL_OPS = env.constants.stencilOps

              check$1.optional(function () {
                env.assert(scope,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid ' + prop)
              })

              function read (name) {
                check$1.optional(function () {
                  env.assert(scope,
                    '!("' + name + '" in ' + value + ')||' +
                    '(' + value + '.' + name + ' in ' + STENCIL_OPS + ')',
                    'invalid ' + prop + '.' + name + ', must be one of ' + Object.keys(stencilOps))
                })

                return scope.def(
                  '"', name, '" in ', value,
                  '?', STENCIL_OPS, '[', value, '.', name, ']:',
                  GL_KEEP)
              }

              return [
                prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT,
                read('fail'),
                read('zfail'),
                read('zpass')
              ]
            })

        case S_POLYGON_OFFSET_OFFSET:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'object', param, env.commandStr)
              var factor = value.factor | 0
              var units = value.units | 0
              check$1.commandType(factor, 'number', param + '.factor', env.commandStr)
              check$1.commandType(units, 'number', param + '.units', env.commandStr)
              return [factor, units]
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid ' + prop)
              })

              var FACTOR = scope.def(value, '.factor|0')
              var UNITS = scope.def(value, '.units|0')

              return [FACTOR, UNITS]
            })

        case S_CULL_FACE:
          return parseParam(
            function (value) {
              var face = 0
              if (value === 'front') {
                face = GL_FRONT
              } else if (value === 'back') {
                face = GL_BACK
              }
              check$1.command(!!face, param, env.commandStr)
              return face
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  value + '==="front"||' +
                  value + '==="back"',
                  'invalid cull.face')
              })
              return scope.def(value, '==="front"?', GL_FRONT, ':', GL_BACK)
            })

        case S_LINE_WIDTH:
          return parseParam(
            function (value) {
              check$1.command(
                typeof value === 'number' &&
                value >= limits.lineWidthDims[0] &&
                value <= limits.lineWidthDims[1],
                'invalid line width, must be a positive number between ' +
                limits.lineWidthDims[0] + ' and ' + limits.lineWidthDims[1], env.commandStr)
              return value
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  'typeof ' + value + '==="number"&&' +
                  value + '>=' + limits.lineWidthDims[0] + '&&' +
                  value + '<=' + limits.lineWidthDims[1],
                  'invalid line width')
              })

              return value
            })

        case S_FRONT_FACE:
          return parseParam(
            function (value) {
              check$1.commandParameter(value, orientationType, param, env.commandStr)
              return orientationType[value]
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  value + '==="cw"||' +
                  value + '==="ccw"',
                  'invalid frontFace, must be one of cw,ccw')
              })
              return scope.def(value + '==="cw"?' + GL_CW + ':' + GL_CCW)
            })

        case S_COLOR_MASK:
          return parseParam(
            function (value) {
              check$1.command(
                isArrayLike(value) && value.length === 4,
                'color.mask must be length 4 array', env.commandStr)
              return value.map(function (v) { return !!v })
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  env.shared.isArrayLike + '(' + value + ')&&' +
                  value + '.length===4',
                  'invalid color.mask')
              })
              return loop(4, function (i) {
                return '!!' + value + '[' + i + ']'
              })
            })

        case S_SAMPLE_COVERAGE:
          return parseParam(
            function (value) {
              check$1.command(typeof value === 'object' && value, param, env.commandStr)
              var sampleValue = 'value' in value ? value.value : 1
              var sampleInvert = !!value.invert
              check$1.command(
                typeof sampleValue === 'number' &&
                sampleValue >= 0 && sampleValue <= 1,
                'sample.coverage.value must be a number between 0 and 1', env.commandStr)
              return [sampleValue, sampleInvert]
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid sample.coverage')
              })
              var VALUE = scope.def(
                '"value" in ', value, '?+', value, '.value:1')
              var INVERT = scope.def('!!', value, '.invert')
              return [VALUE, INVERT]
            })
      }
    })

    return STATE
  }

  function parseUniforms (uniforms, env) {
    var staticUniforms = uniforms.static
    var dynamicUniforms = uniforms.dynamic

    var UNIFORMS = {}

    Object.keys(staticUniforms).forEach(function (name) {
      var value = staticUniforms[name]
      var result
      if (typeof value === 'number' ||
          typeof value === 'boolean') {
        result = createStaticDecl(function () {
          return value
        })
      } else if (typeof value === 'function') {
        var reglType = value._reglType
        if (reglType === 'texture2d' ||
            reglType === 'textureCube') {
          result = createStaticDecl(function (env) {
            return env.link(value)
          })
        } else if (reglType === 'framebuffer' ||
                   reglType === 'framebufferCube') {
          check$1.command(value.color.length > 0,
            'missing color attachment for framebuffer sent to uniform "' + name + '"', env.commandStr)
          result = createStaticDecl(function (env) {
            return env.link(value.color[0])
          })
        } else {
          check$1.commandRaise('invalid data for uniform "' + name + '"', env.commandStr)
        }
      } else if (isArrayLike(value)) {
        result = createStaticDecl(function (env) {
          var ITEM = env.global.def('[',
            loop(value.length, function (i) {
              check$1.command(
                typeof value[i] === 'number' ||
                typeof value[i] === 'boolean',
                'invalid uniform ' + name, env.commandStr)
              return value[i]
            }), ']')
          return ITEM
        })
      } else {
        check$1.commandRaise('invalid or missing data for uniform "' + name + '"', env.commandStr)
      }
      result.value = value
      UNIFORMS[name] = result
    })

    Object.keys(dynamicUniforms).forEach(function (key) {
      var dyn = dynamicUniforms[key]
      UNIFORMS[key] = createDynamicDecl(dyn, function (env, scope) {
        return env.invoke(scope, dyn)
      })
    })

    return UNIFORMS
  }

  function parseAttributes (attributes, env) {
    var staticAttributes = attributes.static
    var dynamicAttributes = attributes.dynamic

    var attributeDefs = {}

    Object.keys(staticAttributes).forEach(function (attribute) {
      var value = staticAttributes[attribute]
      var id = stringStore.id(attribute)

      var record = new AttributeRecord()
      if (isBufferArgs(value)) {
        record.state = ATTRIB_STATE_POINTER
        record.buffer = bufferState.getBuffer(
          bufferState.create(value, GL_ARRAY_BUFFER$2, false, true))
        record.type = 0
      } else {
        var buffer = bufferState.getBuffer(value)
        if (buffer) {
          record.state = ATTRIB_STATE_POINTER
          record.buffer = buffer
          record.type = 0
        } else {
          check$1.command(typeof value === 'object' && value,
            'invalid data for attribute ' + attribute, env.commandStr)
          if ('constant' in value) {
            var constant = value.constant
            record.buffer = 'null'
            record.state = ATTRIB_STATE_CONSTANT
            if (typeof constant === 'number') {
              record.x = constant
            } else {
              check$1.command(
                isArrayLike(constant) &&
                constant.length > 0 &&
                constant.length <= 4,
                'invalid constant for attribute ' + attribute, env.commandStr)
              CUTE_COMPONENTS.forEach(function (c, i) {
                if (i < constant.length) {
                  record[c] = constant[i]
                }
              })
            }
          } else {
            if (isBufferArgs(value.buffer)) {
              buffer = bufferState.getBuffer(
                bufferState.create(value.buffer, GL_ARRAY_BUFFER$2, false, true))
            } else {
              buffer = bufferState.getBuffer(value.buffer)
            }
            check$1.command(!!buffer, 'missing buffer for attribute "' + attribute + '"', env.commandStr)

            var offset = value.offset | 0
            check$1.command(offset >= 0,
              'invalid offset for attribute "' + attribute + '"', env.commandStr)

            var stride = value.stride | 0
            check$1.command(stride >= 0 && stride < 256,
              'invalid stride for attribute "' + attribute + '", must be integer betweeen [0, 255]', env.commandStr)

            var size = value.size | 0
            check$1.command(!('size' in value) || (size > 0 && size <= 4),
              'invalid size for attribute "' + attribute + '", must be 1,2,3,4', env.commandStr)

            var normalized = !!value.normalized

            var type = 0
            if ('type' in value) {
              check$1.commandParameter(
                value.type, glTypes,
                'invalid type for attribute ' + attribute, env.commandStr)
              type = glTypes[value.type]
            }

            var divisor = value.divisor | 0
            if ('divisor' in value) {
              check$1.command(divisor === 0 || extInstancing,
                'cannot specify divisor for attribute "' + attribute + '", instancing not supported', env.commandStr)
              check$1.command(divisor >= 0,
                'invalid divisor for attribute "' + attribute + '"', env.commandStr)
            }

            check$1.optional(function () {
              var command = env.commandStr

              var VALID_KEYS = [
                'buffer',
                'offset',
                'divisor',
                'normalized',
                'type',
                'size',
                'stride'
              ]

              Object.keys(value).forEach(function (prop) {
                check$1.command(
                  VALID_KEYS.indexOf(prop) >= 0,
                  'unknown parameter "' + prop + '" for attribute pointer "' + attribute + '" (valid parameters are ' + VALID_KEYS + ')',
                  command)
              })
            })

            record.buffer = buffer
            record.state = ATTRIB_STATE_POINTER
            record.size = size
            record.normalized = normalized
            record.type = type || buffer.dtype
            record.offset = offset
            record.stride = stride
            record.divisor = divisor
          }
        }
      }

      attributeDefs[attribute] = createStaticDecl(function (env, scope) {
        var cache = env.attribCache
        if (id in cache) {
          return cache[id]
        }
        var result = {
          isStream: false
        }
        Object.keys(record).forEach(function (key) {
          result[key] = record[key]
        })
        if (record.buffer) {
          result.buffer = env.link(record.buffer)
          result.type = result.type || (result.buffer + '.dtype')
        }
        cache[id] = result
        return result
      })
    })

    Object.keys(dynamicAttributes).forEach(function (attribute) {
      var dyn = dynamicAttributes[attribute]

      function appendAttributeCode (env, block) {
        var VALUE = env.invoke(block, dyn)

        var shared = env.shared
        var constants = env.constants

        var IS_BUFFER_ARGS = shared.isBufferArgs
        var BUFFER_STATE = shared.buffer

        // Perform validation on attribute
        check$1.optional(function () {
          env.assert(block,
            VALUE + '&&(typeof ' + VALUE + '==="object"||typeof ' +
            VALUE + '==="function")&&(' +
            IS_BUFFER_ARGS + '(' + VALUE + ')||' +
            BUFFER_STATE + '.getBuffer(' + VALUE + ')||' +
            BUFFER_STATE + '.getBuffer(' + VALUE + '.buffer)||' +
            IS_BUFFER_ARGS + '(' + VALUE + '.buffer)||' +
            '("constant" in ' + VALUE +
            '&&(typeof ' + VALUE + '.constant==="number"||' +
            shared.isArrayLike + '(' + VALUE + '.constant))))',
            'invalid dynamic attribute "' + attribute + '"')
        })

        // allocate names for result
        var result = {
          isStream: block.def(false)
        }
        var defaultRecord = new AttributeRecord()
        defaultRecord.state = ATTRIB_STATE_POINTER
        Object.keys(defaultRecord).forEach(function (key) {
          result[key] = block.def('' + defaultRecord[key])
        })

        var BUFFER = result.buffer
        var TYPE = result.type
        block(
          'if(', IS_BUFFER_ARGS, '(', VALUE, ')){',
          result.isStream, '=true;',
          BUFFER, '=', BUFFER_STATE, '.createStream(', GL_ARRAY_BUFFER$2, ',', VALUE, ');',
          TYPE, '=', BUFFER, '.dtype;',
          '}else{',
          BUFFER, '=', BUFFER_STATE, '.getBuffer(', VALUE, ');',
          'if(', BUFFER, '){',
          TYPE, '=', BUFFER, '.dtype;',
          '}else if("constant" in ', VALUE, '){',
          result.state, '=', ATTRIB_STATE_CONSTANT, ';',
          'if(typeof ' + VALUE + '.constant === "number"){',
          result[CUTE_COMPONENTS[0]], '=', VALUE, '.constant;',
          CUTE_COMPONENTS.slice(1).map(function (n) {
            return result[n]
          }).join('='), '=0;',
          '}else{',
          CUTE_COMPONENTS.map(function (name, i) {
            return (
              result[name] + '=' + VALUE + '.constant.length>' + i +
              '?' + VALUE + '.constant[' + i + ']:0;'
            )
          }).join(''),
          '}}else{',
          'if(', IS_BUFFER_ARGS, '(', VALUE, '.buffer)){',
          BUFFER, '=', BUFFER_STATE, '.createStream(', GL_ARRAY_BUFFER$2, ',', VALUE, '.buffer);',
          '}else{',
          BUFFER, '=', BUFFER_STATE, '.getBuffer(', VALUE, '.buffer);',
          '}',
          TYPE, '="type" in ', VALUE, '?',
          constants.glTypes, '[', VALUE, '.type]:', BUFFER, '.dtype;',
          result.normalized, '=!!', VALUE, '.normalized;')
        function emitReadRecord (name) {
          block(result[name], '=', VALUE, '.', name, '|0;')
        }
        emitReadRecord('size')
        emitReadRecord('offset')
        emitReadRecord('stride')
        emitReadRecord('divisor')

        block('}}')

        block.exit(
          'if(', result.isStream, '){',
          BUFFER_STATE, '.destroyStream(', BUFFER, ');',
          '}')

        return result
      }

      attributeDefs[attribute] = createDynamicDecl(dyn, appendAttributeCode)
    })

    return attributeDefs
  }

  function parseVAO (options, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic
    if (S_VAO in staticOptions) {
      var vao = staticOptions[S_VAO]
      if (vao !== null && attributeState.getVAO(vao) === null) {
        vao = attributeState.createVAO(vao)
      }
      return createStaticDecl(function (env) {
        return env.link(attributeState.getVAO(vao))
      })
    } else if (S_VAO in dynamicOptions) {
      var dyn = dynamicOptions[S_VAO]
      return createDynamicDecl(dyn, function (env, scope) {
        var vaoRef = env.invoke(scope, dyn)
        return scope.def(env.shared.vao + '.getVAO(' + vaoRef + ')')
      })
    }
    return null
  }

  function parseContext (context) {
    var staticContext = context.static
    var dynamicContext = context.dynamic
    var result = {}

    Object.keys(staticContext).forEach(function (name) {
      var value = staticContext[name]
      result[name] = createStaticDecl(function (env, scope) {
        if (typeof value === 'number' || typeof value === 'boolean') {
          return '' + value
        } else {
          return env.link(value)
        }
      })
    })

    Object.keys(dynamicContext).forEach(function (name) {
      var dyn = dynamicContext[name]
      result[name] = createDynamicDecl(dyn, function (env, scope) {
        return env.invoke(scope, dyn)
      })
    })

    return result
  }

  function parseArguments (options, attributes, uniforms, context, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    check$1.optional(function () {
      var KEY_NAMES = [
        S_FRAMEBUFFER,
        S_VERT,
        S_FRAG,
        S_ELEMENTS,
        S_PRIMITIVE,
        S_OFFSET,
        S_COUNT,
        S_INSTANCES,
        S_PROFILE,
        S_VAO
      ].concat(GL_STATE_NAMES)

      function checkKeys (dict) {
        Object.keys(dict).forEach(function (key) {
          check$1.command(
            KEY_NAMES.indexOf(key) >= 0,
            'unknown parameter "' + key + '"',
            env.commandStr)
        })
      }

      checkKeys(staticOptions)
      checkKeys(dynamicOptions)
    })

    var attribLocations = parseAttribLocations(options, attributes)

    var framebuffer = parseFramebuffer(options, env)
    var viewportAndScissor = parseViewportScissor(options, framebuffer, env)
    var draw = parseDraw(options, env)
    var state = parseGLState(options, env)
    var shader = parseProgram(options, env, attribLocations)

    function copyBox (name) {
      var defn = viewportAndScissor[name]
      if (defn) {
        state[name] = defn
      }
    }
    copyBox(S_VIEWPORT)
    copyBox(propName(S_SCISSOR_BOX))

    var dirty = Object.keys(state).length > 0

    var result = {
      framebuffer: framebuffer,
      draw: draw,
      shader: shader,
      state: state,
      dirty: dirty,
      scopeVAO: null,
      drawVAO: null,
      useVAO: false,
      attributes: {}
    }

    result.profile = parseProfile(options, env)
    result.uniforms = parseUniforms(uniforms, env)
    result.drawVAO = result.scopeVAO = parseVAO(options, env)
    // special case: check if we can statically allocate a vertex array object for this program
    if (!result.drawVAO && shader.program && !attribLocations && extensions.angle_instanced_arrays) {
      var useVAO = true
      var staticBindings = shader.program.attributes.map(function (attr) {
        var binding = attributes.static[attr]
        useVAO = useVAO && !!binding
        return binding
      })
      if (useVAO && staticBindings.length > 0) {
        var vao = attributeState.getVAO(attributeState.createVAO(staticBindings))
        result.drawVAO = new Declaration(null, null, null, function (env, scope) {
          return env.link(vao)
        })
        result.useVAO = true
      }
    }
    if (attribLocations) {
      result.useVAO = true
    } else {
      result.attributes = parseAttributes(attributes, env)
    }
    result.context = parseContext(context, env)
    return result
  }

  // ===================================================
  // ===================================================
  // COMMON UPDATE FUNCTIONS
  // ===================================================
  // ===================================================
  function emitContext (env, scope, context) {
    var shared = env.shared
    var CONTEXT = shared.context

    var contextEnter = env.scope()

    Object.keys(context).forEach(function (name) {
      scope.save(CONTEXT, '.' + name)
      var defn = context[name]
      var value = defn.append(env, scope)
      if (Array.isArray(value)) {
        contextEnter(CONTEXT, '.', name, '=[', value.join(), '];')
      } else {
        contextEnter(CONTEXT, '.', name, '=', value, ';')
      }
    })

    scope(contextEnter)
  }

  // ===================================================
  // ===================================================
  // COMMON DRAWING FUNCTIONS
  // ===================================================
  // ===================================================
  function emitPollFramebuffer (env, scope, framebuffer, skipCheck) {
    var shared = env.shared

    var GL = shared.gl
    var FRAMEBUFFER_STATE = shared.framebuffer
    var EXT_DRAW_BUFFERS
    if (extDrawBuffers) {
      EXT_DRAW_BUFFERS = scope.def(shared.extensions, '.webgl_draw_buffers')
    }

    var constants = env.constants

    var DRAW_BUFFERS = constants.drawBuffer
    var BACK_BUFFER = constants.backBuffer

    var NEXT
    if (framebuffer) {
      NEXT = framebuffer.append(env, scope)
    } else {
      NEXT = scope.def(FRAMEBUFFER_STATE, '.next')
    }

    if (!skipCheck) {
      scope('if(', NEXT, '!==', FRAMEBUFFER_STATE, '.cur){')
    }
    scope(
      'if(', NEXT, '){',
      GL, '.bindFramebuffer(', GL_FRAMEBUFFER$2, ',', NEXT, '.framebuffer);')
    if (extDrawBuffers) {
      scope(EXT_DRAW_BUFFERS, '.drawBuffersWEBGL(',
        DRAW_BUFFERS, '[', NEXT, '.colorAttachments.length]);')
    }
    scope('}else{',
      GL, '.bindFramebuffer(', GL_FRAMEBUFFER$2, ',null);')
    if (extDrawBuffers) {
      scope(EXT_DRAW_BUFFERS, '.drawBuffersWEBGL(', BACK_BUFFER, ');')
    }
    scope(
      '}',
      FRAMEBUFFER_STATE, '.cur=', NEXT, ';')
    if (!skipCheck) {
      scope('}')
    }
  }

  function emitPollState (env, scope, args) {
    var shared = env.shared

    var GL = shared.gl

    var CURRENT_VARS = env.current
    var NEXT_VARS = env.next
    var CURRENT_STATE = shared.current
    var NEXT_STATE = shared.next

    var block = env.cond(CURRENT_STATE, '.dirty')

    GL_STATE_NAMES.forEach(function (prop) {
      var param = propName(prop)
      if (param in args.state) {
        return
      }

      var NEXT, CURRENT
      if (param in NEXT_VARS) {
        NEXT = NEXT_VARS[param]
        CURRENT = CURRENT_VARS[param]
        var parts = loop(currentState[param].length, function (i) {
          return block.def(NEXT, '[', i, ']')
        })
        block(env.cond(parts.map(function (p, i) {
          return p + '!==' + CURRENT + '[' + i + ']'
        }).join('||'))
          .then(
            GL, '.', GL_VARIABLES[param], '(', parts, ');',
            parts.map(function (p, i) {
              return CURRENT + '[' + i + ']=' + p
            }).join(';'), ';'))
      } else {
        NEXT = block.def(NEXT_STATE, '.', param)
        var ifte = env.cond(NEXT, '!==', CURRENT_STATE, '.', param)
        block(ifte)
        if (param in GL_FLAGS) {
          ifte(
            env.cond(NEXT)
              .then(GL, '.enable(', GL_FLAGS[param], ');')
              .else(GL, '.disable(', GL_FLAGS[param], ');'),
            CURRENT_STATE, '.', param, '=', NEXT, ';')
        } else {
          ifte(
            GL, '.', GL_VARIABLES[param], '(', NEXT, ');',
            CURRENT_STATE, '.', param, '=', NEXT, ';')
        }
      }
    })
    if (Object.keys(args.state).length === 0) {
      block(CURRENT_STATE, '.dirty=false;')
    }
    scope(block)
  }

  function emitSetOptions (env, scope, options, filter) {
    var shared = env.shared
    var CURRENT_VARS = env.current
    var CURRENT_STATE = shared.current
    var GL = shared.gl
    sortState(Object.keys(options)).forEach(function (param) {
      var defn = options[param]
      if (filter && !filter(defn)) {
        return
      }
      var variable = defn.append(env, scope)
      if (GL_FLAGS[param]) {
        var flag = GL_FLAGS[param]
        if (isStatic(defn)) {
          if (variable) {
            scope(GL, '.enable(', flag, ');')
          } else {
            scope(GL, '.disable(', flag, ');')
          }
        } else {
          scope(env.cond(variable)
            .then(GL, '.enable(', flag, ');')
            .else(GL, '.disable(', flag, ');'))
        }
        scope(CURRENT_STATE, '.', param, '=', variable, ';')
      } else if (isArrayLike(variable)) {
        var CURRENT = CURRENT_VARS[param]
        scope(
          GL, '.', GL_VARIABLES[param], '(', variable, ');',
          variable.map(function (v, i) {
            return CURRENT + '[' + i + ']=' + v
          }).join(';'), ';')
      } else {
        scope(
          GL, '.', GL_VARIABLES[param], '(', variable, ');',
          CURRENT_STATE, '.', param, '=', variable, ';')
      }
    })
  }

  function injectExtensions (env, scope) {
    if (extInstancing) {
      env.instancing = scope.def(
        env.shared.extensions, '.angle_instanced_arrays')
    }
  }

  function emitProfile (env, scope, args, useScope, incrementCounter) {
    var shared = env.shared
    var STATS = env.stats
    var CURRENT_STATE = shared.current
    var TIMER = shared.timer
    var profileArg = args.profile

    function perfCounter () {
      if (typeof performance === 'undefined') {
        return 'Date.now()'
      } else {
        return 'performance.now()'
      }
    }

    var CPU_START, QUERY_COUNTER
    function emitProfileStart (block) {
      CPU_START = scope.def()
      block(CPU_START, '=', perfCounter(), ';')
      if (typeof incrementCounter === 'string') {
        block(STATS, '.count+=', incrementCounter, ';')
      } else {
        block(STATS, '.count++;')
      }
      if (timer) {
        if (useScope) {
          QUERY_COUNTER = scope.def()
          block(QUERY_COUNTER, '=', TIMER, '.getNumPendingQueries();')
        } else {
          block(TIMER, '.beginQuery(', STATS, ');')
        }
      }
    }

    function emitProfileEnd (block) {
      block(STATS, '.cpuTime+=', perfCounter(), '-', CPU_START, ';')
      if (timer) {
        if (useScope) {
          block(TIMER, '.pushScopeStats(',
            QUERY_COUNTER, ',',
            TIMER, '.getNumPendingQueries(),',
            STATS, ');')
        } else {
          block(TIMER, '.endQuery();')
        }
      }
    }

    function scopeProfile (value) {
      var prev = scope.def(CURRENT_STATE, '.profile')
      scope(CURRENT_STATE, '.profile=', value, ';')
      scope.exit(CURRENT_STATE, '.profile=', prev, ';')
    }

    var USE_PROFILE
    if (profileArg) {
      if (isStatic(profileArg)) {
        if (profileArg.enable) {
          emitProfileStart(scope)
          emitProfileEnd(scope.exit)
          scopeProfile('true')
        } else {
          scopeProfile('false')
        }
        return
      }
      USE_PROFILE = profileArg.append(env, scope)
      scopeProfile(USE_PROFILE)
    } else {
      USE_PROFILE = scope.def(CURRENT_STATE, '.profile')
    }

    var start = env.block()
    emitProfileStart(start)
    scope('if(', USE_PROFILE, '){', start, '}')
    var end = env.block()
    emitProfileEnd(end)
    scope.exit('if(', USE_PROFILE, '){', end, '}')
  }

  function emitAttributes (env, scope, args, attributes, filter) {
    var shared = env.shared

    function typeLength (x) {
      switch (x) {
        case GL_FLOAT_VEC2:
        case GL_INT_VEC2:
        case GL_BOOL_VEC2:
          return 2
        case GL_FLOAT_VEC3:
        case GL_INT_VEC3:
        case GL_BOOL_VEC3:
          return 3
        case GL_FLOAT_VEC4:
        case GL_INT_VEC4:
        case GL_BOOL_VEC4:
          return 4
        default:
          return 1
      }
    }

    function emitBindAttribute (ATTRIBUTE, size, record) {
      var GL = shared.gl

      var LOCATION = scope.def(ATTRIBUTE, '.location')
      var BINDING = scope.def(shared.attributes, '[', LOCATION, ']')

      var STATE = record.state
      var BUFFER = record.buffer
      var CONST_COMPONENTS = [
        record.x,
        record.y,
        record.z,
        record.w
      ]

      var COMMON_KEYS = [
        'buffer',
        'normalized',
        'offset',
        'stride'
      ]

      function emitBuffer () {
        scope(
          'if(!', BINDING, '.buffer){',
          GL, '.enableVertexAttribArray(', LOCATION, ');}')

        var TYPE = record.type
        var SIZE
        if (!record.size) {
          SIZE = size
        } else {
          SIZE = scope.def(record.size, '||', size)
        }

        scope('if(',
          BINDING, '.type!==', TYPE, '||',
          BINDING, '.size!==', SIZE, '||',
          COMMON_KEYS.map(function (key) {
            return BINDING + '.' + key + '!==' + record[key]
          }).join('||'),
          '){',
          GL, '.bindBuffer(', GL_ARRAY_BUFFER$2, ',', BUFFER, '.buffer);',
          GL, '.vertexAttribPointer(', [
            LOCATION,
            SIZE,
            TYPE,
            record.normalized,
            record.stride,
            record.offset
          ], ');',
          BINDING, '.type=', TYPE, ';',
          BINDING, '.size=', SIZE, ';',
          COMMON_KEYS.map(function (key) {
            return BINDING + '.' + key + '=' + record[key] + ';'
          }).join(''),
          '}')

        if (extInstancing) {
          var DIVISOR = record.divisor
          scope(
            'if(', BINDING, '.divisor!==', DIVISOR, '){',
            env.instancing, '.vertexAttribDivisorANGLE(', [LOCATION, DIVISOR], ');',
            BINDING, '.divisor=', DIVISOR, ';}')
        }
      }

      function emitConstant () {
        scope(
          'if(', BINDING, '.buffer){',
          GL, '.disableVertexAttribArray(', LOCATION, ');',
          BINDING, '.buffer=null;',
          '}if(', CUTE_COMPONENTS.map(function (c, i) {
            return BINDING + '.' + c + '!==' + CONST_COMPONENTS[i]
          }).join('||'), '){',
          GL, '.vertexAttrib4f(', LOCATION, ',', CONST_COMPONENTS, ');',
          CUTE_COMPONENTS.map(function (c, i) {
            return BINDING + '.' + c + '=' + CONST_COMPONENTS[i] + ';'
          }).join(''),
          '}')
      }

      if (STATE === ATTRIB_STATE_POINTER) {
        emitBuffer()
      } else if (STATE === ATTRIB_STATE_CONSTANT) {
        emitConstant()
      } else {
        scope('if(', STATE, '===', ATTRIB_STATE_POINTER, '){')
        emitBuffer()
        scope('}else{')
        emitConstant()
        scope('}')
      }
    }

    attributes.forEach(function (attribute) {
      var name = attribute.name
      var arg = args.attributes[name]
      var record
      if (arg) {
        if (!filter(arg)) {
          return
        }
        record = arg.append(env, scope)
      } else {
        if (!filter(SCOPE_DECL)) {
          return
        }
        var scopeAttrib = env.scopeAttrib(name)
        check$1.optional(function () {
          env.assert(scope,
            scopeAttrib + '.state',
            'missing attribute ' + name)
        })
        record = {}
        Object.keys(new AttributeRecord()).forEach(function (key) {
          record[key] = scope.def(scopeAttrib, '.', key)
        })
      }
      emitBindAttribute(
        env.link(attribute), typeLength(attribute.info.type), record)
    })
  }

  function emitUniforms (env, scope, args, uniforms, filter) {
    var shared = env.shared
    var GL = shared.gl

    var infix
    for (var i = 0; i < uniforms.length; ++i) {
      var uniform = uniforms[i]
      var name = uniform.name
      var type = uniform.info.type
      var arg = args.uniforms[name]
      var UNIFORM = env.link(uniform)
      var LOCATION = UNIFORM + '.location'

      var VALUE
      if (arg) {
        if (!filter(arg)) {
          continue
        }
        if (isStatic(arg)) {
          var value = arg.value
          check$1.command(
            value !== null && typeof value !== 'undefined',
            'missing uniform "' + name + '"', env.commandStr)
          if (type === GL_SAMPLER_2D || type === GL_SAMPLER_CUBE) {
            check$1.command(
              typeof value === 'function' &&
              ((type === GL_SAMPLER_2D &&
                (value._reglType === 'texture2d' ||
                value._reglType === 'framebuffer')) ||
              (type === GL_SAMPLER_CUBE &&
                (value._reglType === 'textureCube' ||
                value._reglType === 'framebufferCube'))),
              'invalid texture for uniform ' + name, env.commandStr)
            var TEX_VALUE = env.link(value._texture || value.color[0]._texture)
            scope(GL, '.uniform1i(', LOCATION, ',', TEX_VALUE + '.bind());')
            scope.exit(TEX_VALUE, '.unbind();')
          } else if (
            type === GL_FLOAT_MAT2 ||
            type === GL_FLOAT_MAT3 ||
            type === GL_FLOAT_MAT4) {
            check$1.optional(function () {
              check$1.command(isArrayLike(value),
                'invalid matrix for uniform ' + name, env.commandStr)
              check$1.command(
                (type === GL_FLOAT_MAT2 && value.length === 4) ||
                (type === GL_FLOAT_MAT3 && value.length === 9) ||
                (type === GL_FLOAT_MAT4 && value.length === 16),
                'invalid length for matrix uniform ' + name, env.commandStr)
            })
            var MAT_VALUE = env.global.def('new Float32Array([' +
              Array.prototype.slice.call(value) + '])')
            var dim = 2
            if (type === GL_FLOAT_MAT3) {
              dim = 3
            } else if (type === GL_FLOAT_MAT4) {
              dim = 4
            }
            scope(
              GL, '.uniformMatrix', dim, 'fv(',
              LOCATION, ',false,', MAT_VALUE, ');')
          } else {
            switch (type) {
              case GL_FLOAT$8:
                check$1.commandType(value, 'number', 'uniform ' + name, env.commandStr)
                infix = '1f'
                break
              case GL_FLOAT_VEC2:
                check$1.command(
                  isArrayLike(value) && value.length === 2,
                  'uniform ' + name, env.commandStr)
                infix = '2f'
                break
              case GL_FLOAT_VEC3:
                check$1.command(
                  isArrayLike(value) && value.length === 3,
                  'uniform ' + name, env.commandStr)
                infix = '3f'
                break
              case GL_FLOAT_VEC4:
                check$1.command(
                  isArrayLike(value) && value.length === 4,
                  'uniform ' + name, env.commandStr)
                infix = '4f'
                break
              case GL_BOOL:
                check$1.commandType(value, 'boolean', 'uniform ' + name, env.commandStr)
                infix = '1i'
                break
              case GL_INT$3:
                check$1.commandType(value, 'number', 'uniform ' + name, env.commandStr)
                infix = '1i'
                break
              case GL_BOOL_VEC2:
                check$1.command(
                  isArrayLike(value) && value.length === 2,
                  'uniform ' + name, env.commandStr)
                infix = '2i'
                break
              case GL_INT_VEC2:
                check$1.command(
                  isArrayLike(value) && value.length === 2,
                  'uniform ' + name, env.commandStr)
                infix = '2i'
                break
              case GL_BOOL_VEC3:
                check$1.command(
                  isArrayLike(value) && value.length === 3,
                  'uniform ' + name, env.commandStr)
                infix = '3i'
                break
              case GL_INT_VEC3:
                check$1.command(
                  isArrayLike(value) && value.length === 3,
                  'uniform ' + name, env.commandStr)
                infix = '3i'
                break
              case GL_BOOL_VEC4:
                check$1.command(
                  isArrayLike(value) && value.length === 4,
                  'uniform ' + name, env.commandStr)
                infix = '4i'
                break
              case GL_INT_VEC4:
                check$1.command(
                  isArrayLike(value) && value.length === 4,
                  'uniform ' + name, env.commandStr)
                infix = '4i'
                break
            }
            scope(GL, '.uniform', infix, '(', LOCATION, ',',
              isArrayLike(value) ? Array.prototype.slice.call(value) : value,
              ');')
          }
          continue
        } else {
          VALUE = arg.append(env, scope)
        }
      } else {
        if (!filter(SCOPE_DECL)) {
          continue
        }
        VALUE = scope.def(shared.uniforms, '[', stringStore.id(name), ']')
      }

      if (type === GL_SAMPLER_2D) {
        check$1(!Array.isArray(VALUE), 'must specify a scalar prop for textures')
        scope(
          'if(', VALUE, '&&', VALUE, '._reglType==="framebuffer"){',
          VALUE, '=', VALUE, '.color[0];',
          '}')
      } else if (type === GL_SAMPLER_CUBE) {
        check$1(!Array.isArray(VALUE), 'must specify a scalar prop for cube maps')
        scope(
          'if(', VALUE, '&&', VALUE, '._reglType==="framebufferCube"){',
          VALUE, '=', VALUE, '.color[0];',
          '}')
      }

      // perform type validation
      check$1.optional(function () {
        function emitCheck (pred, message) {
          env.assert(scope, pred,
            'bad data or missing for uniform "' + name + '".  ' + message)
        }

        function checkType (type) {
          check$1(!Array.isArray(VALUE), 'must not specify an array type for uniform')
          emitCheck(
            'typeof ' + VALUE + '==="' + type + '"',
            'invalid type, expected ' + type)
        }

        function checkVector (n, type) {
          if (Array.isArray(VALUE)) {
            check$1(VALUE.length === n, 'must have length ' + n)
          } else {
            emitCheck(
              shared.isArrayLike + '(' + VALUE + ')&&' + VALUE + '.length===' + n,
              'invalid vector, should have length ' + n, env.commandStr)
          }
        }

        function checkTexture (target) {
          check$1(!Array.isArray(VALUE), 'must not specify a value type')
          emitCheck(
            'typeof ' + VALUE + '==="function"&&' +
            VALUE + '._reglType==="texture' +
            (target === GL_TEXTURE_2D$3 ? '2d' : 'Cube') + '"',
            'invalid texture type', env.commandStr)
        }

        switch (type) {
          case GL_INT$3:
            checkType('number')
            break
          case GL_INT_VEC2:
            checkVector(2, 'number')
            break
          case GL_INT_VEC3:
            checkVector(3, 'number')
            break
          case GL_INT_VEC4:
            checkVector(4, 'number')
            break
          case GL_FLOAT$8:
            checkType('number')
            break
          case GL_FLOAT_VEC2:
            checkVector(2, 'number')
            break
          case GL_FLOAT_VEC3:
            checkVector(3, 'number')
            break
          case GL_FLOAT_VEC4:
            checkVector(4, 'number')
            break
          case GL_BOOL:
            checkType('boolean')
            break
          case GL_BOOL_VEC2:
            checkVector(2, 'boolean')
            break
          case GL_BOOL_VEC3:
            checkVector(3, 'boolean')
            break
          case GL_BOOL_VEC4:
            checkVector(4, 'boolean')
            break
          case GL_FLOAT_MAT2:
            checkVector(4, 'number')
            break
          case GL_FLOAT_MAT3:
            checkVector(9, 'number')
            break
          case GL_FLOAT_MAT4:
            checkVector(16, 'number')
            break
          case GL_SAMPLER_2D:
            checkTexture(GL_TEXTURE_2D$3)
            break
          case GL_SAMPLER_CUBE:
            checkTexture(GL_TEXTURE_CUBE_MAP$2)
            break
        }
      })

      var unroll = 1
      switch (type) {
        case GL_SAMPLER_2D:
        case GL_SAMPLER_CUBE:
          var TEX = scope.def(VALUE, '._texture')
          scope(GL, '.uniform1i(', LOCATION, ',', TEX, '.bind());')
          scope.exit(TEX, '.unbind();')
          continue

        case GL_INT$3:
        case GL_BOOL:
          infix = '1i'
          break

        case GL_INT_VEC2:
        case GL_BOOL_VEC2:
          infix = '2i'
          unroll = 2
          break

        case GL_INT_VEC3:
        case GL_BOOL_VEC3:
          infix = '3i'
          unroll = 3
          break

        case GL_INT_VEC4:
        case GL_BOOL_VEC4:
          infix = '4i'
          unroll = 4
          break

        case GL_FLOAT$8:
          infix = '1f'
          break

        case GL_FLOAT_VEC2:
          infix = '2f'
          unroll = 2
          break

        case GL_FLOAT_VEC3:
          infix = '3f'
          unroll = 3
          break

        case GL_FLOAT_VEC4:
          infix = '4f'
          unroll = 4
          break

        case GL_FLOAT_MAT2:
          infix = 'Matrix2fv'
          break

        case GL_FLOAT_MAT3:
          infix = 'Matrix3fv'
          break

        case GL_FLOAT_MAT4:
          infix = 'Matrix4fv'
          break
      }

      scope(GL, '.uniform', infix, '(', LOCATION, ',')
      if (infix.charAt(0) === 'M') {
        var matSize = Math.pow(type - GL_FLOAT_MAT2 + 2, 2)
        var STORAGE = env.global.def('new Float32Array(', matSize, ')')
        if (Array.isArray(VALUE)) {
          scope(
            'false,(',
            loop(matSize, function (i) {
              return STORAGE + '[' + i + ']=' + VALUE[i]
            }), ',', STORAGE, ')')
        } else {
          scope(
            'false,(Array.isArray(', VALUE, ')||', VALUE, ' instanceof Float32Array)?', VALUE, ':(',
            loop(matSize, function (i) {
              return STORAGE + '[' + i + ']=' + VALUE + '[' + i + ']'
            }), ',', STORAGE, ')')
        }
      } else if (unroll > 1) {
        scope(loop(unroll, function (i) {
          return Array.isArray(VALUE) ? VALUE[i] : VALUE + '[' + i + ']'
        }))
      } else {
        check$1(!Array.isArray(VALUE), 'uniform value must not be an array')
        scope(VALUE)
      }
      scope(');')
    }
  }

  function emitDraw (env, outer, inner, args) {
    var shared = env.shared
    var GL = shared.gl
    var DRAW_STATE = shared.draw

    var drawOptions = args.draw

    function emitElements () {
      var defn = drawOptions.elements
      var ELEMENTS
      var scope = outer
      if (defn) {
        if ((defn.contextDep && args.contextDynamic) || defn.propDep) {
          scope = inner
        }
        ELEMENTS = defn.append(env, scope)
      } else {
        ELEMENTS = scope.def(DRAW_STATE, '.', S_ELEMENTS)
      }
      if (ELEMENTS) {
        scope(
          'if(' + ELEMENTS + ')' +
          GL + '.bindBuffer(' + GL_ELEMENT_ARRAY_BUFFER$1 + ',' + ELEMENTS + '.buffer.buffer);')
      }
      return ELEMENTS
    }

    function emitCount () {
      var defn = drawOptions.count
      var COUNT
      var scope = outer
      if (defn) {
        if ((defn.contextDep && args.contextDynamic) || defn.propDep) {
          scope = inner
        }
        COUNT = defn.append(env, scope)
        check$1.optional(function () {
          if (defn.MISSING) {
            env.assert(outer, 'false', 'missing vertex count')
          }
          if (defn.DYNAMIC) {
            env.assert(scope, COUNT + '>=0', 'missing vertex count')
          }
        })
      } else {
        COUNT = scope.def(DRAW_STATE, '.', S_COUNT)
        check$1.optional(function () {
          env.assert(scope, COUNT + '>=0', 'missing vertex count')
        })
      }
      return COUNT
    }

    var ELEMENTS = emitElements()
    function emitValue (name) {
      var defn = drawOptions[name]
      if (defn) {
        if ((defn.contextDep && args.contextDynamic) || defn.propDep) {
          return defn.append(env, inner)
        } else {
          return defn.append(env, outer)
        }
      } else {
        return outer.def(DRAW_STATE, '.', name)
      }
    }

    var PRIMITIVE = emitValue(S_PRIMITIVE)
    var OFFSET = emitValue(S_OFFSET)

    var COUNT = emitCount()
    if (typeof COUNT === 'number') {
      if (COUNT === 0) {
        return
      }
    } else {
      inner('if(', COUNT, '){')
      inner.exit('}')
    }

    var INSTANCES, EXT_INSTANCING
    if (extInstancing) {
      INSTANCES = emitValue(S_INSTANCES)
      EXT_INSTANCING = env.instancing
    }

    var ELEMENT_TYPE = ELEMENTS + '.type'

    var elementsStatic = drawOptions.elements && isStatic(drawOptions.elements)

    function emitInstancing () {
      function drawElements () {
        inner(EXT_INSTANCING, '.drawElementsInstancedANGLE(', [
          PRIMITIVE,
          COUNT,
          ELEMENT_TYPE,
          OFFSET + '<<((' + ELEMENT_TYPE + '-' + GL_UNSIGNED_BYTE$8 + ')>>1)',
          INSTANCES
        ], ');')
      }

      function drawArrays () {
        inner(EXT_INSTANCING, '.drawArraysInstancedANGLE(',
          [PRIMITIVE, OFFSET, COUNT, INSTANCES], ');')
      }

      if (ELEMENTS) {
        if (!elementsStatic) {
          inner('if(', ELEMENTS, '){')
          drawElements()
          inner('}else{')
          drawArrays()
          inner('}')
        } else {
          drawElements()
        }
      } else {
        drawArrays()
      }
    }

    function emitRegular () {
      function drawElements () {
        inner(GL + '.drawElements(' + [
          PRIMITIVE,
          COUNT,
          ELEMENT_TYPE,
          OFFSET + '<<((' + ELEMENT_TYPE + '-' + GL_UNSIGNED_BYTE$8 + ')>>1)'
        ] + ');')
      }

      function drawArrays () {
        inner(GL + '.drawArrays(' + [PRIMITIVE, OFFSET, COUNT] + ');')
      }

      if (ELEMENTS) {
        if (!elementsStatic) {
          inner('if(', ELEMENTS, '){')
          drawElements()
          inner('}else{')
          drawArrays()
          inner('}')
        } else {
          drawElements()
        }
      } else {
        drawArrays()
      }
    }

    if (extInstancing && (typeof INSTANCES !== 'number' || INSTANCES >= 0)) {
      if (typeof INSTANCES === 'string') {
        inner('if(', INSTANCES, '>0){')
        emitInstancing()
        inner('}else if(', INSTANCES, '<0){')
        emitRegular()
        inner('}')
      } else {
        emitInstancing()
      }
    } else {
      emitRegular()
    }
  }

  function createBody (emitBody, parentEnv, args, program, count) {
    var env = createREGLEnvironment()
    var scope = env.proc('body', count)
    check$1.optional(function () {
      env.commandStr = parentEnv.commandStr
      env.command = env.link(parentEnv.commandStr)
    })
    if (extInstancing) {
      env.instancing = scope.def(
        env.shared.extensions, '.angle_instanced_arrays')
    }
    emitBody(env, scope, args, program)
    return env.compile().body
  }

  // ===================================================
  // ===================================================
  // DRAW PROC
  // ===================================================
  // ===================================================
  function emitDrawBody (env, draw, args, program) {
    injectExtensions(env, draw)
    if (args.useVAO) {
      if (args.drawVAO) {
        draw(env.shared.vao, '.setVAO(', args.drawVAO.append(env, draw), ');')
      } else {
        draw(env.shared.vao, '.setVAO(', env.shared.vao, '.targetVAO);')
      }
    } else {
      draw(env.shared.vao, '.setVAO(null);')
      emitAttributes(env, draw, args, program.attributes, function () {
        return true
      })
    }
    emitUniforms(env, draw, args, program.uniforms, function () {
      return true
    })
    emitDraw(env, draw, draw, args)
  }

  function emitDrawProc (env, args) {
    var draw = env.proc('draw', 1)

    injectExtensions(env, draw)

    emitContext(env, draw, args.context)
    emitPollFramebuffer(env, draw, args.framebuffer)

    emitPollState(env, draw, args)
    emitSetOptions(env, draw, args.state)

    emitProfile(env, draw, args, false, true)

    var program = args.shader.progVar.append(env, draw)
    draw(env.shared.gl, '.useProgram(', program, '.program);')

    if (args.shader.program) {
      emitDrawBody(env, draw, args, args.shader.program)
    } else {
      draw(env.shared.vao, '.setVAO(null);')
      var drawCache = env.global.def('{}')
      var PROG_ID = draw.def(program, '.id')
      var CACHED_PROC = draw.def(drawCache, '[', PROG_ID, ']')
      draw(
        env.cond(CACHED_PROC)
          .then(CACHED_PROC, '.call(this,a0);')
          .else(
            CACHED_PROC, '=', drawCache, '[', PROG_ID, ']=',
            env.link(function (program) {
              return createBody(emitDrawBody, env, args, program, 1)
            }), '(', program, ');',
            CACHED_PROC, '.call(this,a0);'))
    }

    if (Object.keys(args.state).length > 0) {
      draw(env.shared.current, '.dirty=true;')
    }
  }

  // ===================================================
  // ===================================================
  // BATCH PROC
  // ===================================================
  // ===================================================

  function emitBatchDynamicShaderBody (env, scope, args, program) {
    env.batchId = 'a1'

    injectExtensions(env, scope)

    function all () {
      return true
    }

    emitAttributes(env, scope, args, program.attributes, all)
    emitUniforms(env, scope, args, program.uniforms, all)
    emitDraw(env, scope, scope, args)
  }

  function emitBatchBody (env, scope, args, program) {
    injectExtensions(env, scope)

    var contextDynamic = args.contextDep

    var BATCH_ID = scope.def()
    var PROP_LIST = 'a0'
    var NUM_PROPS = 'a1'
    var PROPS = scope.def()
    env.shared.props = PROPS
    env.batchId = BATCH_ID

    var outer = env.scope()
    var inner = env.scope()

    scope(
      outer.entry,
      'for(', BATCH_ID, '=0;', BATCH_ID, '<', NUM_PROPS, ';++', BATCH_ID, '){',
      PROPS, '=', PROP_LIST, '[', BATCH_ID, '];',
      inner,
      '}',
      outer.exit)

    function isInnerDefn (defn) {
      return ((defn.contextDep && contextDynamic) || defn.propDep)
    }

    function isOuterDefn (defn) {
      return !isInnerDefn(defn)
    }

    if (args.needsContext) {
      emitContext(env, inner, args.context)
    }
    if (args.needsFramebuffer) {
      emitPollFramebuffer(env, inner, args.framebuffer)
    }
    emitSetOptions(env, inner, args.state, isInnerDefn)

    if (args.profile && isInnerDefn(args.profile)) {
      emitProfile(env, inner, args, false, true)
    }

    if (!program) {
      var progCache = env.global.def('{}')
      var PROGRAM = args.shader.progVar.append(env, inner)
      var PROG_ID = inner.def(PROGRAM, '.id')
      var CACHED_PROC = inner.def(progCache, '[', PROG_ID, ']')
      inner(
        env.shared.gl, '.useProgram(', PROGRAM, '.program);',
        'if(!', CACHED_PROC, '){',
        CACHED_PROC, '=', progCache, '[', PROG_ID, ']=',
        env.link(function (program) {
          return createBody(
            emitBatchDynamicShaderBody, env, args, program, 2)
        }), '(', PROGRAM, ');}',
        CACHED_PROC, '.call(this,a0[', BATCH_ID, '],', BATCH_ID, ');')
    } else {
      if (args.useVAO) {
        if (args.drawVAO) {
          if (isInnerDefn(args.drawVAO)) {
            // vao is a prop
            inner(env.shared.vao, '.setVAO(', args.drawVAO.append(env, inner), ');')
          } else {
            // vao is invariant
            outer(env.shared.vao, '.setVAO(', args.drawVAO.append(env, outer), ');')
          }
        } else {
          // scoped vao binding
          outer(env.shared.vao, '.setVAO(', env.shared.vao, '.targetVAO);')
        }
      } else {
        outer(env.shared.vao, '.setVAO(null);')
        emitAttributes(env, outer, args, program.attributes, isOuterDefn)
        emitAttributes(env, inner, args, program.attributes, isInnerDefn)
      }
      emitUniforms(env, outer, args, program.uniforms, isOuterDefn)
      emitUniforms(env, inner, args, program.uniforms, isInnerDefn)
      emitDraw(env, outer, inner, args)
    }
  }

  function emitBatchProc (env, args) {
    var batch = env.proc('batch', 2)
    env.batchId = '0'

    injectExtensions(env, batch)

    // Check if any context variables depend on props
    var contextDynamic = false
    var needsContext = true
    Object.keys(args.context).forEach(function (name) {
      contextDynamic = contextDynamic || args.context[name].propDep
    })
    if (!contextDynamic) {
      emitContext(env, batch, args.context)
      needsContext = false
    }

    // framebuffer state affects framebufferWidth/height context vars
    var framebuffer = args.framebuffer
    var needsFramebuffer = false
    if (framebuffer) {
      if (framebuffer.propDep) {
        contextDynamic = needsFramebuffer = true
      } else if (framebuffer.contextDep && contextDynamic) {
        needsFramebuffer = true
      }
      if (!needsFramebuffer) {
        emitPollFramebuffer(env, batch, framebuffer)
      }
    } else {
      emitPollFramebuffer(env, batch, null)
    }

    // viewport is weird because it can affect context vars
    if (args.state.viewport && args.state.viewport.propDep) {
      contextDynamic = true
    }

    function isInnerDefn (defn) {
      return (defn.contextDep && contextDynamic) || defn.propDep
    }

    // set webgl options
    emitPollState(env, batch, args)
    emitSetOptions(env, batch, args.state, function (defn) {
      return !isInnerDefn(defn)
    })

    if (!args.profile || !isInnerDefn(args.profile)) {
      emitProfile(env, batch, args, false, 'a1')
    }

    // Save these values to args so that the batch body routine can use them
    args.contextDep = contextDynamic
    args.needsContext = needsContext
    args.needsFramebuffer = needsFramebuffer

    // determine if shader is dynamic
    var progDefn = args.shader.progVar
    if ((progDefn.contextDep && contextDynamic) || progDefn.propDep) {
      emitBatchBody(
        env,
        batch,
        args,
        null)
    } else {
      var PROGRAM = progDefn.append(env, batch)
      batch(env.shared.gl, '.useProgram(', PROGRAM, '.program);')
      if (args.shader.program) {
        emitBatchBody(
          env,
          batch,
          args,
          args.shader.program)
      } else {
        batch(env.shared.vao, '.setVAO(null);')
        var batchCache = env.global.def('{}')
        var PROG_ID = batch.def(PROGRAM, '.id')
        var CACHED_PROC = batch.def(batchCache, '[', PROG_ID, ']')
        batch(
          env.cond(CACHED_PROC)
            .then(CACHED_PROC, '.call(this,a0,a1);')
            .else(
              CACHED_PROC, '=', batchCache, '[', PROG_ID, ']=',
              env.link(function (program) {
                return createBody(emitBatchBody, env, args, program, 2)
              }), '(', PROGRAM, ');',
              CACHED_PROC, '.call(this,a0,a1);'))
      }
    }

    if (Object.keys(args.state).length > 0) {
      batch(env.shared.current, '.dirty=true;')
    }
  }

  // ===================================================
  // ===================================================
  // SCOPE COMMAND
  // ===================================================
  // ===================================================
  function emitScopeProc (env, args) {
    var scope = env.proc('scope', 3)
    env.batchId = 'a2'

    var shared = env.shared
    var CURRENT_STATE = shared.current

    emitContext(env, scope, args.context)

    if (args.framebuffer) {
      args.framebuffer.append(env, scope)
    }

    sortState(Object.keys(args.state)).forEach(function (name) {
      var defn = args.state[name]
      var value = defn.append(env, scope)
      if (isArrayLike(value)) {
        value.forEach(function (v, i) {
          scope.set(env.next[name], '[' + i + ']', v)
        })
      } else {
        scope.set(shared.next, '.' + name, value)
      }
    })

    emitProfile(env, scope, args, true, true)

    ;[S_ELEMENTS, S_OFFSET, S_COUNT, S_INSTANCES, S_PRIMITIVE].forEach(
      function (opt) {
        var variable = args.draw[opt]
        if (!variable) {
          return
        }
        scope.set(shared.draw, '.' + opt, '' + variable.append(env, scope))
      })

    Object.keys(args.uniforms).forEach(function (opt) {
      var value = args.uniforms[opt].append(env, scope)
      if (Array.isArray(value)) {
        value = '[' + value.join() + ']'
      }
      scope.set(
        shared.uniforms,
        '[' + stringStore.id(opt) + ']',
        value)
    })

    Object.keys(args.attributes).forEach(function (name) {
      var record = args.attributes[name].append(env, scope)
      var scopeAttrib = env.scopeAttrib(name)
      Object.keys(new AttributeRecord()).forEach(function (prop) {
        scope.set(scopeAttrib, '.' + prop, record[prop])
      })
    })

    if (args.scopeVAO) {
      scope.set(shared.vao, '.targetVAO', args.scopeVAO.append(env, scope))
    }

    function saveShader (name) {
      var shader = args.shader[name]
      if (shader) {
        scope.set(shared.shader, '.' + name, shader.append(env, scope))
      }
    }
    saveShader(S_VERT)
    saveShader(S_FRAG)

    if (Object.keys(args.state).length > 0) {
      scope(CURRENT_STATE, '.dirty=true;')
      scope.exit(CURRENT_STATE, '.dirty=true;')
    }

    scope('a1(', env.shared.context, ',a0,', env.batchId, ');')
  }

  function isDynamicObject (object) {
    if (typeof object !== 'object' || isArrayLike(object)) {
      return
    }
    var props = Object.keys(object)
    for (var i = 0; i < props.length; ++i) {
      if (dynamic.isDynamic(object[props[i]])) {
        return true
      }
    }
    return false
  }

  function splatObject (env, options, name) {
    var object = options.static[name]
    if (!object || !isDynamicObject(object)) {
      return
    }

    var globals = env.global
    var keys = Object.keys(object)
    var thisDep = false
    var contextDep = false
    var propDep = false
    var objectRef = env.global.def('{}')
    keys.forEach(function (key) {
      var value = object[key]
      if (dynamic.isDynamic(value)) {
        if (typeof value === 'function') {
          value = object[key] = dynamic.unbox(value)
        }
        var deps = createDynamicDecl(value, null)
        thisDep = thisDep || deps.thisDep
        propDep = propDep || deps.propDep
        contextDep = contextDep || deps.contextDep
      } else {
        globals(objectRef, '.', key, '=')
        switch (typeof value) {
          case 'number':
            globals(value)
            break
          case 'string':
            globals('"', value, '"')
            break
          case 'object':
            if (Array.isArray(value)) {
              globals('[', value.join(), ']')
            }
            break
          default:
            globals(env.link(value))
            break
        }
        globals(';')
      }
    })

    function appendBlock (env, block) {
      keys.forEach(function (key) {
        var value = object[key]
        if (!dynamic.isDynamic(value)) {
          return
        }
        var ref = env.invoke(block, value)
        block(objectRef, '.', key, '=', ref, ';')
      })
    }

    options.dynamic[name] = new dynamic.DynamicVariable(DYN_THUNK, {
      thisDep: thisDep,
      contextDep: contextDep,
      propDep: propDep,
      ref: objectRef,
      append: appendBlock
    })
    delete options.static[name]
  }

  // ===========================================================================
  // ===========================================================================
  // MAIN DRAW COMMAND
  // ===========================================================================
  // ===========================================================================
  function compileCommand (options, attributes, uniforms, context, stats) {
    var env = createREGLEnvironment()

    // link stats, so that we can easily access it in the program.
    env.stats = env.link(stats)

    // splat options and attributes to allow for dynamic nested properties
    Object.keys(attributes.static).forEach(function (key) {
      splatObject(env, attributes, key)
    })
    NESTED_OPTIONS.forEach(function (name) {
      splatObject(env, options, name)
    })

    var args = parseArguments(options, attributes, uniforms, context, env)

    emitDrawProc(env, args)
    emitScopeProc(env, args)
    emitBatchProc(env, args)

    return extend(env.compile(), {
      destroy: function () {
        args.shader.program.destroy()
      }
    })
  }

  // ===========================================================================
  // ===========================================================================
  // POLL / REFRESH
  // ===========================================================================
  // ===========================================================================
  return {
    next: nextState,
    current: currentState,
    procs: (function () {
      var env = createREGLEnvironment()
      var poll = env.proc('poll')
      var refresh = env.proc('refresh')
      var common = env.block()
      poll(common)
      refresh(common)

      var shared = env.shared
      var GL = shared.gl
      var NEXT_STATE = shared.next
      var CURRENT_STATE = shared.current

      common(CURRENT_STATE, '.dirty=false;')

      emitPollFramebuffer(env, poll)
      emitPollFramebuffer(env, refresh, null, true)

      // Refresh updates all attribute state changes
      var INSTANCING
      if (extInstancing) {
        INSTANCING = env.link(extInstancing)
      }

      // update vertex array bindings
      if (extensions.oes_vertex_array_object) {
        refresh(env.link(extensions.oes_vertex_array_object), '.bindVertexArrayOES(null);')
      }
      for (var i = 0; i < limits.maxAttributes; ++i) {
        var BINDING = refresh.def(shared.attributes, '[', i, ']')
        var ifte = env.cond(BINDING, '.buffer')
        ifte.then(
          GL, '.enableVertexAttribArray(', i, ');',
          GL, '.bindBuffer(',
          GL_ARRAY_BUFFER$2, ',',
          BINDING, '.buffer.buffer);',
          GL, '.vertexAttribPointer(',
          i, ',',
          BINDING, '.size,',
          BINDING, '.type,',
          BINDING, '.normalized,',
          BINDING, '.stride,',
          BINDING, '.offset);'
        ).else(
          GL, '.disableVertexAttribArray(', i, ');',
          GL, '.vertexAttrib4f(',
          i, ',',
          BINDING, '.x,',
          BINDING, '.y,',
          BINDING, '.z,',
          BINDING, '.w);',
          BINDING, '.buffer=null;')
        refresh(ifte)
        if (extInstancing) {
          refresh(
            INSTANCING, '.vertexAttribDivisorANGLE(',
            i, ',',
            BINDING, '.divisor);')
        }
      }
      refresh(
        env.shared.vao, '.currentVAO=null;',
        env.shared.vao, '.setVAO(', env.shared.vao, '.targetVAO);')

      Object.keys(GL_FLAGS).forEach(function (flag) {
        var cap = GL_FLAGS[flag]
        var NEXT = common.def(NEXT_STATE, '.', flag)
        var block = env.block()
        block('if(', NEXT, '){',
          GL, '.enable(', cap, ')}else{',
          GL, '.disable(', cap, ')}',
          CURRENT_STATE, '.', flag, '=', NEXT, ';')
        refresh(block)
        poll(
          'if(', NEXT, '!==', CURRENT_STATE, '.', flag, '){',
          block,
          '}')
      })

      Object.keys(GL_VARIABLES).forEach(function (name) {
        var func = GL_VARIABLES[name]
        var init = currentState[name]
        var NEXT, CURRENT
        var block = env.block()
        block(GL, '.', func, '(')
        if (isArrayLike(init)) {
          var n = init.length
          NEXT = env.global.def(NEXT_STATE, '.', name)
          CURRENT = env.global.def(CURRENT_STATE, '.', name)
          block(
            loop(n, function (i) {
              return NEXT + '[' + i + ']'
            }), ');',
            loop(n, function (i) {
              return CURRENT + '[' + i + ']=' + NEXT + '[' + i + '];'
            }).join(''))
          poll(
            'if(', loop(n, function (i) {
              return NEXT + '[' + i + ']!==' + CURRENT + '[' + i + ']'
            }).join('||'), '){',
            block,
            '}')
        } else {
          NEXT = common.def(NEXT_STATE, '.', name)
          CURRENT = common.def(CURRENT_STATE, '.', name)
          block(
            NEXT, ');',
            CURRENT_STATE, '.', name, '=', NEXT, ';')
          poll(
            'if(', NEXT, '!==', CURRENT, '){',
            block,
            '}')
        }
        refresh(block)
      })

      return env.compile()
    })(),
    compile: compileCommand
  }
}

function stats () {
  return {
    vaoCount: 0,
    bufferCount: 0,
    elementsCount: 0,
    framebufferCount: 0,
    shaderCount: 0,
    textureCount: 0,
    cubeCount: 0,
    renderbufferCount: 0,
    maxTextureUnits: 0
  }
}

var GL_QUERY_RESULT_EXT = 0x8866
var GL_QUERY_RESULT_AVAILABLE_EXT = 0x8867
var GL_TIME_ELAPSED_EXT = 0x88BF

var createTimer = function (gl, extensions) {
  if (!extensions.ext_disjoint_timer_query) {
    return null
  }

  // QUERY POOL BEGIN
  var queryPool = []
  function allocQuery () {
    return queryPool.pop() || extensions.ext_disjoint_timer_query.createQueryEXT()
  }
  function freeQuery (query) {
    queryPool.push(query)
  }
  // QUERY POOL END

  var pendingQueries = []
  function beginQuery (stats) {
    var query = allocQuery()
    extensions.ext_disjoint_timer_query.beginQueryEXT(GL_TIME_ELAPSED_EXT, query)
    pendingQueries.push(query)
    pushScopeStats(pendingQueries.length - 1, pendingQueries.length, stats)
  }

  function endQuery () {
    extensions.ext_disjoint_timer_query.endQueryEXT(GL_TIME_ELAPSED_EXT)
  }

  //
  // Pending stats pool.
  //
  function PendingStats () {
    this.startQueryIndex = -1
    this.endQueryIndex = -1
    this.sum = 0
    this.stats = null
  }
  var pendingStatsPool = []
  function allocPendingStats () {
    return pendingStatsPool.pop() || new PendingStats()
  }
  function freePendingStats (pendingStats) {
    pendingStatsPool.push(pendingStats)
  }
  // Pending stats pool end

  var pendingStats = []
  function pushScopeStats (start, end, stats) {
    var ps = allocPendingStats()
    ps.startQueryIndex = start
    ps.endQueryIndex = end
    ps.sum = 0
    ps.stats = stats
    pendingStats.push(ps)
  }

  // we should call this at the beginning of the frame,
  // in order to update gpuTime
  var timeSum = []
  var queryPtr = []
  function update () {
    var ptr, i

    var n = pendingQueries.length
    if (n === 0) {
      return
    }

    // Reserve space
    queryPtr.length = Math.max(queryPtr.length, n + 1)
    timeSum.length = Math.max(timeSum.length, n + 1)
    timeSum[0] = 0
    queryPtr[0] = 0

    // Update all pending timer queries
    var queryTime = 0
    ptr = 0
    for (i = 0; i < pendingQueries.length; ++i) {
      var query = pendingQueries[i]
      if (extensions.ext_disjoint_timer_query.getQueryObjectEXT(query, GL_QUERY_RESULT_AVAILABLE_EXT)) {
        queryTime += extensions.ext_disjoint_timer_query.getQueryObjectEXT(query, GL_QUERY_RESULT_EXT)
        freeQuery(query)
      } else {
        pendingQueries[ptr++] = query
      }
      timeSum[i + 1] = queryTime
      queryPtr[i + 1] = ptr
    }
    pendingQueries.length = ptr

    // Update all pending stat queries
    ptr = 0
    for (i = 0; i < pendingStats.length; ++i) {
      var stats = pendingStats[i]
      var start = stats.startQueryIndex
      var end = stats.endQueryIndex
      stats.sum += timeSum[end] - timeSum[start]
      var startPtr = queryPtr[start]
      var endPtr = queryPtr[end]
      if (endPtr === startPtr) {
        stats.stats.gpuTime += stats.sum / 1e6
        freePendingStats(stats)
      } else {
        stats.startQueryIndex = startPtr
        stats.endQueryIndex = endPtr
        pendingStats[ptr++] = stats
      }
    }
    pendingStats.length = ptr
  }

  return {
    beginQuery: beginQuery,
    endQuery: endQuery,
    pushScopeStats: pushScopeStats,
    update: update,
    getNumPendingQueries: function () {
      return pendingQueries.length
    },
    clear: function () {
      queryPool.push.apply(queryPool, pendingQueries)
      for (var i = 0; i < queryPool.length; i++) {
        extensions.ext_disjoint_timer_query.deleteQueryEXT(queryPool[i])
      }
      pendingQueries.length = 0
      queryPool.length = 0
    },
    restore: function () {
      pendingQueries.length = 0
      queryPool.length = 0
    }
  }
}

var GL_COLOR_BUFFER_BIT = 16384
var GL_DEPTH_BUFFER_BIT = 256
var GL_STENCIL_BUFFER_BIT = 1024

var GL_ARRAY_BUFFER = 34962

var CONTEXT_LOST_EVENT = 'webglcontextlost'
var CONTEXT_RESTORED_EVENT = 'webglcontextrestored'

var DYN_PROP = 1
var DYN_CONTEXT = 2
var DYN_STATE = 3

function find (haystack, needle) {
  for (var i = 0; i < haystack.length; ++i) {
    if (haystack[i] === needle) {
      return i
    }
  }
  return -1
}

function wrapREGL (args) {
  var config = parseArgs(args)
  if (!config) {
    return null
  }

  var gl = config.gl
  var glAttributes = gl.getContextAttributes()
  var contextLost = gl.isContextLost()

  var extensionState = createExtensionCache(gl, config)
  if (!extensionState) {
    return null
  }

  var stringStore = createStringStore()
  var stats$$1 = stats()
  var extensions = extensionState.extensions
  var timer = createTimer(gl, extensions)

  var START_TIME = clock()
  var WIDTH = gl.drawingBufferWidth
  var HEIGHT = gl.drawingBufferHeight

  var contextState = {
    tick: 0,
    time: 0,
    viewportWidth: WIDTH,
    viewportHeight: HEIGHT,
    framebufferWidth: WIDTH,
    framebufferHeight: HEIGHT,
    drawingBufferWidth: WIDTH,
    drawingBufferHeight: HEIGHT,
    pixelRatio: config.pixelRatio
  }
  var uniformState = {}
  var drawState = {
    elements: null,
    primitive: 4, // GL_TRIANGLES
    count: -1,
    offset: 0,
    instances: -1
  }

  var limits = wrapLimits(gl, extensions)
  var bufferState = wrapBufferState(
    gl,
    stats$$1,
    config,
    destroyBuffer)
  var attributeState = wrapAttributeState(
    gl,
    extensions,
    limits,
    stats$$1,
    bufferState)
  function destroyBuffer (buffer) {
    return attributeState.destroyBuffer(buffer)
  }
  var elementState = wrapElementsState(gl, extensions, bufferState, stats$$1)
  var shaderState = wrapShaderState(gl, stringStore, stats$$1, config)
  var textureState = createTextureSet(
    gl,
    extensions,
    limits,
    function () { core.procs.poll() },
    contextState,
    stats$$1,
    config)
  var renderbufferState = wrapRenderbuffers(gl, extensions, limits, stats$$1, config)
  var framebufferState = wrapFBOState(
    gl,
    extensions,
    limits,
    textureState,
    renderbufferState,
    stats$$1)
  var core = reglCore(
    gl,
    stringStore,
    extensions,
    limits,
    bufferState,
    elementState,
    textureState,
    framebufferState,
    uniformState,
    attributeState,
    shaderState,
    drawState,
    contextState,
    timer,
    config)
  var readPixels = wrapReadPixels(
    gl,
    framebufferState,
    core.procs.poll,
    contextState,
    glAttributes, extensions, limits)

  var nextState = core.next
  var canvas = gl.canvas

  var rafCallbacks = []
  var lossCallbacks = []
  var restoreCallbacks = []
  var destroyCallbacks = [config.onDestroy]

  var activeRAF = null
  function handleRAF () {
    if (rafCallbacks.length === 0) {
      if (timer) {
        timer.update()
      }
      activeRAF = null
      return
    }

    // schedule next animation frame
    activeRAF = raf.next(handleRAF)

    // poll for changes
    poll()

    // fire a callback for all pending rafs
    for (var i = rafCallbacks.length - 1; i >= 0; --i) {
      var cb = rafCallbacks[i]
      if (cb) {
        cb(contextState, null, 0)
      }
    }

    // flush all pending webgl calls
    gl.flush()

    // poll GPU timers *after* gl.flush so we don't delay command dispatch
    if (timer) {
      timer.update()
    }
  }

  function startRAF () {
    if (!activeRAF && rafCallbacks.length > 0) {
      activeRAF = raf.next(handleRAF)
    }
  }

  function stopRAF () {
    if (activeRAF) {
      raf.cancel(handleRAF)
      activeRAF = null
    }
  }

  function handleContextLoss (event) {
    event.preventDefault()

    // set context lost flag
    contextLost = true

    // pause request animation frame
    stopRAF()

    // lose context
    lossCallbacks.forEach(function (cb) {
      cb()
    })
  }

  function handleContextRestored (event) {
    // clear error code
    gl.getError()

    // clear context lost flag
    contextLost = false

    // refresh state
    extensionState.restore()
    shaderState.restore()
    bufferState.restore()
    textureState.restore()
    renderbufferState.restore()
    framebufferState.restore()
    attributeState.restore()
    if (timer) {
      timer.restore()
    }

    // refresh state
    core.procs.refresh()

    // restart RAF
    startRAF()

    // restore context
    restoreCallbacks.forEach(function (cb) {
      cb()
    })
  }

  if (canvas) {
    canvas.addEventListener(CONTEXT_LOST_EVENT, handleContextLoss, false)
    canvas.addEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored, false)
  }

  function destroy () {
    rafCallbacks.length = 0
    stopRAF()

    if (canvas) {
      canvas.removeEventListener(CONTEXT_LOST_EVENT, handleContextLoss)
      canvas.removeEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored)
    }

    shaderState.clear()
    framebufferState.clear()
    renderbufferState.clear()
    textureState.clear()
    elementState.clear()
    bufferState.clear()
    attributeState.clear()

    if (timer) {
      timer.clear()
    }

    destroyCallbacks.forEach(function (cb) {
      cb()
    })
  }

  function compileProcedure (options) {
    check$1(!!options, 'invalid args to regl({...})')
    check$1.type(options, 'object', 'invalid args to regl({...})')

    function flattenNestedOptions (options) {
      var result = extend({}, options)
      delete result.uniforms
      delete result.attributes
      delete result.context
      delete result.vao

      if ('stencil' in result && result.stencil.op) {
        result.stencil.opBack = result.stencil.opFront = result.stencil.op
        delete result.stencil.op
      }

      function merge (name) {
        if (name in result) {
          var child = result[name]
          delete result[name]
          Object.keys(child).forEach(function (prop) {
            result[name + '.' + prop] = child[prop]
          })
        }
      }
      merge('blend')
      merge('depth')
      merge('cull')
      merge('stencil')
      merge('polygonOffset')
      merge('scissor')
      merge('sample')

      if ('vao' in options) {
        result.vao = options.vao
      }

      return result
    }

    function separateDynamic (object, useArrays) {
      var staticItems = {}
      var dynamicItems = {}
      Object.keys(object).forEach(function (option) {
        var value = object[option]
        if (dynamic.isDynamic(value)) {
          dynamicItems[option] = dynamic.unbox(value, option)
          return
        } else if (useArrays && Array.isArray(value)) {
          for (var i = 0; i < value.length; ++i) {
            if (dynamic.isDynamic(value[i])) {
              dynamicItems[option] = dynamic.unbox(value, option)
              return
            }
          }
        }
        staticItems[option] = value
      })
      return {
        dynamic: dynamicItems,
        static: staticItems
      }
    }

    // Treat context variables separate from other dynamic variables
    var context = separateDynamic(options.context || {}, true)
    var uniforms = separateDynamic(options.uniforms || {}, true)
    var attributes = separateDynamic(options.attributes || {}, false)
    var opts = separateDynamic(flattenNestedOptions(options), false)

    var stats$$1 = {
      gpuTime: 0.0,
      cpuTime: 0.0,
      count: 0
    }

    var compiled = core.compile(opts, attributes, uniforms, context, stats$$1)

    var draw = compiled.draw
    var batch = compiled.batch
    var scope = compiled.scope

    // FIXME: we should modify code generation for batch commands so this
    // isn't necessary
    var EMPTY_ARRAY = []
    function reserve (count) {
      while (EMPTY_ARRAY.length < count) {
        EMPTY_ARRAY.push(null)
      }
      return EMPTY_ARRAY
    }

    function REGLCommand (args, body) {
      var i
      if (contextLost) {
        check$1.raise('context lost')
      }
      if (typeof args === 'function') {
        return scope.call(this, null, args, 0)
      } else if (typeof body === 'function') {
        if (typeof args === 'number') {
          for (i = 0; i < args; ++i) {
            scope.call(this, null, body, i)
          }
        } else if (Array.isArray(args)) {
          for (i = 0; i < args.length; ++i) {
            scope.call(this, args[i], body, i)
          }
        } else {
          return scope.call(this, args, body, 0)
        }
      } else if (typeof args === 'number') {
        if (args > 0) {
          return batch.call(this, reserve(args | 0), args | 0)
        }
      } else if (Array.isArray(args)) {
        if (args.length) {
          return batch.call(this, args, args.length)
        }
      } else {
        return draw.call(this, args)
      }
    }

    return extend(REGLCommand, {
      stats: stats$$1,
      destroy: function () {
        compiled.destroy()
      }
    })
  }

  var setFBO = framebufferState.setFBO = compileProcedure({
    framebuffer: dynamic.define.call(null, DYN_PROP, 'framebuffer')
  })

  function clearImpl (_, options) {
    var clearFlags = 0
    core.procs.poll()

    var c = options.color
    if (c) {
      gl.clearColor(+c[0] || 0, +c[1] || 0, +c[2] || 0, +c[3] || 0)
      clearFlags |= GL_COLOR_BUFFER_BIT
    }
    if ('depth' in options) {
      gl.clearDepth(+options.depth)
      clearFlags |= GL_DEPTH_BUFFER_BIT
    }
    if ('stencil' in options) {
      gl.clearStencil(options.stencil | 0)
      clearFlags |= GL_STENCIL_BUFFER_BIT
    }

    check$1(!!clearFlags, 'called regl.clear with no buffer specified')
    gl.clear(clearFlags)
  }

  function clear (options) {
    check$1(
      typeof options === 'object' && options,
      'regl.clear() takes an object as input')
    if ('framebuffer' in options) {
      if (options.framebuffer &&
          options.framebuffer_reglType === 'framebufferCube') {
        for (var i = 0; i < 6; ++i) {
          setFBO(extend({
            framebuffer: options.framebuffer.faces[i]
          }, options), clearImpl)
        }
      } else {
        setFBO(options, clearImpl)
      }
    } else {
      clearImpl(null, options)
    }
  }

  function frame (cb) {
    check$1.type(cb, 'function', 'regl.frame() callback must be a function')
    rafCallbacks.push(cb)

    function cancel () {
      // FIXME:  should we check something other than equals cb here?
      // what if a user calls frame twice with the same callback...
      //
      var i = find(rafCallbacks, cb)
      check$1(i >= 0, 'cannot cancel a frame twice')
      function pendingCancel () {
        var index = find(rafCallbacks, pendingCancel)
        rafCallbacks[index] = rafCallbacks[rafCallbacks.length - 1]
        rafCallbacks.length -= 1
        if (rafCallbacks.length <= 0) {
          stopRAF()
        }
      }
      rafCallbacks[i] = pendingCancel
    }

    startRAF()

    return {
      cancel: cancel
    }
  }

  // poll viewport
  function pollViewport () {
    var viewport = nextState.viewport
    var scissorBox = nextState.scissor_box
    viewport[0] = viewport[1] = scissorBox[0] = scissorBox[1] = 0
    contextState.viewportWidth =
      contextState.framebufferWidth =
      contextState.drawingBufferWidth =
      viewport[2] =
      scissorBox[2] = gl.drawingBufferWidth
    contextState.viewportHeight =
      contextState.framebufferHeight =
      contextState.drawingBufferHeight =
      viewport[3] =
      scissorBox[3] = gl.drawingBufferHeight
  }

  function poll () {
    contextState.tick += 1
    contextState.time = now()
    pollViewport()
    core.procs.poll()
  }

  function refresh () {
    textureState.refresh()
    pollViewport()
    core.procs.refresh()
    if (timer) {
      timer.update()
    }
  }

  function now () {
    return (clock() - START_TIME) / 1000.0
  }

  refresh()

  function addListener (event, callback) {
    check$1.type(callback, 'function', 'listener callback must be a function')

    var callbacks
    switch (event) {
      case 'frame':
        return frame(callback)
      case 'lost':
        callbacks = lossCallbacks
        break
      case 'restore':
        callbacks = restoreCallbacks
        break
      case 'destroy':
        callbacks = destroyCallbacks
        break
      default:
        check$1.raise('invalid event, must be one of frame,lost,restore,destroy')
    }

    callbacks.push(callback)
    return {
      cancel: function () {
        for (var i = 0; i < callbacks.length; ++i) {
          if (callbacks[i] === callback) {
            callbacks[i] = callbacks[callbacks.length - 1]
            callbacks.pop()
            return
          }
        }
      }
    }
  }

  var regl = extend(compileProcedure, {
    // Clear current FBO
    clear: clear,

    // Short cuts for dynamic variables
    prop: dynamic.define.bind(null, DYN_PROP),
    context: dynamic.define.bind(null, DYN_CONTEXT),
    this: dynamic.define.bind(null, DYN_STATE),

    // executes an empty draw command
    draw: compileProcedure({}),

    // Resources
    buffer: function (options) {
      return bufferState.create(options, GL_ARRAY_BUFFER, false, false)
    },
    elements: function (options) {
      return elementState.create(options, false)
    },
    texture: textureState.create2D,
    cube: textureState.createCube,
    renderbuffer: renderbufferState.create,
    framebuffer: framebufferState.create,
    framebufferCube: framebufferState.createCube,
    vao: attributeState.createVAO,

    // Expose context attributes
    attributes: glAttributes,

    // Frame rendering
    frame: frame,
    on: addListener,

    // System limits
    limits: limits,
    hasExtension: function (name) {
      return limits.extensions.indexOf(name.toLowerCase()) >= 0
    },

    // Read pixels
    read: readPixels,

    // Destroy regl and all associated resources
    destroy: destroy,

    // Direct GL state manipulation
    _gl: gl,
    _refresh: refresh,

    poll: function () {
      poll()
      if (timer) {
        timer.update()
      }
    },

    // Current time
    now: now,

    // regl Statistics Information
    stats: stats$$1
  })

  config.onDone(null, regl)

  return regl
}

return wrapREGL;

})));
//# sourceMappingURL=regl.js.map


/***/ }),

/***/ "./css/designer.css":
/*!**************************!*\
  !*** ./css/designer.css ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_designer_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./designer.css */ "./node_modules/css-loader/dist/cjs.js!./css/designer.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_designer_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_designer_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_designer_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_designer_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {



var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {



var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;
  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}
module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ }),

/***/ "./src/designer/api/add-activity-node.ts":
/*!***********************************************!*\
  !*** ./src/designer/api/add-activity-node.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addActivityNode: () => (/* binding */ addActivityNode)
/* harmony export */ });
/* harmony import */ var _graph_bindings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graph-bindings */ "./src/designer/api/graph-bindings.ts");

async function addActivityNode(graphId, node) {
    // Get graph reference.
    const { graph } = _graph_bindings__WEBPACK_IMPORTED_MODULE_0__.graphBindings[graphId];
    // Convert the node coordinates from page to local.
    const { x, y } = graph.pageToLocal(node.position);
    node.position = { x, y };
    node.size = { width: 200, height: 50 };
    node.id = node.id;
    // Add the node to the graph.
    graph.addNode(node);
    graph.cleanSelection();
    graph.select(node.id);
}


/***/ }),

/***/ "./src/designer/api/auto-layout.ts":
/*!*****************************************!*\
  !*** ./src/designer/api/auto-layout.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   autoLayout: () => (/* binding */ autoLayout)
/* harmony export */ });
/* harmony import */ var _antv_layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/layout */ "./node_modules/@antv/layout/es/index.js");
/* harmony import */ var _load_graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./load-graph */ "./src/designer/api/load-graph.ts");
/* harmony import */ var _graph_bindings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./graph-bindings */ "./src/designer/api/graph-bindings.ts");



const dagreLayout = new _antv_layout__WEBPACK_IMPORTED_MODULE_0__.DagreLayout({
    type: 'dagre',
    rankdir: 'LR',
    align: 'DL',
    ranksep: 35,
    nodesep: 15,
});
async function autoLayout(graphId, data) {
    const { graph, interop } = _graph_bindings__WEBPACK_IMPORTED_MODULE_2__.graphBindings[graphId];
    const model = typeof data === 'string' ? JSON.parse(data) : data;
    const newModel = dagreLayout.layout(model);
    (0,_load_graph__WEBPACK_IMPORTED_MODULE_1__.loadGraph)(graphId, newModel);
    await interop.raiseGraphUpdated();
}


/***/ }),

/***/ "./src/designer/api/calculate-activity-size.ts":
/*!*****************************************************!*\
  !*** ./src/designer/api/calculate-activity-size.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   calculateActivitySize: () => (/* binding */ calculateActivitySize)
/* harmony export */ });
/* harmony import */ var _internal_create_activity_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal/create-activity-element */ "./src/designer/internal/create-activity-element.ts");

function calculateActivitySize(activity) {
    const wrapper = document.createElement('div');
    const dummyActivityElement = (0,_internal_create_activity_element__WEBPACK_IMPORTED_MODULE_0__.createActivityElement)(activity, true);
    wrapper.style.position = 'absolute';
    wrapper.appendChild(dummyActivityElement);
    // Append the temporary element to the DOM.
    const bodyElement = document.getElementsByTagName('body')[0];
    bodyElement.append(wrapper);
    // Wait for activity element to be completely rendered.
    // When using custom elements, they are rendered after they are mounted. Before then, they have a 0 width and height.
    return new Promise((resolve, reject) => {
        const checkSize = () => {
            const activityElement = wrapper.getElementsByTagName(_internal_create_activity_element__WEBPACK_IMPORTED_MODULE_0__.activityTagName)[0];
            const activityElementRect = activityElement.getBoundingClientRect();
            // If the custom element has no width or height yet, it means it has not yet rendered.
            if (activityElementRect.width == 0 || activityElementRect.height == 0) {
                // Request an animation frame and call ourselves back immediately after.
                window.requestAnimationFrame(checkSize);
            }
            else {
                const rect = wrapper.firstElementChild.getBoundingClientRect();
                const width = rect.width;
                const height = rect.height;
                // Remove the temporary element (used only to calculate its size).
                wrapper.remove();
                // Update size of the activity node and resolve the promise.
                resolve({ width, height });
            }
        };
        // Begin try to get our element size.
        checkSize();
    });
}


/***/ }),

/***/ "./src/designer/api/center-content.ts":
/*!********************************************!*\
  !*** ./src/designer/api/center-content.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   centerContent: () => (/* binding */ centerContent)
/* harmony export */ });
/* harmony import */ var _graph_bindings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graph-bindings */ "./src/designer/api/graph-bindings.ts");

function centerContent(graphId) {
    const { graph } = _graph_bindings__WEBPACK_IMPORTED_MODULE_0__.graphBindings[graphId];
    graph.centerContent({
        padding: 20,
        useCellGeometry: true
    });
}


/***/ }),

/***/ "./src/designer/api/create-graph.ts":
/*!******************************************!*\
  !*** ./src/designer/api/create-graph.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createGraph: () => (/* binding */ createGraph)
/* harmony export */ });
/* harmony import */ var _antv_x6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6 */ "./node_modules/@antv/x6/es/index.js");
/* harmony import */ var _antv_x6_plugin_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/x6-plugin-selection */ "./node_modules/@antv/x6-plugin-selection/es/index.js");
/* harmony import */ var _antv_x6_plugin_snapline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @antv/x6-plugin-snapline */ "./node_modules/@antv/x6-plugin-snapline/es/index.js");
/* harmony import */ var _antv_x6_plugin_transform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @antv/x6-plugin-transform */ "./node_modules/@antv/x6-plugin-transform/es/index.js");
/* harmony import */ var _antv_x6_plugin_keyboard__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @antv/x6-plugin-keyboard */ "./node_modules/@antv/x6-plugin-keyboard/es/index.js");
/* harmony import */ var _antv_x6_plugin_clipboard__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @antv/x6-plugin-clipboard */ "./node_modules/@antv/x6-plugin-clipboard/es/index.js");
/* harmony import */ var _antv_x6_plugin_history__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @antv/x6-plugin-history */ "./node_modules/@antv/x6-plugin-history/es/index.js");
/* harmony import */ var _graph_bindings__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./graph-bindings */ "./src/designer/api/graph-bindings.ts");
/* harmony import */ var _dotnet_flowchart_designer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./dotnet-flowchart-designer */ "./src/designer/api/dotnet-flowchart-designer.ts");









async function createGraph(containerId, componentRef, readOnly) {
    const containerElement = document.getElementById(containerId);
    const interop = new _dotnet_flowchart_designer__WEBPACK_IMPORTED_MODULE_8__.DotNetFlowchartDesigner(componentRef);
    let lastSelectedNode = null;
    const graph = new _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph({
        container: containerElement,
        autoResize: true,
        grid: {
            type: 'mesh',
            visible: true,
            size: 20,
            args: {
                color: '#f1f1f1',
                thickness: 1,
            }
        },
        magnetThreshold: 0,
        panning: {
            enabled: true,
        },
        mousewheel: {
            enabled: true,
            factor: 1.05,
            minScale: 0.4,
            maxScale: 3,
        },
        interacting: {
            nodeMovable: () => !readOnly,
            arrowheadMovable: () => !readOnly,
            edgeMovable: () => !readOnly,
            vertexMovable: () => !readOnly,
            vertexAddable: () => !readOnly,
            vertexDeletable: () => !readOnly,
            edgeLabelMovable: () => !readOnly,
            magnetConnectable: () => !readOnly,
            toolsAddable: () => !readOnly,
            useEdgeTools: () => !readOnly,
        },
        connecting: {
            router: 'manhattan',
            connector: {
                name: 'rounded',
                args: {
                    radius: 8,
                },
            },
            anchor: 'center',
            connectionPoint: 'anchor',
            allowBlank: false,
            snap: {
                radius: 20,
                anchor: "bbox"
            },
            createEdge() {
                return graph.createEdge({
                    shape: 'elsa-edge',
                    attrs: {
                        line: {
                            strokeDasharray: '5 5',
                        },
                    },
                    zIndex: -1,
                });
            },
            validateConnection({ sourceMagnet, targetMagnet }) {
                if (!sourceMagnet || sourceMagnet.getAttribute('port-group') === 'in') {
                    return false;
                }
                if (!targetMagnet || targetMagnet.getAttribute('port-group') !== 'in') {
                    return false;
                }
                return true;
            },
        },
        highlighting: {
            magnetAdsorbed: {
                name: 'stroke',
                args: {
                    attrs: {
                        fill: '#fff',
                        stroke: '#31d0c6',
                        strokeWidth: 4,
                    },
                },
            },
            embedding: {
                name: 'stroke',
                args: {
                    padding: -1,
                    attrs: {
                        stroke: '#73d13d',
                    },
                },
            },
        }
    });
    graph.use(new _antv_x6_plugin_history__WEBPACK_IMPORTED_MODULE_6__.History({
        enabled: true,
        beforeAddCommand: (e, args) => {
            if (args.key == 'tools')
                return false;
            const supportedEvents = ['cell:added', 'cell:removed', 'cell:change:*'];
            return supportedEvents.indexOf(e) >= 0;
        },
    }));
    graph.use(new _antv_x6_plugin_snapline__WEBPACK_IMPORTED_MODULE_2__.Snapline({
        enabled: true,
        className: 'elsa-snapline',
    }));
    graph.use(new _antv_x6_plugin_selection__WEBPACK_IMPORTED_MODULE_1__.Selection({
        enabled: true,
        multiple: !readOnly,
        modifiers: ['ctrl', 'shift'],
        rubberEdge: false,
        rubberNode: true,
        rubberband: true,
        movable: !readOnly,
        showNodeSelectionBox: true
    }));
    if (!readOnly) {
        graph.use(new _antv_x6_plugin_keyboard__WEBPACK_IMPORTED_MODULE_4__.Keyboard({
            enabled: true
        }));
        graph.use(new _antv_x6_plugin_clipboard__WEBPACK_IMPORTED_MODULE_5__.Clipboard({
            enabled: true,
        }));
        graph.use(new _antv_x6_plugin_transform__WEBPACK_IMPORTED_MODULE_3__.Transform({
            resizing: {
                enabled: true,
            }
        }));
        // Copy the cells in the graph to the internal clipboard with Ctrl+C.
        graph.bindKey(['ctrl+c', 'meta+c'], () => {
            const cells = graph.getSelectedCells();
            if (cells.length) {
                graph.copy(cells);
            }
            return false;
        });
        graph.bindKey(['meta+x', 'ctrl+x'], () => {
            const cells = graph.getSelectedCells();
            if (cells.length) {
                graph.cut(cells);
            }
            return false;
        });
        // Paste
        graph.bindKey(['ctrl+v', 'meta+v'], () => {
            if (!graph.isClipboardEmpty()) {
                const cells = graph.getCellsInClipboard();
                if (cells.length == 0)
                    return;
                const activityCells = cells.filter(x => x.shape == 'elsa-activity');
                const edgeCells = cells.filter(x => x.shape == 'elsa-edge');
                interop.raisePasteCellsRequested(activityCells, edgeCells);
            }
            return false;
        });
        // Undo
        graph.bindKey(['meta+z', 'ctrl+z'], () => {
            if (graph.canUndo()) {
                graph.undo();
            }
            return false;
        });
        // Redo
        graph.bindKey(['meta+y', 'ctrl+y'], () => {
            if (graph.canRedo()) {
                graph.redo();
            }
            return false;
        });
        // Delete
        graph.bindKey('del', () => {
            const cells = graph.getSelectedCells();
            if (cells.length) {
                graph.removeCells(cells);
            }
            return false;
        });
    }
    // Select all
    graph.bindKey(['meta+a', 'ctrl+a'], () => {
        const nodes = graph.getNodes();
        if (nodes) {
            graph.select(nodes);
        }
        return false;
    });
    // zoom
    graph.bindKey(['ctrl+1', 'meta+1'], () => {
        const zoom = graph.zoom();
        if (zoom < 1.5) {
            graph.zoom(0.1);
        }
        return false;
    });
    graph.bindKey(['ctrl+2', 'meta+2'], () => {
        const zoom = graph.zoom();
        if (zoom > 0.5) {
            graph.zoom(-0.1);
        }
        return false;
    });
    graph.on('blank:click', async () => {
        if (!!lastSelectedNode) {
            lastSelectedNode.setProp('selected-port', null);
        }
        await interop.raiseCanvasSelected();
        return false;
    });
    // Move the clicked node to the front. This helps when the user clicks on a node that is behind another node.
    graph.on('node:mousedown', ({ node }) => {
        node.toFront();
        return false;
    });
    // Change the edge's color and style when it is connected to a magnet.
    graph.on('edge:connected', ({ edge }) => {
        edge.attr({
            line: {
                strokeDasharray: '',
            },
        });
        return false;
    });
    graph.on("edge:mouseenter", ({ cell }) => {
        cell.addTools([
            { name: "vertices" },
            {
                name: "button-remove",
                args: { distance: 20 },
            },
        ]);
        return false;
    });
    graph.on("edge:mouseleave", ({ cell }) => {
        if (cell.hasTool("button-remove")) {
            cell.removeTool("button-remove");
        }
        return false;
    });
    graph.on('node:click', async (args) => {
        const { e, node } = args;
        const activity = node.data;
        const activityId = activity.id;
        const activityElementId = `activity-${activityId}`;
        const activityElement = document.getElementById(activityElementId);
        const embeddedPortElements = activityElement.querySelectorAll('.embedded-port');
        const mousePosition = graph.clientToLocal(e.clientX, e.clientY);
        // Check which of the embedded ports intersect with the selected node.
        for (let i = 0; i < embeddedPortElements.length; i++) {
            const embeddedPortElement = embeddedPortElements[i];
            const embeddedPortElementRect = embeddedPortElement.getBoundingClientRect();
            const embeddedPortElementBBox = graph.pageToLocal(embeddedPortElementRect);
            if (!embeddedPortElementBBox.containsPoint(mousePosition))
                continue;
            // Mark the node as unselected.
            if (graph.isSelected(node)) {
                graph.unselect(node);
            }
            const embeddedPortName = embeddedPortElement.getAttribute('data-port-name');
            node.setProp('selected-port', embeddedPortName);
            lastSelectedNode = node;
            await interop.raiseActivityEmbeddedPortSelected(activity, embeddedPortName);
            return;
        }
        if (!graph.isSelected(node)) {
            graph.select(node);
        }
        node.setProp('selected-port', null);
        await interop.raiseActivitySelected(activity);
        return false;
    });
    graph.on('node:dblclick', async (args) => {
        const { e, node } = args;
        const activity = node.data;
        await interop.raiseActivityDoubleClick(activity);
    });
    const onGraphUpdated = async (e) => {
        await interop.raiseGraphUpdated();
        return false;
    };
    const onNodeRemoved = async (e) => {
        await onGraphUpdated(e);
        return false;
    };
    const onNodeAdded = async (e) => {
        await onGraphUpdated(e);
        return false;
    };
    graph.on('node:moved', onGraphUpdated);
    graph.on('node:added', onNodeAdded);
    graph.on('node:removed', onNodeRemoved);
    graph.on('node:change:size', onGraphUpdated);
    graph.on('edge:removed', onGraphUpdated);
    graph.on('edge:connected', onGraphUpdated);
    graph.on('edge:vertexs:added', onGraphUpdated);
    graph.on('edge:vertexs:removed', onGraphUpdated);
    // Register the graph.
    const graphId = containerId;
    _graph_bindings__WEBPACK_IMPORTED_MODULE_7__.graphBindings[graphId] = {
        graphId: graphId,
        graph: graph,
        interop: interop
    };
    return graphId;
}


/***/ }),

/***/ "./src/designer/api/dispose-graph.ts":
/*!*******************************************!*\
  !*** ./src/designer/api/dispose-graph.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   disposeGraph: () => (/* binding */ disposeGraph)
/* harmony export */ });
/* harmony import */ var _graph_bindings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graph-bindings */ "./src/designer/api/graph-bindings.ts");

function disposeGraph(graphId) {
    delete _graph_bindings__WEBPACK_IMPORTED_MODULE_0__.graphBindings[graphId];
}


/***/ }),

/***/ "./src/designer/api/dotnet-flowchart-designer.ts":
/*!*******************************************************!*\
  !*** ./src/designer/api/dotnet-flowchart-designer.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DotNetFlowchartDesigner: () => (/* binding */ DotNetFlowchartDesigner)
/* harmony export */ });
class DotNetFlowchartDesigner {
    componentRef;
    constructor(componentRef) {
        this.componentRef = componentRef;
    }
    /// <summary>
    /// Raises the <see cref="ActivitySelected"/> event.
    /// </summary>
    async raiseActivitySelected(activity) {
        console.debug('ActivitySelected');
        await this.componentRef.invokeMethodAsync('HandleActivitySelected', activity);
    }
    /// <summary>
    /// Raises the <see cref="ActivitySelected"/> event.
    /// </summary>
    async raiseActivityEmbeddedPortSelected(activity, portName) {
        console.debug('ActivityEmbeddedPortSelected');
        await this.componentRef.invokeMethodAsync('HandleActivityEmbeddedPortSelected', activity, portName);
    }
    /// <summary>
    /// Raises the <see cref="ActivityDoubleClick"/> event.
    /// </summary>
    async raiseActivityDoubleClick(activity) {
        console.debug('ActivityDoubleClick');
        await this.componentRef.invokeMethodAsync('HandleActivityDoubleClick', activity);
    }
    /// <summary>
    /// Raises the <see cref="CanvasSelected"/> event.
    /// </summary>
    async raiseCanvasSelected() {
        console.debug('CanvasSelected');
        await this.componentRef.invokeMethodAsync('HandleCanvasSelected');
    }
    /// <summary>
    /// Raises the <see cref="GraphUpdated"/> event.
    /// </summary>
    async raiseGraphUpdated() {
        console.debug('GraphUpdated');
        await this.componentRef.invokeMethodAsync('HandleGraphUpdated');
    }
    /// <summary>
    /// Raises the <see cref="PasteCellsRequested"/> event.
    /// </summary>
    async raisePasteCellsRequested(activityCells, edgeCells) {
        console.debug('PasteCellsRequested');
        await this.componentRef.invokeMethodAsync('HandlePasteCellsRequested', activityCells, edgeCells);
    }
}


/***/ }),

/***/ "./src/designer/api/graph-bindings.ts":
/*!********************************************!*\
  !*** ./src/designer/api/graph-bindings.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   graphBindings: () => (/* binding */ graphBindings)
/* harmony export */ });
// This is a global dictionary that is used to store graph instances.
const graphBindings = {};


/***/ }),

/***/ "./src/designer/api/index.ts":
/*!***********************************!*\
  !*** ./src/designer/api/index.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DotNetFlowchartDesigner: () => (/* reexport safe */ _dotnet_flowchart_designer__WEBPACK_IMPORTED_MODULE_18__.DotNetFlowchartDesigner),
/* harmony export */   addActivityNode: () => (/* reexport safe */ _add_activity_node__WEBPACK_IMPORTED_MODULE_0__.addActivityNode),
/* harmony export */   autoLayout: () => (/* reexport safe */ _auto_layout__WEBPACK_IMPORTED_MODULE_17__.autoLayout),
/* harmony export */   calculateActivitySize: () => (/* reexport safe */ _calculate_activity_size__WEBPACK_IMPORTED_MODULE_1__.calculateActivitySize),
/* harmony export */   centerContent: () => (/* reexport safe */ _center_content__WEBPACK_IMPORTED_MODULE_2__.centerContent),
/* harmony export */   createGraph: () => (/* reexport safe */ _create_graph__WEBPACK_IMPORTED_MODULE_3__.createGraph),
/* harmony export */   disposeGraph: () => (/* reexport safe */ _dispose_graph__WEBPACK_IMPORTED_MODULE_4__.disposeGraph),
/* harmony export */   graphBindings: () => (/* reexport safe */ _graph_bindings__WEBPACK_IMPORTED_MODULE_5__.graphBindings),
/* harmony export */   loadGraph: () => (/* reexport safe */ _load_graph__WEBPACK_IMPORTED_MODULE_6__.loadGraph),
/* harmony export */   pasteCells: () => (/* reexport safe */ _paste_cells__WEBPACK_IMPORTED_MODULE_7__.pasteCells),
/* harmony export */   raiseActivityEmbeddedPortSelected: () => (/* reexport safe */ _raise_activity_embedded_port_selected__WEBPACK_IMPORTED_MODULE_10__.raiseActivityEmbeddedPortSelected),
/* harmony export */   raiseActivitySelected: () => (/* reexport safe */ _raise_activity_selected__WEBPACK_IMPORTED_MODULE_9__.raiseActivitySelected),
/* harmony export */   readGraph: () => (/* reexport safe */ _read_graph__WEBPACK_IMPORTED_MODULE_8__.readGraph),
/* harmony export */   selectActivity: () => (/* reexport safe */ _select_activity__WEBPACK_IMPORTED_MODULE_11__.selectActivity),
/* harmony export */   setGridColor: () => (/* reexport safe */ _set_grid_color__WEBPACK_IMPORTED_MODULE_12__.setGridColor),
/* harmony export */   updateActivity: () => (/* reexport safe */ _update_activity__WEBPACK_IMPORTED_MODULE_13__.updateActivity),
/* harmony export */   updateActivitySize: () => (/* reexport safe */ _update_activity_size__WEBPACK_IMPORTED_MODULE_14__.updateActivitySize),
/* harmony export */   updateActivityStats: () => (/* reexport safe */ _update_activity_stats__WEBPACK_IMPORTED_MODULE_15__.updateActivityStats),
/* harmony export */   zoomToFit: () => (/* reexport safe */ _zoom_to_fit__WEBPACK_IMPORTED_MODULE_16__.zoomToFit)
/* harmony export */ });
/* harmony import */ var _add_activity_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./add-activity-node */ "./src/designer/api/add-activity-node.ts");
/* harmony import */ var _calculate_activity_size__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./calculate-activity-size */ "./src/designer/api/calculate-activity-size.ts");
/* harmony import */ var _center_content__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./center-content */ "./src/designer/api/center-content.ts");
/* harmony import */ var _create_graph__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./create-graph */ "./src/designer/api/create-graph.ts");
/* harmony import */ var _dispose_graph__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dispose-graph */ "./src/designer/api/dispose-graph.ts");
/* harmony import */ var _graph_bindings__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./graph-bindings */ "./src/designer/api/graph-bindings.ts");
/* harmony import */ var _load_graph__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./load-graph */ "./src/designer/api/load-graph.ts");
/* harmony import */ var _paste_cells__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./paste-cells */ "./src/designer/api/paste-cells.ts");
/* harmony import */ var _read_graph__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./read-graph */ "./src/designer/api/read-graph.ts");
/* harmony import */ var _raise_activity_selected__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./raise-activity-selected */ "./src/designer/api/raise-activity-selected.ts");
/* harmony import */ var _raise_activity_embedded_port_selected__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./raise-activity-embedded-port-selected */ "./src/designer/api/raise-activity-embedded-port-selected.ts");
/* harmony import */ var _select_activity__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./select-activity */ "./src/designer/api/select-activity.ts");
/* harmony import */ var _set_grid_color__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./set-grid-color */ "./src/designer/api/set-grid-color.ts");
/* harmony import */ var _update_activity__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./update-activity */ "./src/designer/api/update-activity.ts");
/* harmony import */ var _update_activity_size__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./update-activity-size */ "./src/designer/api/update-activity-size.ts");
/* harmony import */ var _update_activity_stats__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./update-activity-stats */ "./src/designer/api/update-activity-stats.ts");
/* harmony import */ var _zoom_to_fit__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./zoom-to-fit */ "./src/designer/api/zoom-to-fit.ts");
/* harmony import */ var _auto_layout__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./auto-layout */ "./src/designer/api/auto-layout.ts");
/* harmony import */ var _dotnet_flowchart_designer__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./dotnet-flowchart-designer */ "./src/designer/api/dotnet-flowchart-designer.ts");





















/***/ }),

/***/ "./src/designer/api/load-graph.ts":
/*!****************************************!*\
  !*** ./src/designer/api/load-graph.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   loadGraph: () => (/* binding */ loadGraph)
/* harmony export */ });
/* harmony import */ var _graph_bindings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graph-bindings */ "./src/designer/api/graph-bindings.ts");

function loadGraph(graphId, data) {
    const { graph } = _graph_bindings__WEBPACK_IMPORTED_MODULE_0__.graphBindings[graphId];
    const model = typeof data === 'string' ? JSON.parse(data) : data;
    graph.fromJSON(model);
    graph.centerContent({ padding: 20 });
}


/***/ }),

/***/ "./src/designer/api/paste-cells.ts":
/*!*****************************************!*\
  !*** ./src/designer/api/paste-cells.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   pasteCells: () => (/* binding */ pasteCells)
/* harmony export */ });
/* harmony import */ var _graph_bindings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graph-bindings */ "./src/designer/api/graph-bindings.ts");

async function pasteCells(graphId, nodeProps, edgeProps) {
    // Get graph reference.
    const { graph } = _graph_bindings__WEBPACK_IMPORTED_MODULE_0__.graphBindings[graphId];
    // Create nodes and edges from node props and edge props.
    const nodes = nodeProps.map(x => graph.createNode(x));
    const edges = edgeProps.map(x => graph.createEdge(x));
    // Add the nodes and edges to the graph.
    graph.addCell(nodes);
    graph.addCell(edges);
    // Wait for the new cells to be rendered.
    requestAnimationFrame(() => {
        graph.cleanSelection();
        graph.select([...nodes, ...edges]);
    });
}


/***/ }),

/***/ "./src/designer/api/raise-activity-embedded-port-selected.ts":
/*!*******************************************************************!*\
  !*** ./src/designer/api/raise-activity-embedded-port-selected.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   raiseActivityEmbeddedPortSelected: () => (/* binding */ raiseActivityEmbeddedPortSelected)
/* harmony export */ });
/* harmony import */ var _graph_bindings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graph-bindings */ "./src/designer/api/graph-bindings.ts");

async function raiseActivityEmbeddedPortSelected(elementId, activityModel, portName) {
    // Get wrapper element.
    const wrapper = document.getElementById(elementId);
    // Get container element.
    const container = wrapper.closest('.graph-container');
    // Get graph ID.
    const graphId = container.id;
    // Get graph reference.
    const { interop } = _graph_bindings__WEBPACK_IMPORTED_MODULE_0__.graphBindings[graphId];
    // Parse activity model.
    const activity = typeof activityModel === 'string' ? JSON.parse(activityModel) : activityModel;
    await interop.raiseActivityEmbeddedPortSelected(activity, portName);
}


/***/ }),

/***/ "./src/designer/api/raise-activity-selected.ts":
/*!*****************************************************!*\
  !*** ./src/designer/api/raise-activity-selected.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   raiseActivitySelected: () => (/* binding */ raiseActivitySelected)
/* harmony export */ });
/* harmony import */ var _graph_bindings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graph-bindings */ "./src/designer/api/graph-bindings.ts");

async function raiseActivitySelected(elementId, activityModel) {
    // Get wrapper element.
    const wrapper = document.getElementById(elementId);
    // Get container element.
    const container = wrapper.closest('.graph-container');
    // Get graph ID.
    const graphId = container.id;
    // Get graph reference.
    const { interop } = _graph_bindings__WEBPACK_IMPORTED_MODULE_0__.graphBindings[graphId];
    // Parse activity model.
    // Parse activity model.
    const activity = typeof activityModel === 'string' ? JSON.parse(activityModel) : activityModel;
    await interop.raiseActivitySelected(activity);
}


/***/ }),

/***/ "./src/designer/api/read-graph.ts":
/*!****************************************!*\
  !*** ./src/designer/api/read-graph.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   readGraph: () => (/* binding */ readGraph)
/* harmony export */ });
/* harmony import */ var _graph_bindings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graph-bindings */ "./src/designer/api/graph-bindings.ts");

function readGraph(graphId) {
    const { graph } = _graph_bindings__WEBPACK_IMPORTED_MODULE_0__.graphBindings[graphId];
    const model = graph.toJSON();
    // Filter out edges that don't have both a star and end node.
    model.cells = model.cells.filter((cell) => {
        if (cell.shape == 'elsa-activity')
            return true;
        if (cell.shape == 'elsa-edge') {
            const edge = cell;
            if (!!edge.source?.cell && !!edge.target?.cell)
                return true;
        }
        return false;
    });
    return model;
}


/***/ }),

/***/ "./src/designer/api/select-activity.ts":
/*!*********************************************!*\
  !*** ./src/designer/api/select-activity.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   selectActivity: () => (/* binding */ selectActivity)
/* harmony export */ });
/* harmony import */ var _graph_bindings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graph-bindings */ "./src/designer/api/graph-bindings.ts");

async function selectActivity(elementId, activityId) {
    // Get wrapper element.
    const wrapper = document.getElementById(elementId);
    if (wrapper == null) {
        console.warn(`Could not find wrapper element with ID ${elementId}`);
        return;
    }
    // Get container element.
    const container = wrapper.closest('.graph-container');
    // Get graph ID.
    const graphId = container.id;
    // Get graph reference.
    const { graph } = _graph_bindings__WEBPACK_IMPORTED_MODULE_0__.graphBindings[graphId];
    // Get activity node.
    const node = graph.getNodes().find(x => x.id == activityId);
    if (node == null) {
        console.warn(`Could not find node with ID ${activityId} in graph ${graphId}`);
        return;
    }
    // Select the node.
    graph.select(node);
    // Center the selected node.
    graph.centerCell(node);
}


/***/ }),

/***/ "./src/designer/api/set-grid-color.ts":
/*!********************************************!*\
  !*** ./src/designer/api/set-grid-color.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   setGridColor: () => (/* binding */ setGridColor)
/* harmony export */ });
/* harmony import */ var _graph_bindings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graph-bindings */ "./src/designer/api/graph-bindings.ts");

function setGridColor(graphId, color) {
    const { graph } = _graph_bindings__WEBPACK_IMPORTED_MODULE_0__.graphBindings[graphId];
    graph.grid.update({ color: color });
}


/***/ }),

/***/ "./src/designer/api/update-activity-size.ts":
/*!**************************************************!*\
  !*** ./src/designer/api/update-activity-size.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   updateActivitySize: () => (/* binding */ updateActivitySize)
/* harmony export */ });
/* harmony import */ var _calculate_activity_size__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./calculate-activity-size */ "./src/designer/api/calculate-activity-size.ts");
/* harmony import */ var _graph_bindings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./graph-bindings */ "./src/designer/api/graph-bindings.ts");


async function updateActivitySize(elementId, activityModel, size) {
    // Get wrapper element.
    const wrapper = document.getElementById(elementId);
    if (wrapper == null) {
        console.warn(`Could not find wrapper element with ID ${elementId}`);
        return;
    }
    // Get container element.
    const container = wrapper.closest('.graph-container');
    // Get graph ID.
    const graphId = container.id;
    // Get graph reference.
    const { graph } = _graph_bindings__WEBPACK_IMPORTED_MODULE_1__.graphBindings[graphId];
    // Parse activity model.
    const activity = typeof activityModel === 'string' ? JSON.parse(activityModel) : activityModel;
    // Calculate the size of the activity.
    const rect = await (0,_calculate_activity_size__WEBPACK_IMPORTED_MODULE_0__.calculateActivitySize)(activity);
    let width = rect.width;
    let height = rect.height;
    // Get the node from the graph and update its size.
    const activityId = activity.id;
    const node = graph.getNodes().find(x => x.id == activityId);
    if (node == null) {
        console.warn(`Could not find node with ID ${activityId} in graph ${graphId}`);
        return;
    }
    if (!!size) {
        if (size.width > width)
            width = size.width;
        if (size.height > height)
            height = size.height;
    }
    node.size(width, height);
}


/***/ }),

/***/ "./src/designer/api/update-activity-stats.ts":
/*!***************************************************!*\
  !*** ./src/designer/api/update-activity-stats.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   updateActivityStats: () => (/* binding */ updateActivityStats)
/* harmony export */ });
/* harmony import */ var _graph_bindings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graph-bindings */ "./src/designer/api/graph-bindings.ts");

async function updateActivityStats(elementId, activityId, activityStats) {
    // Get wrapper element.
    const wrapper = document.getElementById(elementId);
    if (wrapper == null) {
        console.warn(`Could not find wrapper element with ID ${elementId}`);
        return;
    }
    // Get container element.
    const container = wrapper.closest('.graph-container');
    // Get graph ID.
    const graphId = container.id;
    // Get graph reference.
    const { graph } = _graph_bindings__WEBPACK_IMPORTED_MODULE_0__.graphBindings[graphId];
    // Get the node from the graph and update its size.
    const node = graph.getNodes().find(x => x.id == activityId);
    if (node == null) {
        console.warn(`Could not find node with ID ${activityId} in graph ${graphId}`);
        return;
    }
    node.setProp('activityStats', activityStats);
}


/***/ }),

/***/ "./src/designer/api/update-activity.ts":
/*!*********************************************!*\
  !*** ./src/designer/api/update-activity.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   updateActivity: () => (/* binding */ updateActivity)
/* harmony export */ });
/* harmony import */ var _graph_bindings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graph-bindings */ "./src/designer/api/graph-bindings.ts");

async function updateActivity(graphId, activity, ports) {
    // Get graph reference.
    const { graph, interop } = _graph_bindings__WEBPACK_IMPORTED_MODULE_0__.graphBindings[graphId];
    // Get the node from the graph.
    const activityId = activity.id;
    let node = graph.getNodes().find(x => x.id == activityId);
    // Update the node data.
    if (!!node) {
        // Update the node's data with the activity.
        node.setData(activity, { overwrite: true });
        // Update ports.
        if (!!ports) {
            updatePorts(node, ports);
        }
        // Publish changed event.
        await interop.raiseGraphUpdated();
    }
}
const updatePorts = (node, ports) => {
    const desiredPorts = ports.items;
    const actualPorts = node.ports.items;
    const addedPorts = desiredPorts.filter(x => !actualPorts.some(y => y.id == x.id));
    const removedPorts = actualPorts.filter(x => !desiredPorts.some(y => y.id == x.id));
    if (addedPorts.length > 0)
        node.addPorts(addedPorts);
    if (removedPorts.length > 0)
        node.removePorts(removedPorts);
};


/***/ }),

/***/ "./src/designer/api/zoom-to-fit.ts":
/*!*****************************************!*\
  !*** ./src/designer/api/zoom-to-fit.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   zoomToFit: () => (/* binding */ zoomToFit)
/* harmony export */ });
/* harmony import */ var _graph_bindings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graph-bindings */ "./src/designer/api/graph-bindings.ts");

function zoomToFit(graphId) {
    const { graph } = _graph_bindings__WEBPACK_IMPORTED_MODULE_0__.graphBindings[graphId];
    graph.zoomToFit({
        padding: 20,
        minScale: 0.5,
        maxScale: 3
    });
}


/***/ }),

/***/ "./src/designer/internal/create-activity-element.ts":
/*!**********************************************************!*\
  !*** ./src/designer/internal/create-activity-element.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   activityTagName: () => (/* binding */ activityTagName),
/* harmony export */   createActivityElement: () => (/* binding */ createActivityElement)
/* harmony export */ });
const activityTagName = "elsa-activity-wrapper";
function createActivityElement(activity, detached, selectedPort, stats) {
    const activityElement = document.createElement(activityTagName);
    const activityId = activity.id;
    const elementId = `activity-${activityId}`;
    if (!detached) {
        activityElement.id = elementId;
        activityElement.setAttribute("element-id", elementId);
    }
    if (!!selectedPort)
        activityElement.setAttribute("selected-port-name", selectedPort);
    activityElement.stats = stats;
    //activityElement.activity = activity; // activity can be too deeply nested when dealing with workflow definition activities, exceeding the max depth of 32 with JSInterop.
    activityElement.setAttribute("activity-json", JSON.stringify(activity));
    activityElement.setAttribute("activity-id", activityId);
    return activityElement;
}


/***/ }),

/***/ "./src/designer/internal/init.ts":
/*!***************************************!*\
  !*** ./src/designer/internal/init.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   initialize: () => (/* binding */ initialize)
/* harmony export */ });
/* harmony import */ var _antv_x6__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/x6 */ "./node_modules/@antv/x6/es/index.js");
/* harmony import */ var _create_activity_element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./create-activity-element */ "./src/designer/internal/create-activity-element.ts");


function initialize() {
    _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Shape.HTML.register({
        shape: "elsa-activity",
        effect: ["data", "activityStats"],
        html(cell) {
            const activity = cell.getData();
            const selectedPort = cell.prop('selected-port');
            const activityStats = cell.prop('activityStats');
            return (0,_create_activity_element__WEBPACK_IMPORTED_MODULE_1__.createActivityElement)(activity, false, selectedPort, activityStats);
        },
        ports: {
            groups: {
                in: {
                    position: "left",
                    attrs: {
                        circle: {
                            r: 5,
                            magnet: true,
                            stroke: "#0ea5e9",
                            strokeWidth: 2,
                            fill: "#fff",
                        },
                        text: {
                            fontSize: 12,
                            fill: "#888",
                        },
                    },
                    label: {
                        position: {
                            name: "outside",
                        },
                    },
                },
                out: {
                    position: "right",
                    attrs: {
                        circle: {
                            r: 5,
                            magnet: true,
                            stroke: "#fff",
                            strokeWidth: 2,
                            fill: "#0ea5e9",
                        },
                        text: {
                            fontSize: 12,
                            fill: "#888",
                        },
                    },
                    label: {
                        position: {
                            name: "outside",
                        },
                    },
                },
            },
        }
    });
    _antv_x6__WEBPACK_IMPORTED_MODULE_0__.Graph.registerEdge('elsa-edge', {
        inherit: 'edge',
        attrs: {
            line: {
                stroke: '#C2C8D5',
                strokeWidth: 1,
                targetMarker: 'classic',
                size: 6,
            },
        },
    }, true);
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/regeneratorRuntime.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/regeneratorRuntime.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _typeof = (__webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/typeof.js")["default"]);
function _regeneratorRuntime() {
  "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
    return e;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function define(t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function value(t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(_typeof(e) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function stop() {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function complete(t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function finish(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    "catch": function _catch(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/***/ ((module) => {

function _typeof(o) {
  "@babel/helpers - typeof";

  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(o);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// TODO(Babel 8): Remove this file.

var runtime = __webpack_require__(/*! ../helpers/regeneratorRuntime */ "./node_modules/@babel/runtime/helpers/regeneratorRuntime.js")();
module.exports = runtime;

// Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=
try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _arrayLikeToArray)
/* harmony export */ });
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _arrayWithoutHoles)
/* harmony export */ });
/* harmony import */ var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(r);
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _asyncToGenerator)
/* harmony export */ });
function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c),
      u = i.value;
  } catch (n) {
    return void e(n);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function () {
    var t = this,
      e = arguments;
    return new Promise(function (r, o) {
      var a = n.apply(t, e);
      function _next(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
      }
      function _throw(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
      }
      _next(void 0);
    });
  };
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _classCallCheck)
/* harmony export */ });
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/createClass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/createClass.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _createClass)
/* harmony export */ });
/* harmony import */ var _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toPropertyKey.js */ "./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js");

function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, (0,_toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__["default"])(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _defineProperty)
/* harmony export */ });
/* harmony import */ var _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toPropertyKey.js */ "./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js");

function _defineProperty(e, r, t) {
  return (r = (0,_toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__["default"])(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/iterableToArray.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _iterableToArray)
/* harmony export */ });
function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _nonIterableSpread)
/* harmony export */ });
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _toConsumableArray)
/* harmony export */ });
/* harmony import */ var _arrayWithoutHoles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayWithoutHoles.js */ "./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js");
/* harmony import */ var _iterableToArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterableToArray.js */ "./node_modules/@babel/runtime/helpers/esm/iterableToArray.js");
/* harmony import */ var _unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./unsupportedIterableToArray.js */ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");
/* harmony import */ var _nonIterableSpread_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nonIterableSpread.js */ "./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js");




function _toConsumableArray(r) {
  return (0,_arrayWithoutHoles_js__WEBPACK_IMPORTED_MODULE_0__["default"])(r) || (0,_iterableToArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(r) || (0,_unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(r) || (0,_nonIterableSpread_js__WEBPACK_IMPORTED_MODULE_3__["default"])();
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toPrimitive.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toPrimitive.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toPrimitive)
/* harmony export */ });
/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/esm/typeof.js");

function toPrimitive(t, r) {
  if ("object" != (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__["default"])(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__["default"])(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toPropertyKey)
/* harmony export */ });
/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/esm/typeof.js");
/* harmony import */ var _toPrimitive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toPrimitive.js */ "./node_modules/@babel/runtime/helpers/esm/toPrimitive.js");


function toPropertyKey(t) {
  var i = (0,_toPrimitive_js__WEBPACK_IMPORTED_MODULE_1__["default"])(t, "string");
  return "symbol" == (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__["default"])(i) ? i : i + "";
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/typeof.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/typeof.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _typeof)
/* harmony export */ });
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _unsupportedIterableToArray)
/* harmony export */ });
/* harmony import */ var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(r, a) : void 0;
  }
}


/***/ }),

/***/ "./node_modules/lodash-es/_DataView.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_DataView.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getNative.js */ "./node_modules/lodash-es/_getNative.js");
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");



/* Built-in method references that are verified to be native. */
var DataView = (0,_getNative_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_root_js__WEBPACK_IMPORTED_MODULE_1__["default"], 'DataView');

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DataView);


/***/ }),

/***/ "./node_modules/lodash-es/_Hash.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/_Hash.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _hashClear_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_hashClear.js */ "./node_modules/lodash-es/_hashClear.js");
/* harmony import */ var _hashDelete_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_hashDelete.js */ "./node_modules/lodash-es/_hashDelete.js");
/* harmony import */ var _hashGet_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_hashGet.js */ "./node_modules/lodash-es/_hashGet.js");
/* harmony import */ var _hashHas_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_hashHas.js */ "./node_modules/lodash-es/_hashHas.js");
/* harmony import */ var _hashSet_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_hashSet.js */ "./node_modules/lodash-es/_hashSet.js");






/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = _hashClear_js__WEBPACK_IMPORTED_MODULE_0__["default"];
Hash.prototype['delete'] = _hashDelete_js__WEBPACK_IMPORTED_MODULE_1__["default"];
Hash.prototype.get = _hashGet_js__WEBPACK_IMPORTED_MODULE_2__["default"];
Hash.prototype.has = _hashHas_js__WEBPACK_IMPORTED_MODULE_3__["default"];
Hash.prototype.set = _hashSet_js__WEBPACK_IMPORTED_MODULE_4__["default"];

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Hash);


/***/ }),

/***/ "./node_modules/lodash-es/_ListCache.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_ListCache.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _listCacheClear_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_listCacheClear.js */ "./node_modules/lodash-es/_listCacheClear.js");
/* harmony import */ var _listCacheDelete_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_listCacheDelete.js */ "./node_modules/lodash-es/_listCacheDelete.js");
/* harmony import */ var _listCacheGet_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_listCacheGet.js */ "./node_modules/lodash-es/_listCacheGet.js");
/* harmony import */ var _listCacheHas_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_listCacheHas.js */ "./node_modules/lodash-es/_listCacheHas.js");
/* harmony import */ var _listCacheSet_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_listCacheSet.js */ "./node_modules/lodash-es/_listCacheSet.js");






/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = _listCacheClear_js__WEBPACK_IMPORTED_MODULE_0__["default"];
ListCache.prototype['delete'] = _listCacheDelete_js__WEBPACK_IMPORTED_MODULE_1__["default"];
ListCache.prototype.get = _listCacheGet_js__WEBPACK_IMPORTED_MODULE_2__["default"];
ListCache.prototype.has = _listCacheHas_js__WEBPACK_IMPORTED_MODULE_3__["default"];
ListCache.prototype.set = _listCacheSet_js__WEBPACK_IMPORTED_MODULE_4__["default"];

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ListCache);


/***/ }),

/***/ "./node_modules/lodash-es/_Map.js":
/*!****************************************!*\
  !*** ./node_modules/lodash-es/_Map.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getNative.js */ "./node_modules/lodash-es/_getNative.js");
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");



/* Built-in method references that are verified to be native. */
var Map = (0,_getNative_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_root_js__WEBPACK_IMPORTED_MODULE_1__["default"], 'Map');

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Map);


/***/ }),

/***/ "./node_modules/lodash-es/_MapCache.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_MapCache.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _mapCacheClear_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_mapCacheClear.js */ "./node_modules/lodash-es/_mapCacheClear.js");
/* harmony import */ var _mapCacheDelete_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_mapCacheDelete.js */ "./node_modules/lodash-es/_mapCacheDelete.js");
/* harmony import */ var _mapCacheGet_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_mapCacheGet.js */ "./node_modules/lodash-es/_mapCacheGet.js");
/* harmony import */ var _mapCacheHas_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_mapCacheHas.js */ "./node_modules/lodash-es/_mapCacheHas.js");
/* harmony import */ var _mapCacheSet_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_mapCacheSet.js */ "./node_modules/lodash-es/_mapCacheSet.js");






/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = _mapCacheClear_js__WEBPACK_IMPORTED_MODULE_0__["default"];
MapCache.prototype['delete'] = _mapCacheDelete_js__WEBPACK_IMPORTED_MODULE_1__["default"];
MapCache.prototype.get = _mapCacheGet_js__WEBPACK_IMPORTED_MODULE_2__["default"];
MapCache.prototype.has = _mapCacheHas_js__WEBPACK_IMPORTED_MODULE_3__["default"];
MapCache.prototype.set = _mapCacheSet_js__WEBPACK_IMPORTED_MODULE_4__["default"];

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MapCache);


/***/ }),

/***/ "./node_modules/lodash-es/_Promise.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_Promise.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getNative.js */ "./node_modules/lodash-es/_getNative.js");
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");



/* Built-in method references that are verified to be native. */
var Promise = (0,_getNative_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_root_js__WEBPACK_IMPORTED_MODULE_1__["default"], 'Promise');

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Promise);


/***/ }),

/***/ "./node_modules/lodash-es/_Set.js":
/*!****************************************!*\
  !*** ./node_modules/lodash-es/_Set.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getNative.js */ "./node_modules/lodash-es/_getNative.js");
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");



/* Built-in method references that are verified to be native. */
var Set = (0,_getNative_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_root_js__WEBPACK_IMPORTED_MODULE_1__["default"], 'Set');

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Set);


/***/ }),

/***/ "./node_modules/lodash-es/_SetCache.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_SetCache.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _MapCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_MapCache.js */ "./node_modules/lodash-es/_MapCache.js");
/* harmony import */ var _setCacheAdd_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_setCacheAdd.js */ "./node_modules/lodash-es/_setCacheAdd.js");
/* harmony import */ var _setCacheHas_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_setCacheHas.js */ "./node_modules/lodash-es/_setCacheHas.js");




/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new _MapCache_js__WEBPACK_IMPORTED_MODULE_0__["default"];
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd_js__WEBPACK_IMPORTED_MODULE_1__["default"];
SetCache.prototype.has = _setCacheHas_js__WEBPACK_IMPORTED_MODULE_2__["default"];

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SetCache);


/***/ }),

/***/ "./node_modules/lodash-es/_Stack.js":
/*!******************************************!*\
  !*** ./node_modules/lodash-es/_Stack.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ListCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_ListCache.js */ "./node_modules/lodash-es/_ListCache.js");
/* harmony import */ var _stackClear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_stackClear.js */ "./node_modules/lodash-es/_stackClear.js");
/* harmony import */ var _stackDelete_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_stackDelete.js */ "./node_modules/lodash-es/_stackDelete.js");
/* harmony import */ var _stackGet_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_stackGet.js */ "./node_modules/lodash-es/_stackGet.js");
/* harmony import */ var _stackHas_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_stackHas.js */ "./node_modules/lodash-es/_stackHas.js");
/* harmony import */ var _stackSet_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_stackSet.js */ "./node_modules/lodash-es/_stackSet.js");







/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new _ListCache_js__WEBPACK_IMPORTED_MODULE_0__["default"](entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = _stackClear_js__WEBPACK_IMPORTED_MODULE_1__["default"];
Stack.prototype['delete'] = _stackDelete_js__WEBPACK_IMPORTED_MODULE_2__["default"];
Stack.prototype.get = _stackGet_js__WEBPACK_IMPORTED_MODULE_3__["default"];
Stack.prototype.has = _stackHas_js__WEBPACK_IMPORTED_MODULE_4__["default"];
Stack.prototype.set = _stackSet_js__WEBPACK_IMPORTED_MODULE_5__["default"];

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Stack);


/***/ }),

/***/ "./node_modules/lodash-es/_Symbol.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/_Symbol.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");


/** Built-in value references. */
var Symbol = _root_js__WEBPACK_IMPORTED_MODULE_0__["default"].Symbol;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Symbol);


/***/ }),

/***/ "./node_modules/lodash-es/_Uint8Array.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_Uint8Array.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");


/** Built-in value references. */
var Uint8Array = _root_js__WEBPACK_IMPORTED_MODULE_0__["default"].Uint8Array;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Uint8Array);


/***/ }),

/***/ "./node_modules/lodash-es/_WeakMap.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_WeakMap.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getNative.js */ "./node_modules/lodash-es/_getNative.js");
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");



/* Built-in method references that are verified to be native. */
var WeakMap = (0,_getNative_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_root_js__WEBPACK_IMPORTED_MODULE_1__["default"], 'WeakMap');

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WeakMap);


/***/ }),

/***/ "./node_modules/lodash-es/_apply.js":
/*!******************************************!*\
  !*** ./node_modules/lodash-es/_apply.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (apply);


/***/ }),

/***/ "./node_modules/lodash-es/_arrayAggregator.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_arrayAggregator.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * A specialized version of `baseAggregator` for arrays.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */
function arrayAggregator(array, setter, iteratee, accumulator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    var value = array[index];
    setter(accumulator, value, iteratee(value), array);
  }
  return accumulator;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (arrayAggregator);


/***/ }),

/***/ "./node_modules/lodash-es/_arrayEach.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_arrayEach.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (arrayEach);


/***/ }),

/***/ "./node_modules/lodash-es/_arrayFilter.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_arrayFilter.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (arrayFilter);


/***/ }),

/***/ "./node_modules/lodash-es/_arrayIncludes.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_arrayIncludes.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseIndexOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseIndexOf.js */ "./node_modules/lodash-es/_baseIndexOf.js");


/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && (0,_baseIndexOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array, value, 0) > -1;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (arrayIncludes);


/***/ }),

/***/ "./node_modules/lodash-es/_arrayIncludesWith.js":
/*!******************************************************!*\
  !*** ./node_modules/lodash-es/_arrayIncludesWith.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (arrayIncludesWith);


/***/ }),

/***/ "./node_modules/lodash-es/_arrayLikeKeys.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_arrayLikeKeys.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseTimes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_baseTimes.js */ "./node_modules/lodash-es/_baseTimes.js");
/* harmony import */ var _isArguments_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArguments.js */ "./node_modules/lodash-es/isArguments.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/lodash-es/isArray.js");
/* harmony import */ var _isBuffer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isBuffer.js */ "./node_modules/lodash-es/isBuffer.js");
/* harmony import */ var _isIndex_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_isIndex.js */ "./node_modules/lodash-es/_isIndex.js");
/* harmony import */ var _isTypedArray_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isTypedArray.js */ "./node_modules/lodash-es/isTypedArray.js");







/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = (0,_isArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value),
      isArg = !isArr && (0,_isArguments_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value),
      isBuff = !isArr && !isArg && (0,_isBuffer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value),
      isType = !isArr && !isArg && !isBuff && (0,_isTypedArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? (0,_baseTimes_js__WEBPACK_IMPORTED_MODULE_4__["default"])(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           (0,_isIndex_js__WEBPACK_IMPORTED_MODULE_5__["default"])(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (arrayLikeKeys);


/***/ }),

/***/ "./node_modules/lodash-es/_arrayMap.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_arrayMap.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (arrayMap);


/***/ }),

/***/ "./node_modules/lodash-es/_arrayPush.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_arrayPush.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (arrayPush);


/***/ }),

/***/ "./node_modules/lodash-es/_arrayReduce.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_arrayReduce.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (arrayReduce);


/***/ }),

/***/ "./node_modules/lodash-es/_arraySome.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_arraySome.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (arraySome);


/***/ }),

/***/ "./node_modules/lodash-es/_asciiToArray.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_asciiToArray.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (asciiToArray);


/***/ }),

/***/ "./node_modules/lodash-es/_asciiWords.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_asciiWords.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used to match words composed of alphanumeric characters. */
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

/**
 * Splits an ASCII `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (asciiWords);


/***/ }),

/***/ "./node_modules/lodash-es/_assignMergeValue.js":
/*!*****************************************************!*\
  !*** ./node_modules/lodash-es/_assignMergeValue.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseAssignValue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseAssignValue.js */ "./node_modules/lodash-es/_baseAssignValue.js");
/* harmony import */ var _eq_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eq.js */ "./node_modules/lodash-es/eq.js");



/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !(0,_eq_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object[key], value)) ||
      (value === undefined && !(key in object))) {
    (0,_baseAssignValue_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, key, value);
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assignMergeValue);


/***/ }),

/***/ "./node_modules/lodash-es/_assignValue.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_assignValue.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseAssignValue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseAssignValue.js */ "./node_modules/lodash-es/_baseAssignValue.js");
/* harmony import */ var _eq_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eq.js */ "./node_modules/lodash-es/eq.js");



/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && (0,_eq_js__WEBPACK_IMPORTED_MODULE_0__["default"])(objValue, value)) ||
      (value === undefined && !(key in object))) {
    (0,_baseAssignValue_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, key, value);
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assignValue);


/***/ }),

/***/ "./node_modules/lodash-es/_assocIndexOf.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_assocIndexOf.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _eq_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eq.js */ "./node_modules/lodash-es/eq.js");


/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if ((0,_eq_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assocIndexOf);


/***/ }),

/***/ "./node_modules/lodash-es/_baseAggregator.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_baseAggregator.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseEach_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseEach.js */ "./node_modules/lodash-es/_baseEach.js");


/**
 * Aggregates elements of `collection` on `accumulator` with keys transformed
 * by `iteratee` and values set by `setter`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */
function baseAggregator(collection, setter, iteratee, accumulator) {
  (0,_baseEach_js__WEBPACK_IMPORTED_MODULE_0__["default"])(collection, function(value, key, collection) {
    setter(accumulator, value, iteratee(value), collection);
  });
  return accumulator;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseAggregator);


/***/ }),

/***/ "./node_modules/lodash-es/_baseAssign.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_baseAssign.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _copyObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_copyObject.js */ "./node_modules/lodash-es/_copyObject.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys.js */ "./node_modules/lodash-es/keys.js");



/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && (0,_copyObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(source, (0,_keys_js__WEBPACK_IMPORTED_MODULE_1__["default"])(source), object);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseAssign);


/***/ }),

/***/ "./node_modules/lodash-es/_baseAssignIn.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_baseAssignIn.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _copyObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_copyObject.js */ "./node_modules/lodash-es/_copyObject.js");
/* harmony import */ var _keysIn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keysIn.js */ "./node_modules/lodash-es/keysIn.js");



/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && (0,_copyObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(source, (0,_keysIn_js__WEBPACK_IMPORTED_MODULE_1__["default"])(source), object);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseAssignIn);


/***/ }),

/***/ "./node_modules/lodash-es/_baseAssignValue.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_baseAssignValue.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _defineProperty_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_defineProperty.js */ "./node_modules/lodash-es/_defineProperty.js");


/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && _defineProperty_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
    (0,_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseAssignValue);


/***/ }),

/***/ "./node_modules/lodash-es/_baseClamp.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_baseClamp.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * The base implementation of `_.clamp` which doesn't coerce arguments.
 *
 * @private
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 */
function baseClamp(number, lower, upper) {
  if (number === number) {
    if (upper !== undefined) {
      number = number <= upper ? number : upper;
    }
    if (lower !== undefined) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseClamp);


/***/ }),

/***/ "./node_modules/lodash-es/_baseClone.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_baseClone.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Stack_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./_Stack.js */ "./node_modules/lodash-es/_Stack.js");
/* harmony import */ var _arrayEach_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./_arrayEach.js */ "./node_modules/lodash-es/_arrayEach.js");
/* harmony import */ var _assignValue_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./_assignValue.js */ "./node_modules/lodash-es/_assignValue.js");
/* harmony import */ var _baseAssign_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./_baseAssign.js */ "./node_modules/lodash-es/_baseAssign.js");
/* harmony import */ var _baseAssignIn_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./_baseAssignIn.js */ "./node_modules/lodash-es/_baseAssignIn.js");
/* harmony import */ var _cloneBuffer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_cloneBuffer.js */ "./node_modules/lodash-es/_cloneBuffer.js");
/* harmony import */ var _copyArray_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_copyArray.js */ "./node_modules/lodash-es/_copyArray.js");
/* harmony import */ var _copySymbols_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./_copySymbols.js */ "./node_modules/lodash-es/_copySymbols.js");
/* harmony import */ var _copySymbolsIn_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./_copySymbolsIn.js */ "./node_modules/lodash-es/_copySymbolsIn.js");
/* harmony import */ var _getAllKeys_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./_getAllKeys.js */ "./node_modules/lodash-es/_getAllKeys.js");
/* harmony import */ var _getAllKeysIn_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./_getAllKeysIn.js */ "./node_modules/lodash-es/_getAllKeysIn.js");
/* harmony import */ var _getTag_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_getTag.js */ "./node_modules/lodash-es/_getTag.js");
/* harmony import */ var _initCloneArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_initCloneArray.js */ "./node_modules/lodash-es/_initCloneArray.js");
/* harmony import */ var _initCloneByTag_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./_initCloneByTag.js */ "./node_modules/lodash-es/_initCloneByTag.js");
/* harmony import */ var _initCloneObject_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./_initCloneObject.js */ "./node_modules/lodash-es/_initCloneObject.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/lodash-es/isArray.js");
/* harmony import */ var _isBuffer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./isBuffer.js */ "./node_modules/lodash-es/isBuffer.js");
/* harmony import */ var _isMap_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./isMap.js */ "./node_modules/lodash-es/isMap.js");
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/lodash-es/isObject.js");
/* harmony import */ var _isSet_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./isSet.js */ "./node_modules/lodash-es/isSet.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./keys.js */ "./node_modules/lodash-es/keys.js");
/* harmony import */ var _keysIn_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./keysIn.js */ "./node_modules/lodash-es/keysIn.js");























/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!(0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value)) {
    return value;
  }
  var isArr = (0,_isArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value);
  if (isArr) {
    result = (0,_initCloneArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value);
    if (!isDeep) {
      return (0,_copyArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(value, result);
    }
  } else {
    var tag = (0,_getTag_js__WEBPACK_IMPORTED_MODULE_4__["default"])(value),
        isFunc = tag == funcTag || tag == genTag;

    if ((0,_isBuffer_js__WEBPACK_IMPORTED_MODULE_5__["default"])(value)) {
      return (0,_cloneBuffer_js__WEBPACK_IMPORTED_MODULE_6__["default"])(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : (0,_initCloneObject_js__WEBPACK_IMPORTED_MODULE_7__["default"])(value);
      if (!isDeep) {
        return isFlat
          ? (0,_copySymbolsIn_js__WEBPACK_IMPORTED_MODULE_8__["default"])(value, (0,_baseAssignIn_js__WEBPACK_IMPORTED_MODULE_9__["default"])(result, value))
          : (0,_copySymbols_js__WEBPACK_IMPORTED_MODULE_10__["default"])(value, (0,_baseAssign_js__WEBPACK_IMPORTED_MODULE_11__["default"])(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = (0,_initCloneByTag_js__WEBPACK_IMPORTED_MODULE_12__["default"])(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new _Stack_js__WEBPACK_IMPORTED_MODULE_13__["default"]);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if ((0,_isSet_js__WEBPACK_IMPORTED_MODULE_14__["default"])(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if ((0,_isMap_js__WEBPACK_IMPORTED_MODULE_15__["default"])(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? _getAllKeysIn_js__WEBPACK_IMPORTED_MODULE_16__["default"] : _getAllKeys_js__WEBPACK_IMPORTED_MODULE_17__["default"])
    : (isFlat ? _keysIn_js__WEBPACK_IMPORTED_MODULE_18__["default"] : _keys_js__WEBPACK_IMPORTED_MODULE_19__["default"]);

  var props = isArr ? undefined : keysFunc(value);
  (0,_arrayEach_js__WEBPACK_IMPORTED_MODULE_20__["default"])(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    (0,_assignValue_js__WEBPACK_IMPORTED_MODULE_21__["default"])(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseClone);


/***/ }),

/***/ "./node_modules/lodash-es/_baseCreate.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_baseCreate.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/lodash-es/isObject.js");


/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!(0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseCreate);


/***/ }),

/***/ "./node_modules/lodash-es/_baseDifference.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_baseDifference.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _SetCache_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_SetCache.js */ "./node_modules/lodash-es/_SetCache.js");
/* harmony import */ var _arrayIncludes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_arrayIncludes.js */ "./node_modules/lodash-es/_arrayIncludes.js");
/* harmony import */ var _arrayIncludesWith_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_arrayIncludesWith.js */ "./node_modules/lodash-es/_arrayIncludesWith.js");
/* harmony import */ var _arrayMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_arrayMap.js */ "./node_modules/lodash-es/_arrayMap.js");
/* harmony import */ var _baseUnary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseUnary.js */ "./node_modules/lodash-es/_baseUnary.js");
/* harmony import */ var _cacheHas_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_cacheHas.js */ "./node_modules/lodash-es/_cacheHas.js");







/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */
function baseDifference(array, values, iteratee, comparator) {
  var index = -1,
      includes = _arrayIncludes_js__WEBPACK_IMPORTED_MODULE_0__["default"],
      isCommon = true,
      length = array.length,
      result = [],
      valuesLength = values.length;

  if (!length) {
    return result;
  }
  if (iteratee) {
    values = (0,_arrayMap_js__WEBPACK_IMPORTED_MODULE_1__["default"])(values, (0,_baseUnary_js__WEBPACK_IMPORTED_MODULE_2__["default"])(iteratee));
  }
  if (comparator) {
    includes = _arrayIncludesWith_js__WEBPACK_IMPORTED_MODULE_3__["default"];
    isCommon = false;
  }
  else if (values.length >= LARGE_ARRAY_SIZE) {
    includes = _cacheHas_js__WEBPACK_IMPORTED_MODULE_4__["default"];
    isCommon = false;
    values = new _SetCache_js__WEBPACK_IMPORTED_MODULE_5__["default"](values);
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee == null ? value : iteratee(value);

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;
      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer;
        }
      }
      result.push(value);
    }
    else if (!includes(values, computed, comparator)) {
      result.push(value);
    }
  }
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseDifference);


/***/ }),

/***/ "./node_modules/lodash-es/_baseEach.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_baseEach.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseForOwn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseForOwn.js */ "./node_modules/lodash-es/_baseForOwn.js");
/* harmony import */ var _createBaseEach_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createBaseEach.js */ "./node_modules/lodash-es/_createBaseEach.js");



/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = (0,_createBaseEach_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_baseForOwn_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseEach);


/***/ }),

/***/ "./node_modules/lodash-es/_baseExtremum.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_baseExtremum.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isSymbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isSymbol.js */ "./node_modules/lodash-es/isSymbol.js");


/**
 * The base implementation of methods like `_.max` and `_.min` which accepts a
 * `comparator` to determine the extremum value.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The iteratee invoked per iteration.
 * @param {Function} comparator The comparator used to compare values.
 * @returns {*} Returns the extremum value.
 */
function baseExtremum(array, iteratee, comparator) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    var value = array[index],
        current = iteratee(value);

    if (current != null && (computed === undefined
          ? (current === current && !(0,_isSymbol_js__WEBPACK_IMPORTED_MODULE_0__["default"])(current))
          : comparator(current, computed)
        )) {
      var computed = current,
          result = value;
    }
  }
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseExtremum);


/***/ }),

/***/ "./node_modules/lodash-es/_baseFindIndex.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_baseFindIndex.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseFindIndex);


/***/ }),

/***/ "./node_modules/lodash-es/_baseFlatten.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_baseFlatten.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _arrayPush_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_arrayPush.js */ "./node_modules/lodash-es/_arrayPush.js");
/* harmony import */ var _isFlattenable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isFlattenable.js */ "./node_modules/lodash-es/_isFlattenable.js");



/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = _isFlattenable_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        (0,_arrayPush_js__WEBPACK_IMPORTED_MODULE_1__["default"])(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseFlatten);


/***/ }),

/***/ "./node_modules/lodash-es/_baseFor.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_baseFor.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _createBaseFor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createBaseFor.js */ "./node_modules/lodash-es/_createBaseFor.js");


/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = (0,_createBaseFor_js__WEBPACK_IMPORTED_MODULE_0__["default"])();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseFor);


/***/ }),

/***/ "./node_modules/lodash-es/_baseForOwn.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_baseForOwn.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseFor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseFor.js */ "./node_modules/lodash-es/_baseFor.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys.js */ "./node_modules/lodash-es/keys.js");



/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && (0,_baseFor_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, iteratee, _keys_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseForOwn);


/***/ }),

/***/ "./node_modules/lodash-es/_baseGet.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_baseGet.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _castPath_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_castPath.js */ "./node_modules/lodash-es/_castPath.js");
/* harmony import */ var _toKey_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_toKey.js */ "./node_modules/lodash-es/_toKey.js");



/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = (0,_castPath_js__WEBPACK_IMPORTED_MODULE_0__["default"])(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[(0,_toKey_js__WEBPACK_IMPORTED_MODULE_1__["default"])(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseGet);


/***/ }),

/***/ "./node_modules/lodash-es/_baseGetAllKeys.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_baseGetAllKeys.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _arrayPush_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_arrayPush.js */ "./node_modules/lodash-es/_arrayPush.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/lodash-es/isArray.js");



/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return (0,_isArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object) ? result : (0,_arrayPush_js__WEBPACK_IMPORTED_MODULE_1__["default"])(result, symbolsFunc(object));
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseGetAllKeys);


/***/ }),

/***/ "./node_modules/lodash-es/_baseGetTag.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_baseGetTag.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Symbol.js */ "./node_modules/lodash-es/_Symbol.js");
/* harmony import */ var _getRawTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getRawTag.js */ "./node_modules/lodash-es/_getRawTag.js");
/* harmony import */ var _objectToString_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_objectToString.js */ "./node_modules/lodash-es/_objectToString.js");




/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"].toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? (0,_getRawTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value)
    : (0,_objectToString_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseGetTag);


/***/ }),

/***/ "./node_modules/lodash-es/_baseGt.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/_baseGt.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * The base implementation of `_.gt` which doesn't coerce arguments.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is greater than `other`,
 *  else `false`.
 */
function baseGt(value, other) {
  return value > other;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseGt);


/***/ }),

/***/ "./node_modules/lodash-es/_baseHas.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_baseHas.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHas(object, key) {
  return object != null && hasOwnProperty.call(object, key);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseHas);


/***/ }),

/***/ "./node_modules/lodash-es/_baseHasIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_baseHasIn.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseHasIn);


/***/ }),

/***/ "./node_modules/lodash-es/_baseIndexOf.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_baseIndexOf.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseFindIndex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseFindIndex.js */ "./node_modules/lodash-es/_baseFindIndex.js");
/* harmony import */ var _baseIsNaN_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseIsNaN.js */ "./node_modules/lodash-es/_baseIsNaN.js");
/* harmony import */ var _strictIndexOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_strictIndexOf.js */ "./node_modules/lodash-es/_strictIndexOf.js");




/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? (0,_strictIndexOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array, value, fromIndex)
    : (0,_baseFindIndex_js__WEBPACK_IMPORTED_MODULE_1__["default"])(array, _baseIsNaN_js__WEBPACK_IMPORTED_MODULE_2__["default"], fromIndex);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseIndexOf);


/***/ }),

/***/ "./node_modules/lodash-es/_baseIsArguments.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_baseIsArguments.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseGetTag.js */ "./node_modules/lodash-es/_baseGetTag.js");
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObjectLike.js */ "./node_modules/lodash-es/isObjectLike.js");



/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return (0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && (0,_baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) == argsTag;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseIsArguments);


/***/ }),

/***/ "./node_modules/lodash-es/_baseIsEqual.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_baseIsEqual.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseIsEqualDeep_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseIsEqualDeep.js */ "./node_modules/lodash-es/_baseIsEqualDeep.js");
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObjectLike.js */ "./node_modules/lodash-es/isObjectLike.js");



/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!(0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && !(0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(other))) {
    return value !== value && other !== other;
  }
  return (0,_baseIsEqualDeep_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value, other, bitmask, customizer, baseIsEqual, stack);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseIsEqual);


/***/ }),

/***/ "./node_modules/lodash-es/_baseIsEqualDeep.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_baseIsEqualDeep.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Stack_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_Stack.js */ "./node_modules/lodash-es/_Stack.js");
/* harmony import */ var _equalArrays_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_equalArrays.js */ "./node_modules/lodash-es/_equalArrays.js");
/* harmony import */ var _equalByTag_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_equalByTag.js */ "./node_modules/lodash-es/_equalByTag.js");
/* harmony import */ var _equalObjects_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./_equalObjects.js */ "./node_modules/lodash-es/_equalObjects.js");
/* harmony import */ var _getTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getTag.js */ "./node_modules/lodash-es/_getTag.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/lodash-es/isArray.js");
/* harmony import */ var _isBuffer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isBuffer.js */ "./node_modules/lodash-es/isBuffer.js");
/* harmony import */ var _isTypedArray_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./isTypedArray.js */ "./node_modules/lodash-es/isTypedArray.js");









/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = (0,_isArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object),
      othIsArr = (0,_isArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(other),
      objTag = objIsArr ? arrayTag : (0,_getTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object),
      othTag = othIsArr ? arrayTag : (0,_getTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && (0,_isBuffer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(object)) {
    if (!(0,_isBuffer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new _Stack_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
    return (objIsArr || (0,_isTypedArray_js__WEBPACK_IMPORTED_MODULE_4__["default"])(object))
      ? (0,_equalArrays_js__WEBPACK_IMPORTED_MODULE_5__["default"])(object, other, bitmask, customizer, equalFunc, stack)
      : (0,_equalByTag_js__WEBPACK_IMPORTED_MODULE_6__["default"])(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new _Stack_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new _Stack_js__WEBPACK_IMPORTED_MODULE_3__["default"]);
  return (0,_equalObjects_js__WEBPACK_IMPORTED_MODULE_7__["default"])(object, other, bitmask, customizer, equalFunc, stack);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseIsEqualDeep);


/***/ }),

/***/ "./node_modules/lodash-es/_baseIsMap.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_baseIsMap.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getTag.js */ "./node_modules/lodash-es/_getTag.js");
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObjectLike.js */ "./node_modules/lodash-es/isObjectLike.js");



/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return (0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && (0,_getTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) == mapTag;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseIsMap);


/***/ }),

/***/ "./node_modules/lodash-es/_baseIsMatch.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_baseIsMatch.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Stack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Stack.js */ "./node_modules/lodash-es/_Stack.js");
/* harmony import */ var _baseIsEqual_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseIsEqual.js */ "./node_modules/lodash-es/_baseIsEqual.js");



/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new _Stack_js__WEBPACK_IMPORTED_MODULE_0__["default"];
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? (0,_baseIsEqual_js__WEBPACK_IMPORTED_MODULE_1__["default"])(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseIsMatch);


/***/ }),

/***/ "./node_modules/lodash-es/_baseIsNaN.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_baseIsNaN.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseIsNaN);


/***/ }),

/***/ "./node_modules/lodash-es/_baseIsNative.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_baseIsNative.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/lodash-es/isFunction.js");
/* harmony import */ var _isMasked_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isMasked.js */ "./node_modules/lodash-es/_isMasked.js");
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/lodash-es/isObject.js");
/* harmony import */ var _toSource_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_toSource.js */ "./node_modules/lodash-es/_toSource.js");





/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!(0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) || (0,_isMasked_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value)) {
    return false;
  }
  var pattern = (0,_isFunction_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value) ? reIsNative : reIsHostCtor;
  return pattern.test((0,_toSource_js__WEBPACK_IMPORTED_MODULE_3__["default"])(value));
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseIsNative);


/***/ }),

/***/ "./node_modules/lodash-es/_baseIsSet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_baseIsSet.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getTag.js */ "./node_modules/lodash-es/_getTag.js");
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObjectLike.js */ "./node_modules/lodash-es/isObjectLike.js");



/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return (0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && (0,_getTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) == setTag;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseIsSet);


/***/ }),

/***/ "./node_modules/lodash-es/_baseIsTypedArray.js":
/*!*****************************************************!*\
  !*** ./node_modules/lodash-es/_baseIsTypedArray.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseGetTag.js */ "./node_modules/lodash-es/_baseGetTag.js");
/* harmony import */ var _isLength_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isLength.js */ "./node_modules/lodash-es/isLength.js");
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObjectLike.js */ "./node_modules/lodash-es/isObjectLike.js");




/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return (0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) &&
    (0,_isLength_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value.length) && !!typedArrayTags[(0,_baseGetTag_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value)];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseIsTypedArray);


/***/ }),

/***/ "./node_modules/lodash-es/_baseIteratee.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_baseIteratee.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseMatches_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_baseMatches.js */ "./node_modules/lodash-es/_baseMatches.js");
/* harmony import */ var _baseMatchesProperty_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseMatchesProperty.js */ "./node_modules/lodash-es/_baseMatchesProperty.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/lodash-es/identity.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/lodash-es/isArray.js");
/* harmony import */ var _property_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./property.js */ "./node_modules/lodash-es/property.js");






/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"];
  }
  if (typeof value == 'object') {
    return (0,_isArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value)
      ? (0,_baseMatchesProperty_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value[0], value[1])
      : (0,_baseMatches_js__WEBPACK_IMPORTED_MODULE_3__["default"])(value);
  }
  return (0,_property_js__WEBPACK_IMPORTED_MODULE_4__["default"])(value);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseIteratee);


/***/ }),

/***/ "./node_modules/lodash-es/_baseKeys.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_baseKeys.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isPrototype_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isPrototype.js */ "./node_modules/lodash-es/_isPrototype.js");
/* harmony import */ var _nativeKeys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_nativeKeys.js */ "./node_modules/lodash-es/_nativeKeys.js");



/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!(0,_isPrototype_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object)) {
    return (0,_nativeKeys_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseKeys);


/***/ }),

/***/ "./node_modules/lodash-es/_baseKeysIn.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_baseKeysIn.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/lodash-es/isObject.js");
/* harmony import */ var _isPrototype_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_isPrototype.js */ "./node_modules/lodash-es/_isPrototype.js");
/* harmony import */ var _nativeKeysIn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_nativeKeysIn.js */ "./node_modules/lodash-es/_nativeKeysIn.js");




/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!(0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object)) {
    return (0,_nativeKeysIn_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object);
  }
  var isProto = (0,_isPrototype_js__WEBPACK_IMPORTED_MODULE_2__["default"])(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseKeysIn);


/***/ }),

/***/ "./node_modules/lodash-es/_baseMap.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_baseMap.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseEach_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseEach.js */ "./node_modules/lodash-es/_baseEach.js");
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArrayLike.js */ "./node_modules/lodash-es/isArrayLike.js");



/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = (0,_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(collection) ? Array(collection.length) : [];

  (0,_baseEach_js__WEBPACK_IMPORTED_MODULE_1__["default"])(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseMap);


/***/ }),

/***/ "./node_modules/lodash-es/_baseMatches.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_baseMatches.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseIsMatch_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseIsMatch.js */ "./node_modules/lodash-es/_baseIsMatch.js");
/* harmony import */ var _getMatchData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getMatchData.js */ "./node_modules/lodash-es/_getMatchData.js");
/* harmony import */ var _matchesStrictComparable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_matchesStrictComparable.js */ "./node_modules/lodash-es/_matchesStrictComparable.js");




/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = (0,_getMatchData_js__WEBPACK_IMPORTED_MODULE_0__["default"])(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return (0,_matchesStrictComparable_js__WEBPACK_IMPORTED_MODULE_1__["default"])(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || (0,_baseIsMatch_js__WEBPACK_IMPORTED_MODULE_2__["default"])(object, source, matchData);
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseMatches);


/***/ }),

/***/ "./node_modules/lodash-es/_baseMatchesProperty.js":
/*!********************************************************!*\
  !*** ./node_modules/lodash-es/_baseMatchesProperty.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseIsEqual_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_baseIsEqual.js */ "./node_modules/lodash-es/_baseIsEqual.js");
/* harmony import */ var _get_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./get.js */ "./node_modules/lodash-es/get.js");
/* harmony import */ var _hasIn_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hasIn.js */ "./node_modules/lodash-es/hasIn.js");
/* harmony import */ var _isKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isKey.js */ "./node_modules/lodash-es/_isKey.js");
/* harmony import */ var _isStrictComparable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isStrictComparable.js */ "./node_modules/lodash-es/_isStrictComparable.js");
/* harmony import */ var _matchesStrictComparable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_matchesStrictComparable.js */ "./node_modules/lodash-es/_matchesStrictComparable.js");
/* harmony import */ var _toKey_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_toKey.js */ "./node_modules/lodash-es/_toKey.js");








/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if ((0,_isKey_js__WEBPACK_IMPORTED_MODULE_0__["default"])(path) && (0,_isStrictComparable_js__WEBPACK_IMPORTED_MODULE_1__["default"])(srcValue)) {
    return (0,_matchesStrictComparable_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_toKey_js__WEBPACK_IMPORTED_MODULE_3__["default"])(path), srcValue);
  }
  return function(object) {
    var objValue = (0,_get_js__WEBPACK_IMPORTED_MODULE_4__["default"])(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? (0,_hasIn_js__WEBPACK_IMPORTED_MODULE_5__["default"])(object, path)
      : (0,_baseIsEqual_js__WEBPACK_IMPORTED_MODULE_6__["default"])(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseMatchesProperty);


/***/ }),

/***/ "./node_modules/lodash-es/_baseMerge.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_baseMerge.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Stack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_Stack.js */ "./node_modules/lodash-es/_Stack.js");
/* harmony import */ var _assignMergeValue_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_assignMergeValue.js */ "./node_modules/lodash-es/_assignMergeValue.js");
/* harmony import */ var _baseFor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseFor.js */ "./node_modules/lodash-es/_baseFor.js");
/* harmony import */ var _baseMergeDeep_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_baseMergeDeep.js */ "./node_modules/lodash-es/_baseMergeDeep.js");
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/lodash-es/isObject.js");
/* harmony import */ var _keysIn_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./keysIn.js */ "./node_modules/lodash-es/keysIn.js");
/* harmony import */ var _safeGet_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_safeGet.js */ "./node_modules/lodash-es/_safeGet.js");








/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  (0,_baseFor_js__WEBPACK_IMPORTED_MODULE_0__["default"])(source, function(srcValue, key) {
    stack || (stack = new _Stack_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
    if ((0,_isObject_js__WEBPACK_IMPORTED_MODULE_2__["default"])(srcValue)) {
      (0,_baseMergeDeep_js__WEBPACK_IMPORTED_MODULE_3__["default"])(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer((0,_safeGet_js__WEBPACK_IMPORTED_MODULE_4__["default"])(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      (0,_assignMergeValue_js__WEBPACK_IMPORTED_MODULE_5__["default"])(object, key, newValue);
    }
  }, _keysIn_js__WEBPACK_IMPORTED_MODULE_6__["default"]);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseMerge);


/***/ }),

/***/ "./node_modules/lodash-es/_baseMergeDeep.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_baseMergeDeep.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _assignMergeValue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assignMergeValue.js */ "./node_modules/lodash-es/_assignMergeValue.js");
/* harmony import */ var _cloneBuffer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./_cloneBuffer.js */ "./node_modules/lodash-es/_cloneBuffer.js");
/* harmony import */ var _cloneTypedArray_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./_cloneTypedArray.js */ "./node_modules/lodash-es/_cloneTypedArray.js");
/* harmony import */ var _copyArray_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_copyArray.js */ "./node_modules/lodash-es/_copyArray.js");
/* harmony import */ var _initCloneObject_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./_initCloneObject.js */ "./node_modules/lodash-es/_initCloneObject.js");
/* harmony import */ var _isArguments_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./isArguments.js */ "./node_modules/lodash-es/isArguments.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/lodash-es/isArray.js");
/* harmony import */ var _isArrayLikeObject_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./isArrayLikeObject.js */ "./node_modules/lodash-es/isArrayLikeObject.js");
/* harmony import */ var _isBuffer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isBuffer.js */ "./node_modules/lodash-es/isBuffer.js");
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/lodash-es/isFunction.js");
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/lodash-es/isObject.js");
/* harmony import */ var _isPlainObject_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./isPlainObject.js */ "./node_modules/lodash-es/isPlainObject.js");
/* harmony import */ var _isTypedArray_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./isTypedArray.js */ "./node_modules/lodash-es/isTypedArray.js");
/* harmony import */ var _safeGet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_safeGet.js */ "./node_modules/lodash-es/_safeGet.js");
/* harmony import */ var _toPlainObject_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./toPlainObject.js */ "./node_modules/lodash-es/toPlainObject.js");
















/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = (0,_safeGet_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, key),
      srcValue = (0,_safeGet_js__WEBPACK_IMPORTED_MODULE_0__["default"])(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    (0,_assignMergeValue_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = (0,_isArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(srcValue),
        isBuff = !isArr && (0,_isBuffer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(srcValue),
        isTyped = !isArr && !isBuff && (0,_isTypedArray_js__WEBPACK_IMPORTED_MODULE_4__["default"])(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if ((0,_isArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(objValue)) {
        newValue = objValue;
      }
      else if ((0,_isArrayLikeObject_js__WEBPACK_IMPORTED_MODULE_5__["default"])(objValue)) {
        newValue = (0,_copyArray_js__WEBPACK_IMPORTED_MODULE_6__["default"])(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = (0,_cloneBuffer_js__WEBPACK_IMPORTED_MODULE_7__["default"])(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = (0,_cloneTypedArray_js__WEBPACK_IMPORTED_MODULE_8__["default"])(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if ((0,_isPlainObject_js__WEBPACK_IMPORTED_MODULE_9__["default"])(srcValue) || (0,_isArguments_js__WEBPACK_IMPORTED_MODULE_10__["default"])(srcValue)) {
      newValue = objValue;
      if ((0,_isArguments_js__WEBPACK_IMPORTED_MODULE_10__["default"])(objValue)) {
        newValue = (0,_toPlainObject_js__WEBPACK_IMPORTED_MODULE_11__["default"])(objValue);
      }
      else if (!(0,_isObject_js__WEBPACK_IMPORTED_MODULE_12__["default"])(objValue) || (0,_isFunction_js__WEBPACK_IMPORTED_MODULE_13__["default"])(objValue)) {
        newValue = (0,_initCloneObject_js__WEBPACK_IMPORTED_MODULE_14__["default"])(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  (0,_assignMergeValue_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, key, newValue);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseMergeDeep);


/***/ }),

/***/ "./node_modules/lodash-es/_baseOrderBy.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_baseOrderBy.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _arrayMap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_arrayMap.js */ "./node_modules/lodash-es/_arrayMap.js");
/* harmony import */ var _baseGet_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseGet.js */ "./node_modules/lodash-es/_baseGet.js");
/* harmony import */ var _baseIteratee_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_baseIteratee.js */ "./node_modules/lodash-es/_baseIteratee.js");
/* harmony import */ var _baseMap_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_baseMap.js */ "./node_modules/lodash-es/_baseMap.js");
/* harmony import */ var _baseSortBy_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./_baseSortBy.js */ "./node_modules/lodash-es/_baseSortBy.js");
/* harmony import */ var _baseUnary_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_baseUnary.js */ "./node_modules/lodash-es/_baseUnary.js");
/* harmony import */ var _compareMultiple_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./_compareMultiple.js */ "./node_modules/lodash-es/_compareMultiple.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./identity.js */ "./node_modules/lodash-es/identity.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/lodash-es/isArray.js");










/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */
function baseOrderBy(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = (0,_arrayMap_js__WEBPACK_IMPORTED_MODULE_0__["default"])(iteratees, function(iteratee) {
      if ((0,_isArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(iteratee)) {
        return function(value) {
          return (0,_baseGet_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value, iteratee.length === 1 ? iteratee[0] : iteratee);
        }
      }
      return iteratee;
    });
  } else {
    iteratees = [_identity_js__WEBPACK_IMPORTED_MODULE_3__["default"]];
  }

  var index = -1;
  iteratees = (0,_arrayMap_js__WEBPACK_IMPORTED_MODULE_0__["default"])(iteratees, (0,_baseUnary_js__WEBPACK_IMPORTED_MODULE_4__["default"])(_baseIteratee_js__WEBPACK_IMPORTED_MODULE_5__["default"]));

  var result = (0,_baseMap_js__WEBPACK_IMPORTED_MODULE_6__["default"])(collection, function(value, key, collection) {
    var criteria = (0,_arrayMap_js__WEBPACK_IMPORTED_MODULE_0__["default"])(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return { 'criteria': criteria, 'index': ++index, 'value': value };
  });

  return (0,_baseSortBy_js__WEBPACK_IMPORTED_MODULE_7__["default"])(result, function(object, other) {
    return (0,_compareMultiple_js__WEBPACK_IMPORTED_MODULE_8__["default"])(object, other, orders);
  });
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseOrderBy);


/***/ }),

/***/ "./node_modules/lodash-es/_basePick.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_basePick.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basePickBy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_basePickBy.js */ "./node_modules/lodash-es/_basePickBy.js");
/* harmony import */ var _hasIn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hasIn.js */ "./node_modules/lodash-es/hasIn.js");



/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, paths) {
  return (0,_basePickBy_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, paths, function(value, path) {
    return (0,_hasIn_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, path);
  });
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (basePick);


/***/ }),

/***/ "./node_modules/lodash-es/_basePickBy.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_basePickBy.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseGet.js */ "./node_modules/lodash-es/_baseGet.js");
/* harmony import */ var _baseSet_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseSet.js */ "./node_modules/lodash-es/_baseSet.js");
/* harmony import */ var _castPath_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_castPath.js */ "./node_modules/lodash-es/_castPath.js");




/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = (0,_baseGet_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, path);

    if (predicate(value, path)) {
      (0,_baseSet_js__WEBPACK_IMPORTED_MODULE_1__["default"])(result, (0,_castPath_js__WEBPACK_IMPORTED_MODULE_2__["default"])(path, object), value);
    }
  }
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (basePickBy);


/***/ }),

/***/ "./node_modules/lodash-es/_baseProperty.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_baseProperty.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseProperty);


/***/ }),

/***/ "./node_modules/lodash-es/_basePropertyDeep.js":
/*!*****************************************************!*\
  !*** ./node_modules/lodash-es/_basePropertyDeep.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseGet.js */ "./node_modules/lodash-es/_baseGet.js");


/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return (0,_baseGet_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, path);
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (basePropertyDeep);


/***/ }),

/***/ "./node_modules/lodash-es/_basePropertyOf.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_basePropertyOf.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (basePropertyOf);


/***/ }),

/***/ "./node_modules/lodash-es/_baseRest.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_baseRest.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./identity.js */ "./node_modules/lodash-es/identity.js");
/* harmony import */ var _overRest_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_overRest.js */ "./node_modules/lodash-es/_overRest.js");
/* harmony import */ var _setToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setToString.js */ "./node_modules/lodash-es/_setToString.js");




/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return (0,_setToString_js__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_overRest_js__WEBPACK_IMPORTED_MODULE_1__["default"])(func, start, _identity_js__WEBPACK_IMPORTED_MODULE_2__["default"]), func + '');
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseRest);


/***/ }),

/***/ "./node_modules/lodash-es/_baseSet.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_baseSet.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _assignValue_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_assignValue.js */ "./node_modules/lodash-es/_assignValue.js");
/* harmony import */ var _castPath_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_castPath.js */ "./node_modules/lodash-es/_castPath.js");
/* harmony import */ var _isIndex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_isIndex.js */ "./node_modules/lodash-es/_isIndex.js");
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/lodash-es/isObject.js");
/* harmony import */ var _toKey_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_toKey.js */ "./node_modules/lodash-es/_toKey.js");






/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!(0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object)) {
    return object;
  }
  path = (0,_castPath_js__WEBPACK_IMPORTED_MODULE_1__["default"])(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = (0,_toKey_js__WEBPACK_IMPORTED_MODULE_2__["default"])(path[index]),
        newValue = value;

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = (0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(objValue)
          ? objValue
          : ((0,_isIndex_js__WEBPACK_IMPORTED_MODULE_3__["default"])(path[index + 1]) ? [] : {});
      }
    }
    (0,_assignValue_js__WEBPACK_IMPORTED_MODULE_4__["default"])(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseSet);


/***/ }),

/***/ "./node_modules/lodash-es/_baseSetToString.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_baseSetToString.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constant.js */ "./node_modules/lodash-es/constant.js");
/* harmony import */ var _defineProperty_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_defineProperty.js */ "./node_modules/lodash-es/_defineProperty.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./identity.js */ "./node_modules/lodash-es/identity.js");




/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? _identity_js__WEBPACK_IMPORTED_MODULE_1__["default"] : function(func, string) {
  return (0,_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__["default"])(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(string),
    'writable': true
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseSetToString);


/***/ }),

/***/ "./node_modules/lodash-es/_baseSlice.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_baseSlice.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseSlice);


/***/ }),

/***/ "./node_modules/lodash-es/_baseSortBy.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_baseSortBy.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;

  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseSortBy);


/***/ }),

/***/ "./node_modules/lodash-es/_baseSortedIndex.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_baseSortedIndex.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseSortedIndexBy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseSortedIndexBy.js */ "./node_modules/lodash-es/_baseSortedIndexBy.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./identity.js */ "./node_modules/lodash-es/identity.js");
/* harmony import */ var _isSymbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isSymbol.js */ "./node_modules/lodash-es/isSymbol.js");




/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH = 4294967295,
    HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

/**
 * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
 * performs a binary search of `array` to determine the index at which `value`
 * should be inserted into `array` in order to maintain its sort order.
 *
 * @private
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {boolean} [retHighest] Specify returning the highest qualified index.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 */
function baseSortedIndex(array, value, retHighest) {
  var low = 0,
      high = array == null ? low : array.length;

  if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
    while (low < high) {
      var mid = (low + high) >>> 1,
          computed = array[mid];

      if (computed !== null && !(0,_isSymbol_js__WEBPACK_IMPORTED_MODULE_0__["default"])(computed) &&
          (retHighest ? (computed <= value) : (computed < value))) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    return high;
  }
  return (0,_baseSortedIndexBy_js__WEBPACK_IMPORTED_MODULE_1__["default"])(array, value, _identity_js__WEBPACK_IMPORTED_MODULE_2__["default"], retHighest);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseSortedIndex);


/***/ }),

/***/ "./node_modules/lodash-es/_baseSortedIndexBy.js":
/*!******************************************************!*\
  !*** ./node_modules/lodash-es/_baseSortedIndexBy.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isSymbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isSymbol.js */ "./node_modules/lodash-es/isSymbol.js");


/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH = 4294967295,
    MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeFloor = Math.floor,
    nativeMin = Math.min;

/**
 * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
 * which invokes `iteratee` for `value` and each element of `array` to compute
 * their sort ranking. The iteratee is invoked with one argument; (value).
 *
 * @private
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {Function} iteratee The iteratee invoked per element.
 * @param {boolean} [retHighest] Specify returning the highest qualified index.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 */
function baseSortedIndexBy(array, value, iteratee, retHighest) {
  var low = 0,
      high = array == null ? 0 : array.length;
  if (high === 0) {
    return 0;
  }

  value = iteratee(value);
  var valIsNaN = value !== value,
      valIsNull = value === null,
      valIsSymbol = (0,_isSymbol_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value),
      valIsUndefined = value === undefined;

  while (low < high) {
    var mid = nativeFloor((low + high) / 2),
        computed = iteratee(array[mid]),
        othIsDefined = computed !== undefined,
        othIsNull = computed === null,
        othIsReflexive = computed === computed,
        othIsSymbol = (0,_isSymbol_js__WEBPACK_IMPORTED_MODULE_0__["default"])(computed);

    if (valIsNaN) {
      var setLow = retHighest || othIsReflexive;
    } else if (valIsUndefined) {
      setLow = othIsReflexive && (retHighest || othIsDefined);
    } else if (valIsNull) {
      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
    } else if (valIsSymbol) {
      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
    } else if (othIsNull || othIsSymbol) {
      setLow = false;
    } else {
      setLow = retHighest ? (computed <= value) : (computed < value);
    }
    if (setLow) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return nativeMin(high, MAX_ARRAY_INDEX);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseSortedIndexBy);


/***/ }),

/***/ "./node_modules/lodash-es/_baseTimes.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_baseTimes.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseTimes);


/***/ }),

/***/ "./node_modules/lodash-es/_baseToString.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_baseToString.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Symbol.js */ "./node_modules/lodash-es/_Symbol.js");
/* harmony import */ var _arrayMap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_arrayMap.js */ "./node_modules/lodash-es/_arrayMap.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/lodash-es/isArray.js");
/* harmony import */ var _isSymbol_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isSymbol.js */ "./node_modules/lodash-es/isSymbol.js");





/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if ((0,_isArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return (0,_arrayMap_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value, baseToString) + '';
  }
  if ((0,_isSymbol_js__WEBPACK_IMPORTED_MODULE_3__["default"])(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseToString);


/***/ }),

/***/ "./node_modules/lodash-es/_baseTrim.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_baseTrim.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _trimmedEndIndex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_trimmedEndIndex.js */ "./node_modules/lodash-es/_trimmedEndIndex.js");


/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, (0,_trimmedEndIndex_js__WEBPACK_IMPORTED_MODULE_0__["default"])(string) + 1).replace(reTrimStart, '')
    : string;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseTrim);


/***/ }),

/***/ "./node_modules/lodash-es/_baseUnary.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_baseUnary.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseUnary);


/***/ }),

/***/ "./node_modules/lodash-es/_baseUniq.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_baseUniq.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _SetCache_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_SetCache.js */ "./node_modules/lodash-es/_SetCache.js");
/* harmony import */ var _arrayIncludes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_arrayIncludes.js */ "./node_modules/lodash-es/_arrayIncludes.js");
/* harmony import */ var _arrayIncludesWith_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_arrayIncludesWith.js */ "./node_modules/lodash-es/_arrayIncludesWith.js");
/* harmony import */ var _cacheHas_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_cacheHas.js */ "./node_modules/lodash-es/_cacheHas.js");
/* harmony import */ var _createSet_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_createSet.js */ "./node_modules/lodash-es/_createSet.js");
/* harmony import */ var _setToArray_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_setToArray.js */ "./node_modules/lodash-es/_setToArray.js");







/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = _arrayIncludes_js__WEBPACK_IMPORTED_MODULE_0__["default"],
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = _arrayIncludesWith_js__WEBPACK_IMPORTED_MODULE_1__["default"];
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : (0,_createSet_js__WEBPACK_IMPORTED_MODULE_2__["default"])(array);
    if (set) {
      return (0,_setToArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(set);
    }
    isCommon = false;
    includes = _cacheHas_js__WEBPACK_IMPORTED_MODULE_4__["default"];
    seen = new _SetCache_js__WEBPACK_IMPORTED_MODULE_5__["default"];
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseUniq);


/***/ }),

/***/ "./node_modules/lodash-es/_cacheHas.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_cacheHas.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (cacheHas);


/***/ }),

/***/ "./node_modules/lodash-es/_castPath.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_castPath.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/lodash-es/isArray.js");
/* harmony import */ var _isKey_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isKey.js */ "./node_modules/lodash-es/_isKey.js");
/* harmony import */ var _stringToPath_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_stringToPath.js */ "./node_modules/lodash-es/_stringToPath.js");
/* harmony import */ var _toString_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./toString.js */ "./node_modules/lodash-es/toString.js");





/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if ((0,_isArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value)) {
    return value;
  }
  return (0,_isKey_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value, object) ? [value] : (0,_stringToPath_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_toString_js__WEBPACK_IMPORTED_MODULE_3__["default"])(value));
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (castPath);


/***/ }),

/***/ "./node_modules/lodash-es/_castSlice.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_castSlice.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseSlice_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseSlice.js */ "./node_modules/lodash-es/_baseSlice.js");


/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : (0,_baseSlice_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array, start, end);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (castSlice);


/***/ }),

/***/ "./node_modules/lodash-es/_cloneArrayBuffer.js":
/*!*****************************************************!*\
  !*** ./node_modules/lodash-es/_cloneArrayBuffer.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Uint8Array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Uint8Array.js */ "./node_modules/lodash-es/_Uint8Array.js");


/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new _Uint8Array_js__WEBPACK_IMPORTED_MODULE_0__["default"](result).set(new _Uint8Array_js__WEBPACK_IMPORTED_MODULE_0__["default"](arrayBuffer));
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (cloneArrayBuffer);


/***/ }),

/***/ "./node_modules/lodash-es/_cloneBuffer.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_cloneBuffer.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");


/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? _root_js__WEBPACK_IMPORTED_MODULE_0__["default"].Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (cloneBuffer);


/***/ }),

/***/ "./node_modules/lodash-es/_cloneDataView.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_cloneDataView.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cloneArrayBuffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cloneArrayBuffer.js */ "./node_modules/lodash-es/_cloneArrayBuffer.js");


/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? (0,_cloneArrayBuffer_js__WEBPACK_IMPORTED_MODULE_0__["default"])(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (cloneDataView);


/***/ }),

/***/ "./node_modules/lodash-es/_cloneRegExp.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_cloneRegExp.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (cloneRegExp);


/***/ }),

/***/ "./node_modules/lodash-es/_cloneSymbol.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_cloneSymbol.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Symbol.js */ "./node_modules/lodash-es/_Symbol.js");


/** Used to convert symbols to primitives and strings. */
var symbolProto = _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (cloneSymbol);


/***/ }),

/***/ "./node_modules/lodash-es/_cloneTypedArray.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_cloneTypedArray.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cloneArrayBuffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cloneArrayBuffer.js */ "./node_modules/lodash-es/_cloneArrayBuffer.js");


/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? (0,_cloneArrayBuffer_js__WEBPACK_IMPORTED_MODULE_0__["default"])(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (cloneTypedArray);


/***/ }),

/***/ "./node_modules/lodash-es/_compareAscending.js":
/*!*****************************************************!*\
  !*** ./node_modules/lodash-es/_compareAscending.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isSymbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isSymbol.js */ "./node_modules/lodash-es/isSymbol.js");


/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = (0,_isSymbol_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value);

    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = (0,_isSymbol_js__WEBPACK_IMPORTED_MODULE_0__["default"])(other);

    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
        (valIsNull && othIsDefined && othIsReflexive) ||
        (!valIsDefined && othIsReflexive) ||
        !valIsReflexive) {
      return 1;
    }
    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
        (othIsNull && valIsDefined && valIsReflexive) ||
        (!othIsDefined && valIsReflexive) ||
        !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (compareAscending);


/***/ }),

/***/ "./node_modules/lodash-es/_compareMultiple.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_compareMultiple.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _compareAscending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_compareAscending.js */ "./node_modules/lodash-es/_compareAscending.js");


/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */
function compareMultiple(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = (0,_compareAscending_js__WEBPACK_IMPORTED_MODULE_0__["default"])(objCriteria[index], othCriteria[index]);
    if (result) {
      if (index >= ordersLength) {
        return result;
      }
      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  }
  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
  return object.index - other.index;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (compareMultiple);


/***/ }),

/***/ "./node_modules/lodash-es/_copyArray.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_copyArray.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (copyArray);


/***/ }),

/***/ "./node_modules/lodash-es/_copyObject.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_copyObject.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _assignValue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assignValue.js */ "./node_modules/lodash-es/_assignValue.js");
/* harmony import */ var _baseAssignValue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseAssignValue.js */ "./node_modules/lodash-es/_baseAssignValue.js");



/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      (0,_baseAssignValue_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, key, newValue);
    } else {
      (0,_assignValue_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, key, newValue);
    }
  }
  return object;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (copyObject);


/***/ }),

/***/ "./node_modules/lodash-es/_copySymbols.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_copySymbols.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _copyObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_copyObject.js */ "./node_modules/lodash-es/_copyObject.js");
/* harmony import */ var _getSymbols_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getSymbols.js */ "./node_modules/lodash-es/_getSymbols.js");



/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return (0,_copyObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(source, (0,_getSymbols_js__WEBPACK_IMPORTED_MODULE_1__["default"])(source), object);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (copySymbols);


/***/ }),

/***/ "./node_modules/lodash-es/_copySymbolsIn.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_copySymbolsIn.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _copyObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_copyObject.js */ "./node_modules/lodash-es/_copyObject.js");
/* harmony import */ var _getSymbolsIn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getSymbolsIn.js */ "./node_modules/lodash-es/_getSymbolsIn.js");



/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return (0,_copyObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(source, (0,_getSymbolsIn_js__WEBPACK_IMPORTED_MODULE_1__["default"])(source), object);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (copySymbolsIn);


/***/ }),

/***/ "./node_modules/lodash-es/_coreJsData.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_coreJsData.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");


/** Used to detect overreaching core-js shims. */
var coreJsData = _root_js__WEBPACK_IMPORTED_MODULE_0__["default"]['__core-js_shared__'];

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (coreJsData);


/***/ }),

/***/ "./node_modules/lodash-es/_createAggregator.js":
/*!*****************************************************!*\
  !*** ./node_modules/lodash-es/_createAggregator.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _arrayAggregator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_arrayAggregator.js */ "./node_modules/lodash-es/_arrayAggregator.js");
/* harmony import */ var _baseAggregator_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseAggregator.js */ "./node_modules/lodash-es/_baseAggregator.js");
/* harmony import */ var _baseIteratee_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_baseIteratee.js */ "./node_modules/lodash-es/_baseIteratee.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/lodash-es/isArray.js");





/**
 * Creates a function like `_.groupBy`.
 *
 * @private
 * @param {Function} setter The function to set accumulator values.
 * @param {Function} [initializer] The accumulator object initializer.
 * @returns {Function} Returns the new aggregator function.
 */
function createAggregator(setter, initializer) {
  return function(collection, iteratee) {
    var func = (0,_isArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(collection) ? _arrayAggregator_js__WEBPACK_IMPORTED_MODULE_1__["default"] : _baseAggregator_js__WEBPACK_IMPORTED_MODULE_2__["default"],
        accumulator = initializer ? initializer() : {};

    return func(collection, setter, (0,_baseIteratee_js__WEBPACK_IMPORTED_MODULE_3__["default"])(iteratee, 2), accumulator);
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createAggregator);


/***/ }),

/***/ "./node_modules/lodash-es/_createAssigner.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_createAssigner.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseRest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseRest.js */ "./node_modules/lodash-es/_baseRest.js");
/* harmony import */ var _isIterateeCall_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isIterateeCall.js */ "./node_modules/lodash-es/_isIterateeCall.js");



/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return (0,_baseRest_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && (0,_isIterateeCall_js__WEBPACK_IMPORTED_MODULE_1__["default"])(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createAssigner);


/***/ }),

/***/ "./node_modules/lodash-es/_createBaseEach.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_createBaseEach.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArrayLike.js */ "./node_modules/lodash-es/isArrayLike.js");


/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!(0,_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createBaseEach);


/***/ }),

/***/ "./node_modules/lodash-es/_createBaseFor.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_createBaseFor.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createBaseFor);


/***/ }),

/***/ "./node_modules/lodash-es/_createCaseFirst.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_createCaseFirst.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _castSlice_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_castSlice.js */ "./node_modules/lodash-es/_castSlice.js");
/* harmony import */ var _hasUnicode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_hasUnicode.js */ "./node_modules/lodash-es/_hasUnicode.js");
/* harmony import */ var _stringToArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_stringToArray.js */ "./node_modules/lodash-es/_stringToArray.js");
/* harmony import */ var _toString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toString.js */ "./node_modules/lodash-es/toString.js");





/**
 * Creates a function like `_.lowerFirst`.
 *
 * @private
 * @param {string} methodName The name of the `String` case method to use.
 * @returns {Function} Returns the new case function.
 */
function createCaseFirst(methodName) {
  return function(string) {
    string = (0,_toString_js__WEBPACK_IMPORTED_MODULE_0__["default"])(string);

    var strSymbols = (0,_hasUnicode_js__WEBPACK_IMPORTED_MODULE_1__["default"])(string)
      ? (0,_stringToArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(string)
      : undefined;

    var chr = strSymbols
      ? strSymbols[0]
      : string.charAt(0);

    var trailing = strSymbols
      ? (0,_castSlice_js__WEBPACK_IMPORTED_MODULE_3__["default"])(strSymbols, 1).join('')
      : string.slice(1);

    return chr[methodName]() + trailing;
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createCaseFirst);


/***/ }),

/***/ "./node_modules/lodash-es/_createCompounder.js":
/*!*****************************************************!*\
  !*** ./node_modules/lodash-es/_createCompounder.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _arrayReduce_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_arrayReduce.js */ "./node_modules/lodash-es/_arrayReduce.js");
/* harmony import */ var _deburr_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./deburr.js */ "./node_modules/lodash-es/deburr.js");
/* harmony import */ var _words_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./words.js */ "./node_modules/lodash-es/words.js");




/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]";

/** Used to match apostrophes. */
var reApos = RegExp(rsApos, 'g');

/**
 * Creates a function like `_.camelCase`.
 *
 * @private
 * @param {Function} callback The function to combine each word.
 * @returns {Function} Returns the new compounder function.
 */
function createCompounder(callback) {
  return function(string) {
    return (0,_arrayReduce_js__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_words_js__WEBPACK_IMPORTED_MODULE_1__["default"])((0,_deburr_js__WEBPACK_IMPORTED_MODULE_2__["default"])(string).replace(reApos, '')), callback, '');
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createCompounder);


/***/ }),

/***/ "./node_modules/lodash-es/_createSet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_createSet.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Set_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Set.js */ "./node_modules/lodash-es/_Set.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./noop.js */ "./node_modules/lodash-es/noop.js");
/* harmony import */ var _setToArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_setToArray.js */ "./node_modules/lodash-es/_setToArray.js");




/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(_Set_js__WEBPACK_IMPORTED_MODULE_0__["default"] && (1 / (0,_setToArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(new _Set_js__WEBPACK_IMPORTED_MODULE_0__["default"]([,-0]))[1]) == INFINITY) ? _noop_js__WEBPACK_IMPORTED_MODULE_2__["default"] : function(values) {
  return new _Set_js__WEBPACK_IMPORTED_MODULE_0__["default"](values);
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createSet);


/***/ }),

/***/ "./node_modules/lodash-es/_customDefaultsMerge.js":
/*!********************************************************!*\
  !*** ./node_modules/lodash-es/_customDefaultsMerge.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseMerge_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseMerge.js */ "./node_modules/lodash-es/_baseMerge.js");
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/lodash-es/isObject.js");



/**
 * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
 * objects into destination objects that are passed thru.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to merge.
 * @param {Object} object The parent object of `objValue`.
 * @param {Object} source The parent object of `srcValue`.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 * @returns {*} Returns the value to assign.
 */
function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
  if ((0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(objValue) && (0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(srcValue)) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, objValue);
    (0,_baseMerge_js__WEBPACK_IMPORTED_MODULE_1__["default"])(objValue, srcValue, undefined, customDefaultsMerge, stack);
    stack['delete'](srcValue);
  }
  return objValue;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (customDefaultsMerge);


/***/ }),

/***/ "./node_modules/lodash-es/_deburrLetter.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_deburrLetter.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basePropertyOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_basePropertyOf.js */ "./node_modules/lodash-es/_basePropertyOf.js");


/** Used to map Latin Unicode letters to basic Latin letters. */
var deburredLetters = {
  // Latin-1 Supplement block.
  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
  '\xc7': 'C',  '\xe7': 'c',
  '\xd0': 'D',  '\xf0': 'd',
  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
  '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
  '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
  '\xd1': 'N',  '\xf1': 'n',
  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
  '\xc6': 'Ae', '\xe6': 'ae',
  '\xde': 'Th', '\xfe': 'th',
  '\xdf': 'ss',
  // Latin Extended-A block.
  '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
  '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
  '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
  '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
  '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
  '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
  '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
  '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
  '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
  '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
  '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
  '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
  '\u0134': 'J',  '\u0135': 'j',
  '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
  '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
  '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
  '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
  '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
  '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
  '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
  '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
  '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
  '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
  '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
  '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
  '\u0163': 't',  '\u0165': 't', '\u0167': 't',
  '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
  '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
  '\u0174': 'W',  '\u0175': 'w',
  '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
  '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
  '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
  '\u0132': 'IJ', '\u0133': 'ij',
  '\u0152': 'Oe', '\u0153': 'oe',
  '\u0149': "'n", '\u017f': 's'
};

/**
 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
 * letters to basic Latin letters.
 *
 * @private
 * @param {string} letter The matched letter to deburr.
 * @returns {string} Returns the deburred letter.
 */
var deburrLetter = (0,_basePropertyOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(deburredLetters);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (deburrLetter);


/***/ }),

/***/ "./node_modules/lodash-es/_defineProperty.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_defineProperty.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getNative.js */ "./node_modules/lodash-es/_getNative.js");


var defineProperty = (function() {
  try {
    var func = (0,_getNative_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (defineProperty);


/***/ }),

/***/ "./node_modules/lodash-es/_equalArrays.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_equalArrays.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _SetCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_SetCache.js */ "./node_modules/lodash-es/_SetCache.js");
/* harmony import */ var _arraySome_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_arraySome.js */ "./node_modules/lodash-es/_arraySome.js");
/* harmony import */ var _cacheHas_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_cacheHas.js */ "./node_modules/lodash-es/_cacheHas.js");




/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Check that cyclic values are equal.
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new _SetCache_js__WEBPACK_IMPORTED_MODULE_0__["default"] : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!(0,_arraySome_js__WEBPACK_IMPORTED_MODULE_1__["default"])(other, function(othValue, othIndex) {
            if (!(0,_cacheHas_js__WEBPACK_IMPORTED_MODULE_2__["default"])(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (equalArrays);


/***/ }),

/***/ "./node_modules/lodash-es/_equalByTag.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_equalByTag.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Symbol.js */ "./node_modules/lodash-es/_Symbol.js");
/* harmony import */ var _Uint8Array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_Uint8Array.js */ "./node_modules/lodash-es/_Uint8Array.js");
/* harmony import */ var _eq_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./eq.js */ "./node_modules/lodash-es/eq.js");
/* harmony import */ var _equalArrays_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_equalArrays.js */ "./node_modules/lodash-es/_equalArrays.js");
/* harmony import */ var _mapToArray_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_mapToArray.js */ "./node_modules/lodash-es/_mapToArray.js");
/* harmony import */ var _setToArray_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_setToArray.js */ "./node_modules/lodash-es/_setToArray.js");







/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new _Uint8Array_js__WEBPACK_IMPORTED_MODULE_1__["default"](object), new _Uint8Array_js__WEBPACK_IMPORTED_MODULE_1__["default"](other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return (0,_eq_js__WEBPACK_IMPORTED_MODULE_2__["default"])(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = _mapToArray_js__WEBPACK_IMPORTED_MODULE_3__["default"];

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = _setToArray_js__WEBPACK_IMPORTED_MODULE_4__["default"]);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = (0,_equalArrays_js__WEBPACK_IMPORTED_MODULE_5__["default"])(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (equalByTag);


/***/ }),

/***/ "./node_modules/lodash-es/_equalObjects.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_equalObjects.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getAllKeys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getAllKeys.js */ "./node_modules/lodash-es/_getAllKeys.js");


/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = (0,_getAllKeys_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object),
      objLength = objProps.length,
      othProps = (0,_getAllKeys_js__WEBPACK_IMPORTED_MODULE_0__["default"])(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Check that cyclic values are equal.
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (equalObjects);


/***/ }),

/***/ "./node_modules/lodash-es/_flatRest.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_flatRest.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _flatten_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./flatten.js */ "./node_modules/lodash-es/flatten.js");
/* harmony import */ var _overRest_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_overRest.js */ "./node_modules/lodash-es/_overRest.js");
/* harmony import */ var _setToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_setToString.js */ "./node_modules/lodash-es/_setToString.js");




/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
function flatRest(func) {
  return (0,_setToString_js__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_overRest_js__WEBPACK_IMPORTED_MODULE_1__["default"])(func, undefined, _flatten_js__WEBPACK_IMPORTED_MODULE_2__["default"]), func + '');
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (flatRest);


/***/ }),

/***/ "./node_modules/lodash-es/_freeGlobal.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_freeGlobal.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (freeGlobal);


/***/ }),

/***/ "./node_modules/lodash-es/_getAllKeys.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_getAllKeys.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGetAllKeys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseGetAllKeys.js */ "./node_modules/lodash-es/_baseGetAllKeys.js");
/* harmony import */ var _getSymbols_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_getSymbols.js */ "./node_modules/lodash-es/_getSymbols.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys.js */ "./node_modules/lodash-es/keys.js");




/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return (0,_baseGetAllKeys_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, _keys_js__WEBPACK_IMPORTED_MODULE_1__["default"], _getSymbols_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getAllKeys);


/***/ }),

/***/ "./node_modules/lodash-es/_getAllKeysIn.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_getAllKeysIn.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGetAllKeys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseGetAllKeys.js */ "./node_modules/lodash-es/_baseGetAllKeys.js");
/* harmony import */ var _getSymbolsIn_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_getSymbolsIn.js */ "./node_modules/lodash-es/_getSymbolsIn.js");
/* harmony import */ var _keysIn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keysIn.js */ "./node_modules/lodash-es/keysIn.js");




/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return (0,_baseGetAllKeys_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, _keysIn_js__WEBPACK_IMPORTED_MODULE_1__["default"], _getSymbolsIn_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getAllKeysIn);


/***/ }),

/***/ "./node_modules/lodash-es/_getMapData.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_getMapData.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isKeyable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isKeyable.js */ "./node_modules/lodash-es/_isKeyable.js");


/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return (0,_isKeyable_js__WEBPACK_IMPORTED_MODULE_0__["default"])(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getMapData);


/***/ }),

/***/ "./node_modules/lodash-es/_getMatchData.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_getMatchData.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isStrictComparable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isStrictComparable.js */ "./node_modules/lodash-es/_isStrictComparable.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keys.js */ "./node_modules/lodash-es/keys.js");



/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = (0,_keys_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, (0,_isStrictComparable_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value)];
  }
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getMatchData);


/***/ }),

/***/ "./node_modules/lodash-es/_getNative.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_getNative.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseIsNative_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseIsNative.js */ "./node_modules/lodash-es/_baseIsNative.js");
/* harmony import */ var _getValue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getValue.js */ "./node_modules/lodash-es/_getValue.js");



/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = (0,_getValue_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, key);
  return (0,_baseIsNative_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) ? value : undefined;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getNative);


/***/ }),

/***/ "./node_modules/lodash-es/_getPrototype.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_getPrototype.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _overArg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_overArg.js */ "./node_modules/lodash-es/_overArg.js");


/** Built-in value references. */
var getPrototype = (0,_overArg_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Object.getPrototypeOf, Object);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getPrototype);


/***/ }),

/***/ "./node_modules/lodash-es/_getRawTag.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_getRawTag.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Symbol.js */ "./node_modules/lodash-es/_Symbol.js");


/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"].toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getRawTag);


/***/ }),

/***/ "./node_modules/lodash-es/_getSymbols.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_getSymbols.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _arrayFilter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_arrayFilter.js */ "./node_modules/lodash-es/_arrayFilter.js");
/* harmony import */ var _stubArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stubArray.js */ "./node_modules/lodash-es/stubArray.js");



/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? _stubArray_js__WEBPACK_IMPORTED_MODULE_0__["default"] : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return (0,_arrayFilter_js__WEBPACK_IMPORTED_MODULE_1__["default"])(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getSymbols);


/***/ }),

/***/ "./node_modules/lodash-es/_getSymbolsIn.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_getSymbolsIn.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _arrayPush_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_arrayPush.js */ "./node_modules/lodash-es/_arrayPush.js");
/* harmony import */ var _getPrototype_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_getPrototype.js */ "./node_modules/lodash-es/_getPrototype.js");
/* harmony import */ var _getSymbols_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_getSymbols.js */ "./node_modules/lodash-es/_getSymbols.js");
/* harmony import */ var _stubArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stubArray.js */ "./node_modules/lodash-es/stubArray.js");





/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? _stubArray_js__WEBPACK_IMPORTED_MODULE_0__["default"] : function(object) {
  var result = [];
  while (object) {
    (0,_arrayPush_js__WEBPACK_IMPORTED_MODULE_1__["default"])(result, (0,_getSymbols_js__WEBPACK_IMPORTED_MODULE_2__["default"])(object));
    object = (0,_getPrototype_js__WEBPACK_IMPORTED_MODULE_3__["default"])(object);
  }
  return result;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getSymbolsIn);


/***/ }),

/***/ "./node_modules/lodash-es/_getTag.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/_getTag.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _DataView_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_DataView.js */ "./node_modules/lodash-es/_DataView.js");
/* harmony import */ var _Map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_Map.js */ "./node_modules/lodash-es/_Map.js");
/* harmony import */ var _Promise_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_Promise.js */ "./node_modules/lodash-es/_Promise.js");
/* harmony import */ var _Set_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_Set.js */ "./node_modules/lodash-es/_Set.js");
/* harmony import */ var _WeakMap_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_WeakMap.js */ "./node_modules/lodash-es/_WeakMap.js");
/* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_baseGetTag.js */ "./node_modules/lodash-es/_baseGetTag.js");
/* harmony import */ var _toSource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_toSource.js */ "./node_modules/lodash-es/_toSource.js");








/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = (0,_toSource_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_DataView_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
    mapCtorString = (0,_toSource_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_Map_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
    promiseCtorString = (0,_toSource_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_Promise_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
    setCtorString = (0,_toSource_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_Set_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
    weakMapCtorString = (0,_toSource_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_WeakMap_js__WEBPACK_IMPORTED_MODULE_5__["default"]);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = _baseGetTag_js__WEBPACK_IMPORTED_MODULE_6__["default"];

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((_DataView_js__WEBPACK_IMPORTED_MODULE_1__["default"] && getTag(new _DataView_js__WEBPACK_IMPORTED_MODULE_1__["default"](new ArrayBuffer(1))) != dataViewTag) ||
    (_Map_js__WEBPACK_IMPORTED_MODULE_2__["default"] && getTag(new _Map_js__WEBPACK_IMPORTED_MODULE_2__["default"]) != mapTag) ||
    (_Promise_js__WEBPACK_IMPORTED_MODULE_3__["default"] && getTag(_Promise_js__WEBPACK_IMPORTED_MODULE_3__["default"].resolve()) != promiseTag) ||
    (_Set_js__WEBPACK_IMPORTED_MODULE_4__["default"] && getTag(new _Set_js__WEBPACK_IMPORTED_MODULE_4__["default"]) != setTag) ||
    (_WeakMap_js__WEBPACK_IMPORTED_MODULE_5__["default"] && getTag(new _WeakMap_js__WEBPACK_IMPORTED_MODULE_5__["default"]) != weakMapTag)) {
  getTag = function(value) {
    var result = (0,_baseGetTag_js__WEBPACK_IMPORTED_MODULE_6__["default"])(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? (0,_toSource_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getTag);


/***/ }),

/***/ "./node_modules/lodash-es/_getValue.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_getValue.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getValue);


/***/ }),

/***/ "./node_modules/lodash-es/_hasPath.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_hasPath.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _castPath_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_castPath.js */ "./node_modules/lodash-es/_castPath.js");
/* harmony import */ var _isArguments_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./isArguments.js */ "./node_modules/lodash-es/isArguments.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/lodash-es/isArray.js");
/* harmony import */ var _isIndex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_isIndex.js */ "./node_modules/lodash-es/_isIndex.js");
/* harmony import */ var _isLength_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isLength.js */ "./node_modules/lodash-es/isLength.js");
/* harmony import */ var _toKey_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_toKey.js */ "./node_modules/lodash-es/_toKey.js");







/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = (0,_castPath_js__WEBPACK_IMPORTED_MODULE_0__["default"])(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = (0,_toKey_js__WEBPACK_IMPORTED_MODULE_1__["default"])(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && (0,_isLength_js__WEBPACK_IMPORTED_MODULE_2__["default"])(length) && (0,_isIndex_js__WEBPACK_IMPORTED_MODULE_3__["default"])(key, length) &&
    ((0,_isArray_js__WEBPACK_IMPORTED_MODULE_4__["default"])(object) || (0,_isArguments_js__WEBPACK_IMPORTED_MODULE_5__["default"])(object));
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hasPath);


/***/ }),

/***/ "./node_modules/lodash-es/_hasUnicode.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_hasUnicode.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hasUnicode);


/***/ }),

/***/ "./node_modules/lodash-es/_hasUnicodeWord.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_hasUnicodeWord.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used to detect strings that need a more robust regexp to match words. */
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

/**
 * Checks if `string` contains a word composed of Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a word is found, else `false`.
 */
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hasUnicodeWord);


/***/ }),

/***/ "./node_modules/lodash-es/_hashClear.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_hashClear.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _nativeCreate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_nativeCreate.js */ "./node_modules/lodash-es/_nativeCreate.js");


/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = _nativeCreate_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? (0,_nativeCreate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(null) : {};
  this.size = 0;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hashClear);


/***/ }),

/***/ "./node_modules/lodash-es/_hashDelete.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_hashDelete.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hashDelete);


/***/ }),

/***/ "./node_modules/lodash-es/_hashGet.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_hashGet.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _nativeCreate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_nativeCreate.js */ "./node_modules/lodash-es/_nativeCreate.js");


/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (_nativeCreate_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hashGet);


/***/ }),

/***/ "./node_modules/lodash-es/_hashHas.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_hashHas.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _nativeCreate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_nativeCreate.js */ "./node_modules/lodash-es/_nativeCreate.js");


/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return _nativeCreate_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hashHas);


/***/ }),

/***/ "./node_modules/lodash-es/_hashSet.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_hashSet.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _nativeCreate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_nativeCreate.js */ "./node_modules/lodash-es/_nativeCreate.js");


/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (_nativeCreate_js__WEBPACK_IMPORTED_MODULE_0__["default"] && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hashSet);


/***/ }),

/***/ "./node_modules/lodash-es/_initCloneArray.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_initCloneArray.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (initCloneArray);


/***/ }),

/***/ "./node_modules/lodash-es/_initCloneByTag.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_initCloneByTag.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cloneArrayBuffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_cloneArrayBuffer.js */ "./node_modules/lodash-es/_cloneArrayBuffer.js");
/* harmony import */ var _cloneDataView_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_cloneDataView.js */ "./node_modules/lodash-es/_cloneDataView.js");
/* harmony import */ var _cloneRegExp_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_cloneRegExp.js */ "./node_modules/lodash-es/_cloneRegExp.js");
/* harmony import */ var _cloneSymbol_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_cloneSymbol.js */ "./node_modules/lodash-es/_cloneSymbol.js");
/* harmony import */ var _cloneTypedArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_cloneTypedArray.js */ "./node_modules/lodash-es/_cloneTypedArray.js");






/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return (0,_cloneArrayBuffer_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return (0,_cloneDataView_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return (0,_cloneTypedArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return (0,_cloneRegExp_js__WEBPACK_IMPORTED_MODULE_3__["default"])(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return (0,_cloneSymbol_js__WEBPACK_IMPORTED_MODULE_4__["default"])(object);
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (initCloneByTag);


/***/ }),

/***/ "./node_modules/lodash-es/_initCloneObject.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_initCloneObject.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseCreate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseCreate.js */ "./node_modules/lodash-es/_baseCreate.js");
/* harmony import */ var _getPrototype_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_getPrototype.js */ "./node_modules/lodash-es/_getPrototype.js");
/* harmony import */ var _isPrototype_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isPrototype.js */ "./node_modules/lodash-es/_isPrototype.js");




/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !(0,_isPrototype_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object))
    ? (0,_baseCreate_js__WEBPACK_IMPORTED_MODULE_1__["default"])((0,_getPrototype_js__WEBPACK_IMPORTED_MODULE_2__["default"])(object))
    : {};
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (initCloneObject);


/***/ }),

/***/ "./node_modules/lodash-es/_isFlattenable.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_isFlattenable.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Symbol.js */ "./node_modules/lodash-es/_Symbol.js");
/* harmony import */ var _isArguments_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isArguments.js */ "./node_modules/lodash-es/isArguments.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/lodash-es/isArray.js");




/** Built-in value references. */
var spreadableSymbol = _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"].isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return (0,_isArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) || (0,_isArguments_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isFlattenable);


/***/ }),

/***/ "./node_modules/lodash-es/_isIndex.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_isIndex.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isIndex);


/***/ }),

/***/ "./node_modules/lodash-es/_isIterateeCall.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_isIterateeCall.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _eq_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./eq.js */ "./node_modules/lodash-es/eq.js");
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArrayLike.js */ "./node_modules/lodash-es/isArrayLike.js");
/* harmony import */ var _isIndex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_isIndex.js */ "./node_modules/lodash-es/_isIndex.js");
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/lodash-es/isObject.js");





/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!(0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? ((0,_isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object) && (0,_isIndex_js__WEBPACK_IMPORTED_MODULE_2__["default"])(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return (0,_eq_js__WEBPACK_IMPORTED_MODULE_3__["default"])(object[index], value);
  }
  return false;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isIterateeCall);


/***/ }),

/***/ "./node_modules/lodash-es/_isKey.js":
/*!******************************************!*\
  !*** ./node_modules/lodash-es/_isKey.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/lodash-es/isArray.js");
/* harmony import */ var _isSymbol_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isSymbol.js */ "./node_modules/lodash-es/isSymbol.js");



/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if ((0,_isArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || (0,_isSymbol_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isKey);


/***/ }),

/***/ "./node_modules/lodash-es/_isKeyable.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_isKeyable.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isKeyable);


/***/ }),

/***/ "./node_modules/lodash-es/_isMasked.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_isMasked.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _coreJsData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_coreJsData.js */ "./node_modules/lodash-es/_coreJsData.js");


/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(_coreJsData_js__WEBPACK_IMPORTED_MODULE_0__["default"] && _coreJsData_js__WEBPACK_IMPORTED_MODULE_0__["default"].keys && _coreJsData_js__WEBPACK_IMPORTED_MODULE_0__["default"].keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isMasked);


/***/ }),

/***/ "./node_modules/lodash-es/_isPrototype.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_isPrototype.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isPrototype);


/***/ }),

/***/ "./node_modules/lodash-es/_isStrictComparable.js":
/*!*******************************************************!*\
  !*** ./node_modules/lodash-es/_isStrictComparable.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/lodash-es/isObject.js");


/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !(0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isStrictComparable);


/***/ }),

/***/ "./node_modules/lodash-es/_listCacheClear.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_listCacheClear.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (listCacheClear);


/***/ }),

/***/ "./node_modules/lodash-es/_listCacheDelete.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_listCacheDelete.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _assocIndexOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assocIndexOf.js */ "./node_modules/lodash-es/_assocIndexOf.js");


/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = (0,_assocIndexOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (listCacheDelete);


/***/ }),

/***/ "./node_modules/lodash-es/_listCacheGet.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_listCacheGet.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _assocIndexOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assocIndexOf.js */ "./node_modules/lodash-es/_assocIndexOf.js");


/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = (0,_assocIndexOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(data, key);

  return index < 0 ? undefined : data[index][1];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (listCacheGet);


/***/ }),

/***/ "./node_modules/lodash-es/_listCacheHas.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_listCacheHas.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _assocIndexOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assocIndexOf.js */ "./node_modules/lodash-es/_assocIndexOf.js");


/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return (0,_assocIndexOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this.__data__, key) > -1;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (listCacheHas);


/***/ }),

/***/ "./node_modules/lodash-es/_listCacheSet.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_listCacheSet.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _assocIndexOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assocIndexOf.js */ "./node_modules/lodash-es/_assocIndexOf.js");


/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = (0,_assocIndexOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (listCacheSet);


/***/ }),

/***/ "./node_modules/lodash-es/_mapCacheClear.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_mapCacheClear.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_Hash.js */ "./node_modules/lodash-es/_Hash.js");
/* harmony import */ var _ListCache_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_ListCache.js */ "./node_modules/lodash-es/_ListCache.js");
/* harmony import */ var _Map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_Map.js */ "./node_modules/lodash-es/_Map.js");




/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new _Hash_js__WEBPACK_IMPORTED_MODULE_0__["default"],
    'map': new (_Map_js__WEBPACK_IMPORTED_MODULE_1__["default"] || _ListCache_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
    'string': new _Hash_js__WEBPACK_IMPORTED_MODULE_0__["default"]
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mapCacheClear);


/***/ }),

/***/ "./node_modules/lodash-es/_mapCacheDelete.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_mapCacheDelete.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getMapData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getMapData.js */ "./node_modules/lodash-es/_getMapData.js");


/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = (0,_getMapData_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mapCacheDelete);


/***/ }),

/***/ "./node_modules/lodash-es/_mapCacheGet.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_mapCacheGet.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getMapData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getMapData.js */ "./node_modules/lodash-es/_getMapData.js");


/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return (0,_getMapData_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this, key).get(key);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mapCacheGet);


/***/ }),

/***/ "./node_modules/lodash-es/_mapCacheHas.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_mapCacheHas.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getMapData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getMapData.js */ "./node_modules/lodash-es/_getMapData.js");


/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return (0,_getMapData_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this, key).has(key);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mapCacheHas);


/***/ }),

/***/ "./node_modules/lodash-es/_mapCacheSet.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_mapCacheSet.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getMapData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getMapData.js */ "./node_modules/lodash-es/_getMapData.js");


/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = (0,_getMapData_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mapCacheSet);


/***/ }),

/***/ "./node_modules/lodash-es/_mapToArray.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_mapToArray.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mapToArray);


/***/ }),

/***/ "./node_modules/lodash-es/_matchesStrictComparable.js":
/*!************************************************************!*\
  !*** ./node_modules/lodash-es/_matchesStrictComparable.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (matchesStrictComparable);


/***/ }),

/***/ "./node_modules/lodash-es/_memoizeCapped.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_memoizeCapped.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _memoize_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./memoize.js */ "./node_modules/lodash-es/memoize.js");


/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = (0,_memoize_js__WEBPACK_IMPORTED_MODULE_0__["default"])(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (memoizeCapped);


/***/ }),

/***/ "./node_modules/lodash-es/_nativeCreate.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_nativeCreate.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getNative_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_getNative.js */ "./node_modules/lodash-es/_getNative.js");


/* Built-in method references that are verified to be native. */
var nativeCreate = (0,_getNative_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Object, 'create');

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (nativeCreate);


/***/ }),

/***/ "./node_modules/lodash-es/_nativeKeys.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_nativeKeys.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _overArg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_overArg.js */ "./node_modules/lodash-es/_overArg.js");


/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = (0,_overArg_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Object.keys, Object);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (nativeKeys);


/***/ }),

/***/ "./node_modules/lodash-es/_nativeKeysIn.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_nativeKeysIn.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (nativeKeysIn);


/***/ }),

/***/ "./node_modules/lodash-es/_nodeUtil.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_nodeUtil.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_freeGlobal.js */ "./node_modules/lodash-es/_freeGlobal.js");


/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__["default"].process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (nodeUtil);


/***/ }),

/***/ "./node_modules/lodash-es/_objectToString.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_objectToString.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (objectToString);


/***/ }),

/***/ "./node_modules/lodash-es/_overArg.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_overArg.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (overArg);


/***/ }),

/***/ "./node_modules/lodash-es/_overRest.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_overRest.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _apply_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_apply.js */ "./node_modules/lodash-es/_apply.js");


/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return (0,_apply_js__WEBPACK_IMPORTED_MODULE_0__["default"])(func, this, otherArgs);
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (overRest);


/***/ }),

/***/ "./node_modules/lodash-es/_root.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/_root.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_freeGlobal.js */ "./node_modules/lodash-es/_freeGlobal.js");


/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__["default"] || freeSelf || Function('return this')();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (root);


/***/ }),

/***/ "./node_modules/lodash-es/_safeGet.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_safeGet.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (safeGet);


/***/ }),

/***/ "./node_modules/lodash-es/_setCacheAdd.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_setCacheAdd.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (setCacheAdd);


/***/ }),

/***/ "./node_modules/lodash-es/_setCacheHas.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_setCacheHas.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (setCacheHas);


/***/ }),

/***/ "./node_modules/lodash-es/_setToArray.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_setToArray.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (setToArray);


/***/ }),

/***/ "./node_modules/lodash-es/_setToString.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_setToString.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseSetToString_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseSetToString.js */ "./node_modules/lodash-es/_baseSetToString.js");
/* harmony import */ var _shortOut_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_shortOut.js */ "./node_modules/lodash-es/_shortOut.js");



/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = (0,_shortOut_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_baseSetToString_js__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (setToString);


/***/ }),

/***/ "./node_modules/lodash-es/_shortOut.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_shortOut.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (shortOut);


/***/ }),

/***/ "./node_modules/lodash-es/_stackClear.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_stackClear.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ListCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_ListCache.js */ "./node_modules/lodash-es/_ListCache.js");


/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new _ListCache_js__WEBPACK_IMPORTED_MODULE_0__["default"];
  this.size = 0;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stackClear);


/***/ }),

/***/ "./node_modules/lodash-es/_stackDelete.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_stackDelete.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stackDelete);


/***/ }),

/***/ "./node_modules/lodash-es/_stackGet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_stackGet.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stackGet);


/***/ }),

/***/ "./node_modules/lodash-es/_stackHas.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_stackHas.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stackHas);


/***/ }),

/***/ "./node_modules/lodash-es/_stackSet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_stackSet.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ListCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_ListCache.js */ "./node_modules/lodash-es/_ListCache.js");
/* harmony import */ var _Map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_Map.js */ "./node_modules/lodash-es/_Map.js");
/* harmony import */ var _MapCache_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_MapCache.js */ "./node_modules/lodash-es/_MapCache.js");




/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof _ListCache_js__WEBPACK_IMPORTED_MODULE_0__["default"]) {
    var pairs = data.__data__;
    if (!_Map_js__WEBPACK_IMPORTED_MODULE_1__["default"] || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new _MapCache_js__WEBPACK_IMPORTED_MODULE_2__["default"](pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stackSet);


/***/ }),

/***/ "./node_modules/lodash-es/_strictIndexOf.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_strictIndexOf.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (strictIndexOf);


/***/ }),

/***/ "./node_modules/lodash-es/_stringToArray.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_stringToArray.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _asciiToArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_asciiToArray.js */ "./node_modules/lodash-es/_asciiToArray.js");
/* harmony import */ var _hasUnicode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_hasUnicode.js */ "./node_modules/lodash-es/_hasUnicode.js");
/* harmony import */ var _unicodeToArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_unicodeToArray.js */ "./node_modules/lodash-es/_unicodeToArray.js");




/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return (0,_hasUnicode_js__WEBPACK_IMPORTED_MODULE_0__["default"])(string)
    ? (0,_unicodeToArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(string)
    : (0,_asciiToArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(string);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringToArray);


/***/ }),

/***/ "./node_modules/lodash-es/_stringToPath.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_stringToPath.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _memoizeCapped_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_memoizeCapped.js */ "./node_modules/lodash-es/_memoizeCapped.js");


/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = (0,_memoizeCapped_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringToPath);


/***/ }),

/***/ "./node_modules/lodash-es/_toKey.js":
/*!******************************************!*\
  !*** ./node_modules/lodash-es/_toKey.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isSymbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isSymbol.js */ "./node_modules/lodash-es/isSymbol.js");


/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || (0,_isSymbol_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (toKey);


/***/ }),

/***/ "./node_modules/lodash-es/_toSource.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_toSource.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (toSource);


/***/ }),

/***/ "./node_modules/lodash-es/_trimmedEndIndex.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_trimmedEndIndex.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (trimmedEndIndex);


/***/ }),

/***/ "./node_modules/lodash-es/_unicodeToArray.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_unicodeToArray.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (unicodeToArray);


/***/ }),

/***/ "./node_modules/lodash-es/_unicodeWords.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_unicodeWords.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsDingbatRange = '\\u2700-\\u27bf',
    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
    rsPunctuationRange = '\\u2000-\\u206f',
    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
    rsVarRange = '\\ufe0e\\ufe0f',
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]",
    rsBreak = '[' + rsBreakRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsDigits = '\\d+',
    rsDingbat = '[' + rsDingbatRange + ']',
    rsLower = '[' + rsLowerRange + ']',
    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsUpper = '[' + rsUpperRange + ']',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
    rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
    rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
    rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
    reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
    rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;

/** Used to match complex or compound words. */
var reUnicodeWord = RegExp([
  rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
  rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
  rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
  rsUpper + '+' + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join('|'), 'g');

/**
 * Splits a Unicode `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (unicodeWords);


/***/ }),

/***/ "./node_modules/lodash-es/camelCase.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/camelCase.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _capitalize_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./capitalize.js */ "./node_modules/lodash-es/capitalize.js");
/* harmony import */ var _createCompounder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createCompounder.js */ "./node_modules/lodash-es/_createCompounder.js");



/**
 * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the camel cased string.
 * @example
 *
 * _.camelCase('Foo Bar');
 * // => 'fooBar'
 *
 * _.camelCase('--foo-bar--');
 * // => 'fooBar'
 *
 * _.camelCase('__FOO_BAR__');
 * // => 'fooBar'
 */
var camelCase = (0,_createCompounder_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(result, word, index) {
  word = word.toLowerCase();
  return result + (index ? (0,_capitalize_js__WEBPACK_IMPORTED_MODULE_1__["default"])(word) : word);
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (camelCase);


/***/ }),

/***/ "./node_modules/lodash-es/capitalize.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/capitalize.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _toString_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toString.js */ "./node_modules/lodash-es/toString.js");
/* harmony import */ var _upperFirst_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./upperFirst.js */ "./node_modules/lodash-es/upperFirst.js");



/**
 * Converts the first character of `string` to upper case and the remaining
 * to lower case.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to capitalize.
 * @returns {string} Returns the capitalized string.
 * @example
 *
 * _.capitalize('FRED');
 * // => 'Fred'
 */
function capitalize(string) {
  return (0,_upperFirst_js__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_toString_js__WEBPACK_IMPORTED_MODULE_1__["default"])(string).toLowerCase());
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (capitalize);


/***/ }),

/***/ "./node_modules/lodash-es/clamp.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/clamp.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseClamp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseClamp.js */ "./node_modules/lodash-es/_baseClamp.js");
/* harmony import */ var _toNumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toNumber.js */ "./node_modules/lodash-es/toNumber.js");



/**
 * Clamps `number` within the inclusive `lower` and `upper` bounds.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Number
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 * @example
 *
 * _.clamp(-10, -5, 5);
 * // => -5
 *
 * _.clamp(10, -5, 5);
 * // => 5
 */
function clamp(number, lower, upper) {
  if (upper === undefined) {
    upper = lower;
    lower = undefined;
  }
  if (upper !== undefined) {
    upper = (0,_toNumber_js__WEBPACK_IMPORTED_MODULE_0__["default"])(upper);
    upper = upper === upper ? upper : 0;
  }
  if (lower !== undefined) {
    lower = (0,_toNumber_js__WEBPACK_IMPORTED_MODULE_0__["default"])(lower);
    lower = lower === lower ? lower : 0;
  }
  return (0,_baseClamp_js__WEBPACK_IMPORTED_MODULE_1__["default"])((0,_toNumber_js__WEBPACK_IMPORTED_MODULE_0__["default"])(number), lower, upper);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (clamp);


/***/ }),

/***/ "./node_modules/lodash-es/clone.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/clone.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseClone_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseClone.js */ "./node_modules/lodash-es/_baseClone.js");


/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return (0,_baseClone_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value, CLONE_SYMBOLS_FLAG);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (clone);


/***/ }),

/***/ "./node_modules/lodash-es/cloneDeep.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/cloneDeep.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseClone_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseClone.js */ "./node_modules/lodash-es/_baseClone.js");


/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return (0,_baseClone_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (cloneDeep);


/***/ }),

/***/ "./node_modules/lodash-es/constant.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/constant.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (constant);


/***/ }),

/***/ "./node_modules/lodash-es/debounce.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/debounce.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/lodash-es/isObject.js");
/* harmony import */ var _now_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./now.js */ "./node_modules/lodash-es/now.js");
/* harmony import */ var _toNumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toNumber.js */ "./node_modules/lodash-es/toNumber.js");




/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = (0,_toNumber_js__WEBPACK_IMPORTED_MODULE_0__["default"])(wait) || 0;
  if ((0,_isObject_js__WEBPACK_IMPORTED_MODULE_1__["default"])(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax((0,_toNumber_js__WEBPACK_IMPORTED_MODULE_0__["default"])(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = (0,_now_js__WEBPACK_IMPORTED_MODULE_2__["default"])();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge((0,_now_js__WEBPACK_IMPORTED_MODULE_2__["default"])());
  }

  function debounced() {
    var time = (0,_now_js__WEBPACK_IMPORTED_MODULE_2__["default"])(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (debounce);


/***/ }),

/***/ "./node_modules/lodash-es/deburr.js":
/*!******************************************!*\
  !*** ./node_modules/lodash-es/deburr.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _deburrLetter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_deburrLetter.js */ "./node_modules/lodash-es/_deburrLetter.js");
/* harmony import */ var _toString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toString.js */ "./node_modules/lodash-es/toString.js");



/** Used to match Latin Unicode letters (excluding mathematical operators). */
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

/** Used to compose unicode character classes. */
var rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;

/** Used to compose unicode capture groups. */
var rsCombo = '[' + rsComboRange + ']';

/**
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
 */
var reComboMark = RegExp(rsCombo, 'g');

/**
 * Deburrs `string` by converting
 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
 * letters to basic Latin letters and removing
 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to deburr.
 * @returns {string} Returns the deburred string.
 * @example
 *
 * _.deburr('déjà vu');
 * // => 'deja vu'
 */
function deburr(string) {
  string = (0,_toString_js__WEBPACK_IMPORTED_MODULE_0__["default"])(string);
  return string && string.replace(reLatin, _deburrLetter_js__WEBPACK_IMPORTED_MODULE_1__["default"]).replace(reComboMark, '');
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (deburr);


/***/ }),

/***/ "./node_modules/lodash-es/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/defaults.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseRest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseRest.js */ "./node_modules/lodash-es/_baseRest.js");
/* harmony import */ var _eq_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./eq.js */ "./node_modules/lodash-es/eq.js");
/* harmony import */ var _isIterateeCall_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isIterateeCall.js */ "./node_modules/lodash-es/_isIterateeCall.js");
/* harmony import */ var _keysIn_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keysIn.js */ "./node_modules/lodash-es/keysIn.js");





/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns own and inherited enumerable string keyed properties of source
 * objects to the destination object for all destination properties that
 * resolve to `undefined`. Source objects are applied from left to right.
 * Once a property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaultsDeep
 * @example
 *
 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var defaults = (0,_baseRest_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(object, sources) {
  object = Object(object);

  var index = -1;
  var length = sources.length;
  var guard = length > 2 ? sources[2] : undefined;

  if (guard && (0,_isIterateeCall_js__WEBPACK_IMPORTED_MODULE_1__["default"])(sources[0], sources[1], guard)) {
    length = 1;
  }

  while (++index < length) {
    var source = sources[index];
    var props = (0,_keysIn_js__WEBPACK_IMPORTED_MODULE_2__["default"])(source);
    var propsIndex = -1;
    var propsLength = props.length;

    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value = object[key];

      if (value === undefined ||
          ((0,_eq_js__WEBPACK_IMPORTED_MODULE_3__["default"])(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        object[key] = source[key];
      }
    }
  }

  return object;
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (defaults);


/***/ }),

/***/ "./node_modules/lodash-es/defaultsDeep.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/defaultsDeep.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _apply_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_apply.js */ "./node_modules/lodash-es/_apply.js");
/* harmony import */ var _baseRest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseRest.js */ "./node_modules/lodash-es/_baseRest.js");
/* harmony import */ var _customDefaultsMerge_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_customDefaultsMerge.js */ "./node_modules/lodash-es/_customDefaultsMerge.js");
/* harmony import */ var _mergeWith_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mergeWith.js */ "./node_modules/lodash-es/mergeWith.js");





/**
 * This method is like `_.defaults` except that it recursively assigns
 * default properties.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaults
 * @example
 *
 * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
 * // => { 'a': { 'b': 2, 'c': 3 } }
 */
var defaultsDeep = (0,_baseRest_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(args) {
  args.push(undefined, _customDefaultsMerge_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
  return (0,_apply_js__WEBPACK_IMPORTED_MODULE_2__["default"])(_mergeWith_js__WEBPACK_IMPORTED_MODULE_3__["default"], undefined, args);
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (defaultsDeep);


/***/ }),

/***/ "./node_modules/lodash-es/difference.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/difference.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseDifference_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseDifference.js */ "./node_modules/lodash-es/_baseDifference.js");
/* harmony import */ var _baseFlatten_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_baseFlatten.js */ "./node_modules/lodash-es/_baseFlatten.js");
/* harmony import */ var _baseRest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseRest.js */ "./node_modules/lodash-es/_baseRest.js");
/* harmony import */ var _isArrayLikeObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArrayLikeObject.js */ "./node_modules/lodash-es/isArrayLikeObject.js");





/**
 * Creates an array of `array` values not included in the other given arrays
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. The order and references of result values are
 * determined by the first array.
 *
 * **Note:** Unlike `_.pullAll`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.without, _.xor
 * @example
 *
 * _.difference([2, 1], [2, 3]);
 * // => [1]
 */
var difference = (0,_baseRest_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(array, values) {
  return (0,_isArrayLikeObject_js__WEBPACK_IMPORTED_MODULE_1__["default"])(array)
    ? (0,_baseDifference_js__WEBPACK_IMPORTED_MODULE_2__["default"])(array, (0,_baseFlatten_js__WEBPACK_IMPORTED_MODULE_3__["default"])(values, 1, _isArrayLikeObject_js__WEBPACK_IMPORTED_MODULE_1__["default"], true))
    : [];
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (difference);


/***/ }),

/***/ "./node_modules/lodash-es/eq.js":
/*!**************************************!*\
  !*** ./node_modules/lodash-es/eq.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (eq);


/***/ }),

/***/ "./node_modules/lodash-es/flatten.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/flatten.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseFlatten_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseFlatten.js */ "./node_modules/lodash-es/_baseFlatten.js");


/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? (0,_baseFlatten_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array, 1) : [];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (flatten);


/***/ }),

/***/ "./node_modules/lodash-es/get.js":
/*!***************************************!*\
  !*** ./node_modules/lodash-es/get.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseGet.js */ "./node_modules/lodash-es/_baseGet.js");


/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : (0,_baseGet_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, path);
  return result === undefined ? defaultValue : result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (get);


/***/ }),

/***/ "./node_modules/lodash-es/groupBy.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/groupBy.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseAssignValue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseAssignValue.js */ "./node_modules/lodash-es/_baseAssignValue.js");
/* harmony import */ var _createAggregator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createAggregator.js */ "./node_modules/lodash-es/_createAggregator.js");



/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an object composed of keys generated from the results of running
 * each element of `collection` thru `iteratee`. The order of grouped values
 * is determined by the order they occur in `collection`. The corresponding
 * value of each key is an array of elements responsible for generating the
 * key. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
 * @returns {Object} Returns the composed aggregate object.
 * @example
 *
 * _.groupBy([6.1, 4.2, 6.3], Math.floor);
 * // => { '4': [4.2], '6': [6.1, 6.3] }
 *
 * // The `_.property` iteratee shorthand.
 * _.groupBy(['one', 'two', 'three'], 'length');
 * // => { '3': ['one', 'two'], '5': ['three'] }
 */
var groupBy = (0,_createAggregator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(result, value, key) {
  if (hasOwnProperty.call(result, key)) {
    result[key].push(value);
  } else {
    (0,_baseAssignValue_js__WEBPACK_IMPORTED_MODULE_1__["default"])(result, key, [value]);
  }
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (groupBy);


/***/ }),

/***/ "./node_modules/lodash-es/has.js":
/*!***************************************!*\
  !*** ./node_modules/lodash-es/has.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseHas_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseHas.js */ "./node_modules/lodash-es/_baseHas.js");
/* harmony import */ var _hasPath_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_hasPath.js */ "./node_modules/lodash-es/_hasPath.js");



/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */
function has(object, path) {
  return object != null && (0,_hasPath_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, path, _baseHas_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (has);


/***/ }),

/***/ "./node_modules/lodash-es/hasIn.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/hasIn.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseHasIn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseHasIn.js */ "./node_modules/lodash-es/_baseHasIn.js");
/* harmony import */ var _hasPath_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_hasPath.js */ "./node_modules/lodash-es/_hasPath.js");



/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && (0,_hasPath_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object, path, _baseHasIn_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hasIn);


/***/ }),

/***/ "./node_modules/lodash-es/identity.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/identity.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (identity);


/***/ }),

/***/ "./node_modules/lodash-es/isArguments.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/isArguments.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseIsArguments_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseIsArguments.js */ "./node_modules/lodash-es/_baseIsArguments.js");
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isObjectLike.js */ "./node_modules/lodash-es/isObjectLike.js");



/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = (0,_baseIsArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function() { return arguments; }()) ? _baseIsArguments_js__WEBPACK_IMPORTED_MODULE_0__["default"] : function(value) {
  return (0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isArguments);


/***/ }),

/***/ "./node_modules/lodash-es/isArray.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/isArray.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isArray);


/***/ }),

/***/ "./node_modules/lodash-es/isArrayLike.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/isArrayLike.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isFunction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isFunction.js */ "./node_modules/lodash-es/isFunction.js");
/* harmony import */ var _isLength_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isLength.js */ "./node_modules/lodash-es/isLength.js");



/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && (0,_isLength_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value.length) && !(0,_isFunction_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isArrayLike);


/***/ }),

/***/ "./node_modules/lodash-es/isArrayLikeObject.js":
/*!*****************************************************!*\
  !*** ./node_modules/lodash-es/isArrayLikeObject.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArrayLike.js */ "./node_modules/lodash-es/isArrayLike.js");
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObjectLike.js */ "./node_modules/lodash-es/isObjectLike.js");



/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return (0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && (0,_isArrayLike_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isArrayLikeObject);


/***/ }),

/***/ "./node_modules/lodash-es/isBuffer.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/isBuffer.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");
/* harmony import */ var _stubFalse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stubFalse.js */ "./node_modules/lodash-es/stubFalse.js");



/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? _root_js__WEBPACK_IMPORTED_MODULE_0__["default"].Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || _stubFalse_js__WEBPACK_IMPORTED_MODULE_1__["default"];

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isBuffer);


/***/ }),

/***/ "./node_modules/lodash-es/isEmpty.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/isEmpty.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseKeys_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./_baseKeys.js */ "./node_modules/lodash-es/_baseKeys.js");
/* harmony import */ var _getTag_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_getTag.js */ "./node_modules/lodash-es/_getTag.js");
/* harmony import */ var _isArguments_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./isArguments.js */ "./node_modules/lodash-es/isArguments.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/lodash-es/isArray.js");
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArrayLike.js */ "./node_modules/lodash-es/isArrayLike.js");
/* harmony import */ var _isBuffer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isBuffer.js */ "./node_modules/lodash-es/isBuffer.js");
/* harmony import */ var _isPrototype_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_isPrototype.js */ "./node_modules/lodash-es/_isPrototype.js");
/* harmony import */ var _isTypedArray_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isTypedArray.js */ "./node_modules/lodash-es/isTypedArray.js");









/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if ((0,_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) &&
      ((0,_isArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        (0,_isBuffer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value) || (0,_isTypedArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(value) || (0,_isArguments_js__WEBPACK_IMPORTED_MODULE_4__["default"])(value))) {
    return !value.length;
  }
  var tag = (0,_getTag_js__WEBPACK_IMPORTED_MODULE_5__["default"])(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if ((0,_isPrototype_js__WEBPACK_IMPORTED_MODULE_6__["default"])(value)) {
    return !(0,_baseKeys_js__WEBPACK_IMPORTED_MODULE_7__["default"])(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isEmpty);


/***/ }),

/***/ "./node_modules/lodash-es/isEqual.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/isEqual.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseIsEqual_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseIsEqual.js */ "./node_modules/lodash-es/_baseIsEqual.js");


/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return (0,_baseIsEqual_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value, other);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isEqual);


/***/ }),

/***/ "./node_modules/lodash-es/isFunction.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/isFunction.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseGetTag.js */ "./node_modules/lodash-es/_baseGetTag.js");
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/lodash-es/isObject.js");



/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!(0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = (0,_baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isFunction);


/***/ }),

/***/ "./node_modules/lodash-es/isLength.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/isLength.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isLength);


/***/ }),

/***/ "./node_modules/lodash-es/isMap.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/isMap.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseIsMap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseIsMap.js */ "./node_modules/lodash-es/_baseIsMap.js");
/* harmony import */ var _baseUnary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseUnary.js */ "./node_modules/lodash-es/_baseUnary.js");
/* harmony import */ var _nodeUtil_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_nodeUtil.js */ "./node_modules/lodash-es/_nodeUtil.js");




/* Node.js helper references. */
var nodeIsMap = _nodeUtil_js__WEBPACK_IMPORTED_MODULE_0__["default"] && _nodeUtil_js__WEBPACK_IMPORTED_MODULE_0__["default"].isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? (0,_baseUnary_js__WEBPACK_IMPORTED_MODULE_1__["default"])(nodeIsMap) : _baseIsMap_js__WEBPACK_IMPORTED_MODULE_2__["default"];

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isMap);


/***/ }),

/***/ "./node_modules/lodash-es/isNumber.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/isNumber.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseGetTag.js */ "./node_modules/lodash-es/_baseGetTag.js");
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObjectLike.js */ "./node_modules/lodash-es/isObjectLike.js");



/** `Object#toString` result references. */
var numberTag = '[object Number]';

/**
 * Checks if `value` is classified as a `Number` primitive or object.
 *
 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
 * classified as numbers, use the `_.isFinite` method.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a number, else `false`.
 * @example
 *
 * _.isNumber(3);
 * // => true
 *
 * _.isNumber(Number.MIN_VALUE);
 * // => true
 *
 * _.isNumber(Infinity);
 * // => true
 *
 * _.isNumber('3');
 * // => false
 */
function isNumber(value) {
  return typeof value == 'number' ||
    ((0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && (0,_baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) == numberTag);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isNumber);


/***/ }),

/***/ "./node_modules/lodash-es/isObject.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/isObject.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isObject);


/***/ }),

/***/ "./node_modules/lodash-es/isObjectLike.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/isObjectLike.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isObjectLike);


/***/ }),

/***/ "./node_modules/lodash-es/isPlainObject.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/isPlainObject.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseGetTag.js */ "./node_modules/lodash-es/_baseGetTag.js");
/* harmony import */ var _getPrototype_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_getPrototype.js */ "./node_modules/lodash-es/_getPrototype.js");
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObjectLike.js */ "./node_modules/lodash-es/isObjectLike.js");




/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!(0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) || (0,_baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) != objectTag) {
    return false;
  }
  var proto = (0,_getPrototype_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isPlainObject);


/***/ }),

/***/ "./node_modules/lodash-es/isSet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/isSet.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseIsSet_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseIsSet.js */ "./node_modules/lodash-es/_baseIsSet.js");
/* harmony import */ var _baseUnary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseUnary.js */ "./node_modules/lodash-es/_baseUnary.js");
/* harmony import */ var _nodeUtil_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_nodeUtil.js */ "./node_modules/lodash-es/_nodeUtil.js");




/* Node.js helper references. */
var nodeIsSet = _nodeUtil_js__WEBPACK_IMPORTED_MODULE_0__["default"] && _nodeUtil_js__WEBPACK_IMPORTED_MODULE_0__["default"].isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? (0,_baseUnary_js__WEBPACK_IMPORTED_MODULE_1__["default"])(nodeIsSet) : _baseIsSet_js__WEBPACK_IMPORTED_MODULE_2__["default"];

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isSet);


/***/ }),

/***/ "./node_modules/lodash-es/isSymbol.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/isSymbol.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseGetTag.js */ "./node_modules/lodash-es/_baseGetTag.js");
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObjectLike.js */ "./node_modules/lodash-es/isObjectLike.js");



/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    ((0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && (0,_baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) == symbolTag);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isSymbol);


/***/ }),

/***/ "./node_modules/lodash-es/isTypedArray.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/isTypedArray.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseIsTypedArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseIsTypedArray.js */ "./node_modules/lodash-es/_baseIsTypedArray.js");
/* harmony import */ var _baseUnary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseUnary.js */ "./node_modules/lodash-es/_baseUnary.js");
/* harmony import */ var _nodeUtil_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_nodeUtil.js */ "./node_modules/lodash-es/_nodeUtil.js");




/* Node.js helper references. */
var nodeIsTypedArray = _nodeUtil_js__WEBPACK_IMPORTED_MODULE_0__["default"] && _nodeUtil_js__WEBPACK_IMPORTED_MODULE_0__["default"].isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? (0,_baseUnary_js__WEBPACK_IMPORTED_MODULE_1__["default"])(nodeIsTypedArray) : _baseIsTypedArray_js__WEBPACK_IMPORTED_MODULE_2__["default"];

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isTypedArray);


/***/ }),

/***/ "./node_modules/lodash-es/keys.js":
/*!****************************************!*\
  !*** ./node_modules/lodash-es/keys.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _arrayLikeKeys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_arrayLikeKeys.js */ "./node_modules/lodash-es/_arrayLikeKeys.js");
/* harmony import */ var _baseKeys_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseKeys.js */ "./node_modules/lodash-es/_baseKeys.js");
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArrayLike.js */ "./node_modules/lodash-es/isArrayLike.js");




/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return (0,_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object) ? (0,_arrayLikeKeys_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object) : (0,_baseKeys_js__WEBPACK_IMPORTED_MODULE_2__["default"])(object);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (keys);


/***/ }),

/***/ "./node_modules/lodash-es/keysIn.js":
/*!******************************************!*\
  !*** ./node_modules/lodash-es/keysIn.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _arrayLikeKeys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_arrayLikeKeys.js */ "./node_modules/lodash-es/_arrayLikeKeys.js");
/* harmony import */ var _baseKeysIn_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseKeysIn.js */ "./node_modules/lodash-es/_baseKeysIn.js");
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArrayLike.js */ "./node_modules/lodash-es/isArrayLike.js");




/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return (0,_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object) ? (0,_arrayLikeKeys_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, true) : (0,_baseKeysIn_js__WEBPACK_IMPORTED_MODULE_2__["default"])(object);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (keysIn);


/***/ }),

/***/ "./node_modules/lodash-es/lowerCase.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/lowerCase.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _createCompounder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createCompounder.js */ "./node_modules/lodash-es/_createCompounder.js");


/**
 * Converts `string`, as space separated words, to lower case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the lower cased string.
 * @example
 *
 * _.lowerCase('--Foo-Bar--');
 * // => 'foo bar'
 *
 * _.lowerCase('fooBar');
 * // => 'foo bar'
 *
 * _.lowerCase('__FOO_BAR__');
 * // => 'foo bar'
 */
var lowerCase = (0,_createCompounder_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(result, word, index) {
  return result + (index ? ' ' : '') + word.toLowerCase();
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (lowerCase);


/***/ }),

/***/ "./node_modules/lodash-es/lowerFirst.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/lowerFirst.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _createCaseFirst_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createCaseFirst.js */ "./node_modules/lodash-es/_createCaseFirst.js");


/**
 * Converts the first character of `string` to lower case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.lowerFirst('Fred');
 * // => 'fred'
 *
 * _.lowerFirst('FRED');
 * // => 'fRED'
 */
var lowerFirst = (0,_createCaseFirst_js__WEBPACK_IMPORTED_MODULE_0__["default"])('toLowerCase');

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (lowerFirst);


/***/ }),

/***/ "./node_modules/lodash-es/max.js":
/*!***************************************!*\
  !*** ./node_modules/lodash-es/max.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseExtremum_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseExtremum.js */ "./node_modules/lodash-es/_baseExtremum.js");
/* harmony import */ var _baseGt_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseGt.js */ "./node_modules/lodash-es/_baseGt.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./identity.js */ "./node_modules/lodash-es/identity.js");




/**
 * Computes the maximum value of `array`. If `array` is empty or falsey,
 * `undefined` is returned.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {*} Returns the maximum value.
 * @example
 *
 * _.max([4, 2, 8, 6]);
 * // => 8
 *
 * _.max([]);
 * // => undefined
 */
function max(array) {
  return (array && array.length)
    ? (0,_baseExtremum_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array, _identity_js__WEBPACK_IMPORTED_MODULE_1__["default"], _baseGt_js__WEBPACK_IMPORTED_MODULE_2__["default"])
    : undefined;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (max);


/***/ }),

/***/ "./node_modules/lodash-es/memoize.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/memoize.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _MapCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_MapCache.js */ "./node_modules/lodash-es/_MapCache.js");


/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || _MapCache_js__WEBPACK_IMPORTED_MODULE_0__["default"]);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = _MapCache_js__WEBPACK_IMPORTED_MODULE_0__["default"];

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (memoize);


/***/ }),

/***/ "./node_modules/lodash-es/merge.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/merge.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseMerge_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseMerge.js */ "./node_modules/lodash-es/_baseMerge.js");
/* harmony import */ var _createAssigner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createAssigner.js */ "./node_modules/lodash-es/_createAssigner.js");



/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = (0,_createAssigner_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(object, source, srcIndex) {
  (0,_baseMerge_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, source, srcIndex);
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (merge);


/***/ }),

/***/ "./node_modules/lodash-es/mergeWith.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/mergeWith.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseMerge_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseMerge.js */ "./node_modules/lodash-es/_baseMerge.js");
/* harmony import */ var _createAssigner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createAssigner.js */ "./node_modules/lodash-es/_createAssigner.js");



/**
 * This method is like `_.merge` except that it accepts `customizer` which
 * is invoked to produce the merged values of the destination and source
 * properties. If `customizer` returns `undefined`, merging is handled by the
 * method instead. The `customizer` is invoked with six arguments:
 * (objValue, srcValue, key, object, source, stack).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   if (_.isArray(objValue)) {
 *     return objValue.concat(srcValue);
 *   }
 * }
 *
 * var object = { 'a': [1], 'b': [2] };
 * var other = { 'a': [3], 'b': [4] };
 *
 * _.mergeWith(object, other, customizer);
 * // => { 'a': [1, 3], 'b': [2, 4] }
 */
var mergeWith = (0,_createAssigner_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(object, source, srcIndex, customizer) {
  (0,_baseMerge_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, source, srcIndex, customizer);
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mergeWith);


/***/ }),

/***/ "./node_modules/lodash-es/noop.js":
/*!****************************************!*\
  !*** ./node_modules/lodash-es/noop.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (noop);


/***/ }),

/***/ "./node_modules/lodash-es/now.js":
/*!***************************************!*\
  !*** ./node_modules/lodash-es/now.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js");


/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return _root_js__WEBPACK_IMPORTED_MODULE_0__["default"].Date.now();
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (now);


/***/ }),

/***/ "./node_modules/lodash-es/pick.js":
/*!****************************************!*\
  !*** ./node_modules/lodash-es/pick.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basePick_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_basePick.js */ "./node_modules/lodash-es/_basePick.js");
/* harmony import */ var _flatRest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_flatRest.js */ "./node_modules/lodash-es/_flatRest.js");



/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var pick = (0,_flatRest_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(object, paths) {
  return object == null ? {} : (0,_basePick_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object, paths);
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (pick);


/***/ }),

/***/ "./node_modules/lodash-es/property.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/property.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseProperty_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseProperty.js */ "./node_modules/lodash-es/_baseProperty.js");
/* harmony import */ var _basePropertyDeep_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_basePropertyDeep.js */ "./node_modules/lodash-es/_basePropertyDeep.js");
/* harmony import */ var _isKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_isKey.js */ "./node_modules/lodash-es/_isKey.js");
/* harmony import */ var _toKey_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_toKey.js */ "./node_modules/lodash-es/_toKey.js");





/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return (0,_isKey_js__WEBPACK_IMPORTED_MODULE_0__["default"])(path) ? (0,_baseProperty_js__WEBPACK_IMPORTED_MODULE_1__["default"])((0,_toKey_js__WEBPACK_IMPORTED_MODULE_2__["default"])(path)) : (0,_basePropertyDeep_js__WEBPACK_IMPORTED_MODULE_3__["default"])(path);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (property);


/***/ }),

/***/ "./node_modules/lodash-es/sortBy.js":
/*!******************************************!*\
  !*** ./node_modules/lodash-es/sortBy.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseFlatten_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_baseFlatten.js */ "./node_modules/lodash-es/_baseFlatten.js");
/* harmony import */ var _baseOrderBy_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseOrderBy.js */ "./node_modules/lodash-es/_baseOrderBy.js");
/* harmony import */ var _baseRest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseRest.js */ "./node_modules/lodash-es/_baseRest.js");
/* harmony import */ var _isIterateeCall_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isIterateeCall.js */ "./node_modules/lodash-es/_isIterateeCall.js");





/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection thru each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {...(Function|Function[])} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 30 },
 *   { 'user': 'barney', 'age': 34 }
 * ];
 *
 * _.sortBy(users, [function(o) { return o.user; }]);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
 *
 * _.sortBy(users, ['user', 'age']);
 * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
 */
var sortBy = (0,_baseRest_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && (0,_isIterateeCall_js__WEBPACK_IMPORTED_MODULE_1__["default"])(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && (0,_isIterateeCall_js__WEBPACK_IMPORTED_MODULE_1__["default"])(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return (0,_baseOrderBy_js__WEBPACK_IMPORTED_MODULE_2__["default"])(collection, (0,_baseFlatten_js__WEBPACK_IMPORTED_MODULE_3__["default"])(iteratees, 1), []);
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sortBy);


/***/ }),

/***/ "./node_modules/lodash-es/sortedIndex.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/sortedIndex.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseSortedIndex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseSortedIndex.js */ "./node_modules/lodash-es/_baseSortedIndex.js");


/**
 * Uses a binary search to determine the lowest index at which `value`
 * should be inserted into `array` in order to maintain its sort order.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 * @example
 *
 * _.sortedIndex([30, 50], 40);
 * // => 1
 */
function sortedIndex(array, value) {
  return (0,_baseSortedIndex_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array, value);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sortedIndex);


/***/ }),

/***/ "./node_modules/lodash-es/sortedIndexBy.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/sortedIndexBy.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseIteratee_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseIteratee.js */ "./node_modules/lodash-es/_baseIteratee.js");
/* harmony import */ var _baseSortedIndexBy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseSortedIndexBy.js */ "./node_modules/lodash-es/_baseSortedIndexBy.js");



/**
 * This method is like `_.sortedIndex` except that it accepts `iteratee`
 * which is invoked for `value` and each element of `array` to compute their
 * sort ranking. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The sorted array to inspect.
 * @param {*} value The value to evaluate.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {number} Returns the index at which `value` should be inserted
 *  into `array`.
 * @example
 *
 * var objects = [{ 'x': 4 }, { 'x': 5 }];
 *
 * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
 * // => 0
 */
function sortedIndexBy(array, value, iteratee) {
  return (0,_baseSortedIndexBy_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array, value, (0,_baseIteratee_js__WEBPACK_IMPORTED_MODULE_1__["default"])(iteratee, 2));
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sortedIndexBy);


/***/ }),

/***/ "./node_modules/lodash-es/startCase.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/startCase.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _createCompounder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createCompounder.js */ "./node_modules/lodash-es/_createCompounder.js");
/* harmony import */ var _upperFirst_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./upperFirst.js */ "./node_modules/lodash-es/upperFirst.js");



/**
 * Converts `string` to
 * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
 *
 * @static
 * @memberOf _
 * @since 3.1.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the start cased string.
 * @example
 *
 * _.startCase('--foo-bar--');
 * // => 'Foo Bar'
 *
 * _.startCase('fooBar');
 * // => 'Foo Bar'
 *
 * _.startCase('__FOO_BAR__');
 * // => 'FOO BAR'
 */
var startCase = (0,_createCompounder_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(result, word, index) {
  return result + (index ? ' ' : '') + (0,_upperFirst_js__WEBPACK_IMPORTED_MODULE_1__["default"])(word);
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (startCase);


/***/ }),

/***/ "./node_modules/lodash-es/stubArray.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/stubArray.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stubArray);


/***/ }),

/***/ "./node_modules/lodash-es/stubFalse.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/stubFalse.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stubFalse);


/***/ }),

/***/ "./node_modules/lodash-es/throttle.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/throttle.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _debounce_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./debounce.js */ "./node_modules/lodash-es/debounce.js");
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/lodash-es/isObject.js");



/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if ((0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return (0,_debounce_js__WEBPACK_IMPORTED_MODULE_1__["default"])(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (throttle);


/***/ }),

/***/ "./node_modules/lodash-es/toNumber.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/toNumber.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseTrim_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseTrim.js */ "./node_modules/lodash-es/_baseTrim.js");
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isObject.js */ "./node_modules/lodash-es/isObject.js");
/* harmony import */ var _isSymbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isSymbol.js */ "./node_modules/lodash-es/isSymbol.js");




/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if ((0,_isSymbol_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value)) {
    return NAN;
  }
  if ((0,_isObject_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = (0,_isObject_js__WEBPACK_IMPORTED_MODULE_1__["default"])(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = (0,_baseTrim_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (toNumber);


/***/ }),

/***/ "./node_modules/lodash-es/toPlainObject.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/toPlainObject.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _copyObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_copyObject.js */ "./node_modules/lodash-es/_copyObject.js");
/* harmony import */ var _keysIn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keysIn.js */ "./node_modules/lodash-es/keysIn.js");



/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return (0,_copyObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value, (0,_keysIn_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value));
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (toPlainObject);


/***/ }),

/***/ "./node_modules/lodash-es/toString.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/toString.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseToString.js */ "./node_modules/lodash-es/_baseToString.js");


/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : (0,_baseToString_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (toString);


/***/ }),

/***/ "./node_modules/lodash-es/union.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/union.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseFlatten_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseFlatten.js */ "./node_modules/lodash-es/_baseFlatten.js");
/* harmony import */ var _baseRest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseRest.js */ "./node_modules/lodash-es/_baseRest.js");
/* harmony import */ var _baseUniq_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseUniq.js */ "./node_modules/lodash-es/_baseUniq.js");
/* harmony import */ var _isArrayLikeObject_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isArrayLikeObject.js */ "./node_modules/lodash-es/isArrayLikeObject.js");





/**
 * Creates an array of unique values, in order, from all given arrays using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.union([2], [1, 2]);
 * // => [2, 1]
 */
var union = (0,_baseRest_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(arrays) {
  return (0,_baseUniq_js__WEBPACK_IMPORTED_MODULE_1__["default"])((0,_baseFlatten_js__WEBPACK_IMPORTED_MODULE_2__["default"])(arrays, 1, _isArrayLikeObject_js__WEBPACK_IMPORTED_MODULE_3__["default"], true));
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (union);


/***/ }),

/***/ "./node_modules/lodash-es/uniq.js":
/*!****************************************!*\
  !*** ./node_modules/lodash-es/uniq.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseUniq_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseUniq.js */ "./node_modules/lodash-es/_baseUniq.js");


/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each element
 * is kept. The order of result values is determined by the order they occur
 * in the array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */
function uniq(array) {
  return (array && array.length) ? (0,_baseUniq_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array) : [];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (uniq);


/***/ }),

/***/ "./node_modules/lodash-es/uniqueId.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/uniqueId.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _toString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toString.js */ "./node_modules/lodash-es/toString.js");


/** Used to generate unique IDs. */
var idCounter = 0;

/**
 * Generates a unique ID. If `prefix` is given, the ID is appended to it.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {string} [prefix=''] The value to prefix the ID with.
 * @returns {string} Returns the unique ID.
 * @example
 *
 * _.uniqueId('contact_');
 * // => 'contact_104'
 *
 * _.uniqueId();
 * // => '105'
 */
function uniqueId(prefix) {
  var id = ++idCounter;
  return (0,_toString_js__WEBPACK_IMPORTED_MODULE_0__["default"])(prefix) + id;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (uniqueId);


/***/ }),

/***/ "./node_modules/lodash-es/upperCase.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/upperCase.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _createCompounder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createCompounder.js */ "./node_modules/lodash-es/_createCompounder.js");


/**
 * Converts `string`, as space separated words, to upper case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the upper cased string.
 * @example
 *
 * _.upperCase('--foo-bar');
 * // => 'FOO BAR'
 *
 * _.upperCase('fooBar');
 * // => 'FOO BAR'
 *
 * _.upperCase('__foo_bar__');
 * // => 'FOO BAR'
 */
var upperCase = (0,_createCompounder_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(result, word, index) {
  return result + (index ? ' ' : '') + word.toUpperCase();
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (upperCase);


/***/ }),

/***/ "./node_modules/lodash-es/upperFirst.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/upperFirst.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _createCaseFirst_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createCaseFirst.js */ "./node_modules/lodash-es/_createCaseFirst.js");


/**
 * Converts the first character of `string` to upper case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.upperFirst('fred');
 * // => 'Fred'
 *
 * _.upperFirst('FRED');
 * // => 'FRED'
 */
var upperFirst = (0,_createCaseFirst_js__WEBPACK_IMPORTED_MODULE_0__["default"])('toUpperCase');

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (upperFirst);


/***/ }),

/***/ "./node_modules/lodash-es/words.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/words.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _asciiWords_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_asciiWords.js */ "./node_modules/lodash-es/_asciiWords.js");
/* harmony import */ var _hasUnicodeWord_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_hasUnicodeWord.js */ "./node_modules/lodash-es/_hasUnicodeWord.js");
/* harmony import */ var _toString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toString.js */ "./node_modules/lodash-es/toString.js");
/* harmony import */ var _unicodeWords_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_unicodeWords.js */ "./node_modules/lodash-es/_unicodeWords.js");





/**
 * Splits `string` into an array of its words.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {RegExp|string} [pattern] The pattern to match words.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the words of `string`.
 * @example
 *
 * _.words('fred, barney, & pebbles');
 * // => ['fred', 'barney', 'pebbles']
 *
 * _.words('fred, barney, & pebbles', /[^, ]+/g);
 * // => ['fred', 'barney', '&', 'pebbles']
 */
function words(string, pattern, guard) {
  string = (0,_toString_js__WEBPACK_IMPORTED_MODULE_0__["default"])(string);
  pattern = guard ? undefined : pattern;

  if (pattern === undefined) {
    return (0,_hasUnicodeWord_js__WEBPACK_IMPORTED_MODULE_1__["default"])(string) ? (0,_unicodeWords_js__WEBPACK_IMPORTED_MODULE_2__["default"])(string) : (0,_asciiWords_js__WEBPACK_IMPORTED_MODULE_3__["default"])(string);
  }
  return string.match(pattern) || [];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (words);


/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		id: moduleId,
/******/ 		loaded: false,
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Flag the module as loaded
/******/ 	module.loaded = true;
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/compat get default export */
/******/ (() => {
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = (module) => {
/******/ 		var getter = module && module.__esModule ?
/******/ 			() => (module['default']) :
/******/ 			() => (module);
/******/ 		__webpack_require__.d(getter, { a: getter });
/******/ 		return getter;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/global */
/******/ (() => {
/******/ 	__webpack_require__.g = (function() {
/******/ 		if (typeof globalThis === 'object') return globalThis;
/******/ 		try {
/******/ 			return this || new Function('return this')();
/******/ 		} catch (e) {
/******/ 			if (typeof window === 'object') return window;
/******/ 		}
/******/ 	})();
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/node module decorator */
/******/ (() => {
/******/ 	__webpack_require__.nmd = (module) => {
/******/ 		module.paths = [];
/******/ 		if (!module.children) module.children = [];
/******/ 		return module;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/nonce */
/******/ (() => {
/******/ 	__webpack_require__.nc = undefined;
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!*************************!*\
  !*** ./src/designer.ts ***!
  \*************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DotNetFlowchartDesigner: () => (/* reexport safe */ _designer_api__WEBPACK_IMPORTED_MODULE_2__.DotNetFlowchartDesigner),
/* harmony export */   addActivityNode: () => (/* reexport safe */ _designer_api__WEBPACK_IMPORTED_MODULE_2__.addActivityNode),
/* harmony export */   autoLayout: () => (/* reexport safe */ _designer_api__WEBPACK_IMPORTED_MODULE_2__.autoLayout),
/* harmony export */   calculateActivitySize: () => (/* reexport safe */ _designer_api__WEBPACK_IMPORTED_MODULE_2__.calculateActivitySize),
/* harmony export */   centerContent: () => (/* reexport safe */ _designer_api__WEBPACK_IMPORTED_MODULE_2__.centerContent),
/* harmony export */   createGraph: () => (/* reexport safe */ _designer_api__WEBPACK_IMPORTED_MODULE_2__.createGraph),
/* harmony export */   disposeGraph: () => (/* reexport safe */ _designer_api__WEBPACK_IMPORTED_MODULE_2__.disposeGraph),
/* harmony export */   graphBindings: () => (/* reexport safe */ _designer_api__WEBPACK_IMPORTED_MODULE_2__.graphBindings),
/* harmony export */   loadGraph: () => (/* reexport safe */ _designer_api__WEBPACK_IMPORTED_MODULE_2__.loadGraph),
/* harmony export */   pasteCells: () => (/* reexport safe */ _designer_api__WEBPACK_IMPORTED_MODULE_2__.pasteCells),
/* harmony export */   raiseActivityEmbeddedPortSelected: () => (/* reexport safe */ _designer_api__WEBPACK_IMPORTED_MODULE_2__.raiseActivityEmbeddedPortSelected),
/* harmony export */   raiseActivitySelected: () => (/* reexport safe */ _designer_api__WEBPACK_IMPORTED_MODULE_2__.raiseActivitySelected),
/* harmony export */   readGraph: () => (/* reexport safe */ _designer_api__WEBPACK_IMPORTED_MODULE_2__.readGraph),
/* harmony export */   selectActivity: () => (/* reexport safe */ _designer_api__WEBPACK_IMPORTED_MODULE_2__.selectActivity),
/* harmony export */   setGridColor: () => (/* reexport safe */ _designer_api__WEBPACK_IMPORTED_MODULE_2__.setGridColor),
/* harmony export */   updateActivity: () => (/* reexport safe */ _designer_api__WEBPACK_IMPORTED_MODULE_2__.updateActivity),
/* harmony export */   updateActivitySize: () => (/* reexport safe */ _designer_api__WEBPACK_IMPORTED_MODULE_2__.updateActivitySize),
/* harmony export */   updateActivityStats: () => (/* reexport safe */ _designer_api__WEBPACK_IMPORTED_MODULE_2__.updateActivityStats),
/* harmony export */   zoomToFit: () => (/* reexport safe */ _designer_api__WEBPACK_IMPORTED_MODULE_2__.zoomToFit)
/* harmony export */ });
/* harmony import */ var _css_designer_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../css/designer.css */ "./css/designer.css");
/* harmony import */ var _designer_internal_init__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./designer/internal/init */ "./src/designer/internal/init.ts");
/* harmony import */ var _designer_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./designer/api */ "./src/designer/api/index.ts");



(0,_designer_internal_init__WEBPACK_IMPORTED_MODULE_1__.initialize)();

})();

var __webpack_exports__DotNetFlowchartDesigner = __webpack_exports__.DotNetFlowchartDesigner;
var __webpack_exports__addActivityNode = __webpack_exports__.addActivityNode;
var __webpack_exports__autoLayout = __webpack_exports__.autoLayout;
var __webpack_exports__calculateActivitySize = __webpack_exports__.calculateActivitySize;
var __webpack_exports__centerContent = __webpack_exports__.centerContent;
var __webpack_exports__createGraph = __webpack_exports__.createGraph;
var __webpack_exports__disposeGraph = __webpack_exports__.disposeGraph;
var __webpack_exports__graphBindings = __webpack_exports__.graphBindings;
var __webpack_exports__loadGraph = __webpack_exports__.loadGraph;
var __webpack_exports__pasteCells = __webpack_exports__.pasteCells;
var __webpack_exports__raiseActivityEmbeddedPortSelected = __webpack_exports__.raiseActivityEmbeddedPortSelected;
var __webpack_exports__raiseActivitySelected = __webpack_exports__.raiseActivitySelected;
var __webpack_exports__readGraph = __webpack_exports__.readGraph;
var __webpack_exports__selectActivity = __webpack_exports__.selectActivity;
var __webpack_exports__setGridColor = __webpack_exports__.setGridColor;
var __webpack_exports__updateActivity = __webpack_exports__.updateActivity;
var __webpack_exports__updateActivitySize = __webpack_exports__.updateActivitySize;
var __webpack_exports__updateActivityStats = __webpack_exports__.updateActivityStats;
var __webpack_exports__zoomToFit = __webpack_exports__.zoomToFit;
export { __webpack_exports__DotNetFlowchartDesigner as DotNetFlowchartDesigner, __webpack_exports__addActivityNode as addActivityNode, __webpack_exports__autoLayout as autoLayout, __webpack_exports__calculateActivitySize as calculateActivitySize, __webpack_exports__centerContent as centerContent, __webpack_exports__createGraph as createGraph, __webpack_exports__disposeGraph as disposeGraph, __webpack_exports__graphBindings as graphBindings, __webpack_exports__loadGraph as loadGraph, __webpack_exports__pasteCells as pasteCells, __webpack_exports__raiseActivityEmbeddedPortSelected as raiseActivityEmbeddedPortSelected, __webpack_exports__raiseActivitySelected as raiseActivitySelected, __webpack_exports__readGraph as readGraph, __webpack_exports__selectActivity as selectActivity, __webpack_exports__setGridColor as setGridColor, __webpack_exports__updateActivity as updateActivity, __webpack_exports__updateActivitySize as updateActivitySize, __webpack_exports__updateActivityStats as updateActivityStats, __webpack_exports__zoomToFit as zoomToFit };

//# sourceMappingURL=designer.entry.js.map